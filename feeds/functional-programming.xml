<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - functional programming</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Sun, 31 Dec 2017 20:20:00 -0500</lastBuildDate><item><title>Exploring 4 Languages</title><link>http://www.chriskrycho.com/2017/exploring-4-languages.html</link><description>&lt;p&gt;Today, as I hit the first of the implementation chapters in &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt;, I started thinking about how I wanted to implement it. As I’ve noted &lt;a href="https://twitter.com/chriskrycho/status/934170826718429184"&gt;elsewhere&lt;/a&gt; in the past, very little of the book is &lt;em&gt;truly&lt;/em&gt; specific to F&lt;sup&gt;♯&lt;/sup&gt;, though that’s the language Wlaschin uses in the book—and Wlaschin himself &lt;a href="https://twitter.com/ScottWlaschin/status/934177554331848705"&gt;agrees&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks! Yes, it’s true that you could easily use #ElmLang, #RustLang, #Scala, or especially #OCaml to work through the book. I use hardly any F# specific features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So… I decided to try something a little bit bonkers. I’m going to implement these exercises in &lt;em&gt;four different languages&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fsharp.org"&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reasonml.github.io"&gt;ReasonML&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are all related: they’re descended from &lt;a href="http://smlnj.org/sml.html"&gt;Standard ML&lt;/a&gt;. ReasonML and F&lt;sup&gt;♯&lt;/sup&gt; are like siblings: Reason is merely a custom syntax for OCaml; F&lt;sup&gt;♯&lt;/sup&gt; is (originally) an implementation of OCaml on .NET (though the two languages have diverged since F&lt;sup&gt;♯&lt;/sup&gt; came into existence). Elm and Rust are cousins of each other and of Reason and F&lt;sup&gt;♯&lt;/sup&gt;, though they’re both drawing on other languages besides OCaml as well. I also have some familiarity with Rust, Elm, and F&lt;sup&gt;♯&lt;/sup&gt; already, and have read the docs for Reason a couple times. So this is a &lt;em&gt;bit&lt;/em&gt; less crazy than it might otherwise be.&lt;/p&gt;
&lt;p&gt;Why, though? Mostly because I think it’ll be interesting to compare the implementations of the domain model from the book side by side. It’ll look just a bit different in each language, and I expect to learn a bit more of the &lt;em&gt;feel&lt;/em&gt; of each language by doing this. (That side by side comparison is something I’ve &lt;a href="http://www.chriskrycho.com/rust-and-swift.html" title="Series: Rust and Swift"&gt;done before&lt;/a&gt; and &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html" title="Part V: The value (and challenge) of learning languages in parallel."&gt;found very profitable&lt;/a&gt;.) I’ll also turn it into blog posts, which hopefully will be interesting to others!&lt;/p&gt;
&lt;p&gt;More to come, and soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 31 Dec 2017 20:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-31:/2017/exploring-4-languages.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Types are Small</title><link>http://www.chriskrycho.com/2017/types-are-small.html</link><description>&lt;p&gt;I’ve been reading through &lt;a href="https://fsharpforfunandprofit.com" title="F♯ for Fun and Profit"&gt;Scott Wlaschin&lt;/a&gt;’s really excellent book &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt; and this quote (from his chapter introducing the idea of &lt;em&gt;types&lt;/em&gt; in &lt;em&gt;typed functional programming&lt;/em&gt;) crystallized something for me:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A type in functional programming is not the same as a class in object-oriented programming. It is much simpler. In fact, a type is just the name given to the set of possible values that can be used as inputs or outputs of a function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A lot of times when I’m trying to explain how I use types in a typed functional programming style, this is a serious point of confusion—both for the Java or C♯ OOP programmer and for the programmers coming from dynamic languages. When people think of “types” they tend to think of &lt;em&gt;classes and interfaces and methods, oh my!&lt;/em&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One is the big heavy class. The other is a nice little LEGO block. The difference is &lt;em&gt;huge&lt;/em&gt; in my day to day experience, but I’ve never been able to express it so clearly as Wlaschin’s quote.&lt;/p&gt;
&lt;p&gt;I suspect that when I’m talking to most people coming from dynamically typed languages &lt;em&gt;or&lt;/em&gt; from the standard OOP languages, they hear “Write three interfaces and six classes” when I say “using types to help me with my program.” But what I mean is “Write three tiny little shapes, and then one more that shows how they snap together in a slightly bigger one.” Types aren’t big heavy things. They’re just the shapes I want to flow through my program, written down like documentation for later… that gets checked for me to make sure it stays up to date, and lets me know if I missed something in my description of the shape of the data, or tried to do something I didn’t mean to before.&lt;/p&gt;
&lt;p&gt;You &lt;em&gt;can&lt;/em&gt; write a language like F♯ or TypeScript or Elm like you would C♯, but it’s generally not going to be an especially &lt;em&gt;happy&lt;/em&gt; experience (and it’ll be less happy the more “purely functional,” &lt;em&gt;a la&lt;/em&gt; Elm, you go). But you don’t have to! Types are just tiny little descriptions of the shapes you plan to deal with in a particular spot—more concise and more dependable than writing a JSDoc or something like that.&lt;/p&gt;
&lt;p&gt;Types are small. You can build big things with them, but &lt;em&gt;types are small&lt;/em&gt;.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;In fact, nearly every “I’m just not into types” or even “I think types are worse for most things” talks I’ve seen—including &lt;a href="https://www.youtube.com/watch?v=2V1FtfBDsLU"&gt;this recent and popular one by Rich Hickey&lt;/a&gt;—tend to conflate &lt;em&gt;all&lt;/em&gt; type systems together. But the experience of writing TypeScript is &lt;em&gt;very&lt;/em&gt; different from the experience of writing C♯. (You’ll note that in that talk, for example, Hickey freely jumps back and forth between Java-style types and Haskell-style types when it suits his purposes, and he entirely skips past the structural type systems currently having something of a heyday.) In many cases, I &lt;em&gt;suspect&lt;/em&gt; this is simply a lack of deep experience with the whole variety of type systems out there (though I’d not attribute that to any specific individual).&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 29 Dec 2017 14:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-29:/2017/types-are-small.html</guid><category>functional programming</category><category>software development</category></item><item><title>Announcing True Myth 1.0</title><link>http://www.chriskrycho.com/2017/announcing-true-myth-10.html</link><description>&lt;p&gt;I’m pleased to announce the release of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth 1.0&lt;/a&gt;! True Myth is a library I’ve been working on over the last month or so, for saner programming in JavaScript, with first-class support for TypeScript (and Flow).&lt;/p&gt;
&lt;p&gt;True Myth provides standard, type-safe wrappers and helper functions to help you with two &lt;em&gt;extremely&lt;/em&gt; common cases in programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not having a value—which it solves with a &lt;code&gt;Maybe&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;li&gt;having a &lt;em&gt;result&lt;/em&gt; where you need to deal with either success or failure—which it solves with a &lt;code&gt;Result&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You could implement all of these yourself – it’s not hard! – but it’s much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all.&lt;/p&gt;
&lt;p&gt;Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects—which we get by leaning hard on the type systems in TypeScript or Flow!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;/strong&gt; If you’re familiar with &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; or &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, this has a lot in common with them—its main differences are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Myth has a much smaller API surface than they do&lt;/li&gt;
&lt;li&gt;True Myth aims to be much more approachable for people who aren’t already super familiar with functional programming concepts and jargon&lt;/li&gt;
&lt;li&gt;True Myth does &lt;em&gt;no&lt;/em&gt; runtime checking of your types, whereas both those libraries do by default—it relies on TypeScript or Flow instead&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I really like both of those libraries, though, so you might check them out as well!&lt;/p&gt;
&lt;section id="maybe" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes you don’t have a value. In JavaScript land, we usually represent that with either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, and then trying to program defensively in the places we &lt;em&gt;think&lt;/em&gt; we might get &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: &amp;quot;Hello!&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But sometimes it might come over like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: null
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In normal JavaScript we’d write something like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function logThatValue(thePayload) {
  const length = !!thePayload.hopefullyAString
    ? thePayload.hopefullyAString.length
    : 0;
  
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn’t a big deal right here… but—and this &lt;em&gt;is&lt;/em&gt; a big deal—we have to remember to do this &lt;em&gt;everywhere&lt;/em&gt; we interact with this payload. &lt;code&gt;hopefullyAString&lt;/code&gt; can &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; everywhere we interact with it, anywhere in our program. 😬&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; is our escape hatch. If, instead of just naively interacting with the payload, we do a &lt;em&gt;very small&lt;/em&gt; amount of work up front to normalize the data and use a &lt;code&gt;Maybe&lt;/code&gt; instead of passing around &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; values, we can operate safely on the data throughout our application. If we have something, we get an instance called &lt;code&gt;Just&lt;/code&gt;—as in, “What’s in this field? Just a string” or “Just the string ‘hello’”. If there’s nothing there, we have an instance called &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just&lt;/code&gt; is a wrapper type that holds the actual value in it. &lt;code&gt;Nothing&lt;/code&gt; is a wrapper type which has no value in it. But both of them are concrete types and you’ll never get an &lt;code&gt;undefined is not an object&lt;/code&gt; error when trying to use them!&lt;/p&gt;
&lt;p&gt;Both of them have all the same methods available on them, and the same static functions to work on them. And, importantly, you can do a bunch of neat things with a &lt;code&gt;Maybe&lt;/code&gt; instance without checking whether it’s a &lt;code&gt;Nothing&lt;/code&gt; or a &lt;code&gt;Just&lt;/code&gt;. For example, if you want to double a number if it’s present and do nothing if it isn’t, you can use the &lt;code&gt;Maybe.map&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;
const hereIsANumber = Maybe.just(12);          // Just(12)
const noNumberHere = Maybe.nothing&amp;lt;number&amp;gt;();  // Nothing

const double = (n: number) =&amp;gt; n * 2;
hereIsANumber.map(double);  // Just(24)
noNumberHere.map(double);   // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;a href="https://true-myth.js.org/modules/_maybe_.html"&gt;a &lt;em&gt;lot&lt;/em&gt;&lt;/a&gt; of those helper functions and methods! Just about any way you would need to interact with a &lt;code&gt;Maybe&lt;/code&gt; is there.&lt;/p&gt;
&lt;p&gt;So now that we have a little idea what &lt;code&gt;Maybe&lt;/code&gt; is for and how to use it, here’s that same example, but rewritten to normalize the payload using a &lt;code&gt;Maybe&lt;/code&gt; instance. We’re using TypeScript, so we will get a compiler error if we don’t handle any of these cases right—or if we try to use the value at &lt;code&gt;hopefullyAString&lt;/code&gt; directly after we’ve normalized it!&lt;/p&gt;
&lt;p&gt;(Note that &lt;code&gt;Maybe.of&lt;/code&gt; will construct either a &lt;code&gt;Maybe.Just&lt;/code&gt; if the string is present, or &lt;code&gt;Maybe.Nothing&lt;/code&gt; if the value supplied to it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

type Payload = { hopefullyAString?: string };
type NormalizedPayload = { hopefullyAString: Maybe&amp;lt;string&amp;gt; };

function normalize(payload: Payload): NormalizedPayload {
  return {
    hopefullyAString: Maybe.of(payload.hopefullyAString)
  };
}

function logThatValue(payload: NormalizedPayload) {
  const length = payload.hopefullyAString.mapOr(0, s =&amp;gt; s.length);
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(normalize)
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you might be thinking, &lt;em&gt;Sure, but we could get the same effect by just supplying a default value when we deserialize the data.&lt;/em&gt; That’s true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. &lt;code&gt;Maybe&lt;/code&gt; is another tool in your toolbox, not something you’re &lt;em&gt;obligated&lt;/em&gt; to use everywhere you can.&lt;/p&gt;
&lt;p&gt;However, sometimes there isn’t a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat “no value” distinctly from “there’s a value present, and it’s an empty string”? &lt;em&gt;That’s&lt;/em&gt; where &lt;code&gt;Maybe&lt;/code&gt; comes in handy.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="result" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another common scenario we find ourselves in is dealing with operations which might fail. There are a couple patterns we often use to deal with this: &lt;em&gt;callbacks&lt;/em&gt; and &lt;em&gt;exceptions&lt;/em&gt;. There are major problems with both, especially around reusability and composability.&lt;/p&gt;
&lt;p&gt;The callback pattern (as in e.g. Node) encourages a style where literally every function starts with the exact same code:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function getMeAValue(err, data) {
  if (err) {
    return handleErr(err);
  }
  
  // do whatever the *actual* point of the function is
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two major problems with this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s incredibly repetitive – the very opposite of “Don’t Repeat Yourself”. We wouldn’t do this with &lt;em&gt;anything&lt;/em&gt; else in our codebase!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It puts the error-handling right up front and &lt;em&gt;not in a good way.&lt;/em&gt; While we want to have a failure case in mind when designing the behavior of our functions, it’s not usually the &lt;em&gt;point&lt;/em&gt; of most functions – things like &lt;code&gt;handleErr&lt;/code&gt; in the above example being the exception and not the rule. The actual meat of the function is always after the error handling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But if we’re not using some similar kind of callback pattern, we usually resort to exceptions. But exceptions are unpredictable: you can’t know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it’s a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it’s very easy to miss that. And then this happens:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// in one part of the codebase
function getMeAValue(url) {
  if (isMalformed(url)) {
    throw new Error(`The url `${url}` is malformed!`);
  }
  
  // do something else to load data from the URL
  return data;
}

function render(toRender) {
  // if toRender can&amp;#39;t generate valid HTML, throw Error(&amp;quot;invalid HTML&amp;quot;);
  // if it can, theRenderedHTML;
}

function setDom(html) {
  /* magic to render into DOM */
}

// somewhere else in the codebase -- throws an exception
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
const response = getMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
const htmlForPage = render(value);

// so we definitely can&amp;#39;t get here safely
setDom(htmlForPage);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice: there’s no way for the caller to know that the function will throw. Perhaps you’re very disciplined and write good docstrings for every function – &lt;em&gt;and&lt;/em&gt; moreover, perhaps everyone’s editor shows it to them &lt;em&gt;and&lt;/em&gt; they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data – and then you’re chasing down the problem through error logs.&lt;/p&gt;
&lt;p&gt;More, if you &lt;em&gt;do&lt;/em&gt; want to account for the reality that any function anywhere in JavaScript might actually throw, you’re going to write something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;try {
  const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
  const response = getMeAValue(badUrl);  // throws here
  
  // we never get here, but it could throw too
  const htmlForPage = render(value);
  
  // so we definitely can&amp;#39;t get here safely
  setDom(htmlForPage);
} catch (e) {
  handleErr(e);  // ends up here
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is like the Node example &lt;em&gt;but even worse&lt;/em&gt; for repetition!&lt;/p&gt;
&lt;p&gt;And TypeScript and Flow can’t help you here! They don’t have type signatures to say “This throws an exception!” (TypeScript’s &lt;code&gt;never&lt;/code&gt; might come to mind, but it might mean lots of things, not just exception-throwing.)&lt;/p&gt;
&lt;p&gt;Instead, we can use a &lt;code&gt;Result&lt;/code&gt; to get us a container type, much like &lt;code&gt;Maybe&lt;/code&gt;, to let us deal with this scenario. A &lt;code&gt;Result&lt;/code&gt; is either an &lt;code&gt;Ok&lt;/code&gt; wrapping around a value (like &lt;code&gt;Just&lt;/code&gt; does) or an &lt;code&gt;Err&lt;/code&gt; wrapping around some type defining what went wrong (&lt;em&gt;not&lt;/em&gt; like &lt;code&gt;Nothing&lt;/code&gt;, which has no contents). Both of them have the same sets of methods on them, and the same static functions which can operate on them.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Result from &amp;#39;true-myth/result&amp;#39;;

type Payload = {/* details of the payload...*/}

function getMeAValue(url: string): Result&amp;lt;Payload, string&amp;gt; {
  if (isMalformed(url)) {
    return Result.err(`The url &amp;#39;${url}&amp;#39; is malformed`);
  }
  
  // do something else to load data from the url
  return Result.ok(data);
}

function render(toRender: string): Result&amp;lt;HTMLElement, string&amp;gt; {
  // if toRender can&amp;#39;t generate valid HTML, return Err(&amp;quot;invalid HTML&amp;quot;);
  // if it can, return Ok(theRenderedHTML);
}

function setDom(html: HTMLElement) {
  
}

// somewhere else in the codebase -- no exception this time!
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash

// value = Err(The url &amp;#39;${http:/www.google.com}&amp;#39; is malformed)
const value = getMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
const htmlForPage = value.andThen(render);

// we can&amp;#39;t just invoke `setDom` because it doesn&amp;#39;t take a `Result`.
value.match({
  Ok: html =&amp;gt; setDom(html);
  Err: reason =&amp;gt; alert(`Something went seriously wrong here! ${reason}`);
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we have a &lt;code&gt;Result&lt;/code&gt; instance, we can perform tons of operations on whether it’s &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, just as we could with &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Maybe.Nothing&lt;/code&gt;, until we &lt;em&gt;need&lt;/em&gt; the value. Maybe that’s right away. Maybe we don’t need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Give it a spin!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yarn add true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can even just &lt;code&gt;ember install true-myth&lt;/code&gt; and use it if you’re using Ember (in which case I encourage you to also use &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think – if there’s stuff missing, &lt;a href="https://github.com/chriskrycho/true-myth"&gt;open issues&lt;/a&gt;! And if it’s just not to your taste, again, I encourage you to take a look at &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; and &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, which are both excellent and land in very different design spaces in many ways.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 01 Nov 2017 08:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-01:/2017/announcing-true-myth-10.html</guid><category>software development</category><category>libraries</category><category>programming languages</category><category>typescript</category><category>functional programming</category></item><item><title>“Collection-Last Auto-Curried Functions”</title><link>http://www.chriskrycho.com/2017/collection-last-auto-curried-functions.html</link><description>&lt;p&gt;I’ve been using &lt;a href="https://lodash.com"&gt;lodash&lt;/a&gt; for a while at work, and I love having it in our toolbox. But, as I increasingly embrace &lt;em&gt;composition of smaller functions&lt;/em&gt; as a helpful approach to building up the final version of an overall transformation of some piece of data, I’ve increasingly wanted to be using &lt;a href="https://github.com/lodash/lodash/wiki/FP-Guide"&gt;lodash-fp&lt;/a&gt; instead—those “auto-curried… data-last methods” are &lt;em&gt;nice&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I could belabor the difference with words, but a code sample will do better. Here’s how I would write the same basic transformation in both Lodash and lodash-fp.&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// Lodash
const breakfasts = [&amp;#39;pancakes&amp;#39;, &amp;#39;waffles&amp;#39;, &amp;#39;french toast&amp;#39;]

const uniqueLetters = _.flow([
  bs =&amp;gt; _.map(bs, words),
  _.flatten,
  bs =&amp;gt; _.map(bs, b =&amp;gt; split(b, &amp;#39;&amp;#39;)),
  _.flatten,
  _.uniq,
  ls =&amp;gt; _.sortBy(ls, id),
])

console.log(uniqueLetters(breakfasts))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That gets the job done, but wouldn’t it be nice if we didn’t have to have all those anonymous functions (lambdas) throughout?&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// lodash-fp
const uniqueLettersFp = _.flow([
  _.map(words),
  _.flatten,
  _.map(split(&amp;#39;&amp;#39;)),
  _.flatten,
  _.uniq,
  _.sortBy(id),
])

const breakfasts = [&amp;#39;pancakes&amp;#39;, &amp;#39;waffles&amp;#39;, &amp;#39;french toast&amp;#39;]

console.log(uniqueLettersFp(breakfasts))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suddenly the intent is much clearer with the noise introduced by the lambdas gone. You get this because the lodash-fp functions are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;auto-curried:&lt;/strong&gt; that is, even though &lt;code&gt;_.split&lt;/code&gt; takes the splitter and then a string, you can just write &lt;code&gt;_.split('')&lt;/code&gt; and get back a function which takes a string as an argument.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data-last:&lt;/strong&gt; because &lt;code&gt;_.split&lt;/code&gt; takes the string to split &lt;em&gt;last&lt;/em&gt;, it can be passed into an auto-curried function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You need &lt;em&gt;both&lt;/em&gt; to get that nice clean call to &lt;code&gt;_.flow&lt;/code&gt;. But once you have both, it’s really, really hard ever to go back, because it’s so much nicer for building pipelines of functions.&lt;/p&gt;
&lt;p&gt;…I need to see if I can help &lt;a href="https://github.com/mike-north/ember-lodash/issues/21"&gt;do the work&lt;/a&gt; to make lodash-fp available in Ember.js.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 24 Jun 2017 17:35:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-06-24:/2017/collection-last-auto-curried-functions.html</guid><category>javascript</category><category>functional programming</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we’re both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I’ll be reusing some of this material as the basis of an internal tech talk I’m giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s not tied to JS directly, which means it’s free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That’s the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it’s… still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript’s is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; – not mostly sure, 100% sure – that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say “by design,” I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of “soundness holes” in the type system—there’s still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS… but not none. (That’s even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It’s just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean—&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that’s no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I’d summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item><item><title>Better Off Using Exceptions?</title><link>http://www.chriskrycho.com/2017/better-off-using-exceptions.html</link><description>&lt;p&gt;I saw this post on error-handling in F&lt;sup&gt;♯&lt;/sup&gt;, &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You’re better off using Exceptions"&gt;“You’re better off using Exceptions”&lt;/a&gt; making the rounds on Twitter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exception handling is an error management paradigm that has often been met with criticism. Such criticisms typically revolve around scoping considerations, exceptions-as-control-flow abuse or even the assertion that exceptions are really just a type safe version of goto. To an extent, these seem like valid concerns but it is not within the scope of this article to address those per se.&lt;/p&gt;
&lt;p&gt;Such concerns resonate particularly well within FP communities, often taken to the extreme: we should reject exceptions Show more…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And I get the argument, and in the specific context of F&lt;sup&gt;♯&lt;/sup&gt;—especially given how much C&lt;sup&gt;♯&lt;/sup&gt;-interoperating and therefore exception-throwing-code-interoperating there is there—it’s reasonable.&lt;/p&gt;
&lt;p&gt;But it still makes me sad. (To be clear: exceptions were and are a big win over what you get in languages like C. I’ll take them any day over &lt;code&gt;goto&lt;/code&gt; or &lt;code&gt;segfault&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;You need to embrace exceptions in F&lt;sup&gt;♯&lt;/sup&gt; &lt;em&gt;because F&lt;sup&gt;♯&lt;/sup&gt; has exceptions&lt;/em&gt; and because &lt;em&gt;many of its libraries rely on exceptions&lt;/em&gt;. But my experience with Rust and other non-exception-using languages is that you &lt;em&gt;don’t&lt;/em&gt; need exceptions in the general case.&lt;/p&gt;
&lt;p&gt;The questions are: whether your language has good support for things like flat-mapping, and whether you’re willing to commit to letting the compiler help you with these problems.&lt;/p&gt;
&lt;p&gt;To be sure: there’s more work involved up front to deal with that. But that’s a tradeoff I’m &lt;em&gt;always&lt;/em&gt; willing to make. I’d rather have the compiler tell me if I’m failing to account for something than learn because I saw a runtime error report come up in &lt;a href="https://raygun.com"&gt;Raygun&lt;/a&gt;, especially because that tends to mean an error that affects the user in some way.&lt;/p&gt;
&lt;p&gt;Rust’s model gives you something like exceptions for truly unrecoverable errors, “panics.” A panic gives you all the context you’d get from an exception (one of the virtues of exceptions highlighted in that post), but you can only “catch” it at thread boundaries, and it otherwise just kills the program. Because it’s catastrophic, you only use it where you don’t have any way to recover in your immediate context. But where you can recover in your immediate context… using something like a highly descriptive enum (just as suggested at the end of &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You’re better off using Exceptions"&gt;that original post&lt;/a&gt;!) is a better option.&lt;/p&gt;
&lt;p&gt;It’s well-understood in my circles that you shouldn’t use exceptions for things you can recover from; you should use them for things you &lt;em&gt;can’t&lt;/em&gt; recover from. But in most languages which lean heavily on exceptions, you inevitably start using them for control flow. I say: if you can recover from an error… just recover from it! Account for recoverable errors as possible conditions in your program and carry on! If you can’t recover… don’t. Die and let some other part of your system kick things back off.&lt;/p&gt;
&lt;p&gt;In summary: yes, if you’re in F&lt;sup&gt;♯&lt;/sup&gt;, use exceptions. It &lt;em&gt;is&lt;/em&gt; the right thing to do in many cases (and you don’t have a choice in many others). But I’m hopeful for a future where we handle recoverable errors locally, and &lt;a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html"&gt;act like Erlang or Elixir otherwise&lt;/a&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 20 Feb 2017 12:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-02-20:/2017/better-off-using-exceptions.html</guid><category>fsharp</category><category>software development</category><category>rust</category><category>functional programming</category></item><item><title>The Itch</title><link>http://www.chriskrycho.com/2016/the-itch.html</link><description>&lt;p&gt;It took me until just a few weeks ago to put my finger on why typed functional programming, as a style and approach, has appealed to me so much as I started picking it up over the last year. For all its novelty, typed FP feels—over and over again—&lt;em&gt;familiar&lt;/em&gt;. Strange to say, but it’s true.&lt;/p&gt;
&lt;p&gt;This came home to me again when reading a &lt;a href="https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6#.e887yz63p"&gt;short post on functors&lt;/a&gt;—i.e., &lt;em&gt;mappable&lt;/em&gt; types. I’ve written a lot of JavaScript in the last few years, and it has been a source of constant frustration to me that &lt;code&gt;Array&lt;/code&gt; implements the &lt;code&gt;map&lt;/code&gt; method, but &lt;code&gt;Object&lt;/code&gt; does not. Countless times, I have wanted to take an object shaped like &lt;code&gt;{ count: &amp;lt;number&amp;gt; }&lt;/code&gt; and transform that &lt;code&gt;count&lt;/code&gt;. I’m not alone in that. There’s a reason that libraries like &lt;a href="http://underscorejs.org"&gt;Underscore&lt;/a&gt;, &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;, and &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; all supply utilities to allow you to map over objects. There are also good reasons why it &lt;em&gt;isn’t&lt;/em&gt; implemented for on &lt;code&gt;Object.prototype&lt;/code&gt;: the reality is that coming up with a predictable &lt;em&gt;and&lt;/em&gt; useful API for &lt;em&gt;all&lt;/em&gt; &lt;code&gt;Object&lt;/code&gt; instances is difficult at best: Objects are used for everything from dictionaries to records and strange combinations of the two. But still: there’s something there.&lt;/p&gt;
&lt;p&gt;And reading this post on functors, it struck me what that “something” is: object types are, in principle, functors. Maybe it doesn’t make sense to have a single &lt;code&gt;map&lt;/code&gt; implementation for every &lt;code&gt;Object&lt;/code&gt; instance out there. But they’re perfectly mappable. I didn’t have a word for this before tonight, but now I do. Over and over again, this is my experience with functional programming.&lt;/p&gt;
&lt;p&gt;There’s this familiar feeling of frustration I’m slowly coming to recognize—a mental sensation which is a little like the intellectual equivalent of an itch in a spot you can’t quite reach. You’re reaching for an abstraction to express an idea, but you don’t even know that there &lt;em&gt;is&lt;/em&gt; an abstraction for it. You want to map over objects, and you don’t know why that seems so reasonable, but it does. And then someone explains functors to you. It scratches the itch.&lt;/p&gt;
&lt;p&gt;Another example. Since I started programming eight and a half years ago, I’ve worked seriously with Fortran, C, C++ PHP, Python, and JavaScript. In each of those languages (and especially in the C-descended languages), I have found myself reaching for enums or things like them as a way of trying to represent types and states in my system in a more comprehensive way. I figured out that you should &lt;a href="http://wiki.c2.com/?UseEnumsNotBooleans"&gt;use enums not booleans&lt;/a&gt; a long time before I found the advice on the internet. I was encoding error types as enum values instead of just using &lt;code&gt;int&lt;/code&gt;s almost as soon as I started, because it was obvious to me that &lt;code&gt;ErrorCode someFunction() { ... }&lt;/code&gt; was far more meaningful than &lt;code&gt;int someFunction() { ... }&lt;/code&gt; (even if the context of C meant that the latter often implied the former, and even if it was trivial to coerce one to the other).&lt;/p&gt;
&lt;p&gt;Then I read &lt;a href="https://gumroad.com/l/maybe-haskell/"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt;, a book I’ve mentioned often on this blog because it was so revelatory for me. This is what I had been reaching for all those years—and then some. Handing data around with the constraints? Yes, please! I had played with unions, enums, structs with enums inside them, anything to try to get some type-level clarity and guarantees about what my code was doing. Haskell showed me the way; and since then Rust and Elm and F# have reinforced it many times over. &lt;a href="https://guide.elm-lang.org/types/union_types.html"&gt;Tagged unions&lt;/a&gt; are a joy. They let me say what I mean—finally.&lt;/p&gt;
&lt;p&gt;I can still feel that itch. It’s shifted a little, but it’s still there: reaching for higher abstractions to let me tell the machine more clearly what I intend. Half a dozen times this year, I’ve realized: &lt;em&gt;Here&lt;/em&gt; is where dependent types would be useful. They’re far beyond me, but close enough now I can see. I’m sure a year from now, I’ll have find some tools to scratch &lt;em&gt;these&lt;/em&gt; itches, only to discover a few more.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 19 Dec 2016 21:45:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-19:/2016/the-itch.html</guid><category>software development</category><category>functional programming</category><category>Rust</category><category>JavaScript</category></item><item><title>What is Functional Programming?</title><link>http://www.chriskrycho.com/2016/what-is-functional-programming.html</link><description>&lt;p&gt;&lt;i class='editorial'&gt;The following is a script I wrote for a tech talk I gave on functional programming. The recording isn’t (and won’t be) publicly available; but a script is often easier to reference anyway!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; updated with corrected performance characterstics.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Hello, everyone. Today, we are going to talk about functional programming—asking what it is, and why we should care.&lt;/p&gt;
&lt;section id="clearing-the-table-functional-programmings-reputation" class="level2"&gt;
&lt;h2&gt;Clearing the Table: Functional Programming’s Reputation&lt;/h2&gt;
&lt;p&gt;Functional programming has something of a reputation: on the one hand, as incredible difficult, dense, full of mathematical jargon, applicable only to certain fields like machine learning or massive data analysis; on the other hand, as a kind of panacea that solves all of your problems. The reality, I think, is a little bit of both.&lt;/p&gt;
&lt;p&gt;The world of functional programming &lt;em&gt;does&lt;/em&gt; include a lot of jargon from the math world, and there are good reasons for that, but there is also a lot we could do to make it more approachable to people who don’t have a background in, say category. Category theory is useful, of course, and I think there are times when we might want to be able to draw on it. But gladly, functional programming doesn’t require you to know what an &lt;em&gt;applicative functor&lt;/em&gt; is to be able to use it. (And, gladly, there’s a lot of increasingly-solid teaching material out there about functional programming which &lt;em&gt;doesn’t&lt;/em&gt; lean on math concepts.)&lt;/p&gt;
&lt;p&gt;On the other side, functional programming does give us some real and serious benefits, and that’s what I’m going to spend the first third or so of this talk looking at. But of course, it’s still just a tool, and even though it is a very helpful and very powerful tool, it can’t keep us from writing bugs. Still, every tool we can add to our belt for writing correct software is a win.&lt;/p&gt;
&lt;p&gt;One more prefatory note before we get into the meat of this talk: unfamiliar terminology is not specific to functional programming. So, yes, when you see this list, it might seem a little out there:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functor&lt;/li&gt;
&lt;li&gt;Applicative&lt;/li&gt;
&lt;li&gt;Monoid&lt;/li&gt;
&lt;li&gt;Monad&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And in truth, a number of those could have better names. &lt;em&gt;But&lt;/em&gt; we have plenty of terminology we throw around in the world of imperative, object-oriented programming. To pick just one, obvious and easy example—what are the &lt;abbr&gt;SOLID&lt;/abbr&gt; principles?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single reponsibility&lt;/li&gt;
&lt;li&gt;Open/closed&lt;/li&gt;
&lt;li&gt;Liskov substitution&lt;/li&gt;
&lt;li&gt;Interface segregation&lt;/li&gt;
&lt;li&gt;Dependency inversion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may not remember what it felt like the first time you encountered &lt;abbr&gt;SOLID&lt;/abbr&gt;, but suffice it to say: “Liskov substitution principle” isn’t any more intuitive or obvious than “Monad”. You’re just familiar with one of them. The same is true of “applicative” and “Visitor pattern”. And so on. Granted, again: it would be nice for some of these things to have easier names, a &lt;em&gt;big&lt;/em&gt; part of the pain here is just unfamiliarity.&lt;/p&gt;
&lt;p&gt;So, with that out of the way, what &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming" class="level2"&gt;
&lt;h2&gt;What is functional programming?&lt;/h2&gt;
&lt;p&gt;Functional programming is a style of programming that uses &lt;em&gt;pure functions&lt;/em&gt; and &lt;em&gt;immutable data&lt;/em&gt; for as many things as possible, and builds programs primarily out of &lt;em&gt;functions&lt;/em&gt; rather than other abstractions. I’ll define all of those terms in a moment, but first…&lt;/p&gt;
&lt;section id="why-do-we-care" class="level3"&gt;
&lt;h3&gt;Why do we care?&lt;/h3&gt;
&lt;p&gt;We care, frankly, because &lt;em&gt;we’re not that smart&lt;/em&gt;. Let’s think about some of the kinds of things we’re doing with, say, restaurant software: clients, with locations, building baskets, composed of products with options and modifiers, which have a set of rules for what combinations are allowed both of products and of their elements as making up a basket, which turn into orders, which have associated payment schemes (sometimes a lot of them), which generate data to send to a point-of-sale as well as summaries for the customer who ordered it, and so on. There are a &lt;em&gt;lot&lt;/em&gt; of moving pieces there. I’m sure a missed some non-trivial pieces, too. And if all of that is &lt;em&gt;stateful&lt;/em&gt;, that’s a lot of state to hold in your head.&lt;/p&gt;
&lt;p&gt;Let me be a bit provocative for a moment. Imagine you were reading a JavaScript module and it looked like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;var foo = 12;
var bar = &amp;#39;blah&amp;#39;;
var quux = { waffles: &amp;#39;always&amp;#39; };

export function doSomething() {
  foo = 42;
}

export function getSomething() {
  bar = quux;
  quux.waffles = &amp;#39;never&amp;#39;;
  return bar;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everyone watching would presumably say, “No that’s bad, don’t do that!” Why? Because there is &lt;em&gt;global state&lt;/em&gt; being changed by those functions, and there’s nothing about the functions which tells you what’s going on. Global variables are bad. Bad bad bad. We all know this. Why is it bad? Because you have no idea when you call &lt;code&gt;doSomething()&lt;/code&gt; or &lt;code&gt;getSomething()&lt;/code&gt; what kinds of side effects it might have. And if &lt;code&gt;doSomething()&lt;/code&gt; and &lt;code&gt;getSomething()&lt;/code&gt; affect the same data, then the order you call them in matters.&lt;/p&gt;
&lt;p&gt;In a previous job, I spent literally months chasing a bunch of bugs in a C codebase where all of the state was global. &lt;em&gt;We don’t do this anymore.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;But really, what’s different about this?&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class AThing {
  constructor() {
    this.foo = 12;
    this.bar = &amp;#39;blah&amp;#39;;
    this.quux = { waffles: &amp;#39;always&amp;#39; };
  }

  doSomething() {
    this.foo = 42;
  }

  getSomething() {
    this.bar = this.quux;
    this.quux.waffles = &amp;#39;never&amp;#39;;
    return this.bar;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have some “internal” data, just like we had in the module up above. And we have some public methods which change that state. In terms of these internals, it’s the same. There are differences in terms of having &lt;em&gt;instances&lt;/em&gt; and things like that, but in terms of understanding the behavior of the system—understanding the state involved—it’s the same. It’s global, mutable state. Now it’s not global like attaching something to the &lt;code&gt;window&lt;/code&gt; object in JavaScript, and that’s good, but still: at the module or class level, it’s just global mutable state, with no guarantees about how anything works. And this is normal—endemic, even—in object-oriented code. We encapsulate our state, but we have &lt;em&gt;tons&lt;/em&gt; of state, it’s all mutable, and as far as any given class method call is concerned, it’s all global to that class.&lt;/p&gt;
&lt;p&gt;You have no idea, when you call a given object method, what it might do. The fact that you call it with an &lt;code&gt;Int&lt;/code&gt; and get out a &lt;code&gt;String&lt;/code&gt; tells you almost nothing. For all you know, it’s triggering a &lt;abbr&gt;JSON-RPC&lt;/abbr&gt; call using the int as the &lt;abbr&gt;ID&lt;/abbr&gt; for the endpoint, which in turn triggers an operation, responds with another &lt;abbr&gt;ID&lt;/abbr&gt;, which you then use to query a database, and load a string from there, which you then set on some other member of the object instance, and then return. Should you write a method that does that? Probably not. But you can; nothing stops you.&lt;/p&gt;
&lt;p&gt;When you call a method, you have no idea what it will do. JavaScript, TypeScript, C&lt;sup&gt;♯&lt;/sup&gt;, it doesn’t matter. You have literally no idea. And that makes things &lt;em&gt;hard&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It often makes fixing bugs hard, because it means you have to figure out which particular &lt;em&gt;state&lt;/em&gt; caused the issue, and find a way to reproduce that state. Which usually means calling methods in a particular order.&lt;/li&gt;
&lt;li&gt;It makes testing hard. Again, it often entails calling methods in a particular order. It also means you often need mocks for all those outside-world things you’re trying to do.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Functional programming is an out. An escape hatch. An acknowledgement, a recognition, that holding all of this in our heads is too much for us. No one is that smart. And our software, even at its best, is hard to hold in our heads, hard to make sure that our changes don’t break something seemingly unrelated, hard to see how the pieces fit together—hard, in a phrase you’ll often hear from functional programming fans, hard to reason about.&lt;/p&gt;
&lt;p&gt;So, how do we solve these problems? With functional programming!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming-1" class="level3"&gt;
&lt;h3&gt;What &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/h3&gt;
&lt;p&gt;Functional programming is basically combining four bigs ideas:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;First class functions&lt;/li&gt;
&lt;li&gt;Higher-order functions&lt;/li&gt;
&lt;li&gt;Pure functions&lt;/li&gt;
&lt;li&gt;Immutable data&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The combination of these things leads us to a &lt;em&gt;very&lt;/em&gt; different style of programming than traditional &lt;abbr&gt;OOP&lt;/abbr&gt;. Let’s define them.&lt;/p&gt;
&lt;section id="first-class-functions-and-higher-order-functions" class="level4"&gt;
&lt;h4&gt;First class functions and higher-order functions&lt;/h4&gt;
&lt;p&gt;We’ll start by looking at the things that are probably most familiar to you if you’re a JavaScript developer (even if you haven’t necessarily heard the names): first-class functions and higher-order functions.&lt;/p&gt;
&lt;p&gt;When we talk about &lt;em&gt;first class functions,&lt;/em&gt; we mean that functions are just data—they’re first-class items in the language just like any other type. As such, a function is just another thing you can hand around as an argument to other functions. There’s no distinction between a function and a number or a string or some complex data structure. This is essential because, when you combine it with higher-order functions, it allows for incredible &lt;em&gt;simplicity&lt;/em&gt; and incredible &lt;em&gt;reusability&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Higher-order functions, in turn, are functions which take other functions as parameters or return them as their values. We’ll see this in detail in a worked example in a few, but for right now, let’s just use a really simple example that will be familiar to anyone who’s done much JavaScript: using &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we have a collection like an array and we want to transform every piece of data in it, we could of course do it with a for loop, and with iterable types we could use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;&lt;code&gt;for ... of&lt;/code&gt;&lt;/a&gt;. But with &lt;code&gt;map&lt;/code&gt;, we can just leave the implementation details of &lt;em&gt;how&lt;/em&gt; the items in the array are iterated through, and instead worry about what we want to change. We can do that because &lt;code&gt;map&lt;/code&gt; takes functions as arguments.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(value =&amp;gt; value * 2);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We did it there with a function explicitly, but we could just as easily extract the function like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const double = value =&amp;gt; value * 2;
const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(double);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is possible because &lt;em&gt;functions are just data&lt;/em&gt;—they’re first-class members of the language—and therefore &lt;em&gt;functions can be arguments or return values&lt;/em&gt;—the language supports higher-order functions.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="pure-functions" class="level4"&gt;
&lt;h4&gt;Pure functions&lt;/h4&gt;
&lt;p&gt;What about &lt;em&gt;pure functions&lt;/em&gt;? Pure functions are functions with &lt;em&gt;no effects&lt;/em&gt;. The input directly translates to the output, every time. The examples we looked at just a moment ago with &lt;code&gt;map&lt;/code&gt; are all pure functions (and it’s a really weird antipattern to use effectful functions with &lt;code&gt;map&lt;/code&gt;! Don’t do that! Use &lt;code&gt;forEach&lt;/code&gt; if you must have an effect). Here are a few more super simple examples:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const toString = (number) =&amp;gt; `The value is ${number}`;
const toLength = (list) =&amp;gt; list.length;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are some examples of straightforward functions which are &lt;em&gt;not&lt;/em&gt; pure:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const logDataFromEndpoint = (endpoint) =&amp;gt; {
  fetch(endpoint).then(response =&amp;gt; {
    console.log(response);
  });
};

let foo = 42;
const setFoo = (newValue) =&amp;gt; {
  foo = newValue;
};

const getFoo = () =&amp;gt; foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So a pure function is one whose output is &lt;em&gt;solely&lt;/em&gt; determined by its input That means no talking to a database, no making &lt;abbr&gt;API&lt;/abbr&gt; calls, no reading from or writing to disk.&lt;/p&gt;
&lt;p&gt;And of course, you can’t do anything meaningful with &lt;em&gt;just&lt;/em&gt; pure functions. We need user input, and we need to put the results of our computation somewhere. So the goal isn’t to write &lt;em&gt;only&lt;/em&gt; pure functions. It’s to write &lt;em&gt;mostly&lt;/em&gt; pure functions and to &lt;em&gt;isolate&lt;/em&gt; all impure functions.&lt;/p&gt;
&lt;p&gt;What this gets us is two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;A much smaller list of things to worry about when we’re looking at a given function.&lt;/li&gt;
&lt;li&gt;The ability to &lt;em&gt;compose&lt;/em&gt; functions together more easily.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have fewer things to keep in our heads when we look at any given pure function, because we don’t have to worry at all about whether something it touches has been changed by another function or not. We have inputs. We transform them into outputs. That’s it. Compare these two things in practice.&lt;/p&gt;
&lt;p&gt;Here’s a traditional &lt;abbr&gt;OOP&lt;/abbr&gt; approach:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class Order {
  constructor() {
    this.subTotal = 0.0;
    this.taxRate = 0.01;
  }

  getTotal() {
    return this.subTotal * (1 + this.taxRate);
  }
}

const order = new Order();
order.subTotal = 42.00;

const total = order.getTotal();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the total is always dependent on what has happened in the object. If we write &lt;code&gt;order.subTotal = 43&lt;/code&gt;, &lt;code&gt;order.total&lt;/code&gt; will change. So if we want to test how &lt;code&gt;total&lt;/code&gt; behaves, or if there’s a bug in it, we need to make sure we’ve made all the appropriate transformations to the object ahead of time. That’s no big deal here; the &lt;code&gt;total&lt;/code&gt; getter is incredibly simple (and in fact, we’d normally just write it with a property getter). But still, we have to construct an order and make sure all the relevant properties are set to get the right value out of &lt;code&gt;getTotal()&lt;/code&gt;. Things outside the method call itself affect what we get back. We have no way to test &lt;code&gt;getTotal()&lt;/code&gt; by itself, and no way to debug it if there’s a bug without first doing some object setup.&lt;/p&gt;
&lt;p&gt;Now, here’s a functional approach.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const order = {
  subTotal: 42.0,
  taxRate: 0.01
}

const getTotal = (subTotal, taxRate) =&amp;gt; subTotal * (1 + taxRate);
const total = getTotal(order.subTotal, order.taxRate);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the object is &lt;em&gt;just data&lt;/em&gt;. It’s a &lt;em&gt;record&lt;/em&gt;. And the function just takes a couple of arguments. If there needed to be a more complicated transformation internally, we could do that just as easily. Note that it also decouples the structure of the data from the actual computation (though we could pass in a record as well if we had a good reason to).&lt;/p&gt;
&lt;p&gt;This makes it easily testable, for free. Want to make sure different tax rates get the correct output? Just… pass in a different tax rate. You don’t have to do any complicated work setting up an object instance first (which is especially important for more complex data types). It also makes it easier to chase down any bugs: the only thing you have to care about is that simple function body. There’s no other state to think about, because there’s no state at all here from the perspective of the function: just inputs and outputs.&lt;/p&gt;
&lt;p&gt;This has one other &lt;em&gt;really&lt;/em&gt; important consequence, which goes by the name &lt;strong&gt;referential transparency&lt;/strong&gt;. All that means is that anywhere you see a pure function, you can always substitute the value it produces, or vice versa. This is quite unlike the &lt;code&gt;Order::getTotal()&lt;/code&gt; method, where (a) it’s attached to an object instance and (b) it’s dependent on other things about that object. You can’t just substitute it in, or freely move it around, when you’re doing a refactor. &lt;em&gt;Maybe&lt;/em&gt; you can, but you’d better hope that all the other state is shuffled around with it correctly. Whereas, with the standalone &lt;code&gt;getTotal()&lt;/code&gt; function, all you need is its arguments, and you’ll always get the same thing back.&lt;/p&gt;
&lt;p&gt;This is just like math: if you say, &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt; = 5&lt;/span&gt; when solving an algebraic equation, you can put &lt;span class="math inline"&gt;5&lt;/span&gt; &lt;em&gt;anywhere you see &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;; or, if it’s useful for factoring the equation or something, you can just as easily put &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; anywhere you see &lt;span class="math inline"&gt;5&lt;/span&gt;. And in math, that’s true for &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt; as well. When we use pure functions, it’s true for programming, too! That makes refactoring much easier.&lt;/p&gt;
&lt;p&gt;As we’ll see in the example I walk through in a minute, it also lets us &lt;em&gt;compose&lt;/em&gt; functions together far more easily. If all we have are inputs and outputs, then I can take the output from one function and use it as the input to the next.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="immutable-data" class="level4"&gt;
&lt;h4&gt;Immutable data&lt;/h4&gt;
&lt;p&gt;Complementing the use of mostly pure functions is to use &lt;em&gt;immutable data&lt;/em&gt;. Instead of having objects which we mutate, we create copies of the data as we transform it.&lt;/p&gt;
&lt;p&gt;You’re probably wondering how in the world this can work (and also how you avoid it being incredibly computationally expensive). For the most part, we can rely on two things: smart compilers and runtimes, and the fact that we often don’t need to reuse the &lt;em&gt;exact&lt;/em&gt; same data because we’re transforming it. However, as we’ll see below, in languages which don’t have native support for immutability, it can impose a performance penalty. Gladly, there are ways to work around this!&lt;/p&gt;
&lt;hr /&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="a-worked-example" class="level2"&gt;
&lt;h2&gt;A Worked Example&lt;/h2&gt;
&lt;p&gt;Let’s get down to a real example of these ideas. This is a ‘code kata’ I do every so often. In this particular kata, you get a list of burger orders which looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;[
  { condiments: [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;, &amp;#39;pickles&amp;#39;] },
  { condiments: [&amp;#39;tomatoes&amp;#39;] },
  { condiments: [&amp;#39;mustard&amp;#39;, &amp;#39;ketchup&amp;#39;] },
  // etc...
]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’re supposed to take this list (of 10,000-some-odd burger variations!) and determine what the top ten most common orders (not just condiments, but orders) are. (The truth is, the list actually mostly looks like &lt;code&gt;condiments: ['ketchup']&lt;/code&gt; over and over again.) So as a preliminary, you can assume that the data is being loaded like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getBurgers = () =&amp;gt;
  fetch(&amp;#39;http://files.example.com/burgers.json&amp;#39;)
    .then(request =&amp;gt; request.json());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we’ll print our results (which will always end up in the same format) like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const descAndCountToOutput = descAndCount =&amp;gt; `${descAndCount[0]}: ${descAndCount[1]}`;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is actually a perfect case to demonstrate how functional programming ideas can help us solve a problem.&lt;/p&gt;
&lt;section id="imperative" class="level3"&gt;
&lt;h3&gt;Imperative&lt;/h3&gt;
&lt;p&gt;First, let’s look at what I think is a &lt;em&gt;relatively&lt;/em&gt; reasonable imperative approach. Our basic strategy will be:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  let totals = {};

  // 2. Build up a mapping from description to count.
  for (let burger of burgers) {
    // 1. Convert condiments to descriptions.
    // 1.1. Convert the objects to just their lists of condiments.
    const condiments = burger.condiments;
    // 1.2. Sort those strings.
    condiments.sort();
    // 1.3. Turn them into descriptions by joining them with a comma.
    const description = condiments.join(&amp;#39;, &amp;#39;);

    // 2. Build up a mapping from description to count.
    const previousCount = totals[description];
    totals[description] = previousCount ? previousCount + 1 : 1;
  }

  // 3. Sort that by count.
  const sortableCondiments = Object.entries(totals);
  sortableCondiments.sort((a, b) =&amp;gt; b[1] - a[1]);
  // 4. Get the top 10.
  const topTen = sortableCondiments.slice(0, 10);
  // 5. Print out the results.
  for (let descAndCount of topTen) {
    console.log(descAndCountToOutput(descAndCount));
  }
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s pretty well-factored. But it’s pretty wrapped up on the specific details of this problem, and there’s basically nothing here I could reuse. It’s also relatively hard to test. There aren’t really a lot of pieces there we could break up into smaller functions if we wanted to figure out why something was broken. The way you’d end up fixing a bug here is probably by dropping &lt;code&gt;debugger&lt;/code&gt; or &lt;code&gt;console.log()&lt;/code&gt; statements in there to see what the values are at any given spot.&lt;/p&gt;
&lt;p&gt;And this is where functional programming really does give us a better way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="functional" class="level3"&gt;
&lt;h3&gt;Functional&lt;/h3&gt;
&lt;p&gt;Instead of thinking about the specific details of &lt;em&gt;how&lt;/em&gt; to get from A to B, let’s think about what we start with and what we finish with, and see if we can build up a pipeline of transformations that will get us there.&lt;/p&gt;
&lt;p&gt;We start with a &lt;em&gt;list&lt;/em&gt; of &lt;em&gt;objects&lt;/em&gt; containing &lt;em&gt;arrays&lt;/em&gt; of &lt;em&gt;strings&lt;/em&gt;. We want to end up with a &lt;em&gt;list&lt;/em&gt; of the &lt;em&gt;distinct combinations&lt;/em&gt; and their &lt;em&gt;frequency&lt;/em&gt;. How can we do this? Well, the basic idea is the same as what we did above:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To someone acquainted with functional programming, that looks like a bunch of &lt;code&gt;map&lt;/code&gt;s, a &lt;code&gt;reduce&lt;/code&gt;, and some &lt;code&gt;sort&lt;/code&gt;s. And each of those using just simple, pure functions. Let’s see what that might look like. First, what are our transformations?&lt;/p&gt;
&lt;p&gt;The step 1 transformations are all quite straightforward:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
// 1.1. Convert the objects to just their lists of condiments.
const toCondiments = burger =&amp;gt; burger.condiments ? burger.condiments : [];
// 1.2. Sort those strings.
const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();
// 1.3. Turn them into descriptions by joining them with a comma.
const toDescriptions = condiments =&amp;gt; condiments.join(&amp;#39;, &amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 2 is a little more involved: it involves building up a new data structure (&lt;code&gt;totals&lt;/code&gt;) from an old one. This function is a &lt;em&gt;reducer&lt;/em&gt;: it will build up &lt;code&gt;totals&lt;/code&gt; by updating &lt;code&gt;totals&lt;/code&gt; with each &lt;code&gt;description&lt;/code&gt; from an array of them.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 2. Build up a mapping from description to count.
const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  totals[description] = count;
  return totals;
};

// 3. Sort that by count.
const byCount = (a, b) =&amp;gt; b[1] - a[1];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll see how to get just 10 in a moment; for now, let’s also wrap up the output:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 5. Print it out
const output = value =&amp;gt; { console.log(value); };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are our base building blocks, and we’ll re-use them in each of the approaches I cover below. Note that we’ve now taken those same basic steps from our imperative approach and turned them into standalone, testable functions. They’re small and single-purpose, which always helps. But more importantly, (with two exceptions we’ll talk about in a minute) all of those transformations are &lt;em&gt;pure functions&lt;/em&gt;, we know that we’ll get the same results every time we use them. If I want to make sure that burger condiments are converted correctly, I can test &lt;em&gt;just that function&lt;/em&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;describe(&amp;#39;toCondiments&amp;#39;, () =&amp;gt; {
  it(&amp;#39;returns an empty list when there is no `condiments`&amp;#39;, () =&amp;gt; {
    toCondiments({}).should.deepEqual([]);
  });

  it(&amp;#39;returns the list of condiments when it is passed&amp;#39;, () =&amp;gt; {
    const condiments = [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;];
    toCondiments({ condiments }).should.deepEqual(condiments);
  });
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a trivial example, of course, but it gets the point across: all we have to do to test this is pass in an object. It doesn’t depend on anything else. It doesn’t have &lt;em&gt;any knowledge&lt;/em&gt; of how we’re going to use it. It doesn’t know that it’s going to be used with data coming from an array. All it knows is that if you give it an object with a &lt;code&gt;condiments&lt;/code&gt; property, it’ll hand you back the array attached to that property.&lt;/p&gt;
&lt;p&gt;The result is that, with all of these functions, we don’t have to deal with mocks or stubs or anything like that to be testable. Input produces output. Pure functions are great for this. Now, some of you may be thinking, “That’s great, but what about &lt;abbr&gt;I/O&lt;/abbr&gt;, or databases, or any other time we actually interact with the world? What about talking to a point-of-sale?” I actually have some tentative thoughts about a future tech talk to look at how to do that in some detail, but for today, just remember that the goal is to write as many pure functions as possible, and to isolate the rest of your code from knowing about that. And of course, that’s best practice anyway! We’re just codifying it. We’ll see what that looks like in practice in just a minute.&lt;/p&gt;
&lt;p&gt;Now, while we’re on the topic of pure functions, some of you with quick eyes may have noticed that two of these little functions we laid out are actually &lt;em&gt;not&lt;/em&gt; pure: JavaScript’s &lt;code&gt;Array.sort&lt;/code&gt; method operates in-place, for performance reasons, and so does our &lt;code&gt;toTotals&lt;/code&gt; function. So a truly pure version of the sorting function looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, we &lt;em&gt;could&lt;/em&gt; define the &lt;code&gt;toTotals&lt;/code&gt; to return a new object every time, like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  const update = { [description]: count };
  return Object.assign({}, totals, update);
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, given the amount of data we’re dealing with, that’s prohibitively expensive. We end up spending a &lt;em&gt;lot&lt;/em&gt; of time allocating objects and garbage-collecting them. As a result, it’s tens of thousands of times slower. Running it on my 4GHz iMac, the in-place version takes less than 40ms. Doing it the strictly pure way—returning copies every time—takes ~53s. And if you profile it, almost all of that time is spent in &lt;code&gt;assign&lt;/code&gt; (52.95s).&lt;/p&gt;
&lt;p&gt;This takes us to an important point, though: it’s actually not a particularly big deal to have this particular data changed in place, because we’re not going to do anything &lt;em&gt;else&lt;/em&gt; with it. And in fact, under the hood, this is exactly what pure functional languages do with these kinds of transformations—precisely because it’s perfectly safe to do so, because we’re the only ones who have access to this data. We’re generating a &lt;em&gt;new&lt;/em&gt; data structure from the data that we were originally handed, and the next function will make its own new data structure (whether a copy or something else).&lt;/p&gt;
&lt;p&gt;In other words, when we’re talking about a &lt;em&gt;pure function&lt;/em&gt;, we don’t really care about internal mutability (though of course, that can bite us if we’re not careful). We’re really concerned about &lt;em&gt;external&lt;/em&gt; mutability. As long as the same inputs get the same outputs every time, the rest of the world doesn’t have to care how we got that result.&lt;/p&gt;
&lt;p&gt;Now let’s see how we use these functions.&lt;/p&gt;
&lt;section id="pure-javascript" class="level4"&gt;
&lt;h4&gt;Pure JavaScript&lt;/h4&gt;
&lt;p&gt;First, here’s a pure-JavaScript approach, but a more functional one instead of an imperative one:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const descriptionToCount = burgers
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(toDescriptions)
    .reduce(toTotals, {})

  const entries = Object.entries(descriptionToCount);

  [...entries]
    .sort(byCount)
    .slice(0, 10)  // 4. Get the top 10.
    .map(descAndCountToOutput)
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, the good: our transformation is no longer all jumbled together. In fact, our code reads a lot like our original description did. Also, notice that we just have a bunch of functions operating on data: none of the functions used here have any knowledge about where the data comes from that they operate on.&lt;/p&gt;
&lt;p&gt;But then we also have a couple things that are a &lt;em&gt;little&lt;/em&gt; bit clunky. The main thing that sticks out is that sudden stop in the chain in the middle.&lt;/p&gt;
&lt;p&gt;When we’re dealing with the &lt;code&gt;Array&lt;/code&gt; type, everything is fine, but when we convert our data into a &lt;code&gt;Map&lt;/code&gt;, we no longer have that option, so we have to jump through some hoops to do the transformation back into the data type we need. We’re stuck if the object type doesn’t have the method we need. We’re kind of trying to mash together the imperative and functional styles, and it’s leaving us in a little bit of a weird spot.&lt;/p&gt;
&lt;p&gt;There’s another issue here, though, and it’s the way that using the method-style calling convention obscures something important. When we call &lt;em&gt;most&lt;/em&gt; of those methods, we’re doing something quite different from what most &lt;em&gt;methods&lt;/em&gt; do. A method normally is an operation on an object. These methods—most of them—are operations that return &lt;em&gt;new&lt;/em&gt; objects. So it’s nice from a syntax perspective, but if we’re not &lt;em&gt;already&lt;/em&gt; familiar with the behavior of a given method, it won’t be clear at all that we’re actually generating a bunch of totally new data by calling those methods.&lt;/p&gt;
&lt;p&gt;And… two of these methods (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt;) &lt;em&gt;are&lt;/em&gt; not doing that, but are modifying an array in place instead.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="lodash" class="level4"&gt;
&lt;h4&gt;Lodash&lt;/h4&gt;
&lt;p&gt;The first step away from this problem is to use a tool like &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// More functional, with _:
// We tweak how a few of these work slightly to play nicely.
const _toDescriptions = condiments =&amp;gt; _.join(condiments, &amp;#39;, &amp;#39;);
const _byCount = _.property(1);

getBurgers().then(burgers =&amp;gt; {
  const condiments = _.map(burgers, toCondiments);
  const sortedCondiments = _.map(condiments, toSortedCondiments);
  const descriptions = _.map(sortedCondiments, _toDescriptions);
  const totals = _.reduce(descriptions, toTotals, {});
  const totalPairs = _.toPairs(totals);
  const sortedPairs = _.sortBy(totalPairs, _byCount);
  const sortedPairsDescending = _.reverse(sortedPairs);
  const topTen = _.take(sortedPairsDescending, 10);
  const forOutput = _.map(topTen, descAndCountToOutput)
  _.forEach(forOutput, output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But it seems like we lost something when we moved away from the object-oriented approach. Being able to chain things, so that each item worked with the previous item, was actually pretty nice. And needing all these intermediate variables is &lt;em&gt;not&lt;/em&gt; so nice.&lt;/p&gt;
&lt;p&gt;One way around this is to use Lodash’s &lt;code&gt;_.chain&lt;/code&gt; method. That would have let us write it like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const foo = _.chain(burgers)
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(_toDescriptions)
    .reduce(toTotals, {})
    .toPairs()
    .sortBy(_byCount)
    .reverse()
    .take(10)
    .map(descAndCountToOutput)
    .value()
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that &lt;em&gt;is&lt;/em&gt; a win. But it only works because JavaScript is &lt;em&gt;incredibly&lt;/em&gt; dynamic and lets us change the behavior of the underlying &lt;code&gt;Array&lt;/code&gt; type. (You’d have a much harder time doing that in Java or C&lt;sup&gt;♯&lt;/sup&gt;!)&lt;/p&gt;
&lt;p&gt;Perhaps just as importantly, it requires us to make sure that we do that &lt;code&gt;_.chain()&lt;/code&gt; call on on anything we want to tackle this way. So, can we get the benefits of this some &lt;em&gt;other&lt;/em&gt; way? Well, obviously the answer is &lt;em&gt;yes&lt;/em&gt; because I wouldn’t be asking otherwise.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="with-ramda." class="level4"&gt;
&lt;h4&gt;With Ramda.&lt;/h4&gt;
&lt;p&gt;But we can actually go a bit further, and end up in a spot where we don’t need to modify the object prototype at all. We can just do this with a series of standalone functions which don’t depend on being attached to &lt;em&gt;any&lt;/em&gt; object. If we use the &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; library,&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; we can tackle this with nothing but functions.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
  R.reduce(toTotals, {}),
  R.toPairs,
  R.sortBy(R.prop(1)),  // will give us least to greatest
  R.reverse,
  R.take(10),
  R.map(descAndCountToOutput)
);

return getBurgers()
  .then(getTop10Burgers)
  .then(R.forEach(output));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice the difference between here and even where we started with Lodash: we’re no longer dependent on a specific piece of data being present. Instead, we’ve created a standalone function which can operate on that data, simply by “piping” together—that is, &lt;em&gt;composing&lt;/em&gt;—a bunch of other, smaller functions. The output from each one is used as the input for the next.&lt;/p&gt;
&lt;p&gt;One of the many small niceties that falls out of this is that we can refactor this just by pulling it apart into smaller acts of compositions.&lt;/p&gt;
&lt;p&gt;Here’s an example of how we might use that. We defined those simple transformations for the condiments as a set of three functions, which converted them from objects with &lt;code&gt;condiments&lt;/code&gt; elements, sorted them, and joined them into a string. Now, let’s build those into meaningful functions for each step:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
const burgerRecordsToDescriptions = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
);

// 2. Build up a mapping from description to count.
const descriptionsToUniqueCounts = R.pipe(
  R.reduce(toTotals, {}),
  R.toPairs,
);

// 3. Sort that by count.
const uniqueCountsToSortedPairs = R.pipe(
  R.sortBy(R.prop(1)),
  R.reverse,
);

// For (4), to get the top 10, we&amp;#39;ll just use `R.take(10)`.
// We could also alias that, but it doesn&amp;#39;t gain us much.

// 5. Print it out
const sortedPairsToConsole = R.pipe(
  R.map(descAndCountToOutput),
  R.forEach(output)
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can put those together into another, top-level function to do &lt;em&gt;exactly&lt;/em&gt; our steps.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  burgerRecordsToDescriptions,  // (1)
  descriptionsToUniqueCounts,   // (2)
  uniqueCountsToSortedPairs,    // (3)
  R.take(10)                    // (4)
);

getBurgers()
  .then(getTop10Burgers)
  .then(sortedPairsToConsole);  // (5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, because each step is just composing together functions, “refactoring” is easy. And, to be sure, you have to be mindful about what comes in and out of each function. But that’s true in the imperative approach, too: you always have to keep track of the state of the object you’re building up, but there you’re doing it in the middle of a loop, so you’re keeping track of a lot &lt;em&gt;more&lt;/em&gt; state at any given time. Functions with simple inputs and outputs give us a more explicit way of specifying the structure and state of the data at any given time. That’s true even in JavaScript, but it goes double if we’re in a typed language like F&lt;sup&gt;♯&lt;/sup&gt;, Elm, etc., where we can specify those types for the function as a way of designing the flow of the program. (That’s such a helpful way of solving problems, in fact, that I may also do a talk on type-driven design in the future!)&lt;/p&gt;
&lt;p&gt;Note, as well, that we’ve now completely isolated our input and output from everything else. The middle there is a chain of pure functions, built out of other pure functions, which neither know nor care that the data came in from an &lt;abbr&gt;API&lt;/abbr&gt; call, or that we’re going to print it to the console when we finish.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;So this takes us back around to that first question: why do we care? At the end of the day, is this really a win over the imperative style? Is the final version, using Ramda, really better than the pure-JavaScript mostly-functional version we used at first?&lt;/p&gt;
&lt;p&gt;Obviously, I think the answers there are yes. The Ramda version there at the end is &lt;em&gt;way&lt;/em&gt; better than the imperative version, and substantially better than even the first “functional” JavaScript versions we wrote.&lt;/p&gt;
&lt;p&gt;For me, at least, the big takeaway here is this: we just built a small but reasonable transformation of data out of a bunch of really small pieces. That has two big consequences—consequences we’ve talked about all along the way, but which you’ve now seen in practice:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Those pieces are easy to test. If something isn’t working, I can easily take those pieces apart and test them individually, or test the result of any combination of them. As a result, I can test any part of that pipe chain, and I can &lt;em&gt;fix&lt;/em&gt; pieces independent of each other. No part depends on being in the middle of a looper where transformations are done to other parts.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because they’re small and do one simple things, I can recombine those pieces any way I like. And you see that in the Ramda examples in particular: most of what we’re doing in those examples is not even something we wrote ourselves. They’re also &lt;em&gt;really&lt;/em&gt; basic building blocks, available in basically every standard library.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One last thing: if you’re curious about performance… you should know that it does matter for data at scale. In my tests (which are admittedly extremely unscientific; unfortunately, I couldn’t get JSPerf running nicely with this particular set of variations), I found that the time it took to run these varied depending on the approach &lt;em&gt;and&lt;/em&gt; the library. With a ~10k-record data set:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The imperative version, unsurprisingly, was the fastest, taking ~16–17ms.&lt;/li&gt;
&lt;li&gt;After that, the chained lodash version and the pure-&lt;abbr&gt;JS&lt;/abbr&gt; version were comparable, at ~32–36ms, or around twice as long to finish as the imperative version.&lt;/li&gt;
&lt;li&gt;The plain lodash version was consistently a &lt;em&gt;little&lt;/em&gt; slower yet, at ~38–43ms.&lt;/li&gt;
&lt;li&gt;Ramda is &lt;em&gt;slow&lt;/em&gt;: both variations consistently took over 90ms to finish.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those differences added up on larger data sets: dealing with ~10,000,000 records, the times ranged from ~12s for the imperative version, to ~15s for the lodash and pure-&lt;abbr&gt;JS&lt;/abbr&gt; variants, to ~50s for the Ramda version.&lt;/p&gt;
&lt;p&gt;They were all pretty darn quick. Compilers, including JavaScript &lt;abbr&gt;JIT&lt;/abbr&gt;s, are incredibly smart. Mostly you can just trust them; come back and profile before you even &lt;em&gt;think&lt;/em&gt; about optimizing things. But you &lt;em&gt;should&lt;/em&gt; know the performance characteristics of different libraries and consider the implications of what the language does well and what it doesn’t. Ramda is likely slower because of the way it curries every function—something that works well in languages with native support for it, e.g. F&lt;sup&gt;♯&lt;/sup&gt; or Elm or Haskell, but imposes a penalty in languages which don’t… like JavaScript. That said, if you’re not in the habit of processing tens of thousands of records, you’re probably okay using any of them.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;or &lt;a href="https://github.com/lodash/lodash/wiki/FP-Guide"&gt;lodash-fp&lt;/a&gt;, but Ramda is a bit better documented and I just like it a little better&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 11 Nov 2016 22:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-11:/2016/what-is-functional-programming.html</guid><category>software development</category><category>functional programming</category><category>javascript</category></item></channel></rss>