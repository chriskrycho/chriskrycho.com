<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - rust</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Wed, 07 Nov 2018 07:00:00 -0500</lastBuildDate><item><title>Review: The Rust Programming Language</title><link>http://www.chriskrycho.com/2018/review-the-rust-programming-language.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I intended to publish this review months ago, but the single hardest month of my career punched me in the face repeatedly and I just found myself entirely unable to write for all of September and most of October. Here it is at last, with apologies to No Starch for the delay!&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;No Starch Press kindly provided me with a review copy of &lt;a href="https://nostarch.com/Rust"&gt;&lt;cite&gt;The Rust Programming Language&lt;/cite&gt;&lt;/a&gt;, by Steve Klabnik and Carol Nichols, with contributions from the Rust community. A &lt;em&gt;real-world, physical&lt;/em&gt; review copy. And it’s magnificent.&lt;/p&gt;
&lt;p&gt;TODO: add image!&lt;/p&gt;
&lt;p&gt;I’ve read the vast majority of this book (as well as the previous edition) online over the last couple years as Steve and Carol have worked on it; it has been an invaluable resource for many a &lt;a href="https://newrustacean.com"&gt;New Rustacean&lt;/a&gt; episode. (Bonus: you can hear me talk with Carol about working on &lt;cite&gt;The Rust Programming Language&lt;/abbr&gt; in &lt;a href="https://newrustacean.com/show_notes/interview/_3/index.html"&gt;my interview with her back in 2016&lt;/a&gt;! And yes: writing the book took that long.) This is in some sense &lt;em&gt;the&lt;/em&gt; authoritative book on Rust.&lt;/p&gt;
&lt;p&gt;You might wonder why you’d pick up a physical copy of this book given that it is available online for free. There are a few reasons that come to mind:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;The quality of the online book is in many ways a direct result of No Starch Press’ deep investment in the text. They’re not making any money from the online copy. They &lt;em&gt;do&lt;/em&gt; recoup some of their costs when we buy ebook or physical copies. So that’s one good reason: a way of saying “thank you!” and investing in the continued existence of No Starch and projects like this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I used the word &lt;em&gt;magnificent&lt;/em&gt; above to describe this, and I mean it. This printing is a fabulous example of really excellent book design. I take typography and presentation seriously, and not a whit less for programming books than for copies of &lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;The Lord of the Rings&lt;/cite&gt;. Everything in this printing is top-notch. Little details like the way that code listings are displayed—right down to the way some text is faded away to emphasize what’s &lt;em&gt;new&lt;/em&gt; in a listing—make this one of the most readable programming texts I’ve ever seen.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As delightful and powerful as hypertext is, the physicality of a book is equally delightful and powerful, just in different ways. There is nothing quite like the tactile experience of flipping through a book. Nothing in digital text lets you forge connections to learning the way that scribbling notes in a margin does. And the sheer physicality of a volume this large gives you mental hooks to hang what you’re learning on: you can remember that it felt like &lt;em&gt;this&lt;/em&gt; to have the book open to where you learned it.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(That last point is an argument in favor of printed books in general. You can expect me to come back to that theme time and again in this space (even while I continue to value digital spaces like this one for what &lt;em&gt;they&lt;/em&gt; uniquely do.)&lt;/p&gt;
&lt;p&gt;No Starch sent me this copy to review with no expectation of a positive review—but even if they’d been paying me, they couldn’t make me say that this book is &lt;em&gt;great&lt;/em&gt;. But great it is. If you have any interest in &lt;a href="https://www.rust-lang.org/en-US/"&gt;Rust&lt;/a&gt;, you should grab a copy!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 07 Nov 2018 07:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-11-07:/2018/review-the-rust-programming-language.html</guid><category>book reviews</category><category>rust</category><category>programming languages</category></item><item><title>Scales of Feedback Time in Software Development</title><link>http://www.chriskrycho.com/2018/scales-of-feedback-time-in-software-development.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;&lt;strong&gt;&lt;a href="http://www.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience&lt;/a&gt;:&lt;/strong&gt; fans of compiled languages with expressive type systems. I’m not trying to persuade fans of dynamic languages they should use a compiler here; I’m trying to surface something that often goes unstated in discussions among fans of compiled languages with expressive type systems, but hopefully it’s interesting beyond that. If you don’t like compiled languages, just skip the build step bits; the rest all still applies.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;There are basically six stages of the development of any given software component where you can receive feedback on what you build:&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;compilers, static analysis tools, and/or pair programming&lt;/li&gt;
&lt;li&gt;automated test suites&lt;/li&gt;
&lt;li&gt;manual local testing&lt;/li&gt;
&lt;li&gt;continuous integration (&lt;abbr&gt;CI&lt;/abbr&gt;) test results&lt;/li&gt;
&lt;li&gt;deploying to staging (or a similar test environment) for manual testing&lt;/li&gt;
&lt;li&gt;deploying to live, i.e. when production traffic is meaningfully different from what you can test on staging&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What’s interesting to note is that there are also, in my experience, roughly order-of-magnitude differences between each of those layers in terms of the &lt;em&gt;cycle time&lt;/em&gt; between when you make a change and whether you know it is broken. That is, there seem to be rough factor-of-ten differences between the feedback you get from—&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;compilers, static analysis tools, and/or pair programming—all of which can show you feedback in near-real-time as you’re typing and saving your code, especially with a good language server or a fast compiler or a speedy linter&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;automated test suites, assuming they’re running on every build change and are reasonably speedy themselves, or scoped to the things impacted by the changes made&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;manual local testing, which you can repeat after every build, but which usually requires you to switch contexts to execute the program in some way&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;abbr&gt;CI&lt;/abbr&gt;, presumably doing the automated equivalent of what you do in both layers 2 and 3, but requiring a push to some central location and a remote build and execution of the test suite, and often a much larger integration test suite than you’d run locally&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;deploying to staging, and repeating the same kinds of manual testing you might do locally in layer 2 in a more production-like environment&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;deploying to live, and repeating the same kinds of manual testing you might do locally in layers 2 or 5, as well as getting feedback from observability or monitoring systems using your real traffic&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(Those last two &lt;em&gt;might&lt;/em&gt; be comparable in the cycle time sense. However, the way most teams I’ve heard of work, any deploy to live is usually preceded by a deploy to staging. What’s more, with most changes that you can’t test until it’s live, it’s often the case that you’re not going to know if something is wrong until it has been live for at least a little while. Finally, some kinds of things you can really only test with production load and monitoring or observability systems, and those kinds of things are at least sometimes not to be visible immediately after deployment, but only in the system’s aggregate behavior or weird outliers that show up given enough scale.)&lt;/p&gt;
&lt;p&gt;What all of this gets at is that stepping to a higher layer nearly always entails a &lt;em&gt;dramatic&lt;/em&gt; increase in the &lt;em&gt;cycle time&lt;/em&gt; for software development: that is, the amount of time between when I make a change and when I know whether it’s broken or not. If I can know that I have a problem because my compiler surfaces errors in my editor, that probably saves me a minute or two each day over only being able to see the same error in a test suite. By the same token, being able to surface an error in a test suite running on every build will likely save me anything from minutes to hours of cycle time compared to something I can only test in production.&lt;/p&gt;
&lt;p&gt;At first blush, this looks like an argument for pushing everything to the lowest-numbered layer possible, and I think that’s &lt;em&gt;kind of&lt;/em&gt; right. I (and probably many other people who end up in, say, Rust or Haskell or Elm or other languages with similarly rich type systems) tend to prefer putting as much as possible into layer 1 here precisely because we have so often been bitten by things that are at layer 2 in other languages or frameworks and take a lot of time to figure out why they broke at layer 2. This happened to me in a C&lt;sup&gt;♯&lt;/sup&gt; server application just a couple weeks ago, and chasing it down was &lt;em&gt;not fun&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, my enthusiasm for rich type systems notwithstanding, I &lt;em&gt;don’t&lt;/em&gt; think this observation about these layers of cycle time means we should put everything in the compiler all the time. Indeed, there are some things it is too expensive or difficult to test anywhere &lt;em&gt;but&lt;/em&gt; production (all the way up at layer 6). What’s more–although this is often overlooked in these discussions–putting too much of this rich information in layer 1 can absolutely kill your compile times in many languages. In my experience, this is particularly true of many of the languages with rich enough type systems to make layer 1 handling genuinely viable in the first place!&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I do think, though, that being aware of the cost in cycle time is useful, as is being explicit about &lt;em&gt;why&lt;/em&gt; we think it’s worth slotting a particular set of feedback into layer 2 vs. layer 1 (or layers 3, 4, 5, or 6). That goes for library development, of course.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; It goes equally for application development, though! It can be really helpful to make explicit both which of these layers you’re landing in and (just as important) why you’ve landed there for any given bit of feedback you want or need to get–making the tradeoffs explicit along the way.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;Thanks to my friend Ben Makuh for looking over an earlier draft of this piece and providing really helpful feedback on it! Thanks as well to Greg Vaughn for noting shortly after I published it that pair programming also sits at the “immediate feedback” layer.&lt;/i&gt;&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;There’s some ongoing work in the Rust web working group to build an exemplar web framework, &lt;a href="https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html"&gt;Tide&lt;/a&gt;. The &lt;a href="https://rust-lang-nursery.github.io/wg-net/2018/10/16/tide-routing.html"&gt;most recent post&lt;/a&gt; tackled routing, and prompted &lt;a href="https://internals.rust-lang.org/t/routing-and-extraction-in-tide-a-first-sketch/8587"&gt;an interesting discussion&lt;/a&gt; on the &lt;a href="https://internals.rust-lang.org/"&gt;Rust internals forum&lt;/a&gt;. This post is a cleaned-up, better-articulated, more general version of &lt;a href="https://internals.rust-lang.org/t/routing-and-extraction-in-tide-a-first-sketch/8587/36?u=chriskrycho"&gt;a post&lt;/a&gt; I offered in that thread.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Right now I and a few others are trying to figure out why one particular type definition in the TypeScript definitions for Ember.js causes a build to take about 20× as long as the build without that type definition. It’s the difference between a 6.5-second build and a 2.5-&lt;em&gt;minute&lt;/em&gt; build.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;as in the example of a web server’s &lt;abbr&gt;API&lt;/abbr&gt; for route handling which originally prompted this post&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 22 Oct 2018 21:15:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-10-22:/2018/scales-of-feedback-time-in-software-development.html</guid><category>software development</category><category>testing</category><category>programming languages</category><category>Rust</category></item><item><title>Rust is Incredibly Productive for CLIs</title><link>http://www.chriskrycho.com/2018/rust-is-incredibly-productive-for-clis.html</link><description>&lt;p&gt;There are &lt;em&gt;reasons&lt;/em&gt; I’m a Rust fanboy. One of them is the kind of thing I proved out to myself today—again, because I’ve had this experience before, albeit not with anything quite this “complicated.”&lt;/p&gt;
&lt;p&gt;I built &lt;a href="https://github.com/chriskrycho/evernote2md"&gt;a little tool&lt;/a&gt; in Rust to convert Evernote exports (in their custom &lt;code&gt;.enex&lt;/code&gt; &lt;abbr&gt;XML&lt;/abbr&gt; format) to Markdown files with &lt;abbr&gt;YAML&lt;/abbr&gt; metadata headers—mostly just to see how quickly and effectively I could do it, because I’ve never actually had an excuse to use &lt;a href="https://serde.rs"&gt;Serde&lt;/a&gt; and I thought this might be a nice spot to try it.&lt;/p&gt;
&lt;p&gt;There’s a lot this little library &lt;em&gt;doesn’t&lt;/em&gt; do. (Like include the creation and modification timestamps in the header, for example.) But all of those things would be &lt;em&gt;very&lt;/em&gt; straightforward to do. I built this functioning little “script” in about two hours. For context: I’ve taken multiple passes at this in Python—which in the way people normally think about these things should be way &lt;em&gt;easier&lt;/em&gt;—and I’ve failed both times.&lt;/p&gt;
&lt;p&gt;Rust’s compiler just helps you out &lt;em&gt;so much&lt;/em&gt; along the way, not only with the type-checking but with the really amazing metaprogramming capabilities you get with it. Being able to slap &lt;code&gt;#[derive(Deserialize)]&lt;/code&gt; on a struct and a couple attributes on struct fields and having it Just Work™ to deserialize XML into local types is mind-blowing. (The only thing I know of that’s playing the same game is F&lt;sup&gt;♯&lt;/sup&gt; type-providers. I’d love to hear about similar capabilities in other languages!)&lt;/p&gt;
&lt;p&gt;I’m basically at the point where if I need a small command-line tool, I write it in Rust, &lt;em&gt;not&lt;/em&gt; in a conventional scripting language like Python, because the benefits I get more than outweigh whatever small extra amount of mental overhead there is. And there’s not much of that mental overhead anyway for this kind of thing! As you can see &lt;a href="https://github.com/chriskrycho/evernote2md/blob/master/src/main.rs#L71"&gt;in the actual code&lt;/a&gt;, I make free and liberal use of &lt;a href="https://doc.rust-lang.org/1.26.0/std/option/enum.Option.html"&gt;&lt;code&gt;expect&lt;/code&gt;&lt;/a&gt; for this kind of tool.&lt;/p&gt;
&lt;p&gt;It’s also hard to oversell the ecosystem—even as relatively nascent as it is compared to some much older languages, the tools which exist are just really good. This project uses &lt;a href="https://serde.rs"&gt;Serde&lt;/a&gt; for deserializing from &lt;abbr&gt;XML&lt;/abbr&gt; and serializing to &lt;abbr&gt;YAML&lt;/abbr&gt;; &lt;a href="https://github.com/rust-lang/regex"&gt;Regex&lt;/a&gt;; &lt;a href="https://clap.rs"&gt;Clap&lt;/a&gt; for command line parsing; a nice little wrapper around &lt;a href="https://pandoc.org"&gt;pandoc&lt;/a&gt;; and, superpower even among superpowers, &lt;a href="https://docs.rs/rayon/1.0.1/rayon/"&gt;Rayon&lt;/a&gt;: free parallelization.&lt;/p&gt;
&lt;p&gt;Rust is, in short, &lt;em&gt;very productive&lt;/em&gt; for things in this space. Far more than you might expect from the billing. Yes, it’s a “systems programming language” and you can write operating systems with it. But it’s also just a really great tool for &lt;em&gt;all sorts&lt;/em&gt; of domains, including little &lt;abbr&gt;CLI&lt;/abbr&gt; tools like this one.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 20 May 2018 08:35:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-20:/2018/rust-is-incredibly-productive-for-clis.html</guid><category>Rust</category><category>programming languages</category></item><item><title>Aesthetics and Programming Languages</title><link>http://www.chriskrycho.com/2018/aesthetics-and-programming-languages.html</link><description>&lt;p&gt;My distaste for the aesthetics of C&lt;sup&gt;♯&lt;/sup&gt; are fairly well known to people I talk to about programming languages—perhaps equally as well known as my love of Rust. So much so that both are running jokes among some of my colleagues and friends. My hypersensitivity to aesthetics both in general and also specifically in programming languages and work environment is &lt;em&gt;also&lt;/em&gt; so well-known as to be a gag.&lt;/p&gt;
&lt;p&gt;But I was writing a bunch of Rust this weekend, and looking at it and thinking about it and wondering why it is that C&lt;sup&gt;♯&lt;/sup&gt; drives me so up the wall aesthetically and experientially, while Rust doesn’t. On the surface, they don’t actually look all that different.&lt;/p&gt;
&lt;p&gt;Here’s &lt;em&gt;roughly&lt;/em&gt; equivalent code in each:&lt;/p&gt;
&lt;pre class="cs"&gt;&lt;code&gt;public class Person {
    public string Name { get; set; } = &amp;quot;Chris&amp;quot;;

    public void greet() {
        Console.WriteLine($&amp;quot;Hello, {Name}&amp;quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Person {
    name: String,
}

impl Person {
    pub fn new() -&amp;gt; Person {
        Person { name: String::from(&amp;quot;Chris&amp;quot;) }
    }

    pub fn greet(&amp;amp;self) {
        println!(&amp;quot;Hello, {}&amp;quot;, self.name);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you start tossing in generics and lifetimes, Rust can actually end up looking a &lt;em&gt;lot&lt;/em&gt; messier than C&lt;sup&gt;♯&lt;/sup&gt;.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;impl&amp;lt;&amp;#39;a, &amp;#39;b, T, U&amp;gt; SomeTrait&amp;lt;&amp;#39;a, U&amp;gt; for SomeType&amp;lt;&amp;#39;b, U&amp;gt;
where
    T: SomeOtherTrait + YetAnotherTrait,
    U: OhWowSoManyTraits
{
    fn some_trait_method(&amp;amp;self) {
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing about that is what I would call aesthetically beautiful in a general sense! There’s a &lt;em&gt;lot&lt;/em&gt; of syntax.&lt;/p&gt;
&lt;p&gt;What I’ve concluded so far, though, is that my difference in feelings comes down to the way that syntax maps back to the underlying semantics, and my feelings about those underlying semantics. The basic language design approach C&lt;sup&gt;♯&lt;/sup&gt; takes—i.e. everything is a class; mutation is both encouraged and implicit; don’t bother with value types—drives me batty. I don’t love the syntax, not least because it ends up being &lt;em&gt;so&lt;/em&gt; verbose and noisy (you can express the same things in F&lt;sup&gt;♯&lt;/sup&gt; much more briefly)—but also because I actively dislike the programming models it encourages (I don’t like the C&lt;sup&gt;♯&lt;/sup&gt; programming model when I see in in F&lt;sup&gt;♯&lt;/sup&gt; either!).&lt;/p&gt;
&lt;p&gt;Rust, by contrast, matches the way I &lt;em&gt;do&lt;/em&gt; and &lt;em&gt;want to&lt;/em&gt; think about the world. Mutability is allowed but neither actively encouraged nor actively discouraged; more to the point it’s &lt;em&gt;explicit&lt;/em&gt;. Insofar as “shared mutable state is the root of all evil,” Rust has two legs up on C&lt;sup&gt;♯&lt;/sup&gt;: it (a) doesn’t &lt;em&gt;allow&lt;/em&gt; shared mutable state and (b) makes explicit where mutation &lt;em&gt;is&lt;/em&gt; happening. It also separates data from behavior. It also has real value types. It also has sum types and pattern matching. In both cases, a lot of the syntactical noise is inessential, a holdover from the legacy of C; but in Rust’s case the way it maps onto a &lt;em&gt;programming model&lt;/em&gt; that is more like OCaml than like C decreases the pain I feel from that noise.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;could&lt;/em&gt; be taken to validate the idea that syntax doesn’t matter, that the underlying semantics are everything, but that’s not the case. It’s not that I &lt;em&gt;love&lt;/em&gt; Rust’s syntax. It’s that, although I dislike it at times, it doesn’t rise to the level of frustration I feel in C&lt;sup&gt;♯&lt;/sup&gt; because it’s not coupled to a programming model that I loathe. The syntax matters; it’s just not the &lt;em&gt;only&lt;/em&gt; thing that matters.&lt;/p&gt;
&lt;p&gt;An interesting thing to consider: what Rust would look like in a world where it embraced its OCaml roots. (I don’t think Rust should have done this; spending its complexity budget on ideas instead of syntax was the right choice. But it’s still interesting.) The simplest level of translation might look something (very) roughly like this:&lt;/p&gt;
&lt;pre class="haskell"&gt;&lt;code&gt;impl &amp;#39;a &amp;#39;b T U SomeTrait &amp;#39;a T for SomeType &amp;#39;b U
  where T : SomeOtherTrait + YetAnotherTrait

  some_trait_method :: &amp;amp;self -&amp;gt; void
  some_trait_method self =
    -- ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is obviously still a lot of syntax, but it’s all basically necessary given the things Rust is trying to express with lifetimes, ownership, etc.—and I did this off the top of my head with literally &lt;em&gt;no&lt;/em&gt; consideration other than “what’s the most direct translation into roughly Haskell-ish syntax I can write?” It makes me genuinely curious where a language that aimed for Rust’s same kinds of guarantees but actively embracing the ML/Haskell family’s syntax might end up. I have a guess that I’d like it even better than I do Rust.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 13 May 2018 11:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-13:/2018/aesthetics-and-programming-languages.html</guid><category>csharp</category><category>rust</category><category>programming languages</category></item><item><title>Exploring 4 Languages: Integrity and Consistency</title><link>http://www.chriskrycho.com/2018/exploring-4-languages-integrity-and-consistency.html</link><description>&lt;p&gt;In chapter 6, Wlaschin turns to one of the most important aspects of “domain modeling”: keeping it consistent. It’s all well and good to set up a domain model, but if you don’t have a way to make sure that model is reliable everywhere you use it, well… you’ve done a lot of extra work and you’re not going to see a lot of results for all that effort! But as Wlaschin points out, we can actually use the type systems, and the types we wrote up in the previous chapter, to help us enforce the business &lt;em&gt;rules&lt;/em&gt; for our domain (as well as the business &lt;em&gt;shapes&lt;/em&gt; in the domain).&lt;/p&gt;
&lt;p&gt;An important note: you can see the latest version of this code (along with history indicating some of my travails in getting there!) in &lt;a href="https://github.com/chriskrycho/dmmf"&gt;this public repository on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;section id="a-simple-example-widgetcode" class="level2"&gt;
&lt;h2&gt;A simple example: &lt;code&gt;WidgetCode&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;We’ll start with one of the simpler examples: validating that a &lt;code&gt;WidgetCode&lt;/code&gt; is legitimate. A &lt;code&gt;WidgetCode&lt;/code&gt;, in this domain, is valid if, and &lt;em&gt;only&lt;/em&gt; if, it has a &lt;code&gt;W&lt;/code&gt; followed by four digits.&lt;/p&gt;
&lt;p&gt;The basic tack we’ll take, in all four languages, is to leverage the way the types work to make it so we have to use a function to create a valid instance of a &lt;code&gt;WidgetCode&lt;/code&gt;. That’s a bit of extra work (though especially in the functional-first languages, it ends up not being a &lt;em&gt;lot&lt;/em&gt; of extra work) but it lets us use &lt;code&gt;Result&lt;/code&gt; types to handle invalid data up front.&lt;/p&gt;
&lt;p&gt;The downside is that we can’t just get directly at the value inside our wrapper types using basic pattern matching. Instead, we need to be provide a function for “unwrapping” it. Tradeoffs!&lt;/p&gt;
&lt;p&gt;We’ll go at this using the most appropriate tool from each language, but in every case we’ll end up with a &lt;code&gt;create&lt;/code&gt; function that takes a string and returns a &lt;code&gt;Result&lt;/code&gt; with the successful option being a &lt;code&gt;WidgetCode&lt;/code&gt; and the error option being a string describing the error; and a &lt;code&gt;value&lt;/code&gt; function to unwrap a valid code. Throughout, I also assume an essentially-identical implementation of a related &lt;code&gt;GizmoCode&lt;/code&gt; type; I pull both in to show how they end up being used side by side.&lt;/p&gt;
&lt;section id="rust" class="level3"&gt;
&lt;h3&gt;Rust&lt;/h3&gt;
&lt;p&gt;We are using a tuple struct to wrap the string value here. Since there is no &lt;code&gt;pub&lt;/code&gt; modifier in the wrapped &lt;code&gt;String&lt;/code&gt;, it’s opaque from the perspective of the caller—and this is exactly what we want. We’ll pull in &lt;a href="https://docs.rs/regex/0.2.10/regex/"&gt;the &lt;code&gt;Regex&lt;/code&gt; crate&lt;/a&gt; and validate the code passed to us on creation.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use regex::Regex;

pub struct WidgetCode(String);

impl WidgetCode {
    pub fn create(code: &amp;amp;str) -&amp;gt; Result&amp;lt;WidgetCode, String&amp;gt; {
        let re = Regex::new(r&amp;quot;W\d{4}&amp;quot;).expect(r&amp;quot;W\d{4} is a valid regex&amp;quot;);
        if re.is_match(code) {
            Ok(WidgetCode(String::from(code)))
        } else {
            Err(String::from(
                &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;,
            ))
        }
    }

    pub fn value(&amp;amp;self) -&amp;gt; &amp;amp;str {
        &amp;amp;self.0
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fairly idiomatic Rust: we’re &lt;em&gt;borrowing&lt;/em&gt; a &lt;em&gt;reference&lt;/em&gt; to the code as a “string slice”, and creating a new, wrapped &lt;code&gt;String&lt;/code&gt; instance to wrap up the code &lt;em&gt;or&lt;/em&gt; return a new &lt;code&gt;String&lt;/code&gt; as an error. When we get the value out, we return a reference to the string,&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; with &lt;code&gt;&amp;amp;self.0&lt;/code&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; to indicate a reference, &lt;code&gt;.0&lt;/code&gt; to indicate the first item of a tuple. Note as well that the final &lt;code&gt;if&lt;/code&gt; block here is an expression. There’s no semicolon terminating it, and this whole &lt;code&gt;if&lt;/code&gt; block ends up being the resulting value of the function.&lt;/p&gt;
&lt;p&gt;One other point of interest here is that the creation of the regex &lt;em&gt;itself&lt;/em&gt; is checked by the compiler for us! If we pass an invalid regular expression, this simply won’t compile.&lt;/p&gt;
&lt;p&gt;This could also live in its own module, &lt;code&gt;ordering/widget_code.rs&lt;/code&gt;, and in fact that’s how I would normally do this (and have in the repository where I’m working): every one of these small types would get its own module file within the containing &lt;code&gt;Ordering&lt;/code&gt; module. It’s not &lt;em&gt;necessary&lt;/em&gt;, but as the domain model grows, it becomes increasingly &lt;em&gt;convenient&lt;/em&gt; in that you always know where to find things.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Then we can import it and use it like this in &lt;code&gt;ordering/mod.rs&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;mod widget_code;
mod gizmo_code;

use widget_code::WidgetCode;
use gizmo_code::GizmoCode;

pub enum ProductCode {
    Widget(WidgetCode),
    Gizmo(GizmoCode),
}

fn demo_it() {
    let valid = WidgetCode::create(&amp;quot;W1234&amp;quot;);
    let invalid = WidgetCode::create(&amp;quot;wat&amp;quot;);

    let unwrapped = match valid {
        Ok(ref code) =&amp;gt; code.value(),
        Err(_) =&amp;gt; &amp;quot;&amp;quot;,
    };
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that in Rust, the &lt;code&gt;mod.rs&lt;/code&gt; file declares all child modules. If you had a &lt;code&gt;widget_code.rs&lt;/code&gt; on the file system but no &lt;code&gt;mod widget_code;&lt;/code&gt;, Rust would just ignore the declaration entirely. Then Rust also requires us to &lt;code&gt;use widget_code;&lt;/code&gt; to access its contents. The distinction between declaring and using a given module makes some sense: by the time all is said and done with this exercise, we won’t be doing much of anything in this &lt;code&gt;Ordering&lt;/code&gt; module; it’ll exist primarily as a grouping construct for all the &lt;em&gt;other&lt;/em&gt; modules.&lt;/p&gt;
&lt;p&gt;In this case, we go ahead and import the &lt;code&gt;WidgetCode&lt;/code&gt; type from the module. We only have the one type there, with no standalone functions: everything is attached to the type via the &lt;code&gt;impl&lt;/code&gt; block; so we can just call everything directly off of the type. This ends up feeling &lt;em&gt;kind of&lt;/em&gt; like the way we’d do things in a traditional OOP language, but also &lt;em&gt;really not&lt;/em&gt;, because we still have a separation between the data type and the implementation of functionality attached to it. It’s not obvious &lt;em&gt;here&lt;/em&gt;, but we could write &lt;code&gt;impl WidgetCode&lt;/code&gt; in some &lt;em&gt;other&lt;/em&gt; module in the crate, and as long as there’s no conflict between the implementations, it’s fine! And then we could call whatever function we defined in &lt;em&gt;that&lt;/em&gt; block “on” &lt;code&gt;WidgetCode&lt;/code&gt;. This is on the one hand &lt;em&gt;totally&lt;/em&gt; unlike what we’ll see in the other languages, and on the other hand &lt;em&gt;weirdly analogous&lt;/em&gt; to them.&lt;/p&gt;
&lt;p&gt;I’m going to pass over why we need &lt;code&gt;ref code&lt;/code&gt; here, as it gets into details of Rust’s model of ownership and reference borrowing &lt;em&gt;and&lt;/em&gt; it’s going to be unneeded because of improvements to Rust’s compiler fairly soon. The one thing to note here is that we get nice memory/allocation behavior, i.e. we’re not doing a bunch of separate heap string allocations here. This is one of the big upsides to Rust in general! It’s not quite as pretty as what we’ll see below, but the performance wins are awesome.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="elm" class="level3"&gt;
&lt;h3&gt;Elm&lt;/h3&gt;
&lt;p&gt;Elm introduces us to a pattern we’ll see in each of the more traditional “functional” languages: the use of &lt;em&gt;modules&lt;/em&gt; for this kind of structure. First the code, then some comments on it:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- src/ordering/WidgetCode.elm
module Ordering.WidgetCode exposing (WidgetCode, create, value)

import Regex exposing (contains, regex)


type WidgetCode
    = WidgetCode String


create : String -&amp;gt; Result String WidgetCode
create code =
    if contains (regex &amp;quot;W\\d{4}&amp;quot;) code then
        Ok (WidgetCode code)
    else
        Err &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;


value : WidgetCode -&amp;gt; String
value (WidgetCode code) =
    code&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm’s module system lets you choose exactly what to expose. In this case, we’re only exporting the type itself along the &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; functions—but, importantly, &lt;em&gt;not&lt;/em&gt; the normal type constructors for the type.&lt;/p&gt;
&lt;p&gt;You can import the things exposed both as a module and as individual items. Assume we implemented &lt;code&gt;GizmoCode&lt;/code&gt; the same way. We’d import and use them in &lt;code&gt;Ordering.elm&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- Ordering.elm
import Ordering.WidgetCode as WidgetCode exposing (WidgetCode)
import Ordering.GizmoCode as GizmoCode exposing (GizmoCode)

type ProductCode
    = Widget WidgetCode
    | Gizmo GizmoCode
    
valid =
    WidgetCode.create &amp;quot;W1234&amp;quot;


invalid =
    WidgetCode.create &amp;quot;wat&amp;quot;


unwrapped =
    case valid of
        Result.Ok code -&amp;gt;
            WidgetCode.value (code)

        Result.Err _ -&amp;gt;
            &amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with Rust, we can’t construct the type without using the provided function. As I’ve written the imports, you’d create a &lt;code&gt;WidgetCode&lt;/code&gt; by writing &lt;code&gt;WidgetCode.create &amp;quot;W1234&amp;quot;&lt;/code&gt;. You could also import it directly, but that would have its own problems once you had the &lt;code&gt;create&lt;/code&gt; function imported for &lt;code&gt;GizmoCode&lt;/code&gt; as well.&lt;/p&gt;
&lt;p&gt;Finally, notice the way we aliased the module name here with &lt;code&gt;as&lt;/code&gt; on the import: we don’t have to write out the fully qualified path this way. And there’s no conflict between the aliased module name and the type name – they live in their own namespaces (as it should be!). Importing the type name distinctly is handy because it means we don’t have to write the body of the union type out as &lt;code&gt;Widget WidgetCode.WidgetCode&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="f" class="level3"&gt;
&lt;h3&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;The F&lt;sup&gt;♯&lt;/sup&gt; code looks a &lt;em&gt;lot&lt;/em&gt; like the Elm code. The main differences here have to do with their module systems.&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;namespace Ordering

type WidgetCode = private WidgetCode of string
module WidgetCode =
    let create code =
        if Regex.IsMatch(code, @&amp;quot;W\d{4}&amp;quot;) then
            Ok (WidgetCode code)
        else
            Error &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;

    let value (WidgetCode code) = code&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we declare that we’re in the &lt;code&gt;namespace Ordering&lt;/code&gt;. Everything here will be publicly visible to everything &lt;em&gt;else&lt;/em&gt; in the &lt;code&gt;namespace Ordering&lt;/code&gt;. We could also make this a &lt;code&gt;module&lt;/code&gt;, and in that case we’d need to explicitly open it in other modules. Because it’s part of the base namespace we’re using for &lt;code&gt;Ordering&lt;/code&gt;, though, we get it for “free”. There’s a downside to this, though. More on that below.&lt;/p&gt;
&lt;p&gt;Also notice that this means that we have yet one more “namespace” for names to live in: &lt;code&gt;namespace&lt;/code&gt; names are different from &lt;code&gt;module&lt;/code&gt; are different from type names! So here we declare a top-level &lt;code&gt;module Ordering&lt;/code&gt; here so that we can actually write code that &lt;em&gt;does something&lt;/em&gt; in the file – &lt;code&gt;namespace&lt;/code&gt;s can only contain type definitions (including &lt;code&gt;module&lt;/code&gt; definitions).&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;namespace Ordering

type ProductCode =
    | Widget of WidgetCode
    | Gizmo of GizmoCode

module DemoIt =
    let valid = WidgetCode.create &amp;quot;W1234&amp;quot;
    let invalid = WidgetCode.create &amp;quot;wat&amp;quot;
    
    let unwrapped =
        match valid with
        | Ok(code) -&amp;gt; WidgetCode.value code
        | Error(_) -&amp;gt; &amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The things to notice here as particularly different from the others:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;We don’t have to explicitly import the module names, because we used the same namespace (&lt;code&gt;Ordering&lt;/code&gt;) to group them. We could also have done &lt;code&gt;namespace Ordering.WidgetCode&lt;/code&gt; and &lt;code&gt;open Ordering.WidgetCode&lt;/code&gt;; that might actually make more or less sense in the context. I &lt;em&gt;think&lt;/em&gt; this is probably more idiomatic, however, which is why I picked it.&lt;/li&gt;
&lt;li&gt;Since we’re keeping the rest of the containing module in the same namespace, we &lt;em&gt;do&lt;/em&gt; have to declare &lt;code&gt;module DemoIt&lt;/code&gt; for functionality – not just types – to live in. This is true for both &lt;code&gt;Ordering.fs&lt;/code&gt; and &lt;code&gt;WidgetCode.fs&lt;/code&gt; and so on.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This way of structuring things works really well, but it has one major downside compared to Elm and Rust: where any given name comes from is &lt;em&gt;not&lt;/em&gt; obvious from any given text file. Using modules instead of namespaces and using more fully qualified names &lt;em&gt;could&lt;/em&gt; help here, but the reality is simply that F&lt;sup&gt;♯&lt;/sup&gt; (like C&lt;sup&gt;♯&lt;/sup&gt;) basically leaves you out to dry here. My take is that this is basically what happens when you design a language &lt;em&gt;assuming&lt;/em&gt; IDE-like tooling. But especially when looking at e.g. GitHub diff views, or just browsing source code in general, I strongly prefer the way Elm and Rust generally lead you to do explicit imports or fully qualified paths. (Both have an escape hatch: Rust’s &lt;code&gt;use path::to::module::*;&lt;/code&gt; and Elm’s &lt;code&gt;import Path.To.Module exposing (..)&lt;/code&gt;, but both are actively discouraged as bad practice in &lt;em&gt;most&lt;/em&gt; situations.)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="reason" class="level3"&gt;
&lt;h3&gt;Reason&lt;/h3&gt;
&lt;p&gt;Interestingly, Reason &lt;em&gt;looks&lt;/em&gt; most like Rust but &lt;em&gt;behaves&lt;/em&gt; most like F&lt;sup&gt;♯&lt;/sup&gt;. The biggest difference is that I need a separate &lt;em&gt;interface file&lt;/em&gt; for Reason to get the privacy benefits that I’m getting in all the other languages.&lt;/p&gt;
&lt;p&gt;We put the definition file at &lt;code&gt;ordering/Ordering_WidgetCode.rei&lt;/code&gt;. (I’ll comment on the long name in a moment.)&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type gizmoCode = pri | GizmoCode(string);

let create: string =&amp;gt; Js.Result.t(widgetCode, string);

let value: widgetCode =&amp;gt; string;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that module definition in place, we can separately supply the implementation, in &lt;code&gt;ordering/Ordering_WidgetCode.re&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type widgetCode =
  | WidgetCode(string);

let create = code =&amp;gt; {
  let isMatch =
    Js.Re.fromString(&amp;quot;W\\d{4}&amp;quot;) |&amp;gt; Js.Re.exec(code) |&amp;gt; Js.Option.isSome;
  if (isMatch) {
    Js.Result.Ok(WidgetCode(code));
  } else {
    Js.Result.Error(
      &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;
    );
  };
};

let value = (WidgetCode(code)) =&amp;gt; code;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that you could do the same thing with an interface file for F&lt;sup&gt;♯&lt;/sup&gt;. We’re also doing something that’s similar in principle to the use of private types in in F&lt;sup&gt;♯&lt;/sup&gt;, but unlike in F&lt;sup&gt;♯&lt;/sup&gt; we &lt;em&gt;have&lt;/em&gt; to use the module interface to make it work as far as I can tell. The &lt;em&gt;interface&lt;/em&gt; can declare the type private, but in the actual implementation, the type has to be non-private to be constructable. (If I’m wrong, please send me a note to let me know! But that’s what I gathered from reading OCaml docs, as well as from command line error messages as I played around.) Also, the fact that Reason has landed on the keyword &lt;code&gt;pri&lt;/code&gt; instead of OCaml and F&lt;sup&gt;♯&lt;/sup&gt;’s much saner &lt;code&gt;private&lt;/code&gt; is super weird.&lt;/p&gt;
&lt;p&gt;The interface file just defines the types, and has the &lt;code&gt;.rei&lt;/code&gt; extension. &lt;code&gt;type widgetCode&lt;/code&gt; here is an &lt;em&gt;abstract&lt;/em&gt; type, which provides no information about what it contains. Note the function types are provided as well. Here I’m using specifically the &lt;code&gt;Js.Result&lt;/code&gt; type; there is also a &lt;code&gt;Result&lt;/code&gt; type in at least one of the OCaml standard libraries. This is one of the more complicated things about Reason compared to the others: there are… &lt;em&gt;several&lt;/em&gt; standard libraries to choose from, which will or won’t work differently depending on what compile target you’re picking.&lt;/p&gt;
&lt;p&gt;In any case, once we have both the module and the implementation defined, we can use it like this in &lt;code&gt;ordering.re&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;module WidgetCode = Ordering_WidgetCode;

module GizmoCode = Ordering_GizmoCode;

open WidgetCode;

open GizmoCode;

type productCode =
  | Widget(widgetCode)
  | Gizmo(gizmoCode);

let valid = WidgetCode.create(&amp;quot;W1234&amp;quot;);

let invalid = WidgetCode.create(&amp;quot;wat&amp;quot;);

let unwrapped =
  switch valid {
  | Js.Result.Ok(code) =&amp;gt; WidgetCode.value(code)
  | Js.Result.Error(_) =&amp;gt; &amp;quot;&amp;quot;
  };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We do this mapping from &lt;code&gt;Ordering_WidgetCode&lt;/code&gt; to &lt;code&gt;WidgetCode&lt;/code&gt; here because OCaml and therefore Reason has only a single global namespace for its module names as defined by the file system. You can nest modules, but only &lt;em&gt;within&lt;/em&gt; files. The workaround is, well… &lt;code&gt;Ordering_&lt;/code&gt; and remapping the name as we have here. This lets you access the nested modules as &lt;code&gt;Ordering.WidgetCode&lt;/code&gt; and so on elsewhere.&lt;/p&gt;
&lt;p&gt;Then we &lt;code&gt;open WidgetCode&lt;/code&gt; etc. so that we can write &lt;code&gt;widgetCode&lt;/code&gt; instead of &lt;code&gt;WidgetCode.widgetCode&lt;/code&gt; in the &lt;code&gt;productCode&lt;/code&gt; definition. This is basically the same effect we get from just being in the same &lt;code&gt;namespace&lt;/code&gt; in F&lt;sup&gt;♯&lt;/sup&gt; (which, again, we could rewrite exactly this way), or from the kinds of imports we discussed above for Rust and Elm.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="numeric-validation-unitquantity" class="level2"&gt;
&lt;h2&gt;Numeric validation: &lt;code&gt;UnitQuantity&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;So far, the showing tilts &lt;em&gt;heavily&lt;/em&gt; in F&lt;sup&gt;♯&lt;/sup&gt;’s and Elm’s favor in terms of expressiveness and elegance. However, there’s a lot of variation depending on exactly what you’re doing. If, for example, you want to validate a &lt;em&gt;range&lt;/em&gt;, well… then Rust actually has a pretty good approach! Once again, you’ll note that these all have a lot in common; the difference mostly comes down to the degree of syntactical noise required to express the same basic thing.&lt;/p&gt;
&lt;p&gt;In this section, I’m not really going to spend a lot of time discussing the details and differences; I’m just leaving it here to show an interesting example where the languages’ design decisions end up have slightly different ergonomic tradeoffs.&lt;/p&gt;
&lt;section id="rust-1" class="level3"&gt;
&lt;h3&gt;Rust&lt;/h3&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// ordering/unit_quantity.rs
pub struct UnitQuantity(u32);

impl UnitQuantity {
    pub fn create(qty: u32) -&amp;gt; Result&amp;lt;UnitQuantity, String&amp;gt; {
        match qty {
            0 =&amp;gt; Err(String::from(&amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;)),
            1...1000 =&amp;gt; Ok(UnitQuantity(qty)),
            _ =&amp;gt; Err(String::from(&amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;)),
        }
    }

    pub fn value(&amp;amp;self) -&amp;gt; u32 {
        self.0
    }

    pub fn minimum() -&amp;gt; UnitQuantity {
        UnitQuantity(1)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="elm-1" class="level3"&gt;
&lt;h3&gt;Elm&lt;/h3&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- ordering/UnitQuantity.elm
module Ordering.UnitQuantity exposing (UnitQuantity, create, value)


type UnitQuantity
    = UnitQuantity Int


create : Int -&amp;gt; Result String UnitQuantity
create qty =
    if qty &amp;lt; 1 then
        Err &amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;
    else if qty &amp;gt; 1000 then
        Err &amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;
    else
        Ok (UnitQuantity qty)


value : UnitQuantity -&amp;gt; Int
value (UnitQuantity qty) =
    qty

    
minimum : UnitQuantity
minimum = UnitQuantity 1&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="f-1" class="level3"&gt;
&lt;h3&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h3&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// ordering/UnitQuantity.fs
namespace Ordering

type UnitQuantity = private UnitQuantity of uint32
module UnitQuantity =
    let create qty =
        if qty &amp;lt; 1u then
            Error &amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;
        else if qty &amp;gt; 1000u then
            Error &amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;
        else
            Ok (UnitQuantity qty)

    let value (UnitQuantity qty) = qty
    
    let minimum = UnitQuantity 1&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="reason-1" class="level3"&gt;
&lt;h3&gt;Reason&lt;/h3&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* ordering/Ordering_UnitQuantity.rei */
type unitQuantity = pri | UnitQuantity(int);

let create: int =&amp;gt; Js.Result.t(unitQuantity, string);

let value: unitQuantity =&amp;gt; int;

let minimum: unitQuantity;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* ordering/Ordering_UnitQuantity.re */

type unitQuantity =
  | UnitQuantity(int);

let create = qty =&amp;gt;
  if (qty &amp;lt; 1) {
    Js.Result.Error(&amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;);
  } else if (qty &amp;gt; 1000) {
    Js.Result.Error(&amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;);
  } else {
    Js.Result.Ok(UnitQuantity(qty));
  };

let value = (UnitQuantity(qty)) =&amp;gt; qty;

let minimum = UnitQuantity(1);&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="aside-on-documentation" class="level2"&gt;
&lt;h2&gt;Aside: On Documentation&lt;/h2&gt;
&lt;p&gt;One thing that became &lt;em&gt;extremely&lt;/em&gt; clear in the course of working all of this out is that the documentation stories for these languages are in vastly, &lt;em&gt;vastly&lt;/em&gt; different places.&lt;/p&gt;
&lt;p&gt;Figuring out how to write this private &lt;code&gt;create&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; approach was &lt;em&gt;very&lt;/em&gt; straightforward in Rust, because it’s literally just right there in how &lt;code&gt;impl&lt;/code&gt; blocks and the &lt;code&gt;pub&lt;/code&gt; keyword work: things default to private, including the contents of a struct, and you &lt;em&gt;always&lt;/em&gt; define the related functionality with &lt;code&gt;pub fn&lt;/code&gt; declarations in the related &lt;code&gt;impl&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;Elm and F&lt;sup&gt;♯&lt;/sup&gt; were both slightly harder, in that I had to poke around a bit to figure out the right way to do it. But not &lt;em&gt;that&lt;/em&gt; much harder. Both use module-level isolation to accomplish this; the main difference there was that F&lt;sup&gt;♯&lt;/sup&gt; just lets you do it inline and Elm explicitly ties modules to files.&lt;/p&gt;
&lt;p&gt;Reason… was very, &lt;em&gt;very&lt;/em&gt; difficult to get sorted out. This is just a function of the state of the ecosystem. Reason is &lt;em&gt;distinct syntax&lt;/em&gt; for OCaml, but it also leans on BuckleScript. That means that if you want to figure out how to do anything, you probably need to search in the docs for all of those, and if your answer turns out to come from OCaml then you have to figure out how to translate it back into Reason and BuckleScript! Ultimately, I was able to figure it out and get the project layout to how you see it in the repository, but… it took a lot more digging than with any of the other projects!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;As with our &lt;a href="http://www.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html"&gt;previous foray&lt;/a&gt;, we can see a ton of similarities across these languages. All lean heavily on pattern-matching for dealing with different scenarios; all let us make use of a &lt;code&gt;Result&lt;/code&gt; type for handling success or failure; all make heavy use of expression-bodied-ness; and all supply &lt;em&gt;some&lt;/em&gt; way to make types constructable only in safe/controlled ways.&lt;/p&gt;
&lt;p&gt;For Rust, that’s a matter of leaving the internals of a &lt;code&gt;struct&lt;/code&gt; private and making &lt;code&gt;pub fn&lt;/code&gt; helpers to do the construction and value retrieval. For Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason, that’s a matter of having the normal type &lt;em&gt;constructors&lt;/em&gt; be private while exposing the types themselves normally. They do that in different ways (F&lt;sup&gt;♯&lt;/sup&gt;’s &lt;code&gt;private type&lt;/code&gt;, Elm’s &lt;code&gt;exposing&lt;/code&gt;, and Reason’s &lt;code&gt;pri&lt;/code&gt; annotation on the type variant in a module interface file), but the effect is essentially identical, and functionally equivalent to what we see in Rust.&lt;/p&gt;
&lt;p&gt;The main differences we see across Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason have to do with the nature of the various module systems. In a lot of ways, Reason’s is the least capable &lt;em&gt;for this specific purpose&lt;/em&gt;, because it’s directly tied to OCaml’s module system, which substantially predates any of the others. (I say “in a lot of ways” because OCaml’s modules are surprisingly capable; they end up being their own kind of types and you can do some crazy things with them, all of which I’d like to actually come to understand… eventually.) Rust’s module system, meanwhile, has a lot of similarities to Elm’s in particular, but because we actually carry functions along with the types they &lt;code&gt;impl&lt;/code&gt; (though they get defined separately, with all the power that entails), we have a bit less boilerplate we need to write just to get at the specific functions in play.&lt;/p&gt;
&lt;p&gt;Next time (probably only a couple of weeks away because we’re working through the book at work in a book club!), I’ll be looking at Chapter 7: Modeling Workflows as Pipelines. I suspect this will be a place where the true functional orientation of Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason will much more sharply differentiate them from the sometimes-functionalish-but-not-actually-functional way we write things in Rust.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This reference will live and be valid as long as the underlying &lt;code&gt;WidgetCode&lt;/code&gt; is. We could also return a &lt;code&gt;String&lt;/code&gt; if we wanted that value to live independently of the &lt;code&gt;WidgetCode&lt;/code&gt; instance backing it.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Putting it in its own module, whether in a separate &lt;em&gt;does&lt;/em&gt; have implications for privacy, though we don’t much care about them in this case. Rust lets us set the privacy on &lt;a href="https://doc.rust-lang.org/1.24.1/reference/visibility-and-privacy.html"&gt;a whole spectrum&lt;/a&gt;, from “visible everywhere” to “only visible in this specific module.”&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 24 Mar 2018 22:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-03-24:/2018/exploring-4-languages-integrity-and-consistency.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages: Starting to Model the Domain</title><link>http://www.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html</link><description>&lt;p&gt;In the first three chapters of &lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;, Wlaschin walks through the creation of a “domain model” for an order-taking system. (It’s well worth reading the book just for a bunch of the lessons in that section—I found them quite helpful!) Then, after spending a chapter introducing F&lt;sup&gt;♯&lt;/sup&gt;’s type system, he introduces the ways you can &lt;em&gt;use&lt;/em&gt; those type mechanics to express the domain. In today’s post, I’ll show the idiomatic implementations of these types in each of Rust, Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and ReasonML.&lt;/p&gt;
&lt;section id="simple-values" class="level2"&gt;
&lt;h2&gt;Simple values&lt;/h2&gt;
&lt;p&gt;Simple wrapper types let you take simple types like strings, numbers, etc. and use types to represent part of the business domain you’re dealing with—the basic idea being that a Customer ID may be a number, but it’s not interchangeable with &lt;em&gt;other&lt;/em&gt; numbers such as Order IDs.&lt;/p&gt;
&lt;p&gt;Here’s the most ergonomic and effective (and automatically-formatted in line with the language standards, where applicable!) way to do that in each of the languages:&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct CustomerId(i32);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type CustomerId
    = CustomerId Int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML:&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type customerId =
  | CustomerId(int);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how similar these all are! The Rust implementation is the &lt;em&gt;most&lt;/em&gt; distinctive, though you can do it with the same kind of union type as the others. Here’s how that would look:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum CustomerId {
  CustomerId(i32),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For performance reasons, you might also choose to implement the F&lt;sup&gt;♯&lt;/sup&gt; type as a struct:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;&amp;lt;Struct&amp;gt;
type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="complex-data" class="level2"&gt;
&lt;h2&gt;Complex data&lt;/h2&gt;
&lt;p&gt;Wlaschin then moves on to showing how to model more complex data structures: types that “and” or “or” together other data. We “and” data together using record or struct types, and “or” data together using “union” or “enum” types. (Assume we’ve defined &lt;code&gt;CustomerInfo&lt;/code&gt;, &lt;code&gt;ShippingAddress&lt;/code&gt;, etc. types for all of these.)&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
struct Order {
    customer_info: CustomerInfo,
    shipping_address: ShippingAddress,
    billing_address: BillingAddress,
    order_lines: Vec&amp;lt;OrderLine&amp;gt;,
    billing_amount: BillingAmount,
}

// &amp;quot;or&amp;quot;
enum ProductCode {
    Widget(WidgetCode),
    Gizmo(GizmoCode),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- &amp;quot;and&amp;quot;
type alias Order =
    { customerInfo : CustomerInfo
    , shippingAddress : ShippingAddress
    , billingAddress : BillingAddress
    , orderLines : List OrderLine
    , billingAmount : BillingAmount
    }

-- &amp;quot;or&amp;quot;
type ProductCode
    = Widget WidgetCode
    | Gizmo GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
type Order = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine list
    AmountToBill: BillingAmount
}

// &amp;quot;or&amp;quot;
type ProductCode =
    | Widget of WidgetCode
    | Gizmo of GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML—note that since we’re assuming we’ve already defined the other types here, you can write this without duplicating the name and type declaration, just like you can with JavaScript object properties.&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* &amp;quot;and&amp;quot; */
type order = {
  customerInfo,
  shippingAddress,
  billingAddress,
  orderLine,
  billingAmount
};

/* &amp;quot;or&amp;quot; */
type productCode =
  | Widget(widgetCode)
  | Gizmo(gizmoCode);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An interesting aside: unless you planned to reuse these types, you wouldn’t usually write these as standalone types with this many wrapper types in it in Rust in particular (even if the compiler would often recognize that it could squash them down for you).&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Instead, you’d normally write &lt;em&gt;only&lt;/em&gt; the base enum type to start, and refactor out the &lt;code&gt;struct&lt;/code&gt; wrapper later only if you found you needed it elsewhere:&lt;/p&gt;
&lt;pre class="diff"&gt;&lt;code&gt;enum ProductCode {
-    Widget(WidgetCode),
+    Widget(String),
-    Gizmo(GizmoCode),
+    Gizmo(String),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That said: given how the book is tackling things, and the fact that you might want to &lt;em&gt;validate&lt;/em&gt; these types… having them as these low-cost wrappers is probably worth it. (In fact, having read a bit further than I’ve managed to write out yet, I can guarantee it.)&lt;/p&gt;
&lt;p&gt;We work through the rest of the basic types this way. But what about the types where we don’t yet have a good idea how we want to handle them?&lt;/p&gt;
&lt;p&gt;Each of these languages gives us an out (or more than one) for how to say “I don’t know what to put here yet.”&lt;/p&gt;
&lt;p&gt;Rust (which does not have a built-in &lt;code&gt;Never&lt;/code&gt; type… yet; see below):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// Make an empty enum (which you by definition cannot construct)
enum Never {}

// Use it throughout where we don&amp;#39;t know the type yet. It will fail to compile
// anywhere we try to *use* this, because you can&amp;#39;t construct it.
type OrderId = Never;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (which has a built-in &lt;code&gt;Never&lt;/code&gt; type):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- It will fail to compile anywhere we try to *use* this, because you cannot
-- construct `Never`.
type alias OrderId =
    Never&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (which &lt;em&gt;sort&lt;/em&gt; of does):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// Make a convenience type for the `exn`/`System.Exception` type
type Undefined = exn

type OrderId = Undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (which also &lt;em&gt;sort&lt;/em&gt; of does—identically with F&lt;sup&gt;♯&lt;/sup&gt;):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* Make a convenience type for the `exn`/`System.Exception` type */
type undefined = exn;

/*
  Use it throughout where we don&amp;#39;t know the type yet. It will compile, but fail
  to run anywhere we try to *use* this.
 */
type orderId = undefined;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For both F&lt;sup&gt;♯&lt;/sup&gt; and Reason, that’s following Wlaschin’s example. The main reason to do that is to make explicit that we’re not actually wanting an &lt;em&gt;exception&lt;/em&gt; type in our domain model, but just something we haven’t &lt;em&gt;yet&lt;/em&gt; defined. Anywhere we attempted to use it, we’d have to handle it like, well… an exception, instead of an actual type.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type OrderId = !;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="workflows-and-functions" class="level2"&gt;
&lt;h2&gt;Workflows and functions&lt;/h2&gt;
&lt;p&gt;Once we have the basic types themselves in place, we need to write down the ways we transform between them. In a functional style, we’re not going to implement instance methods—though as we’ll see in the next post, what we do in Rust will have &lt;em&gt;some&lt;/em&gt; similarities to class methods—we’re going to implement standalone functions which take types and return other types.&lt;/p&gt;
&lt;p&gt;Again, you’ll note that despite the common lineage, there is a fair amount of variation here. (Note that we’d also have defined the &lt;code&gt;UnvalidatedOrder&lt;/code&gt;, &lt;code&gt;ValidationError&lt;/code&gt;, and &lt;code&gt;ValidatedOrder&lt;/code&gt; types for all of this; I’m mostly interested in showing &lt;em&gt;new&lt;/em&gt; differences here.)&lt;/p&gt;
&lt;p&gt;Rust (using the &lt;a href="https://github.com/alexcrichton/futures-rs"&gt;Futures&lt;/a&gt; library to represent eventual computation):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidationResponse&amp;lt;T&amp;gt; = Future&amp;lt;Item = T, Error = ValidationError&amp;gt;;

fn validate_order(unvalidated: UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt; {
    unimplemented!()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (using the built-in &lt;code&gt;Task&lt;/code&gt; type for eventual computation; &lt;code&gt;Task&lt;/code&gt;s encapsulate both eventuality and the possibility of failure):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type ValidationResponse a
    = Task (List ValidationError) a

type alias ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse ValidatedOrder&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (using the built-in &lt;code&gt;Async&lt;/code&gt; type for eventual computation):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type ValidationResponse&amp;lt;&amp;#39;a&amp;gt; = Async&amp;lt;Result&amp;lt;&amp;#39;a,ValidationError list&amp;gt;&amp;gt;

type ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (using the built-in JavaScript-specific &lt;code&gt;Js.Promise&lt;/code&gt; type—which is exactly what it sounds like—for eventual computation):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type validationResponse(&amp;#39;a) = Js.Promise.t(Js.Result.t(&amp;#39;a, list(validationError)));

type validateOrder = unvalidatedOrder =&amp;gt; validationResponse(validatedOrder);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again Rust is much &lt;em&gt;more&lt;/em&gt; different here from the others than they are from each other. The biggest difference between Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason is how they handle generics and type parameters.&lt;/p&gt;
&lt;p&gt;You’ll note that in Elm, they just follow the name of the wrapping type. This is a kind of syntactic symmetry: the way you &lt;em&gt;name&lt;/em&gt; a generic type like this is the same basic way you &lt;em&gt;construct&lt;/em&gt; it. It’s quite elegant. And as it turns out, the same is true of Reason; it’s just that its authors have chosen to follow OCaml and use parentheses for them instead of following Haskell with spaces—a reasonable choice, given Reason is surface syntax for OCaml and not Haskell.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; uses angle brackets, I strongly suspect, because that’s what C&lt;sup&gt;#&lt;/sup&gt; uses for generics, and keeping them syntactically aligned in things like this is very helpful. Rust similarly uses angle brackets for similarity with other languages which have similar surface syntax—especially C++ (with its templates).&lt;/p&gt;
&lt;p&gt;The way you &lt;em&gt;name&lt;/em&gt; generic parameters differs between the languages as well. Elm, following Haskell, uses lowercase letters to name its generics (usually called &lt;em&gt;type parameters&lt;/em&gt; in Elm). F&lt;sup&gt;#&lt;/sup&gt; and Reason both (unsurprisingly) follow OCaml in using lowercase letters preceded by an apostrophe to name generics—in F&lt;sup&gt;#&lt;/sup&gt;, &lt;code&gt;TypeGenericOver&amp;lt;'a&amp;gt;&lt;/code&gt;; in Reason, &lt;code&gt;typeGenericOver('a)&lt;/code&gt;. Rust follows the convention from languages like C++, Java, and C&lt;sup&gt;#&lt;/sup&gt; and uses capital letters, &lt;code&gt;TypeGenericOver&amp;lt;T&amp;gt;&lt;/code&gt;. The use of specific letters is conventional, not mandated by the language (unlike the casing). The ML family usually starts with &lt;code&gt;a&lt;/code&gt; and moves through the alphabet; Rust and the languages it follows usually start with &lt;code&gt;T&lt;/code&gt; (for &lt;em&gt;type&lt;/em&gt;) and moves forward through the alphabet. (Sometimes you’ll also see different letters where it’s obviously a better fit for what’s contained.)&lt;/p&gt;
&lt;p&gt;These languages also vary in the syntax for constructing a &lt;em&gt;list&lt;/em&gt; of things. In F&lt;sup&gt;#&lt;/sup&gt; has convenience syntax for a few built-ins (the most common being the &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Option&lt;/code&gt; types), allowing you to write them &lt;em&gt;either&lt;/em&gt; as e.g. &lt;code&gt;List&amp;lt;ConcreteType&amp;gt;&lt;/code&gt; or &lt;code&gt;ConcreteType list&lt;/code&gt; (as here in the example). Elm, Reason, and Rust all just use the standard syntax for generic types—&lt;code&gt;List a&lt;/code&gt;, &lt;code&gt;list('a)&lt;/code&gt;, and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Finally, you’ll also note that we haven’t written out a &lt;em&gt;type&lt;/em&gt; declaration here for Rust; we’ve actually written out a stub of a function, with the &lt;a href="https://doc.rust-lang.org/std/macro.unimplemented.html"&gt;&lt;code&gt;unimplemented!()&lt;/code&gt;&lt;/a&gt; &lt;a href="https://doc.rust-lang.org/1.17.0/reference/macros-by-example.html"&gt;macro&lt;/a&gt;. If you invoke this function, you’ll get a clear crash with an explanation of which function isn’t implemented.&lt;/p&gt;
&lt;p&gt;Now, Rust also &lt;em&gt;does&lt;/em&gt; let us write out the type of these functions as type aliases if we want:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidateOrder =
    Fn(UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You just don’t use these very often in idiomatic Rust; it’s much more conventional to simply write out what I did above. However, the one time you &lt;em&gt;might&lt;/em&gt; use a type alias like this is when you’re defining the type of a closure and you don’t want to write it inline. This is a pretty sharp difference between Rust and the other languages on display here, and it goes to the difference in their approaches.&lt;/p&gt;
&lt;p&gt;Rust is &lt;em&gt;not&lt;/em&gt; a functional-first language in the way that each of the others are, though it certainly draws heavily on ideas from functional programming throughout and makes quite a few affordances for a functional style. Instead, it’s a programming language first and foremost interested in combining the most screaming performance possible with true safety, and leaning on ideas from the ML family (among others!) as part of achieving that.&lt;/p&gt;
&lt;p&gt;Among other things, this is why you don’t have currying or partial application in Rust: those essentially &lt;em&gt;require&lt;/em&gt; you to have invisible heap-allocation to be ergonomic. We &lt;em&gt;don’t&lt;/em&gt; have that in Rust, as we do in Elm, Reason, and F&lt;sup&gt;♯&lt;/sup&gt;. If we want to pass around a function, we have to explicitly wrap it in a pointer to hand it around if we construct it in another function. (I won’t go into more of the details of this here; I’ve covered it some &lt;a href="http://www.newrustacean.com/show_notes/e004/index.html"&gt;on New Rustacean&lt;/a&gt; and some &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;in my Rust and Swift comparison&lt;/a&gt; a couple years ago.)&lt;/p&gt;
&lt;p&gt;That same underlying focus on performance and explicitness is the reason we have &lt;code&gt;Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;&lt;/code&gt; in the Rust case: we’re explicitly returning a &lt;em&gt;pointer&lt;/em&gt; to the type here. In Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason, that’s &lt;em&gt;always&lt;/em&gt; the case. But in Rust, you can and often do return stack-allocated data and rely on “move” semantics to copy or alias it properly under the hood.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;So: lots of similarities here at first blush. The biggest differences that show up at this point are purely syntactical, other than some mildly sharper differences with Rust because of its focus on performance. The fact that these languages share a common lineage means it’s not hard to read any of them if you’re familiar with the others, and it’s actually quite easy to switch between them at the levels of both syntax and semantics.&lt;/p&gt;
&lt;p&gt;As usual, when dealing with languages in a relatively similar family, it’s &lt;em&gt;most&lt;/em&gt; difficult to learn the &lt;em&gt;library&lt;/em&gt; differences. The most obvious example of that here is Reason’s &lt;code&gt;Js.Promise&lt;/code&gt;, Elm’s &lt;code&gt;Task&lt;/code&gt;, F&lt;sup&gt;♯&lt;/sup&gt;’s &lt;code&gt;Async&lt;/code&gt;, and Rust’s &lt;code&gt;Future&lt;/code&gt; types: each of those has their own quirks, their own associated helper functions or methods, and their own ways of handling the same basic patterns.&lt;/p&gt;
&lt;p&gt;Still, if you have played with any one of these, you could pretty easily pick up one of the others. It’s sort of like switching between Python and Ruby: there are some real differences there, but the similarities are greater than the differences. Indeed, if anything, these languages are &lt;em&gt;more&lt;/em&gt; similar than those.&lt;/p&gt;
&lt;p&gt;Next time I’ll dig into Wlaschin’s chapter on &lt;em&gt;validating&lt;/em&gt; the domain model, and here some of the not-just-syntax-level differences in the languages will start to become more apparent.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I can’t speak to what’s idiomatic this way in any of the non-Rust languages, because I just haven’t used them enough yet.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 14 Jan 2018 09:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-14:/2018/exploring-4-languages-starting-to-model-the-domain.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages: Project Setup</title><link>http://www.chriskrycho.com/2018/exploring-4-languages-project-setup.html</link><description>&lt;p&gt;In this post, I’m just going to briefly talk through the steps I needed to do to set up each of the languages and my editor setup for them. Gladly, it was pretty simple. At the end, I’ll offer a note on my thoughts on the setup processes. (Note that this isn’t “How to do this for anyone ever”—it’s “how I did it, with some notes where it might be relevant to you.”)&lt;/p&gt;
&lt;p&gt;For context, I’m running macOS and using &lt;a href="https://code.visualstudio.com"&gt;VS Code&lt;/a&gt; as my editor. Whenever I say “Install the VS Code extension,” you can do it either by opening the extension side panel and searching for &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;, or by typing &lt;code&gt;ext install &amp;lt;extension label&amp;gt;&lt;/code&gt;—I’ll write it like &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;extension label&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The source code as of what I’m describing in this post is &lt;a href="https://github.com/chriskrycho/dmmf/tree/project-setup"&gt;at the &lt;code&gt;project-setup&lt;/code&gt; tag&lt;/a&gt; in &lt;a href="https://github.com/chriskrycho/dmmf/"&gt;the repo&lt;/a&gt;.&lt;/p&gt;
&lt;section id="rust" class="level2"&gt;
&lt;h2&gt;Rust&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation:&lt;/strong&gt; Install &lt;a href="https://rustup.rs"&gt;&lt;em&gt;rustup&lt;/em&gt;&lt;/a&gt;: &lt;code&gt;curl https://sh.rustup.rs -sSf | sh&lt;/code&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code extension: &lt;code&gt;Rust (rls)&lt;/code&gt;/&lt;code&gt;rust&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of &lt;a href="https://github.com/chriskrycho/dmmf"&gt;my repo&lt;/a&gt;, I ran &lt;code&gt;cargo new rust&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="elm" class="level2"&gt;
&lt;h2&gt;Elm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: There are installers, but I just did &lt;code&gt;npm i -g elm&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code Elm extension: &lt;code&gt;Elm&lt;/code&gt;/&lt;code&gt;elm&lt;/code&gt;.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Install the &lt;code&gt;create-elm-app&lt;/code&gt; tool: &lt;code&gt;npm i -g create-elm-app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the root of the project, I ran &lt;code&gt;create-elm-app elm&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="f" class="level2"&gt;
&lt;h2&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Install &lt;a href="http://www.mono-project.com"&gt;mono&lt;/a&gt;: &lt;code&gt;brew install mono&lt;/code&gt; (note installation instructions &lt;a href="option-5-install-f-with-mono-via-homebrew-64-bit"&gt;here&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Install the VS Code Ionide extension: &lt;code&gt;Ionide-fsharp&lt;/code&gt;/&lt;code&gt;ionide-fsharp&lt;/code&gt;. It’ll automatically install the associated Paket and FAKE extensions from the Ionide project as well, and those will install Paket and FAKE during installation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;In the root of the repo, I created the &lt;code&gt;fsharp&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;Then I opened a VS Code instance to to that directory, opened the command palette, and ran &lt;code&gt;F#: New Project&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;I chose &lt;code&gt;console&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;I left the directory blank&lt;/li&gt;
&lt;li&gt;I named the project &lt;code&gt;dmmf&lt;/code&gt; (for &lt;em&gt;D&lt;/em&gt;omain &lt;em&gt;M&lt;/em&gt;odeling &lt;em&gt;M&lt;/em&gt;ade &lt;em&gt;F&lt;/em&gt;unctional).&lt;/li&gt;
&lt;li&gt;Since F&lt;sup&gt;♯&lt;/sup&gt; (like C&lt;sup&gt;♯&lt;/sup&gt;) prefers PascalCase names, I renamed the generated module &lt;code&gt;DMMF&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="reasonml" class="level2"&gt;
&lt;h2&gt;ReasonML&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Following the setup instructions &lt;a href="https://reasonml.github.io/guide/javascript/quickstart"&gt;here&lt;/a&gt;, I ran &lt;code&gt;npm install -g bs-platform&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; following &lt;a href="https://reasonml.github.io/guide/editor-tools/global-installation"&gt;the official instructions&lt;/a&gt;—
&lt;ul&gt;
&lt;li&gt;I ran &lt;code&gt;npm install -g https://github.com/reasonml/reason-cli/archive/3.0.4-bin-darwin.tar.gz&lt;/code&gt; to install the dependencies for the editor configuration.&lt;/li&gt;
&lt;li&gt;I installed the VS Code extension: &lt;code&gt;Reason&lt;/code&gt;/&lt;code&gt;reasonml&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of the repo, I ran &lt;code&gt;bsb -init reason -theme basic-reason&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="comments-on-the-setup-processes" class="level2"&gt;
&lt;h2&gt;Comments on the setup processes&lt;/h2&gt;
&lt;p&gt;Most of the languages have &lt;em&gt;fairly&lt;/em&gt; straightforward processes to get up and running with a good-to-excellent tooling experience.&lt;/p&gt;
&lt;p&gt;The best of them is Rust, which is &lt;em&gt;extremely&lt;/em&gt; easy to get up and running with.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; Elm is roughly in the middle—it’s less straightforward than Rust in that &lt;code&gt;create-elm-app&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; an officially supported approach, unlike &lt;code&gt;rustup&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;, so you’re going to have a much less awesome experience if you don’t know about it.&lt;/p&gt;
&lt;p&gt;Reason and F&lt;sup&gt;♯&lt;/sup&gt; both have slightly larger negatives.&lt;/p&gt;
&lt;p&gt;Reason requires you to &lt;code&gt;npm install&lt;/code&gt; a large, gzipped file with multiple dependencies all bundled, instead of having a dedicated installer &lt;em&gt;a la&lt;/em&gt; &lt;code&gt;rustup&lt;/code&gt;. It also has the possibility for a not-so-great first-run experience in the editor, which &lt;a href="https://github.com/facebook/reason/issues/1729"&gt;I discovered&lt;/a&gt; all too quickly.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; essentially requires you to use an editor extension to get the language setup with &lt;a href="https://fsprojects.github.io/Paket/"&gt;Paket&lt;/a&gt;, which is a &lt;em&gt;much&lt;/em&gt; better choice of package manager than the default .NET package manager NuGet. Command line tools exist and are improving rapidly, and you &lt;em&gt;can&lt;/em&gt; &lt;a href="https://fsprojects.github.io/Paket/paket-and-dotnet-cli.html"&gt;get them working&lt;/a&gt;… but it’s harder than it needs to be. And that project setup wizard is &lt;em&gt;fine&lt;/em&gt;, but it’s a lot noisier than just doing &lt;code&gt;create-elm-app&lt;/code&gt; or especially &lt;code&gt;cargo new&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In any case, though, I have them all up and running now! More soon!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re uncomfortable with running that script, there are &lt;a href="https://www.rust-lang.org/en-US/other-installers.html"&gt;other options&lt;/a&gt; as well.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Note that the VS Code extension is &lt;em&gt;not&lt;/em&gt; the best experience out there for Elm: the Atom extensions (&lt;a href="https://atom.io/packages/language-elm"&gt;language-elm&lt;/a&gt; and &lt;a href="https://atom.io/packages/elmjutsu"&gt;elmjutsu&lt;/a&gt;) are. I stuck with VS Code because it’s &lt;em&gt;good enough&lt;/em&gt; and, more importantly, the Code extensions are arguably best in class for the &lt;em&gt;other&lt;/em&gt; languages… and it’s what I use every day.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;I’m not just saying that because I’m a Rust fanboy, either! If Rust were hard to use, I’d be complaining &lt;em&gt;louder&lt;/em&gt; because of my enthusiasm for the language.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 01 Jan 2018 13:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-01:/2018/exploring-4-languages-project-setup.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages</title><link>http://www.chriskrycho.com/2017/exploring-4-languages.html</link><description>&lt;p&gt;Today, as I hit the first of the implementation chapters in &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt;, I started thinking about how I wanted to implement it. As I’ve noted &lt;a href="https://twitter.com/chriskrycho/status/934170826718429184"&gt;elsewhere&lt;/a&gt; in the past, very little of the book is &lt;em&gt;truly&lt;/em&gt; specific to F&lt;sup&gt;♯&lt;/sup&gt;, though that’s the language Wlaschin uses in the book—and Wlaschin himself &lt;a href="https://twitter.com/ScottWlaschin/status/934177554331848705"&gt;agrees&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks! Yes, it’s true that you could easily use #ElmLang, #RustLang, #Scala, or especially #OCaml to work through the book. I use hardly any F# specific features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So… I decided to try something a little bit bonkers. I’m going to implement these exercises in &lt;em&gt;four different languages&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fsharp.org"&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reasonml.github.io"&gt;ReasonML&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are all related: they’re descended from &lt;a href="http://smlnj.org/sml.html"&gt;Standard ML&lt;/a&gt;. ReasonML and F&lt;sup&gt;♯&lt;/sup&gt; are like siblings: Reason is merely a custom syntax for OCaml; F&lt;sup&gt;♯&lt;/sup&gt; is (originally) an implementation of OCaml on .NET (though the two languages have diverged since F&lt;sup&gt;♯&lt;/sup&gt; came into existence). Elm and Rust are cousins of each other and of Reason and F&lt;sup&gt;♯&lt;/sup&gt;, though they’re both drawing on other languages besides OCaml as well. I also have some familiarity with Rust, Elm, and F&lt;sup&gt;♯&lt;/sup&gt; already, and have read the docs for Reason a couple times. So this is a &lt;em&gt;bit&lt;/em&gt; less crazy than it might otherwise be.&lt;/p&gt;
&lt;p&gt;Why, though? Mostly because I think it’ll be interesting to compare the implementations of the domain model from the book side by side. It’ll look just a bit different in each language, and I expect to learn a bit more of the &lt;em&gt;feel&lt;/em&gt; of each language by doing this. (That side by side comparison is something I’ve &lt;a href="http://www.chriskrycho.com/rust-and-swift.html" title="Series: Rust and Swift"&gt;done before&lt;/a&gt; and &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html" title="Part V: The value (and challenge) of learning languages in parallel."&gt;found very profitable&lt;/a&gt;.) I’ll also turn it into blog posts, which hopefully will be interesting to others!&lt;/p&gt;
&lt;p&gt;More to come, and soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 31 Dec 2017 20:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-31:/2017/exploring-4-languages.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Becoming a Contributor</title><link>http://www.chriskrycho.com/2017/becoming-a-contributor.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;Here is the full text of the talk I gave at Rust Belt Rust, as it was prepared; headings correspond to individual slides. You can see the slides as they were presented &lt;a href="/talks/rust-belt-rust/"&gt;here&lt;/a&gt;. Note that I extemporize fairly freely when actually giving a talk, so this is &lt;em&gt;not&lt;/em&gt; a word-for-word equivalent of the talk as delivered, but the gist is the same!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;I’ll update this post with the video once it’s available!&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;figure&gt;
&lt;img src="/talks/rust-belt-rust/img/family.jpg" alt="family" /&gt;&lt;figcaption&gt;family&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Hello, everyone! It’s good to see all of you. We only have half an hour, and even if that’s ten to fifteen minutes longer than a normal New Rustacean episode, that’s still not much time, so let’s jump right in! Our theme is “Becoming a Contributor.” There are two prongs to this talk, two big ideas I hope you all walk away with.&lt;/p&gt;
&lt;section id="introduction-the-big-ideas" class="level3"&gt;
&lt;h3&gt;Introduction: The Big Ideas&lt;/h3&gt;
&lt;p&gt;The first thing I hope all of you take away is that &lt;strong&gt;there is no reason &lt;em&gt;you&lt;/em&gt; cannot contribute meaningfully&lt;/strong&gt; to the success of Rust – or indeed any open-source project you care about. Anyone can be a contributor. And not “even you” but perhaps “&lt;em&gt;especially&lt;/em&gt; you”. The fact that you’re an outsider, or new to programming, or new to systems programming: sometimes that makes you a &lt;em&gt;better&lt;/em&gt; contributor. Because you don’t necessarily share the biases of – you’re not wearing the same blinders that – someone who’s been writing systems-level code for 20 years have. So the first idea: &lt;strong&gt;you can contribute&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The second idea I hope you take away is &lt;strong&gt;just &lt;em&gt;how many&lt;/em&gt; ways there are to contribute meaningfully&lt;/strong&gt;. It has almost become a cliche in the Rust community to say “code isn’t the only thing that matters,” but I want to show you today just how true that is. And I want to make that point again more forcefully, because for all that we often say that, the idea that &lt;em&gt;shipping code&lt;/em&gt; is what really matters is the kind of pernicious lie that can come back and bite any of us. It certainly gets to me at times! But it’s a lie, and we’re going to see that in detail. That’s the second big idea: &lt;strong&gt;there are an &lt;em&gt;astounding&lt;/em&gt; number of ways you can contribute&lt;/strong&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="introduction-why" class="level3"&gt;
&lt;h3&gt;Introduction: Why?&lt;/h3&gt;
&lt;p&gt;There are a lot of things to be passionate about in the world of software development. But at the end of the day, I care about software because I care about &lt;em&gt;people&lt;/em&gt;. To borrow a label from Scott Wlaschin – a developer I admire enormously, mostly working over in the F# community – I am a &lt;em&gt;humanist&lt;/em&gt;, not a &lt;em&gt;technologist&lt;/em&gt;. The technologies are interesting in themselves to a degree; but I mostly care about the ways that technologies can help us serve people more effectively. As software developers, that takes a lot of shapes. But today I want to zoom in on just these two ideas about open-source software:&lt;/p&gt;
&lt;/section&gt;
&lt;section id="introduction-the-big-ideas-1" class="level3"&gt;
&lt;h3&gt;Introduction: The Big Ideas&lt;/h3&gt;
&lt;p&gt;So: why these two ideas? For one thing, because I think they are among the most applicable to everyone here. We have an enormous open-source focus. But for another, because they can also serve as windows into the ways we can – and should – think about software more generally. So: let’s talk about how you become a &lt;em&gt;contributor&lt;/em&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="introduction-outline" class="level3"&gt;
&lt;h3&gt;Introduction: Outline&lt;/h3&gt;
&lt;p&gt;We’re going to take this on in the good old grammar-school fashion: &lt;em&gt;who&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, &lt;em&gt;when&lt;/em&gt;, &lt;em&gt;where&lt;/em&gt;, &lt;em&gt;why&lt;/em&gt;, and &lt;em&gt;how&lt;/em&gt;. We’re not going to take them in that order though, and we might smash a few of them together.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Introduction&lt;/li&gt;
&lt;li&gt;Why bother contributing? &lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;Who is a contributor? &lt;!-- .element: class="fragment" data-fragment-index="2" --&gt;&lt;/li&gt;
&lt;li&gt;What is a contribution? How can you contribute? &lt;!-- .element: class="fragment" data-fragment-index="3" --&gt;
&lt;ul&gt;
&lt;li&gt;…so many things they won’t fit on this slide. &lt;!-- .element: class="fragment" data-fragment-index="4" --&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;When and where to contribute? &lt;!-- .element: class="fragment" data-fragment-index="5" --&gt;&lt;/li&gt;
&lt;li&gt;Conclusion &lt;!-- .element: class="fragment" data-fragment-index="6" --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;section id="why-bother-contributing" class="level2"&gt;
&lt;h2&gt;Why bother contributing?&lt;/h2&gt;
&lt;p&gt;The first question we might be asking is: &lt;em&gt;why contribute at all&lt;/em&gt;? Why should you be interested in becoming a contributor? And the best answer I can offer is: because there is more work than hands to do it. Always. Every open-source maintainer can tell you the truth of this.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="who-is-a-contributor" class="level2"&gt;
&lt;h2&gt;Who is a contributor?&lt;/h2&gt;
&lt;p&gt;People define this differently, but I have a very simple definition: &lt;strong&gt;A contributor is &lt;em&gt;anyone&lt;/em&gt; who improves a project.&lt;/strong&gt;&lt;/p&gt;
&lt;section id="who-is-a-contributor-examples" class="level3"&gt;
&lt;h3&gt;Who is a contributor? Examples&lt;/h3&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;submit a patch to fix a typo &lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;add a small correction for a code sample in a project &lt;!-- .element: class="fragment" data-fragment-index="2" --&gt;&lt;/li&gt;
&lt;li&gt;file an issue instead of just suffering through a problem in silence &lt;!-- .element: class="fragment" data-fragment-index="3" --&gt;&lt;/li&gt;
&lt;li&gt;everything else we’re going to talk about today &lt;!-- .element: class="fragment" data-fragment-index="4" --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="who-is-a-contributor-me" class="level3"&gt;
&lt;h3&gt;Who is a contributor? Me!&lt;/h3&gt;
&lt;p&gt;That might sound overblown, but it’s really not. I am literally standing on this stage in front of you today because I submitted some small typo and code sample improvements to “Rust by Example” a few years ago, and realized: I can make a difference in this community. And that gave me the motivation I needed to &lt;em&gt;keep&lt;/em&gt; contributing.&lt;/p&gt;
&lt;p&gt;&lt;img src="/talks/rust-belt-rust/img/first-commit.png" alt="my first Rust commit" /&gt;&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="who-is-a-contributor-1" class="level3"&gt;
&lt;h3&gt;Who is a contributor?&lt;/h3&gt;
&lt;p&gt;I don’t imagine the story is all that different for &lt;em&gt;most&lt;/em&gt; people who are open-source contributors in this room. Something got them over the hump, and it was probably something small, insignificant-seeming at the time. They might be particularly skilled in this thing or that thing, but in fact a lot of them are in those roles just because they saw a need and stepped up to fill it. And then kept at it for a long time. But it made them a contributor. And that feeling – of helping build something bigger than you can build on your own – is a good one. I’d go so far as to say it’s part of what humans are &lt;em&gt;meant&lt;/em&gt; for. It’s part of us in a deep, deep way.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="who-is-a-contributor-2" class="level2"&gt;
&lt;h2&gt;Who is a contributor?&lt;/h2&gt;
&lt;p&gt;If you’re inclined to quibble with that definition, I challenge you to ask &lt;em&gt;why?&lt;/em&gt; I think, most often, it’s because we feel defensive about wanting to project our own particular kinds of contribution as the most important, or the most valuable. But I’m more of the mindset that, as I read recently, “anyone who would be first… must be last of all, and servant of all.” We should stop worrying about our own prestige and turf-marking, and start rejoicing in the many different ways people are able to make our projects better.&lt;/p&gt;
&lt;p&gt;There’s no magic that makes you qualified to be a contributor. There’s just a willingness to serve where you see a need.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-how-can-you-contribute" class="level2"&gt;
&lt;h2&gt;What &amp;amp; how can you contribute?&lt;/h2&gt;
&lt;p&gt;And that takes us into the “what” of all of this, the &lt;em&gt;how&lt;/em&gt;. (Yes, I’m combining those two). &lt;strong&gt;&lt;em&gt;What&lt;/em&gt; is a contribution? &lt;em&gt;How&lt;/em&gt; can you contribute?&lt;/strong&gt; Turns out, this is a &lt;em&gt;long&lt;/em&gt; list.&lt;/p&gt;
&lt;section id="what-how-code" class="level3"&gt;
&lt;h3&gt;What &amp;amp; how: code&lt;/h3&gt;
&lt;p&gt;Let’s get this right out of the way up front, because it’s the most obvious: you can write code. You can fix bugs or help implement new features. You can do that even if you’re not an expert – especially in the Rust community. Many Rust projects have gone out of their way to mark issues as good-first-issues, or easy-to-tackle, or mentorship-available. Maybe it’s your first contribution to an open-source project: that’s okay. You can take a stab at it, and the fact that it might not be good &lt;em&gt;is okay&lt;/em&gt;. The whole point of these kinds of issues is that they give you a place where you can jump in safely.&lt;/p&gt;
&lt;p&gt;&lt;img src="/talks/rust-belt-rust/img/good-first-issue.png" alt="good first issue" /&gt; &lt;img src="/talks/rust-belt-rust/img/mentored.png" alt="mentored" /&gt; &lt;img src="/talks/rust-belt-rust/img/easy.png" alt="easy" /&gt;&lt;/p&gt;
&lt;p&gt;That goes equally for everything from the Rust compiler itself to many of the other projects in the ecosystem. Look at the repository, for example! And it’s not just this project. &lt;em&gt;Lots&lt;/em&gt; of projects in the Rust ecosystem are like this.&lt;/p&gt;
&lt;section id="what-how-code-were-kind-here" class="level4"&gt;
&lt;h4&gt;What &amp;amp; how: code – we’re kind here&lt;/h4&gt;
&lt;p&gt;And no one is going to swear at you or insult for making a mistake here. Not even if you’re working on something important, and not even if you’ve been doing it for a while. That is not. how. we. roll. here. &lt;em&gt;Everyone&lt;/em&gt; makes mistakes!&lt;/p&gt;
&lt;p&gt;Instead, we &lt;em&gt;want&lt;/em&gt; people to show up, knowing nothing: we’re happy to help. Remember: we want people to contribute! So: try opening a PR and let people help you learn how to do it well! In fact, if you haven’t ever opened a PR on a Rust project, find one that looks interesting to you and has an issue tagged that way, and submit a PR before the weekend is out! You can do it!&lt;/p&gt;
&lt;p&gt;&lt;img src="/talks/rust-belt-rust/img/good-first-issue.png" alt="good first issue" /&gt; &lt;img src="/talks/rust-belt-rust/img/mentored.png" alt="mentored" /&gt; &lt;img src="/talks/rust-belt-rust/img/easy.png" alt="easy" /&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-how-code-a-caveat" class="level4"&gt;
&lt;h4&gt;What &amp;amp; how: code – a caveat&lt;/h4&gt;
&lt;p&gt;But code is not the only thing that makes you a contributor. I put it up front because I think it’s worth doing – but I also wanted to get it out of the way. In every software community, it’s easy to &lt;em&gt;over&lt;/em&gt;-value the code. That might sound crazy, given that it’s open-source &lt;em&gt;software&lt;/em&gt;, but the reality is that no one fails to value the code. We &lt;em&gt;do&lt;/em&gt; often fail to value all the other things that make an open-source software project actually useful. It’s certainly true that there’s no project without the code. But it’s also the case that there’s no &lt;em&gt;useful&lt;/em&gt; software without a lot of other things besides the code, and we often undervalue those.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="filing-bugs" class="level3"&gt;
&lt;h3&gt;Filing bugs&lt;/h3&gt;
&lt;p&gt;So let’s take one step away from code, and talk about what is probably the single &lt;em&gt;easiest&lt;/em&gt; way anyone can contribute. &lt;em&gt;File issues.&lt;/em&gt; If you’re using a binary and it doesn’t work, open a ticket. If you’re integrating a library and it seems like the API doesn’t do what it should, or if it seems like it’s missing some functionality… well, you can suffer in silence, or you can open a bug ticket! Many times, the author of the software &lt;em&gt;doesn’t know there’s a problem&lt;/em&gt;. The only way they can fix it is if they know about it!&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/talks/rust-belt-rust/img/new-issue.png" alt="filing bugs" /&gt;&lt;figcaption&gt;filing bugs&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;
&lt;section id="docs" class="level3"&gt;
&lt;h3&gt;Docs&lt;/h3&gt;
&lt;p&gt;Perhaps the thing most of you will be most persuaded of the utility of is &lt;em&gt;documentation&lt;/em&gt;. All of us have faced the difficulty of trying to figure out how to integrate some poorly-documented (or undocumented!) library into our own codebase. That experience, in word, &lt;em&gt;sucks&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So working on documentation is one of the highest-value areas you can contribute to any project. It’s also really hard, in a bunch of ways – harder, in some ways, than writing the code is!&lt;/p&gt;
&lt;section id="docs-who" class="level4"&gt;
&lt;h4&gt;Docs: who?&lt;/h4&gt;
&lt;p&gt;One kind of documentation is &lt;strong&gt;explanation of how things work under the hood&lt;/strong&gt;. The implementer is the most qualified there! That doesn’t mean they don’t still need help even with that, though! Some people are incredible implementors and terrible explainers; you can often do a great service by serving as an “interpreter” for them – taking their explanations and making the literary tweaks and cleanups and polish that they need.&lt;/p&gt;
&lt;p&gt;Another kind of documentation, though, developers and maintainers are often really poorly equipped to write, and that’s &lt;strong&gt;introductory documentation&lt;/strong&gt;. This is the problem of expertise: when you know exactly how something is &lt;em&gt;meant&lt;/em&gt; to work, and especially when you’re the one who implemented it, there are things that seem obvious to you which simply aren’t obvious to someone approaching it for the first time. And as hard as you try, you &lt;em&gt;can’t&lt;/em&gt; escape that entirely. You can imagine what it might be like not to know something, but there’s no substitute for actually not knowing something.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="docs-how" class="level4"&gt;
&lt;h4&gt;Docs – how?&lt;/h4&gt;
&lt;p&gt;What that means is that one of the most valuable things you can do as you learn a new library is &lt;em&gt;write down the things you don’t understand from the docs as you go&lt;/em&gt;. And when you figure them out, &lt;em&gt;write that down, too&lt;/em&gt;. If nothing else, writing up that experience – filing it as an issue on the bug tracker, or otherwise getting it in the hands of the maintainers – can help them make important changes to things like the order various concepts are introduced, or adding little notes to help people feel comfortable with not knowing something until it &lt;em&gt;can&lt;/em&gt; be introduced later, and other things like that. It can help them recognize and fill in gaps in their docs – things they simply assumed but which they didn’t realize they were assuming – and fill those in. At the most extreme, you might even help them realize that some parts of the docs need full rewrites… and the work you’ve done in writing things down might just be the foundation or the actual content of those new docs.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Write down the things you don’t understand from the docs as you go.&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;When you figure them out, write that down, too.&lt;!-- .element: class="fragment" data-fragment-index="2" --&gt;&lt;/li&gt;
&lt;li&gt;Then: file an issue or write a PR to improve it!&lt;!-- .element: class="fragment" data-fragment-index="3" --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;section id="docs-varieties" class="level4"&gt;
&lt;h4&gt;Docs: varieties&lt;/h4&gt;
&lt;p&gt;So what kinds of things would we call &lt;em&gt;documentation&lt;/em&gt;?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API documentation&lt;!-- .element class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;READMEs&lt;!-- .element class="fragment" data-fragment-index="2" --&gt;&lt;/li&gt;
&lt;li&gt;Tutorials&lt;!-- .element class="fragment" data-fragment-index="3" --&gt;&lt;/li&gt;
&lt;li&gt;Books&lt;!-- .element class="fragment" data-fragment-index="4" --&gt;&lt;/li&gt;
&lt;li&gt;The Rust Reference&lt;!-- .element class="fragment" data-fragment-index="5" --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Okay, books are a &lt;em&gt;huge&lt;/em&gt; undertaking, but they can genuinely serve as documentation. Especially for large projects. In fact, several of the most important pieces of “documentation” the Rust project itself has are books: “The Rust Programming Language”, “Rust by Example”, and “The Rustonomicon”. But there are also important but totally unofficial books like Daniel Keep’s “A Practical Intro to Macros in Rust 1.0” and “The Little Book of Rust Macros”, or Jorge Aparicio’s book on microcontrollers with Rust.&lt;/p&gt;
&lt;p&gt;The Rust Reference: This is a special category, and one that’s especially important to me. The Rust Reference is supposed to be an exhaustive guide to the language, and the value of that being complete and accurate is hard to overstate. It’s also wildly out of date today. I wrote an RFC last year that said, basically, “We need to actually document everything! That includes updating the Reference!” The trick is: it’s a huge undertaking, and while I and a few others made a good start on it earlier this year, that effort got bogged down by life, and it needs to be resuscitated. And it’s not just Rust which could use investment in that area. Other languages and frameworks have the same issue. It’s &lt;em&gt;really&lt;/em&gt; important that there be an answer other than “dive into the source and try to figure out what its intent is” – the more central the component is in the ecosystem, the more important that is.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="docs-translation" class="level4"&gt;
&lt;h4&gt;Docs: Translation&lt;/h4&gt;
&lt;p&gt;Another huge place you can contribute to documentation is &lt;em&gt;translation&lt;/em&gt;. For good or ill, English has become the sort of &lt;em&gt;primary&lt;/em&gt; language of programming, but that doesn’t mean we should treat it as the &lt;em&gt;only&lt;/em&gt; language, or as &lt;em&gt;more important&lt;/em&gt; than other languages. Translating documentation is amazing and very needed work, and it’s work that not everyone is really capable of! I’m fluent in English and… ancient Hebrew and ancient Greek. For some reason, there’s not much demand for technical writing in Greek from the era when Plato was alive. So I’m not much use at translation.&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/talks/rust-belt-rust/img/translation.png" alt="translation" /&gt;&lt;figcaption&gt;translation&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;But many of you out there &lt;em&gt;are&lt;/em&gt; multilingual, and could take docs written in English and convert them for, say, Czech-speaking developers. Perhaps just as importantly, you can go the &lt;em&gt;other&lt;/em&gt; direction, and help non-English-speaking maintainers reach a broader audience. Take an amazing project which only has documentation in Amharic (because its developers don’t feel comfortable enough in English to translate it themselves) and translate it to English: &lt;em&gt;use&lt;/em&gt; the fact that English &lt;em&gt;is&lt;/em&gt; the common language to increase the reach of non-Western developers!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="visual-design" class="level3"&gt;
&lt;h3&gt;Visual Design&lt;/h3&gt;
&lt;p&gt;One of the areas where you could move the ball down the field fastest in the Rust community is with &lt;strong&gt;&lt;em&gt;visual&lt;/em&gt; design&lt;/strong&gt;. (To be clear, the &lt;em&gt;language&lt;/em&gt; design is great!) But our websites could sometimes use some work.&lt;/p&gt;
&lt;section id="visual-design-its-not-just-us" class="level4"&gt;
&lt;h4&gt;Visual design: it’s not just us&lt;/h4&gt;
&lt;p&gt;Systems programming language types have historically &lt;em&gt;not&lt;/em&gt; spent a lot of time on the &lt;em&gt;presentation&lt;/em&gt; of their tools. In part this is just a matter of what these kinds of languages have been oriented towards: if you spend all day hacking on kernel code, you’re &lt;em&gt;likelier&lt;/em&gt; to be a person for whom user interface and visual design is less interesting than, say, optimizing memory performance or minimizing the number of cache misses a given approach has. But presentation &lt;em&gt;does&lt;/em&gt; matter, and it matters especially as we want to enable more and more people to be able to write this kind of code.&lt;/p&gt;
&lt;p&gt;Speaking frankly, though I’ve spent a large chunk of my career to date writing systems-level languages, I’ve found the way a lot of these tools are presented to be a huge turn-off, and at times a barrier even to getting them working for me locally. Perhaps the most egregious example of that was some of the “documentation” – I’m not sure I should even call it that! – for Fortran, when I was first getting started programming back in college. The presentation of the material was essentially hacker-ish in a &lt;em&gt;bad&lt;/em&gt; way: no CSS, no attention to organization of the material, no structure to help you find your way through it.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="visual-design-how" class="level4"&gt;
&lt;h4&gt;Visual design: how&lt;/h4&gt;
&lt;p&gt;If you’re an expert or just a talented amateur, please pitch in&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/p&gt;
&lt;p&gt;You can help here even if you’re not especially comfortable with visual design or even if you’re outright bad at it if you’re willing to spend just a little time on it! For example, you can simply help a team adopt something like Bootstrap. Yes, it’ll look like many other open-source projects out there. But it won’t be horribly, catastrophically ugly and unreadable! Or you can do use one of these simple starter kits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://usewing.ml"&gt;Wing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://purecss.io"&gt;Pure.css&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://getskeleton.coma"&gt;Skeleton&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So don’t think that just because you aren’t a design expert means you can’t help here.&lt;/p&gt;
&lt;p&gt;Just as important as the &lt;em&gt;visual&lt;/em&gt; design is thinking about and actively designing the &lt;strong&gt;information hierarchy&lt;/strong&gt; of your content. What leads to what? Which pieces go together, and which pieces can be broken up into their own pages or sections within pages? Think about the content like an &lt;em&gt;outline&lt;/em&gt;. Many sites don’t have any such structure to them; they’re kind of haphazardly cobbled together. If you can help the maintainers with the &lt;em&gt;structure&lt;/em&gt; and &lt;em&gt;organization&lt;/em&gt; of their content, that can make an enormous differences as well.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="blogging" class="level3"&gt;
&lt;h3&gt;Blogging&lt;/h3&gt;
&lt;p&gt;One of the other big ways you can help a project may not even end up in the repository at all. You can &lt;em&gt;blog&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I know blogging can seem intimidating, for many of the same reasons that writing documentation can. Technical writing is hard, and it’s a completely different skill from programming. But it doesn’t have to be amazing; it just has to get the information out there – and you’ll get better as you practice.&lt;/p&gt;
&lt;section id="blogging-easy-mode" class="level4"&gt;
&lt;h4&gt;Blogging: “Easy Mode”&lt;/h4&gt;
&lt;p&gt;You can start on “easy mode”, too. I mentioned this earlier when talking about documentation, but “just write down what you’re learning” is an incredibly effective technique for generating content. If you look at a lot of the technical blogging I’ve done over the years, it has been nothing more complicated than “here is what I just learned.” And if you want a &lt;em&gt;superb&lt;/em&gt; example of this which is &lt;em&gt;very&lt;/em&gt; different from mine, take a look at the work that Julia Evans does on her blog! She regularly writes down, in an inimitable way, highly technical ideas she’s just learning. If you want someone to make arcane Linux command line tools seem amazing and approachable, her blog is your ticket.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Just write down what you’re learning.&lt;br/&gt; —Me, just now&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/section&gt;
&lt;section id="blogging-good-examples" class="level4"&gt;
&lt;h4&gt;Blogging: good examples&lt;/h4&gt;
&lt;p&gt;But even beyond “what I just learned,” blogging is a superb way for teaching in general. Over the course of this year, for example, Vaidehi Joshi has been writing what is essentially a friendly introduction to computer science on her blog on Medium. This is a totally different style of &lt;em&gt;content&lt;/em&gt; (as well as of presentation!) from the kind of “what I just learned” content that Julia Evans writes,but it’s also really effective, because she takes her knowledge and translates it into something others can pick up. That’s obviously more work than just writing down things you just learned, but it can also pay really high dividends as others are able to substantially deepen their knowledge.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="blogging-all-the-options" class="level4"&gt;
&lt;h4&gt;Blogging: all the options!&lt;/h4&gt;
&lt;p&gt;In blogging, as in documentation, there is a whole spectrum of basic teaching content you can contribute! And communities need the whole spectrum for simple introductions to extremely thorough, advanced tutorials.&lt;/p&gt;
&lt;p&gt;But blog posts can also be much more versatile than traditional documentation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;They can be one-offs, or series.&lt;/strong&gt; You can give a topic as much depth, or as little depth, as you &lt;em&gt;care about&lt;/em&gt; or &lt;em&gt;think it deserves&lt;/em&gt;. I wrote an 18-part series comparing Rust and Swift, and it could have been 30 parts if I hadn’t eventually gotten derailed. That’s not &lt;em&gt;documentation&lt;/em&gt;, but there’s a lot people can learn from those kinds of things.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;They can introduce a technology, or dig deep into how to use it, or how it’s built.&lt;/strong&gt; You’re not limited to just one particular tack when blogging. Is your interest in the specific implementation details of some corner of the compiler? Write about that! Is your interest in how a given Rust library solves a specific kind of problem you’ve run into with another library, or with a similar library in another language? Write about that! You get the idea.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;They can critique or highlight problems with specific pieces of the ecosystem!&lt;/strong&gt; A careful, well-articulated, critical blog post can do wonders for showing the problems with a given approach and can even sometimes help suggest the right solutions to those problems. I’ve repeatedly watched, for example, as people have blogged about their struggles getting their heads around the Tokio tooling; the result has been a &lt;em&gt;lot&lt;/em&gt; of work by the Tokio team to respond to those problems. The more thoughtful and careful you are in that kind of criticism, the better! Good criticism is &lt;em&gt;incredibly&lt;/em&gt; valuable. Because we all have blind spots, and someone else’s perspective can help jar us out of those.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;They can show how to &lt;em&gt;integrate&lt;/em&gt; different parts of the ecosystem.&lt;/strong&gt; For example, as part of the “Increasing Rust’s Reach” initiative, Ryan Blecher recently wrote up a detailed walk-through on how to use the Diesel ORM and the Rocket web framework together to build a small blogging engine. That’s &lt;em&gt;huge&lt;/em&gt;! It makes it that much easier for someone who’s just starting out with Rust, coming in from something like Python or Ruby, to dive in and get that intensely rewarding feeling of &lt;em&gt;having built something&lt;/em&gt; in a relatively small amount of time. That’s also helpful because (almost) no one is building something with &lt;em&gt;just&lt;/em&gt; Diesel, or just &lt;em&gt;any&lt;/em&gt; crate. A huge part of what every software developer does is about fitting together other pieces of software.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;They can invite feedback on your own projects.&lt;/strong&gt; Talk about what you’re doing, what your stumbling blocks are, what you don’t understand. People will often show up and help you with comments and clarifications!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that’s just scratching the surface. Blogs are incredibly versatile, and you should lean on that.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="audio-and-video" class="level3"&gt;
&lt;h3&gt;Audio and Video&lt;/h3&gt;
&lt;p&gt;Not just words! Noises and pictures, too!&lt;/p&gt;
&lt;section id="audio-podcasts" class="level4"&gt;
&lt;h4&gt;Audio: podcasts&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Not everyone learns the same way.&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;Lots of people have commutes.&lt;!-- .element: class="fragment" data-fragment-index="2" --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="audio-but-there-are-already-podcasts" class="level4"&gt;
&lt;h4&gt;Audio: but there are already podcasts&lt;/h4&gt;
&lt;p&gt;Everything I’ve talked about so far has been in written form. But audio and video media can also be really helpful. Not everyone learns best by reading. And not everyone has tons of time to sit down and read a book every day. One of the reasons I started the New Rustacean podcast is that it gives people a way to get up to speed on the language while on a daily commute. But there’s still a &lt;em&gt;huge&lt;/em&gt; need for more audio and video content in this space!&lt;/p&gt;
&lt;p&gt;One podcast is not enough!&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/talks/rust-belt-rust/img/newrustacean.png" alt="New Rustacean" /&gt;&lt;figcaption&gt;New Rustacean&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;Two&lt;/em&gt; podcasts is not enough!&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/talks/rust-belt-rust/img/rfe.png" alt="Request for Explanation" /&gt;&lt;figcaption&gt;Request for Explanation&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Seriously, not even &lt;em&gt;three&lt;/em&gt; podcasts is enough!&lt;/p&gt;
&lt;figure&gt;
&lt;img src="/talks/rust-belt-rust/img/rusty-spike.png" alt="Rusty Spike" /&gt;&lt;figcaption&gt;Rusty Spike&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;So I’m laying down another challenge: there’s plenty of room for more, and more kinds, of audio content in this ecosystem.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="video" class="level4"&gt;
&lt;h4&gt;Video&lt;/h4&gt;
&lt;p&gt;Again: people have different learning styles!&lt;/p&gt;
&lt;p&gt;There’s also a huge opening for people to produce good video content. I’ve heard often from people that things like RailsCasts were essential in helping them learn the Ruby on Rails ecosystem. We &lt;em&gt;need&lt;/em&gt; video tutorials which might look kind of like that, or like the kinds of things I’m doing on the podcast. If you have any skill that way, and any interest in teaching, you should make Rust videos – there aren’t many out there.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="video-what" class="level4"&gt;
&lt;h4&gt;Video: what&lt;/h4&gt;
&lt;p&gt;There are lots of options here—not just live streaming!&lt;/p&gt;
&lt;p&gt;Another, totally different tack you can take with video is &lt;em&gt;live-streaming&lt;/em&gt;. Sean Griffin has done this at times, and I’ve actually done it just once, and it’s a ton of fun – and it can be incredibly illuminating for other people to see how you work and how you solve problems. You can also do like I did and live-pair on something. It’s a pain to set up, but it’s also a lot of fun.&lt;/p&gt;
&lt;p&gt;And no doubt there are more ideas you have—please just go do them!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="talk-to-people" class="level3"&gt;
&lt;h3&gt;Talk to people&lt;/h3&gt;
&lt;p&gt;Just talking with people matters. And there are lots of places to do it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IRC/Gitter/Slack/Discourse&lt;/li&gt;
&lt;li&gt;Meetups&lt;/li&gt;
&lt;li&gt;Conferences&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also host or help with a local meet-up! For a lot of people, one of the major challenges of learning &lt;em&gt;any&lt;/em&gt; new piece of technology is that – even with IRC and Gitter and Slack and so on – you can feel isolated and alone. And people can help you solve problems in person, and make you feel supported in person, in ways that even a great community can’t really manage online. So &lt;em&gt;go&lt;/em&gt; to meet-ups, at a minimum. And help the organizers. And if there isn’t a meet-up in your community… you can start one! The #rust-community team has a ton of resources.&lt;/p&gt;
&lt;p&gt;Physicality matters. Presence matters. (We know this! We’re at a conference!)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="being-inviting" class="level3"&gt;
&lt;h3&gt;Being inviting&lt;/h3&gt;
&lt;p&gt;Last but not least in this list of &lt;em&gt;how&lt;/em&gt; to be a contributor, I want to take a minute and talk about “being a contributor” to those of you who’ve been contributors for a long time. Some of you have been shipping open-source software for years – some of you even for decades. Much of what I’ve said so far is old hat for you. Maybe not the design bits quite so much! But you’ve been doing this for a long time, and you’re not trying to get over the hump of making your first contribution. You have other things to contribute here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The most important thing you can do is practice &lt;strong&gt;welcome people.&lt;/strong&gt; The Rust community does this well, in general, but it’s something we need to keep in front of us as a goal as the community grows. It’s easy to get frustrated with newcomers as your project grows, demands on your time increase, and your work as a maintainer seems less like fun and more like a second job. But continuing to actively welcome newcomers in is &lt;em&gt;incredibly&lt;/em&gt; powerful. You can make it possible for people to go from zero to really making a difference. And remember: so once were you. None of us started out as magical wizards of Rust and open-source.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The second big thing you can do is &lt;strong&gt;mentoring.&lt;/strong&gt; As I mentioned, I’m now the maintainer of one of the core pieces necessary to make Ember.js and TypeScript play nicely together. But while I’ve done &lt;em&gt;some&lt;/em&gt; writing-of-code with that, a much larger part of my current and future work there is about helping other people learn TypeScript well enough to start using it in their apps and add-ons. But the flip-side of that is: even a fair bit of the code I &lt;em&gt;have&lt;/em&gt; written, I was able to write because someone more comfortable with some of the infrastructure mentored &lt;em&gt;me&lt;/em&gt; through its quirks and oddities.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="when-where-to-contribute" class="level2"&gt;
&lt;h2&gt;When &amp;amp; where to contribute&lt;/h2&gt;
&lt;p&gt;The last thing I want to touch on is &lt;em&gt;when and where&lt;/em&gt; to contribute. There are two things I’d suggest you should consider here:&lt;/p&gt;
&lt;section id="when-where-you" class="level3"&gt;
&lt;h3&gt;When &amp;amp; where: you&lt;/h3&gt;
&lt;p&gt;Where are &lt;em&gt;you&lt;/em&gt; in the process of becoming comfortable with contributing?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Just getting started?&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;Already comfortable?&lt;!-- .element: class="fragment" data-fragment-index="2" --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’ve never done any open-source work at all before, that’s different than if you’ve gotten pretty comfortable with it in a different ecosystem and are just figuring out where to make yourself useful in &lt;em&gt;this&lt;/em&gt; ecosystem.&lt;/p&gt;
&lt;section id="when-where-if-youre-just-getting-started" class="level4"&gt;
&lt;h4&gt;When &amp;amp; where: if you’re just getting started&lt;/h4&gt;
&lt;p&gt;If you’re just getting started, I’d pick a big project with lots of those “Help Wanted” and “Mentoring” and “Easy” tags on issues, and let the size of the project help you out. Those are projects that are &lt;em&gt;used to&lt;/em&gt; helping people make their first contributions. Crazy as it seems, something like Servo can actually be an &lt;em&gt;easier&lt;/em&gt; place to start out that a much smaller project. Sure, the technical lift is higher, but there are also a lot more people actively invested in your success there.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Look for these!&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/p&gt;
&lt;p class="fragment" data-fragment-index="1"&gt;
&lt;img src="/talks/rust-belt-rust/img/help-wanted.png" alt="help wanted" /&gt; &lt;img src="/talks/rust-belt-rust/img/easy.png" alt="help wanted" /&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pick big projects!&lt;!-- .element: class="fragment" data-fragment-index="2" --&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;section id="when-where-if-youre-experienced" class="level4"&gt;
&lt;h4&gt;When &amp;amp; where: if you’re experienced&lt;/h4&gt;
&lt;p&gt;On the other hand, if you’re already comfortable contributing and have some idea what you’re best at, you might look around and find smaller projects with fewer contributors which look interesting and &lt;em&gt;could use the help&lt;/em&gt;. Because again, there’s always more work to do than hands to do it.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="when-where-project-lifecycles" class="level4"&gt;
&lt;h4&gt;When &amp;amp; where: project lifecycles&lt;/h4&gt;
&lt;p&gt;The second consideration dovetails nicely with that: &lt;strong&gt;where is a given project at in its life-cycle?&lt;/strong&gt; As enthusiastic as you might be about some project, if it’s a small project and it’s already in a “basically done” state, well… that’s probably a lot less useful a place to invest your time &lt;em&gt;if&lt;/em&gt; you’re focusing on code. On the other hand, it’s often the case that projects are “done” in terms of code, but desperately need help with documentation, their web site, etc. Big projects, or projects just starting out, are often better places to dig in if you’re really looking to flex your coding muscles (but both of them &lt;em&gt;also&lt;/em&gt; usually have huge needs in terms of all those non-code avenues we talked about).&lt;/p&gt;
&lt;p&gt;Where is a given project at in its life-cycle?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;small project, basically done?&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;need docs?&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;big project, a billion needs?&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;li&gt;etc.&lt;!-- .element: class="fragment" data-fragment-index="1" --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Think about those, and then see if you can pick a project that’s a good fit for your current skillset and comfort level and jump in!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;And that’s a good place to wrap things up! I hope you’re feeling like &lt;em&gt;you can do this&lt;/em&gt;. Because you can. Open-source a project of your own and see where it goes. Write a blog post. Add some docs. Open a PR. Record a podcast. Make some videos. Start a meet up. Become a contributor! And remember:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Anyone can contribute meaningfully.&lt;/li&gt;
&lt;li&gt;People can contribute in a stunning variety of ways.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="more-info" class="level2"&gt;
&lt;h2&gt;More info&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.rust-lang.org/en-US/contribute.html" class="uri"&gt;https://www.rust-lang.org/en-US/contribute.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.rust-lang.org/2017/09/18-impl-future-for-rust.html" class="uri"&gt;https://blog.rust-lang.org/2017/09/18-impl-future-for-rust.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://internals.rust-lang.org/" class="uri"&gt;https://internals.rust-lang.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#rust&lt;/code&gt;, &lt;code&gt;#rust-community&lt;/code&gt;, &lt;code&gt;#rust-internals&lt;/code&gt;, etc. on irc.mozilla.org&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 02 Nov 2017 07:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-02:/2017/becoming-a-contributor.html</guid><category>talks</category><category>software development</category><category>rust</category><category>open source software</category></item><item><title>Better Off Using Exceptions?</title><link>http://www.chriskrycho.com/2017/better-off-using-exceptions.html</link><description>&lt;p&gt;I saw this post on error-handling in F&lt;sup&gt;♯&lt;/sup&gt;, &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You’re better off using Exceptions"&gt;“You’re better off using Exceptions”&lt;/a&gt; making the rounds on Twitter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exception handling is an error management paradigm that has often been met with criticism. Such criticisms typically revolve around scoping considerations, exceptions-as-control-flow abuse or even the assertion that exceptions are really just a type safe version of goto. To an extent, these seem like valid concerns but it is not within the scope of this article to address those per se.&lt;/p&gt;
&lt;p&gt;Such concerns resonate particularly well within FP communities, often taken to the extreme: we should reject exceptions Show more…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And I get the argument, and in the specific context of F&lt;sup&gt;♯&lt;/sup&gt;—especially given how much C&lt;sup&gt;♯&lt;/sup&gt;-interoperating and therefore exception-throwing-code-interoperating there is there—it’s reasonable.&lt;/p&gt;
&lt;p&gt;But it still makes me sad. (To be clear: exceptions were and are a big win over what you get in languages like C. I’ll take them any day over &lt;code&gt;goto&lt;/code&gt; or &lt;code&gt;segfault&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;You need to embrace exceptions in F&lt;sup&gt;♯&lt;/sup&gt; &lt;em&gt;because F&lt;sup&gt;♯&lt;/sup&gt; has exceptions&lt;/em&gt; and because &lt;em&gt;many of its libraries rely on exceptions&lt;/em&gt;. But my experience with Rust and other non-exception-using languages is that you &lt;em&gt;don’t&lt;/em&gt; need exceptions in the general case.&lt;/p&gt;
&lt;p&gt;The questions are: whether your language has good support for things like flat-mapping, and whether you’re willing to commit to letting the compiler help you with these problems.&lt;/p&gt;
&lt;p&gt;To be sure: there’s more work involved up front to deal with that. But that’s a tradeoff I’m &lt;em&gt;always&lt;/em&gt; willing to make. I’d rather have the compiler tell me if I’m failing to account for something than learn because I saw a runtime error report come up in &lt;a href="https://raygun.com"&gt;Raygun&lt;/a&gt;, especially because that tends to mean an error that affects the user in some way.&lt;/p&gt;
&lt;p&gt;Rust’s model gives you something like exceptions for truly unrecoverable errors, “panics.” A panic gives you all the context you’d get from an exception (one of the virtues of exceptions highlighted in that post), but you can only “catch” it at thread boundaries, and it otherwise just kills the program. Because it’s catastrophic, you only use it where you don’t have any way to recover in your immediate context. But where you can recover in your immediate context… using something like a highly descriptive enum (just as suggested at the end of &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You’re better off using Exceptions"&gt;that original post&lt;/a&gt;!) is a better option.&lt;/p&gt;
&lt;p&gt;It’s well-understood in my circles that you shouldn’t use exceptions for things you can recover from; you should use them for things you &lt;em&gt;can’t&lt;/em&gt; recover from. But in most languages which lean heavily on exceptions, you inevitably start using them for control flow. I say: if you can recover from an error… just recover from it! Account for recoverable errors as possible conditions in your program and carry on! If you can’t recover… don’t. Die and let some other part of your system kick things back off.&lt;/p&gt;
&lt;p&gt;In summary: yes, if you’re in F&lt;sup&gt;♯&lt;/sup&gt;, use exceptions. It &lt;em&gt;is&lt;/em&gt; the right thing to do in many cases (and you don’t have a choice in many others). But I’m hopeful for a future where we handle recoverable errors locally, and &lt;a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html"&gt;act like Erlang or Elixir otherwise&lt;/a&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 20 Feb 2017 12:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-02-20:/2017/better-off-using-exceptions.html</guid><category>fsharp</category><category>software development</category><category>rust</category><category>functional programming</category></item><item><title>The Itch</title><link>http://www.chriskrycho.com/2016/the-itch.html</link><description>&lt;p&gt;It took me until just a few weeks ago to put my finger on why typed functional programming, as a style and approach, has appealed to me so much as I started picking it up over the last year. For all its novelty, typed FP feels—over and over again—&lt;em&gt;familiar&lt;/em&gt;. Strange to say, but it’s true.&lt;/p&gt;
&lt;p&gt;This came home to me again when reading a &lt;a href="https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6#.e887yz63p"&gt;short post on functors&lt;/a&gt;—i.e., &lt;em&gt;mappable&lt;/em&gt; types. I’ve written a lot of JavaScript in the last few years, and it has been a source of constant frustration to me that &lt;code&gt;Array&lt;/code&gt; implements the &lt;code&gt;map&lt;/code&gt; method, but &lt;code&gt;Object&lt;/code&gt; does not. Countless times, I have wanted to take an object shaped like &lt;code&gt;{ count: &amp;lt;number&amp;gt; }&lt;/code&gt; and transform that &lt;code&gt;count&lt;/code&gt;. I’m not alone in that. There’s a reason that libraries like &lt;a href="http://underscorejs.org"&gt;Underscore&lt;/a&gt;, &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;, and &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; all supply utilities to allow you to map over objects. There are also good reasons why it &lt;em&gt;isn’t&lt;/em&gt; implemented for on &lt;code&gt;Object.prototype&lt;/code&gt;: the reality is that coming up with a predictable &lt;em&gt;and&lt;/em&gt; useful API for &lt;em&gt;all&lt;/em&gt; &lt;code&gt;Object&lt;/code&gt; instances is difficult at best: Objects are used for everything from dictionaries to records and strange combinations of the two. But still: there’s something there.&lt;/p&gt;
&lt;p&gt;And reading this post on functors, it struck me what that “something” is: object types are, in principle, functors. Maybe it doesn’t make sense to have a single &lt;code&gt;map&lt;/code&gt; implementation for every &lt;code&gt;Object&lt;/code&gt; instance out there. But they’re perfectly mappable. I didn’t have a word for this before tonight, but now I do. Over and over again, this is my experience with functional programming.&lt;/p&gt;
&lt;p&gt;There’s this familiar feeling of frustration I’m slowly coming to recognize—a mental sensation which is a little like the intellectual equivalent of an itch in a spot you can’t quite reach. You’re reaching for an abstraction to express an idea, but you don’t even know that there &lt;em&gt;is&lt;/em&gt; an abstraction for it. You want to map over objects, and you don’t know why that seems so reasonable, but it does. And then someone explains functors to you. It scratches the itch.&lt;/p&gt;
&lt;p&gt;Another example. Since I started programming eight and a half years ago, I’ve worked seriously with Fortran, C, C++ PHP, Python, and JavaScript. In each of those languages (and especially in the C-descended languages), I have found myself reaching for enums or things like them as a way of trying to represent types and states in my system in a more comprehensive way. I figured out that you should &lt;a href="http://wiki.c2.com/?UseEnumsNotBooleans"&gt;use enums not booleans&lt;/a&gt; a long time before I found the advice on the internet. I was encoding error types as enum values instead of just using &lt;code&gt;int&lt;/code&gt;s almost as soon as I started, because it was obvious to me that &lt;code&gt;ErrorCode someFunction() { ... }&lt;/code&gt; was far more meaningful than &lt;code&gt;int someFunction() { ... }&lt;/code&gt; (even if the context of C meant that the latter often implied the former, and even if it was trivial to coerce one to the other).&lt;/p&gt;
&lt;p&gt;Then I read &lt;a href="https://gumroad.com/l/maybe-haskell/"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt;, a book I’ve mentioned often on this blog because it was so revelatory for me. This is what I had been reaching for all those years—and then some. Handing data around with the constraints? Yes, please! I had played with unions, enums, structs with enums inside them, anything to try to get some type-level clarity and guarantees about what my code was doing. Haskell showed me the way; and since then Rust and Elm and F# have reinforced it many times over. &lt;a href="https://guide.elm-lang.org/types/union_types.html"&gt;Tagged unions&lt;/a&gt; are a joy. They let me say what I mean—finally.&lt;/p&gt;
&lt;p&gt;I can still feel that itch. It’s shifted a little, but it’s still there: reaching for higher abstractions to let me tell the machine more clearly what I intend. Half a dozen times this year, I’ve realized: &lt;em&gt;Here&lt;/em&gt; is where dependent types would be useful. They’re far beyond me, but close enough now I can see. I’m sure a year from now, I’ll have find some tools to scratch &lt;em&gt;these&lt;/em&gt; itches, only to discover a few more.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 19 Dec 2016 21:45:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-19:/2016/the-itch.html</guid><category>software development</category><category>functional programming</category><category>Rust</category><category>JavaScript</category></item><item><title>Rust development using VS Code on OS X, debugging included</title><link>http://www.chriskrycho.com/2016/rust-development-using-vs-code-on-os-x-debugging-included.html</link><description>&lt;p&gt;&lt;a href="https://medium.com/@royalstream/rust-development-using-vs-code-on-os-x-debugging-included-bc10c9863777#.wgjbgie5a"&gt;Super handy guide for getting a debugging/IDE environment set up for Rust.&lt;/a&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 18 Nov 2016 20:48:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-18:/2016/rust-development-using-vs-code-on-os-x-debugging-included.html</guid><category>software development</category><category>rust</category><category>links</category></item><item><title>Using Rust for ‘Scripting’</title><link>http://www.chriskrycho.com/2016/using-rust-for-scripting.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;&lt;strong&gt;Edit&lt;/strong&gt;: fixed some typos, cleaned up implementation a bit based on feedback around the internet.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;A lightly edited version of this post was syndicated in &lt;a href="https://hackerbits.com/chris-krycho-using-rust-for-scripting/"&gt;Hacker Bits, Issue 13&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="i.-using-rust-instead-of-python" class="level2"&gt;
&lt;h2&gt;I. Using Rust Instead of Python&lt;/h2&gt;
&lt;p&gt;A friend asked me today about writing a little script to do a simple conversion of the names of some files in a nested set of directories. Everything with one file extension needed to get another file extension. After asking if it was the kind of thing where he had time to and/or wanted to learn how to do it himself (always important when someone has expressed that interest more generally), I said, “Why don’t I do this in Rust?”&lt;/p&gt;
&lt;p&gt;Now, given the description, you might think, &lt;i class=thought&gt;Wouldn’t it make more sense to do that in Python or Perl or even just a shell script?&lt;/i&gt; And the answer would be: it depends—on what the target operating system is, for example, and what the person’s current setup is. I knew, for example, that my friend is running Windows, which means he doesn’t have Python or Perl installed. I’m not a huge fan of either batch scripts or PowerShell (and I don’t know either of them all that well, either).&lt;/p&gt;
&lt;p&gt;I could have asked him to install Python. But, on reflection, I thought: &lt;i class=thought&gt;Why would I do that? I can write this in Rust.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Writing it in Rust means I can compile it and hand it to him, and he can run it. And that’s it. As wonderful as they are, the fact that languages like Python, Perl, Ruby, JavaScript, etc. require having the runtime bundled up with them makes just shipping a tool a lot harder—&lt;em&gt;especially&lt;/em&gt; on systems which aren’t a Unix derivative and don’t have them installed by default. (Yes, I know that &lt;em&gt;mostly&lt;/em&gt; means Windows, but it doesn’t &lt;em&gt;solely&lt;/em&gt; mean Windows. And, more importantly: the vast majority of the desktop-type computers in the world &lt;em&gt;still run Windows&lt;/em&gt;. So that’s a big reason all by itself.)&lt;/p&gt;
&lt;p&gt;So there’s the justification for shipping a compiled binary. Why Rust specifically? Well, because I’m a fanboy. (But I’m a fanboy because Rust often gives you roughly the feel of using a high-level language like Python, but lets you ship standalone binaries. The same is true of a variety of other languages, too, like Haskell; but Rust is the one I know and like right now.)&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;&lt;strong&gt;Edit the second:&lt;/strong&gt; this is getting a lot of views from Hacker News, and it’s worth note: I’m not actually advocating that everyone stop using shell scripts for this kind of thing. I’m simply noting that it’s &lt;em&gt;possible&lt;/em&gt; (and sometimes even &lt;em&gt;nice&lt;/em&gt;) to be able to do this kind of thing in Rust, cross-compile it, and just ship it. And hey, types are nice when you’re trying to do more sophisticated things than I’m doing here! Also, for those worried about running untrusted binaries: I handed my friend the code, and would happily teach him how to build it.&lt;/i&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="ii.-building-a-simple-script" class="level2"&gt;
&lt;h2&gt;II. Building a Simple “Script”&lt;/h2&gt;
&lt;p&gt;Building a “script”-style tool in Rust is pretty easy, gladly. I’ll walk through exactly what I did to create this “script”-like tool for my friend. My goal here was to rename every file in a directory from &lt;code&gt;*.cha&lt;/code&gt; to &lt;code&gt;*.txt&lt;/code&gt;.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.rust-lang.org/en-US/downloads.html"&gt;Install Rust.&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a new binary:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;cargo new --bin rename-it&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the dependencies to the Cargo.toml file. I used the &lt;a href="https://doc.rust-lang.org/glob/glob/index.html"&gt;glob&lt;/a&gt; crate for finding all the &lt;code&gt;.cha&lt;/code&gt; files and the &lt;a href="https://clap.rs"&gt;clap&lt;/a&gt; crate for argument parsing.&lt;/p&gt;
&lt;pre class="toml"&gt;&lt;code&gt;[package]
name = &amp;quot;rename-it&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Chris Krycho &amp;lt;chris@chriskrycho.com&amp;gt;&amp;quot;]

[dependencies]
clap = &amp;quot;2.15.0&amp;quot;
glob = &amp;quot;0.2&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the actual implementation to the &lt;code&gt;main.rs&lt;/code&gt; file (iterating till you get it the way you want, of course).&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;extern crate clap;
extern crate glob;

use glob::glob;
use std::fs;

use clap::{Arg, App, AppSettings};


fn main() {
  let path_arg_name = &amp;quot;path&amp;quot;;
  let args = App::new(&amp;quot;cha-to-txt&amp;quot;)
    .about(&amp;quot;Rename .cha to .txt&amp;quot;)
    .setting(AppSettings::ArgRequiredElseHelp)
    .arg(Arg::with_name(path_arg_name)
      .help(&amp;quot;path to the top directory with .cha files&amp;quot;))
    .get_matches();

  let path = args.value_of(path_arg_name)
    .expect(&amp;quot;You didn&amp;#39;t supply a path&amp;quot;);
  let search = String::from(path) + &amp;quot;/**/*.cha&amp;quot;;
  let paths = glob(&amp;amp;search)
    .expect(&amp;quot;Could not find paths in glob&amp;quot;)
    .map(|p| p.expect(&amp;quot;Bad individual path in glob&amp;quot;));

  for path in paths {
    match fs::rename(&amp;amp;path, &amp;amp;path.with_extension(&amp;quot;txt&amp;quot;)) {
      Ok(_) =&amp;gt; (),
      Err(reason) =&amp;gt; panic!(&amp;quot;{}&amp;quot;, reason),
    };
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compile it.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;cargo build --release&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the executable to hand to a friend.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In my case, I actually added in the step of &lt;em&gt;recompiling&lt;/em&gt; it on Windows after doing all the development on macOS. This is one of the real pieces of magic with Rust: you can &lt;em&gt;easily&lt;/em&gt; write cross-platform code. The combination of Cargo and native-compiled-code makes it super easy to write this kind of thing—and, honestly, easier to do so in a cross-platform way than it would be with a traditional scripting language.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But what’s really delightful is that we can do better. I don’t even need to install Rust on Windows to compile a Rust binary for Windows.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="iii.-cross-compiling-to-windows-from-macos" class="level2"&gt;
&lt;h2&gt;III. Cross-Compiling to Windows from macOS&lt;/h2&gt;
&lt;p&gt;Once again, let’s do this step by step. Three notes: First, I got pretty much everything other than the first and last steps here from WindowsBunny on the &lt;a href="https://botbot.me/mozilla/rust/"&gt;#rust&lt;/a&gt; &lt;abbr&gt;IRC&lt;/abbr&gt; channel. (If you’ve never hopped into #rust, you should: it’s amazing.) Second, you’ll need a Windows installation to make this work, as you’ll need some libraries. (That’s a pain, but it’s a one-time pain.) Third, this is the setup for doing in on macOS Sierra; steps may look a little different on an earlier version of macOS or on Linux.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Install the Windows compilation target with &lt;code&gt;rustup&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;rustup target add x86_64-pc-windows-msvc&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the required linker (&lt;a href="http://lld.llvm.org"&gt;&lt;code&gt;lld&lt;/code&gt;&lt;/a&gt;) by way of installing the LLVM toolchain.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;brew install llvm&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a symlink somewhere on your &lt;code&gt;PATH&lt;/code&gt; to the newly installed linker, specifically with the name &lt;code&gt;link.exe&lt;/code&gt;. I have &lt;code&gt;~/bin&lt;/code&gt; on my &lt;code&gt;PATH&lt;/code&gt; for just this kind of thing, so I can do that like so:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ln -s /usr/local/opt/llvm/bin/lld-link ~/bin/link.exe&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(We have to do this because the Rust compiler &lt;a href="https://github.com/rust-lang/rust/blob/master/src/librustc_trans/back/msvc/mod.rs#L300"&gt;specifically goes looking for &lt;code&gt;link.exe&lt;/code&gt; on non-Windows targets&lt;/a&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the target files for the Windows build to link against. Those are in these directories, where &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; will be a number like &lt;code&gt;10586.0&lt;/code&gt; or similar (you should pick the highest one if there is more than one):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C:\Program Files\Windows Kits\10\Lib\10.0.&amp;lt;something&amp;gt;\ucrt\x64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C:\Program Files\Windows Kits\10\Lib\10.0.&amp;lt;something&amp;gt;\um\x64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\lib\amd64&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that if you don’t already have &lt;abbr&gt;MSVC&lt;/abbr&gt; installed, you’ll need to install it. If you don’t have Visual Studio installed on a Windows machine &lt;em&gt;at all&lt;/em&gt;, you can do that by using the links &lt;a href="http://landinghub.visualstudio.com/visual-cpp-build-tools"&gt;here&lt;/a&gt;. Otherwise, on Windows, go to &lt;strong&gt;Add/Remove Programs&lt;/strong&gt; and opting to Modify the Visual Studio installation. There, you can choose to add the C++ tools to the installation.&lt;/p&gt;
&lt;p&gt;Note also that if you’re building for 32-bit Windows you’ll want to grab &lt;em&gt;those&lt;/em&gt; libraries instead of the 64-bit libraries.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set the &lt;code&gt;LIB&lt;/code&gt; environment variable to include those paths and build the program. Let’s say you put them in something like &lt;code&gt;/Users/chris/lib/windows&lt;/code&gt; (which is where I put mine). Your Cargo invocation will look like this:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;env LIB=&amp;quot;/Users/chris/lib/windows/ucrt/x64/;/Users/chris/lib/windows/um/x64/;/Users/chris/lib/windows/VC_lib/amd64/&amp;quot; \
cargo build --release --target=x86_64-pc-windows-msvc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the final &lt;code&gt;/&lt;/code&gt; on each path and the enclosing quotation marks are all important!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the binary to hand to a friend, without ever having had to leave your Mac.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To be sure, there was a little extra work involved in getting cross-compilation set up. (This is the kind of thing I’d love to see further automated with &lt;code&gt;rustup&lt;/code&gt; in 2017!) But what we have at the end is pretty magical. Now we can just compile cross-platform code and hand it to our friends.&lt;/p&gt;
&lt;p&gt;Given that, I expect not to be using Python for these kinds of tools much going forward.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Again: you can do similar with Haskell or OCaml or a number of other languages. And those are great options; they are in &lt;em&gt;some&lt;/em&gt; ways easier than Rust—but Cargo is really magical for this.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 14 Nov 2016 22:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-14:/2016/using-rust-for-scripting.html</guid><category>rust</category><category>software development</category><category>programming languages</category></item><item><title>Rust vs. React Native—What?</title><link>http://www.chriskrycho.com/2016/rust-vs-react-native-what.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I was recently discussing some thoughts I’ve had on building a top-notch application experience in a Slack team I belong to, and noted that I believe that a Rust core with native UIs is a &lt;em&gt;massively&lt;/em&gt; winning strategy. A friend in the group responded that he thinks “React + JS is eating the world right now” and that “Rust as awesome for if you want to write a JS vm, or something like that… or a compiler… anything involving lots of speed and stability.” What follows is my response, lightly edited to remove details specific to that friend and to add a few further thoughts.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Here’s the thing: I don’t &lt;em&gt;care&lt;/em&gt; what’s eating the world today, for three reasons:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;I just want to build the best stuff I can build, and native UIs are still massively better than React and even React Native&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; in innumerable ways. There are clear advantages to React Native + JavaScript, and times when you absolutely should take that approach. But there are also a lot of times and reasons why you shouldn’t. Heck, even if you just want killer performance &lt;em&gt;in browsers&lt;/em&gt;, our future includes things like Rust-to-WebAssembly, and that’s a good thing.&lt;/li&gt;
&lt;li&gt;What was eating the world five years ago? Ten? Is it still eating the world today? I don’t feel obliged to follow those trends (not least because, not being a consultancy, following those trends doesn’t buy me anything for the things I want to do; your tradeoffs and mine look way different).&lt;/li&gt;
&lt;li&gt;I’m actually getting really tired of just treating as acceptable or normative the performance characteristics of browsers. Browsers are awesome. But we can (and should) do a &lt;em&gt;lot&lt;/em&gt; better in terms of user experience, and I don’t see browsers catching up to what you can do with e.g. Cocoa (Touch). Sure, that doesn’t matter that much for building yet-another-storefront. (Again, there are different tradeoffs for every single app!) But why in the world are we in a spot now where one of the most popular text editors in the world is &lt;em&gt;slower&lt;/em&gt; than any text editor of five years ago? That’s not a &lt;em&gt;necessary&lt;/em&gt; decision, and you can (and should) go after the same degree of ease-of-extensibility that Atom has had—perhaps even using things like HTML and CSS for skinning!—while not tying yourself to the browser and its upsides and downsides for &lt;em&gt;everything&lt;/em&gt;. We have &lt;em&gt;incredibly&lt;/em&gt; powerful machines, and the user experience is often getting &lt;em&gt;slower&lt;/em&gt;. I’m looking for ways to change that.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again, JS+React&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; may be &lt;em&gt;exactly&lt;/em&gt; the right tradeoff for a lot of apps, and given what consultancies (like my friends’s!) are doing, I think doing that with ReactNative for apps is a &lt;em&gt;very&lt;/em&gt; good move. It makes good sense business-wise, and it makes good sense in terms of the apps you’re likely to be delivering. Don’t hear me for a second saying Rust is the best for &lt;em&gt;everything&lt;/em&gt;. I think it, or something like it, is a very good choice for &lt;em&gt;many&lt;/em&gt; things, though, and it shouldn’t be dismissed simply because it’s a very different world from doing Ruby or Elixir or JavaScript.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;So much for my initial response. On reflection, I wanted to expand it a bit. So here’s another few hundred words!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Beyond this, I think there’s a bit of a false dichotomy here: the idea that “lots of speed and stability” &lt;em&gt;aren’t&lt;/em&gt; values we should be seeking more aggressively for &lt;em&gt;all&lt;/em&gt; our apps. Fully granted that not every app needs the same &lt;em&gt;degree&lt;/em&gt; of each of those, and moreover that there are a lot of ways to get to those goals. Still: speed and stability are &lt;em&gt;core&lt;/em&gt; user experience values. I don’t really care how you get at those goals, whether it’s with Rust, or Elixir or Clojure, or, yes, React with TypeScript or &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt;. I &lt;em&gt;do&lt;/em&gt; think that Rust is, for the moment at least, uniquely positioned to add real value in this space because it gives screaming performance but with so many niceties we’re used to when writing languages like Python or Ruby and so much of the power you get in languages like OCaml or F♯.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; But at the end of the day, I think &lt;em&gt;all&lt;/em&gt; apps should focus much more on speed and stability than they do today. We have supercomputers in our pockets, and we’re often shipping apps that are slower and more finicky.&lt;/p&gt;
&lt;p&gt;But I have this dream of a world where apps aren’t needlessly power-hungry or memory-intensive, where every swipe and or click or scroll results in buttery-smooth responses. We won’t get there by saying, “You know, Facebook is doing &lt;em&gt;x&lt;/em&gt; so that’s good enough for me.”&lt;/p&gt;
&lt;p&gt;Of course every developer, and any given product shop or consultancy, is going to have to make decisions about which stacks it invests in. If you’re primarily shipping web applications, investing in Elixir and React with React Native for your apps is a very sensible move. Most of your clients’ native apps may not &lt;em&gt;need&lt;/em&gt; the degree of polished performance you might get from writing their iOS app in Swift and their Android app in Kotlin and the core in Rust (or even C++). That tradeoff is a &lt;em&gt;tradeoff&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But let’s remember that there is real value there, and that some apps &lt;em&gt;do&lt;/em&gt; deserve that investment. We should evaluate the tradeoffs at every turn, and our core considerations should enduringly include &lt;em&gt;speed and stability&lt;/em&gt;. Don’t dismiss Rust (or Swift, or F♯) out of hand.&lt;/p&gt;
&lt;p&gt;Equally importantly, we need to stop assuming that just because something is eating the world today means it’s also the future. Betting big on Flash in the mid-2000s wasn’t a &lt;em&gt;bad&lt;/em&gt; move by a long shot. But its massive popularity then wasn’t a good predictor for its future. That goes double, frankly, for projects coming out of Facebook or Google or similar: big companies like that have the resources to drop everything and use a new language, or a new tool, as it suits them. If you don’t believe me, look at the actual open-source records of both of those companies! What’s hot today is far more relevant to a consultancy than to a product shop. And in both cases, choosing tech suitable for the job at hand is more important yet.&lt;/p&gt;
&lt;p&gt;My friend gets that, for what it’s worth. He’s making the right moves for his business as the owner of a consultancy. I just want him—and lots of other people—to see where languages like Rust and Swift and F♯ might be worth considering. And speed and stability matter in a lot of places besides just compilers and VMs.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I’m aware that React-Native ultimately binds down to native widgets. It’s still not quite the same.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;or, frankly, Ember or whatever else; React is great, but it is also overhyped.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Swift too, and honestly for a lot of things Swift is an easier experience for not &lt;em&gt;that&lt;/em&gt; much less performance than Rust. But as of today you &lt;em&gt;can’t&lt;/em&gt; ship core functionality in Swift for Android or Windows.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Oct 2016 08:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-10-07:/2016/rust-vs-react-native-what.html</guid><category>JavaScript</category><category>Rust</category><category>Swift</category><category>F Sharp</category><category>software development</category></item><item><title>Rust and Swift (xviii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xviii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="part-i-ownership-semantics-vs.reference-counting" class="level2"&gt;
&lt;h2&gt;Part I: Ownership Semantics vs. Reference Counting&lt;/h2&gt;
&lt;p&gt;Perhaps unsurprisingly, the Swift book follows on from its discussion of initialization with a discussion of deinitialization, and here the differences between Rust and Swift are substantial, but (as has so often been the case) so are the analogies.&lt;/p&gt;
&lt;p&gt;In Rust, memory is, by default, stack-allocated and -deallocated, but with a very impressive system for tracking the lifetime of that data and allowing its to be moved from one function to another. The Rust compiler tracks the &lt;em&gt;ownership&lt;/em&gt; of every given item in the program as it is passed from one function to another, allowing other parts of the program to “borrow” the data safely, until a given piece of data goes out of scope entirely. At that point, Rust runs its destructors automatically. As part of its system for managing memory safely, Rust also tracks where and when a program attempts to access any given piece of data (whether directly or via reference), and will refuse to compile if you try to reference data in a place where it has already gone out of scope and been cleaned up (“dropped,” in Rust-speak).&lt;/p&gt;
&lt;p&gt;If this was a bit fuzzy, don’t worry: there’s a lot to say here. It’s arguably the most distinctive feature of the language, and it’s also the main thing that tends to trip up newcomers to the language. If you’re interested in further material on the topic, my own most succinct treatment of it is in &lt;a href="http://www.newrustacean.com/show_notes/e002/index.html" title="e002: Something borrowed, something... moved?"&gt;an early episode&lt;/a&gt; of New Rustacean, my Rust developer podcast, and &lt;a href="https://doc.rust-lang.org/book/ownership.html"&gt;the official documentation&lt;/a&gt; is &lt;em&gt;very&lt;/em&gt; good. For now, suffice it to say: Rust does extremely rigorous &lt;em&gt;compile-time&lt;/em&gt; checks to let you do C or C++-style memory management, but with absolute guarantees that you won’t have e.g. use-after-free bugs, with a default to handling everything on the stack.&lt;/p&gt;
&lt;p&gt;It is of course impossible to handle &lt;em&gt;everything&lt;/em&gt; on the stack, so there are heap-allocated types (e.g. vectors, a dynamically sized array-like type), which are fundamentally reference (or pointer) types. But those follow the same basic rules: Rust tracks the &lt;em&gt;pointers&lt;/em&gt; throughout their uses, and when they go out of scope, Rust automatically tears down not only the pointer but also the data behind it. There are times, though, when you can’t comply with Rust’s normal rules for handling multiple-access to the same data. For those situations, it also supplies some “smart pointer” container types, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt;, the &lt;em&gt;reference-counted&lt;/em&gt; (non-thread-safe) and &lt;em&gt;atomically reference-counted&lt;/em&gt; (thread-safe) types. Both types just wrap up a type that you intend to put on the heap with reference-counters, which increment and decrement as various pieces of a program get access to them. Note that, unlike the compiler-level, &lt;em&gt;compile-time&lt;/em&gt; checks mentioned earlier, these are &lt;em&gt;run-time&lt;/em&gt; counts and they therefore incur a small but real runtime performance penalty. (The distinctions between the two types have to do with how they guarantee their memory safety and what kinds of a guarantees are required for cross-thread safety, and they’re important for writing Rust but not so important for this comparison, so I’ll leave them aside.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;In Swift, all class instances (which are pass-by-reference types) are tracked with &lt;em&gt;automatic reference counting&lt;/em&gt; and cleaned up automatically when there are no more references to them. Don’t confuse Rust’s “&lt;em&gt;atomically&lt;/em&gt; reference-counted” type with Swift’s “&lt;em&gt;automatically&lt;/em&gt; reference-counted” type. Unlike Rust’s behavior in having everything checked at compile-time, reference counting is a run-time check in Swift, just as it is with the &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; types in Rust.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But it happens for all reference types all the time in Swift, not just when specified manually as in Rust. (Value types seem to be &lt;em&gt;always&lt;/em&gt; passed by value, though the compiler has some smarts about that so it doesn’t get insanely expensive.) It’s &lt;em&gt;automatic&lt;/em&gt; in that the compiler and runtime handle it “behind the scenes” from the developer’s perspective.&lt;/p&gt;
&lt;p&gt;Swift’s approach here isn’t quite the same as having a full-on garbage-collected runtime like you’d see in Java, C&lt;sup&gt;#&lt;/sup&gt;, Python, Ruby, JavaScript, etc. (and so doesn’t have the performance issues those often can). But it also isn’t like Rust’s default of having &lt;em&gt;no&lt;/em&gt; runtime cost. It’s somewhere in the middle, with a goal of very good performance but good developer ergonomics. I think it achieves that latter goal: for the most part, it means that you don’t have to think about memory allocation and deallocation explicitly. Certainly there are times when you have to think about how your program handles those issues, but neither is it right up in your face like it is in Rust,&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; nor does it come with the costs of a heavier runtime (from startup, to GC pauses, to non-deterministic performance characteristics).&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To make it concrete, the following snippets do &lt;em&gt;basically&lt;/em&gt; the same thing—but note that the reference counting is explicit in Rust. We’ll start with Rust, doing it the normal way:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct WouldBeJedi {
    name: String,
    rank: u8,
    description: String,
}

impl WouldBeJedi {
    fn new(name: &amp;amp;str, rank: u8, description: &amp;amp;str) -&amp;gt; WouldBeJedi {
        WouldBeJedi {
            name: name.to_string(),
            rank: rank,
            description: description.to_string()
        }
    }
}

fn main() {
    let trainee = WouldBeJedi::new(
        &amp;quot;Zayne Carrick&amp;quot;, 1, &amp;quot;not very competent, but still a great hero&amp;quot;);

    // When calling the function, we pass it a reference, and it
    // &amp;quot;borrows&amp;quot; access to the data. But the validity of that access
    // is checked at compile time. `main()` keeps the &amp;quot;ownership&amp;quot;
    // of the data.
    describe(&amp;amp;trainee);

    // When `main` ends, nothing owns the data anymore, so
    // Rust cleans it up. If something were still borrowing the
    // data (say, if we&amp;#39;d passed a reference into another thread),
    // this would actually be a compile error, because references
    // have to be guaranteed to live as long as the thing they
    // point back to. Rust has tools for managing that, as well,
    // its &amp;quot;lifetimes&amp;quot;, but we can leave them aside for this example.
}

fn describe(trainee: &amp;amp;WouldBeJedi) {
    // Rust checks at compile time to make sure there are no
    // mutable &amp;quot;borrows&amp;quot; of the data, and therefore knows
    // that it is safe to reference the data here, because it can
    // be *sure* nothing will change it at the same time.

    // Under the covers, this macro will actually call a
    // function with the data we pass it, so Rust actually checks
    // the ownership and borrowing state here, too. Again, all
    // at compile time, and therefore with no runtime penalty.
    println!(&amp;quot;{} (rank {}) is {}.&amp;quot;,
             trainee.name,
             trainee.rank,
             trainee.description);

    // When we exit the function, Rust notes that it is no
    // longer &amp;quot;borrowing&amp;quot; the data.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here’s the Swift code—note as well that we use a &lt;code&gt;class&lt;/code&gt; not a &lt;code&gt;struct&lt;/code&gt; here:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class WouldBeJedi {
    let name: String
    let rank: UInt8
    let description: String

    init(name: String, rank: UInt8, description: String) {
        self.name = name
        self.rank = rank
        self.description = description
    }
}

func main() {
    let aTrainee = WouldBeJedi(
        name: &amp;quot;Zayne Carrick&amp;quot;,
        rank: 1,
        description: &amp;quot;not very competent, but a great hero&amp;quot;)

    // When calling the function, the reference count goes up
    // here, too, but it&amp;#39;s implicit, rather than explicit.
    describe(aTrainee)

    // The implicit reference count Swift maintains for `aTrainee`
    // will go from 1 to 0 here, and Swift will do its cleanup of the
    // object data.
}

func describe(_ trainee: WouldBeJedi) {
    // When we enter this function, Swift bumps the reference
    // count, from 1 to 2. Both `main` and `describe` now have a
    // reference to the data.

    // No need for the unwrapping or any of that; Swift handles it
    // all automatically... thus the name of the technology!
    print(&amp;quot;\(trainee.name) (rank \(trainee.rank)) is \(trainee.description).&amp;quot;)

    // When we exit the function, Swift bumps the reference count
    // back down to 1 automatically.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, here is the (much longer, because all the reference counting is done explicitly) reference-counted Rust version:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::rc::Rc;

pub struct WouldBeJedi {
    name: String,
    rank: u8,
    description: String,
}

fn main() {
    let trainee = WouldBeJedi {
        name: &amp;quot;Zayne Carrick&amp;quot;.to_string(),
        rank: 1,
        description: &amp;quot;not very competent, but a great hero&amp;quot;.to_string()
    };
    let wrapped_trainee = Rc::new(trainee);

    // Start by calling `clone()` to get a *reference* to the
    // trainee. This increases the reference count by one.
    let ref_trainee = wrapped_trainee.clone();
    // Then pass the reference to the `describe()` function.
    // Note that we *move* the reference to the function, so
    // once the function returns, the reference will go out
    // of scope, and the reference count will decrement.
    describe(ref_trainee);

    // When `main` ends, several things will happen in order:
    // 1. The reference count on the `wrapped_trainee` will
    //    go to zero. As a result, the `wrapped_trainee`
    //    pointer---the `Rc` type we created---will get
    //    cleaned up.
    // 2. Once `wrapped_trainee` has been cleaned up, Rust
    //    will notice that there are no more references
    //    anywhere to `trainee` and clean it up as well.
    //    (More on this below.)
}

fn describe(trainee: Rc&amp;lt;WouldBeJedi&amp;gt;) {
    // We now have a *reference* to the underlying data, and
    // therefore can freely access the underlying data.
    println!(&amp;quot;{} (rank {}) is {}.&amp;quot;,
             trainee.name,
             trainee.rank,
             trainee.description);


    // When we exit the function, Rust destroys this *owned*
    // clone of the reference, and that bumps the reference
    // count back down to 1 automatically.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that if we strip out all the explanatory comments and details, the &lt;em&gt;normal&lt;/em&gt; versions of the Rust and Swift code are pretty similar.&lt;/p&gt;
&lt;p&gt;Rust—&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct WouldBeJedi {
    name: String,
    rank: u8,
    description: String,
}

impl WouldBeJedi {
    fn new(name: &amp;amp;str, rank: u8, description: &amp;amp;str) -&amp;gt; WouldBeJedi {
        WouldBeJedi {
            name: name.to_string(),
            rank: rank,
            description: description.to_string()
        }
    }
}

fn main() {
    let trainee = WouldBeJedi::new(
        &amp;quot;Zayne Carrick&amp;quot;,
        1,
        &amp;quot;not very competent, but still a great hero&amp;quot;);

    describe(&amp;amp;trainee);
}

fn describe(trainee: &amp;amp;WouldBeJedi) {
    println!(&amp;quot;{} (rank {}) is {}.&amp;quot;,
             trainee.name,
             trainee.rank,
             trainee.description);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift (as usual, is &lt;em&gt;slightly&lt;/em&gt; briefer than Rust)—&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class WouldBeJedi {
    let name: String
    let rank: UInt8
    let description: String

    init(name: String, rank: UInt8, description: String) {
        self.name = name
        self.rank = rank
        self.description = description
    }
}

func main() {
    let aTrainee = WouldBeJedi(
        name: &amp;quot;Zayne Carrick&amp;quot;,
        rank: 1,
        description: &amp;quot;not very competent, but a great hero&amp;quot;)

    describe(aTrainee)
}

func describe(_ trainee: WouldBeJedi) {
    print(&amp;quot;\(trainee.name) (rank \(trainee.rank)) is \(trainee.description).&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in both of these implementations, all the actual cleanup of the memory is handled behind the scenes—this feels much more like writing Python than writing C, &lt;em&gt;especially&lt;/em&gt; for complex data types. Not least because this same kind of nice cleanup can happen for complex, heap-allocated types like dynamically-sized vectors/arrays, etc. Both languages just manage it automatically. (The same is true of modern C++, for the most part, but it has a more complicated story there because of its relationship with C, where &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; and friends run rampant and are quite necessary for writing a lot of kinds of code.) Most of the time, when you’re done using data, you just &lt;em&gt;stop using it&lt;/em&gt;, and both Rust and Swift will clean it up for you. The feel of using either language is fairly similar, though the underlying semantics are quite different.&lt;/p&gt;
&lt;hr /&gt;
&lt;/section&gt;
&lt;section id="part-2-deconstructiondeinitialization" class="level2"&gt;
&lt;h2&gt;Part 2: Deconstruction/Deinitialization&lt;/h2&gt;
&lt;p&gt;Both Rust and Swift recognize that, the ordinary case notwithstanding, there are many times when you &lt;em&gt;do&lt;/em&gt; need to run some cleanup as part of tearing down an object. For example, if you had an open database connection attached to an object, you should return it to the collection pool before finishing tear-down of the object.&lt;/p&gt;
&lt;p&gt;In Rust, this is accomplished by implementing the &lt;code&gt;Drop&lt;/code&gt; trait and supplying the requisite &lt;code&gt;drop&lt;/code&gt; method. Imagine we had defined a &lt;code&gt;Jedi&lt;/code&gt; type, with a bunch of details about the Jedi’s lightsaber (including whether the Jedi even &lt;em&gt;has&lt;/em&gt; a lightsaber. We know from the &lt;em&gt;Star Wars&lt;/em&gt; movies that lightsabers turn off automatically when the Jedi dies, or even just drops it for that matter. We can implement &lt;em&gt;all&lt;/em&gt; of this in Rust using just the &lt;code&gt;Drop&lt;/code&gt; trait. Here’s a pretty full example.&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; (Note that both of these implementations draw heavily on material I covered in &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;previous posts&lt;/a&gt;.)&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;#[derive(Debug)]
enum Color {
    Red,
    Blue,
    Green,
    Purple,
    Yellow
}

enum SaberState {
    On,
    Off,
}

struct Lightsaber {
    color: Color,
    blades: u8,
    state: SaberState
}

impl Lightsaber {
    pub fn new(color: Color, blades: u8) -&amp;gt; Lightsaber {
        if blades &amp;gt; 2 {
            panic!(&amp;quot;That&amp;#39;s just silly. Looking at you, Kylo.&amp;quot;);
        }

        Lightsaber { color: color, blades: blades, state: SaberState::Off }
    }

    pub fn on(&amp;amp;mut self) {
        self.state = SaberState::On;
    }

    pub fn off(&amp;amp;mut self) {
        self.state = SaberState::Off;
    }
}

struct WouldBeJedi {
    name: String,
    lightsaber: Option&amp;lt;Lightsaber&amp;gt;,
}

impl WouldBeJedi {
    pub fn new(name: &amp;amp;str, lightsaber: Option&amp;lt;Lightsaber&amp;gt;) -&amp;gt; WouldBeJedi {
        WouldBeJedi { name: name.to_string(), lightsaber: lightsaber }
    }

    pub fn describe(&amp;amp;self) {
        let lightsaber = match self.lightsaber {
            Some(ref saber) =&amp;gt;
                format!(&amp;quot;a {:?} lightsaber with {:} blades.&amp;quot;, saber.color, saber.blades),
            None =&amp;gt; &amp;quot;no lightsaber.&amp;quot;.to_string()
        };

        println!(&amp;quot;{} has {}&amp;quot;, self.name, lightsaber)
    }
}

// Here&amp;#39;s the actually important bit.
impl Drop for WouldBeJedi {
    fn drop(&amp;amp;mut self) {
        if let Some(ref mut lightsaber) = self.lightsaber {
            lightsaber.off();
        }
    }
}


fn main() {
    let saber = Lightsaber::new(Color::Yellow, 1);
    let a_jedi = WouldBeJedi::new(&amp;quot;Zayne Carrick&amp;quot;, Some(saber));
    a_jedi.describe();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can do much the same in Swift, using its deinitializers, which are fairly analogous to (but much simpler than) &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvii.html"&gt;its initializers&lt;/a&gt;, and fulfill the same role as Rust’s &lt;code&gt;Drop&lt;/code&gt; trait and &lt;code&gt;drop()&lt;/code&gt; method.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;enum Color {
    case red, blue, green, purple, yellow
}

enum SaberState {
    case on, off
}

struct Lightsaber {
    let color: Color
    let blades: UInt8
    var state: SaberState = .off

    init?(color: Color, blades: UInt8) {
        if blades &amp;gt; 2 {
            print(&amp;quot;That&amp;#39;s just silly. Looking at you, Kylo.&amp;quot;)
            return nil
        }

        self.color = color
        self.blades = blades
    }

    mutating func on() {
        state = .on
    }

    mutating func off() {
        state = .off
    }
}

class WouldBeJedi {
    let name: String
    var lightsaber: Lightsaber?

    init(name: String, lightsaber: Lightsaber?) {
        self.name = name
        self.lightsaber = lightsaber
    }

    deinit {
        self.lightsaber?.off()
    }

    func describe() {
        let saberDescription: String
        if let saber = self.lightsaber {
            saberDescription = &amp;quot;a \(saber.color) lightsaber with \(saber.blades) blades.&amp;quot;
        } else {
            saberDescription = &amp;quot;no lightsaber.&amp;quot;
        }

        print(&amp;quot;\(name) has \(saberDescription)&amp;quot;)
    }
}

func main() {
    let saber = Lightsaber(color: .yellow, blades: 1)
    let aJedi = WouldBeJedi(name: &amp;quot;Zayne Carrick&amp;quot;, lightsaber: saber)
    aJedi.describe();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a bit briefer, but that’s mostly down to Swift’s shorthand for optionals (the &lt;code&gt;?&lt;/code&gt; operator), which we’ll get to in a future post.&lt;/p&gt;
&lt;p&gt;Curiously, &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;enum&lt;/code&gt; types &lt;em&gt;cannot&lt;/em&gt; have deinitializers in Swift. I expect this has something to do with their being value types rather than reference types, but the book offers no comment. (If a reader knows the answer, I’d welcome clarification.)&lt;/p&gt;
&lt;p&gt;Much as in the discussion of of initializers, the usual patterns with Rust and Swift’s approach come into play. Rust opts to build the pattern on the same basic language machinery (traits). Swift uses a bit of syntactical sugar dedicated to the purpose. It’s undeniable that the Swift is a bit briefer.&lt;/p&gt;
&lt;p&gt;However, there are a couple upsides to Rust’s approach. First, it is applicable on &lt;em&gt;all&lt;/em&gt; types, where Swift’s applies only to classes. Second, there is no additional syntax to remember. &lt;code&gt;Drop&lt;/code&gt; is just a trait like any other, and &lt;code&gt;drop&lt;/code&gt; a method like any other. Third, then, this means that you can run it explicitly elsewhere if you need to, and as a result you can define whatever kind of custom deconstruction behavior you might need. If we’d created &lt;code&gt;a_jedi&lt;/code&gt; above in Rust, we could simply write &lt;code&gt;a_jedi.drop()&lt;/code&gt; anywhere:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn prove_incompetent(a_jedi: WouldBeJedi) {
    // make some series of grievous mistakes which mean
    // you&amp;#39;re no longer able to be a Jedi and as such,
    // among other things, lose your lightsaber...
    a_jedi.drop();
    // other stuff
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or (going a bit more abstract) we could define a &lt;code&gt;daring_derring_do()&lt;/code&gt; method which called &lt;code&gt;drop()&lt;/code&gt; itself:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;impl WouldBeJedi {
    pub fn daring_derring_do(self) {
        // do some other operation, like freeing slaves from
        // a secret colony of slavers. But if it fails...
        self.drop();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, really, define &lt;em&gt;any&lt;/em&gt; behavior which culminated in a &lt;code&gt;drop()&lt;/code&gt; call. That’s extremely powerful, and it’s the upside that comes with its just being a trait whose behavior we have to define ourselves.&lt;/p&gt;
&lt;p&gt;That takes us back to one of the fundamental differences in design between the two languages. Rust goes out of its way to leave power in the hands of the user, at the cost of requiring the user to be a bit more explicit. Swift prioritizes brevity and productivity, but it gets there by taking some of the power out of the hands of the developer. Neither of these is wrong, &lt;em&gt;per se&lt;/em&gt;. They’re just aiming for (and in this case, I think, fairly successfully landing in) somewhat different spots on a spectrum of tradeoffs.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; More on initializers!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I did, however, cover them &lt;a href="http://www.newrustacean.com/show_notes/e015/index.html" title="e015: Not dumb pointers"&gt;quite recently&lt;/a&gt; on my podcast. Yes, this &lt;em&gt;is&lt;/em&gt; another shameless plug.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Mostly, anyway. I believe the Swift compiler also does some degree of static analysis similar to that done by Rust—though to a &lt;em&gt;much&lt;/em&gt; lesser extent and, speaking purely descriptively, much less rigorously (it just has different goals). Swift then uses that analysis to handle things at compile time rather than via reference counts if it’s able to determine that it can do so.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;We could, if we so desired, get this same basic behavior in Rust. We can easily imagine a world in which every type was automatically wrapped in &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;, and in fact, I’d be very interested to see just such a language—something which was only a thin layer over Rust, keeping all its semantics but wrapping some or all non-stack-allocated types in &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt; as appropriate. (Something like &lt;a href="http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/"&gt;this&lt;/a&gt;, but done behind the scenes rather than manually opted into.) You’d incur some performance coasts, but with the benefit that you’d have an &lt;em&gt;extremely&lt;/em&gt; ergonomic, practical, ML-descended language quite appropriate for slightly higher-level tasks, and without the radical shift required by switching to a lazily-evaluated, purely functional language like Haskell.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Notably, those tradeoffs are often entirely worth it, and high-performance VMs have astoundingly good characteristics in many ways. The JVM, the CLR, and all the JavaScript VMs have astonishingly excellent performance at this point.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;I &lt;em&gt;might&lt;/em&gt; have gotten slightly carried away in the details here. I’m just a little bit of a nerd.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 24 Jul 2016 15:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-07-24:/2016/rust-and-swift-xviii.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (xvii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xvii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvi.html"&gt;last part&lt;/a&gt;, I talked through the first chunk of the Swift book’s material on initializers. But it’s a long section, and I definitely didn’t cover everything. (I also got a few bits incorrect, and thankfully got great feedback to tighten it up from Twitter, so if you read it right after I posted it, you might skim back through and find the places where I added “&lt;strong&gt;Edit:&lt;/strong&gt; …”)&lt;/p&gt;
&lt;p&gt;Picking up from where we left on, then. Swift has a number of further initializer types, some of which map rather directly to the way initializers work in Rust, and some of which have no &lt;em&gt;direct&lt;/em&gt; analog at all.&lt;/p&gt;
&lt;p&gt;In the first category are the memberwise initializers Swift supplies by default for &lt;em&gt;all&lt;/em&gt; types. The most basic &lt;code&gt;init&lt;/code&gt; method just uses the names of the members of any given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; type in Swift (as in the previous section, I’m going to use the types the Swift book uses for simplicity):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Size {
    var height = 0.0, width = 0.0
}

someSize = Size(height: 1.0, width: 2.0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This actually looks almost exactly like the normal way we construct types in Rust, where the same basic pattern would look like this:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Size {
    height: f64,
    width: f64,
}

some_size = Size { height: 1.0, width: 2.0 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two big differences between the languages here. The first, and most immediately apparent, is syntactical: in this case, Rust doesn’t have a function-call syntax for creating instances, and Swift does. Swift’s syntax is similar to one of the several C++ constructor patterns, or especially to Python’s initializer calls (if we made a point to be explicit about the keyword arguments):&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;class Size:
    height = 0.0
    width = 0.0
    def __init__(height, width):
        self.height = height
        self.width = width

someSize = Size(height=1.0, width=2.0)  # unnecessarily explicit&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second, and more significant, is that the default, memberwise initializer in in Swift is only available &lt;em&gt;if you have not defined any other initializers&lt;/em&gt;. This is very, &lt;em&gt;very&lt;/em&gt; different from Rust, where there’s not really any such thing as a dedicated initializer—just methods. If we defined &lt;code&gt;Size::new&lt;/code&gt; or &lt;code&gt;Size::default&lt;/code&gt; or &lt;code&gt;Size::any_other_funky_initializer&lt;/code&gt;, it wouldn’t make a whit of difference in our ability to define the type this way.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; However, and this is important: because Rust has field-level public vs. private considerations, we cannot always do memberwise initialization of any given &lt;code&gt;struct&lt;/code&gt; type there, either; it is just that the reasons are different. So:&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;mod Shapes {
    struct Rectangle {
        pub height: f64,
        pub width: f64,
        area: f64,
    }
}

fn main() {
    // This won&amp;#39;t work: we haven&amp;#39;t constructed `Size::area`, and as we noted
    // last time, you cannot partially initialize a struct.
    let some_size = Shapes::Size { height: 1.0, width: 2.0 };

    // But neither will this, because `area` isn&amp;#39;t public:
    let some_other_size = Shapes::Size { height: 1.0, width: 2.0, area: 2.0 };
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift lets you refer to &lt;em&gt;other&lt;/em&gt; initializers on the same type (reinforcing that &lt;code&gt;init()&lt;/code&gt; is basically a kind of method, albeit one with some special rules and some special sugar). You do that by calling &lt;code&gt;self.init()&lt;/code&gt;, and—very importantly—you can only call it from within another initializer. No funky reinitializations or anything like that. The net result is that if you have a couple different variations on ways you might initialize a type, you still get the benefit of reusability; you don’t have to reimplement the same initialization function over and over again. Do whatever &lt;em&gt;additional&lt;/em&gt; setup is required in any given instance, and then call a common base initializer.&lt;/p&gt;
&lt;p&gt;With Rust, again, we just have methods, so you &lt;em&gt;could&lt;/em&gt; of course call them wherever you like. However, those methods are distinguished as being type-level or instance-level methods by their signatures, rather than by keyword. If the first argument is (some variant on) &lt;code&gt;self&lt;/code&gt;, it’s an instance method, otherwise, a type-level method. This eliminates any potential confusion around the initializers:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Foo {
    pub a: i32
}

impl Foo {
    pub fn new(a: i32) -&amp;gt; Foo {
        Foo { a: a }
    }

    pub fn bar(&amp;amp;self) {
        // yes:
        let another_foo = Foo::new();
        // no (won&amp;#39;t even compile):
        // let self_foo = self.new();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can (of course!) build up a type through multiple layers of methods which are useful to compose an instance &lt;em&gt;together&lt;/em&gt;. This is what the &lt;a href="http://doc.rust-lang.org/stable/style/ownership/builders.html"&gt;&lt;em&gt;builder pattern&lt;/em&gt;&lt;/a&gt; is all about. There are definitely times when you want to be able to tweak how your initialization plays out, and being able to do that without just passing in some hairy set of options in a special data type is nice.&lt;/p&gt;
&lt;p&gt;One other important qualification on the Swift initializers: those default, memberwise constructors you get for free? You &lt;em&gt;only&lt;/em&gt; get them for free if you don’t define your own initializers. (The closest analogy to this in Rust is that you’ll have issues if you try to both &lt;code&gt;#[derive(Default)]&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;impl Default for Foo&lt;/code&gt;, since both will give you an implementation of &lt;code&gt;Foo::default()&lt;/code&gt;.) You can get around this in Swift by using an &lt;em&gt;extension&lt;/em&gt;. We’ll come back to that in a future post.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; You can also get around it by supplying a parameter-less, body-less initializer in addition to any other initializers you supply, so: &lt;code&gt;init() {}&lt;/code&gt;. (This, frankly, seems like a hack to me. It’s a &lt;em&gt;useful&lt;/em&gt; hack, given the other constraints, but these kinds of things pile up.) Similarly, you can just reimplement member-wise initializers yourself if you have a reason to (say, if you’ve implemented any &lt;em&gt;others&lt;/em&gt; and therefore the defaults no longer exist).&lt;/p&gt;
&lt;p&gt;Now things take a turn into Swift-only territory &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xv.html"&gt;again&lt;/a&gt; as we look at initialization in the context of inheritance. (As mentioned last time: Rust will eventually get inheritance-like behavior, but it’s coming much later, and is not going to be &lt;em&gt;exactly&lt;/em&gt; like classical inheritance. Rust &lt;em&gt;strongly&lt;/em&gt; favors composition over inheritance, where Swift &lt;em&gt;lightly&lt;/em&gt; does but still supports the latter.)&lt;/p&gt;
&lt;p&gt;Swift has two kinds of initializers for class initializers. One, a &lt;em&gt;designated initializer&lt;/em&gt;, is required; a designated initializer must fully initialize every property on a class, and call the superclass initializer (assuming there is one). These can be inherited, but again: they are required.&lt;/p&gt;
&lt;p&gt;There are also &lt;em&gt;convenience initializers&lt;/em&gt;, which provide variant APIs for setting up any given class. These (by definition, given what we said a moment ago) &lt;em&gt;must&lt;/em&gt; call a designated initializer along the way. These could be useful in a lot of different scenarios: setting up variants on the class (as in our temperature examples from before), doing alternate setup depending on initial conditions, etc.&lt;/p&gt;
&lt;p&gt;The only difference between the two syntactically is that &lt;em&gt;convenience&lt;/em&gt; initializers get the &lt;code&gt;convenience&lt;/code&gt; keyword in front of the &lt;code&gt;init&lt;/code&gt; declaration, so:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class Foo {
    var bar : Int
    let quux: String
    // designated
    init(_ bar: Int, _ quux: String) {
        self.bar = bar
        self.quux = quux
    }

    // A convenience method which only takes the string.
    convenience init(_ quux: String) {
        self.init(0, quux)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Swift book gives a set of rules about how these delegated and convenience initializers must behave. The short version is that convenience initializers (eventually) have to call a delegated initializer from &lt;em&gt;their own&lt;/em&gt; class, and designated initializers have to call a designated initializer from the &lt;em&gt;superclass&lt;/em&gt;. This is an implementation detail, though: from the perspective of a &lt;em&gt;user&lt;/em&gt; of the class, it doesn’t matter which initializer is called.&lt;/p&gt;
&lt;p&gt;The other important bit about Swift &lt;em&gt;class&lt;/em&gt; initialization is that it is a two-phase process, which you might think of as “primary initialization” and “customization.” The primary initialization sets up the properties on a class &lt;em&gt;as defined by the class which introduced them&lt;/em&gt;. The following sample should illustrate how it plays out:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class Foo {
    let plainTruth = &amp;quot;Doug Adams was good at what he did.&amp;quot;
    let answer = 0

    init() {
        baz = answer / 2
    }
}

// Bar inherits from Foo
class Bar: Foo {
    let question = &amp;quot;What is the meaning of life, the universe, and everything?&amp;quot;
    let answer = 42

    init() {
        super.init()  // calls Foo.init()
    }

    convenience init(newQuestion question: String, newAnswer answer: Int) {
        self.question = question
        self.answer = answer
        self.init()  // calls own `init()`
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When building a &lt;code&gt;Bar&lt;/code&gt; via either the designated or convenience initializer, &lt;code&gt;plainTruth&lt;/code&gt; and &lt;code&gt;answer&lt;/code&gt; will be set up from &lt;code&gt;Foo&lt;/code&gt;, then &lt;code&gt;question&lt;/code&gt; will be set and &lt;code&gt;answer&lt;/code&gt; will be reassigned in &lt;code&gt;Bar&lt;/code&gt;. If the convenience initializer is used, then it will also override those new defaults with the arguments passed by the caller, before running the designated initializer, which will in turn call the superclass designated initializer. The machinery all makes good sense; I appreciate that there are no weird edge cases in the initialization &lt;em&gt;rules&lt;/em&gt; here. (There &lt;em&gt;are&lt;/em&gt; a bunch of special rules about which initializers get inherited; I’m just going to leave those aside at this point as they’re entirely irrelevant for a comparison between the languages. We’re already pretty far off into the weeds here.)&lt;/p&gt;
&lt;p&gt;Obviously, none of this remotely applies to Rust at all. Not having inheritance &lt;em&gt;does&lt;/em&gt; keep these things simpler (though of course it also means there’s a tool missing from your toolbox which you might miss). And of course, the rules around &lt;em&gt;method resolution&lt;/em&gt; are not totally trivial there, especially now that &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md"&gt;&lt;code&gt;impl&lt;/code&gt; specialization&lt;/a&gt; is making its way &lt;a href="https://github.com/rust-lang/rust/issues/31844"&gt;into the language&lt;/a&gt;. But those don’t strictly speaking, affect &lt;em&gt;initialization&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To account for the case that initialization can fail, Swift lets you definite &lt;em&gt;failable&lt;/em&gt; initializers, written like &lt;code&gt;init?()&lt;/code&gt;. Calling such an initializer produces an optional. You trigger the &lt;code&gt;nil&lt;/code&gt; valued optional state by writing &lt;code&gt;return nil&lt;/code&gt; at some point in the body of the initializer. Quoting from the Swift book, though, “Strictly speaking, initializers do not return a value…. Although you write &lt;code&gt;return nil&lt;/code&gt; tro trigger an initialization failure, you do not use the &lt;code&gt;return&lt;/code&gt; keyword to indicate initialization success.” These failable initializers get the same overall behavior and treatment as normal initializers in terms of delegating to other initializers within the same class, and inheriting them from superclasses.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class Foo {
    let bar: Int
    init?(succeed: Bool) {
        if !succeed {
            return nil
        }

        bar = 42
    }
}

let foo = Foo(true)
print(&amp;quot;\(foo?.bar)&amp;quot;)  // 42
let quux = Foo(false)
Print(&amp;quot;\(foo?.bar)&amp;quot;)  // nil&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is another of the places where Swift’s choice to treat initialization as a special case, not just another kind of method, ends up having some weird side effects. If &lt;code&gt;init&lt;/code&gt; calls were &lt;em&gt;methods&lt;/em&gt;, they would always just be &lt;em&gt;returning the type&lt;/em&gt;. This is exactly what we see in Rust, of course. To be clear, there are reasons why the Swift team made that choice, and many of them we’ve already touched on incidentally; the long and short of it is that inheritance adds some wrinkles. These aren’t &lt;em&gt;constructors&lt;/em&gt;, they’re &lt;em&gt;initializers&lt;/em&gt;. The point, per the Swift book, is “to ensure that &lt;code&gt;self&lt;/code&gt; is fully and correctly initializer by the time that initialization ends.” If you’re familiar with Python, you can think of Swift initializers as being quite analogous to &lt;code&gt;__init__(self)&lt;/code&gt; methods, which similarly are responsible for &lt;em&gt;initialization&lt;/em&gt; but not &lt;em&gt;construction&lt;/em&gt;. When we build a type in Rust, by contrast, we’re doing something much more like calling Python &lt;code&gt;__new__(cls)&lt;/code&gt; methods, which &lt;em&gt;do&lt;/em&gt; construct the type.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Edit:&lt;/strong&gt; interestingly, I’m &lt;a href="https://twitter.com/austinzheng/status/749831726122217473"&gt;informed via Twitter&lt;/a&gt; that Swift initializers can also throw errors. (Thanks, Austin!) The Swift book doesn’t mention this because it hasn’t gotten to error-handling yet (and so, neither have we).&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You can of course write failable constructors in Rust, too:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Foo {
    bar: i64,
};

impl Foo {
    pub fn optional_new(succeed: bool) -&amp;gt; Option&amp;lt;Foo&amp;gt; {
        if succeed { Some(Foo { bar: 0 }) }
        else { None }
    }
}

let foo = Foo::optional_new(true);
match foo {
    Some(f) =&amp;gt; println!(&amp;quot;{}&amp;quot;, f.bar),
    None =&amp;gt; println!(&amp;quot;None&amp;quot;),
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are conditions in both languages where you’d want to do this: places where an initialization &lt;em&gt;can&lt;/em&gt; fail, e.g. trying to open a file, or open a websocket, or anything where the type represents something that is not guaranteed to return a valid result. It makes sense then that in both cases, returning an &lt;em&gt;optional&lt;/em&gt; value is the outcome. Of course, Rust can equally well have an initializer return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Waffles {
    syrup: bool,
    butter: bool,
}

impl Waffles {
    fn properly(all_supplies: bool) -&amp;gt; Result&amp;lt;Waffles, String&amp;gt; {
        if all_supplies {
            Ok(Waffles { syrup: true, butter: true } )
        }
        else {
            let msg = &amp;quot;Who makes waffles this way???&amp;quot;;
            Err(msg.to_string())
        }
    }
}

let waffles = Waffles::properly(true);
match waffles {
    Ok(_) =&amp;gt; println!(&amp;quot;Got some waffles, yeah!&amp;quot;),
    Err(s) =&amp;gt; println!(&amp;quot;{:}&amp;quot;, s),
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;This is simply not the kind of thing you can do in Swift, as far as I can tell. The upside to Swift’s approach is that there is one, standard path. The downside is that if you have a scenario where it makes sense to return an error—i.e., to indicate &lt;em&gt;why&lt;/em&gt; a class failed to initialize and not merely &lt;em&gt;that&lt;/em&gt; it failed—you’re going to have to jump through many more hoops.&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/del&gt; &lt;em&gt;&lt;strong&gt;Edit:&lt;/strong&gt; See above; Swift &lt;em&gt;can&lt;/em&gt; do this. Moreover, the underlying semantics aren’t especially different from Rust’s. However, it does introduce &lt;em&gt;yet more&lt;/em&gt; syntax, rather than just being a normal return. But we’ll talk about that in more detail when we get to error-handling.&lt;/em&gt;&lt;a href="#fn4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; The downside for Rust is that there’s no shorthand; everything is explicit. The upside is the flexibility to do as makes the most sense in a given context, including defining whatever types you need and returning them as you see fit. If you need a type like &lt;code&gt;PartialSuccessPossible&amp;lt;C, P, E&amp;gt;&lt;/code&gt; where &lt;code&gt;C&lt;/code&gt; is a complete type, &lt;code&gt;P&lt;/code&gt; a partial type, and &lt;code&gt;E&lt;/code&gt; an error, you can do that. (I’m not saying that’s a good idea, for the record.) That in turn flows out of building even higher level language features on lower-level features and not introducing new syntax for the most part. Trade-offs!&lt;/p&gt;
&lt;p&gt;And with that, we’re done talking about initializers. This was a &lt;em&gt;huge&lt;/em&gt; topic—but it makes sense. If you don’t nail this down carefully, you’ll be in for a world of hurt later, and that goes whether you’re designing a language or just using it to build things.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvi.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Initialization: another area where Swift has a lot more going on than Rust.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[**Next: Deinitialization: ownership semantics and automatic reference counting][18]&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Also recall that in Rust, we would set the default values either by using the &lt;code&gt;#[derive(Default)]&lt;/code&gt; annotation or by implementing the &lt;code&gt;Default&lt;/code&gt; trait ourselves.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;I’m including a module because of a quirk around the public/private rules: within the same module, &lt;code&gt;area&lt;/code&gt; isn’t hidden and you can actually go ahead and initialize the object.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Depending on how you think about extensions, &lt;em&gt;either&lt;/em&gt; Rust doesn’t have anything quite like them… &lt;em&gt;or&lt;/em&gt; every type implementation is just an extension, because &lt;code&gt;impl&lt;/code&gt; allows you to extend &lt;em&gt;any&lt;/em&gt; data type in basically arbitrary ways (a few caveats of course). More on all of this when we get there.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Here’s a preview of what that would look like, though (fair warning, there’s a lot going on here we haven’t talked about!):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;enum Setup {
    case succeed
    case error
    case fail
}

enum BarSetupError: ErrorProtocol {
    case argh
}

class Bar {
    let blah: Int
    init?(setup: Setup) throws {
        switch setup {
        case .succeed:
            blah = 42
        case .error:
            throw BarSetupError.argh
        case .fail:
            return nil
        }
    }
}

do {
    let bar = try Bar(setup: .succeed)
    print(&amp;quot;\(bar!.blah)&amp;quot;)

    let baz = try Bar(setup: .fail)
    print(&amp;quot;\(baz?.blah)&amp;quot;)

    let quux = try Bar(setup: .error)
    print(&amp;quot;\(quux?.blah)&amp;quot;)
} catch BarSetupError.argh {
    print(&amp;quot;Oh teh noes!&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from this would be &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt;, and &lt;code&gt;Oh teh noes!&lt;/code&gt;.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;&lt;del&gt;It’s conceivable this is actually possible, but nothing in &lt;em&gt;The Swift Programming Language&lt;/em&gt; even hints at it, if so.&lt;/del&gt; See above!&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 30 Jun 2016 23:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-30:/2016/rust-and-swift-xvii.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Vectors and Iterator Access in Rust</title><link>http://www.chriskrycho.com/2016/vectors-and-iterator-access-in-rust.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;In the midst of doing my reading and research for New Rustacean episode 15 (which will be out fairly soon after I post this), I bumped into this little tidbit. It doesn’t fit in the episode, so I thought I’d share it here.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;When you’re dealing with vectors in Rust, a common misstep when working with them via iterators is to &lt;em&gt;move&lt;/em&gt; them when you only to &lt;em&gt;borrow&lt;/em&gt; them. If you write &lt;code&gt;for i in x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is an iterator, you’ll &lt;em&gt;move&lt;/em&gt; the iterator into the looping construct. Instead, you should nearly always write &lt;code&gt;for i in &amp;amp;x&lt;/code&gt; to borrow a reference to the iterator, or &lt;code&gt;for i in &amp;amp;mut x&lt;/code&gt; if you need to get a mutable reference to it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 16 Jun 2016 20:59:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-16:/2016/vectors-and-iterator-access-in-rust.html</guid><category>rust</category></item><item><title>Rust and Swift (xvi)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xvi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class="editorial"&gt;Thanks to ubsan, aatch, and niconii on the &lt;a href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;amp;channel=%23rust"&gt;#rust-lang IRC&lt;/a&gt; for a fascinating discussion of the current status of Rust’s initialization analysis, as well as some very interesting comments on what might be possible to do in the future. Everything actually interesting about Rust in this post comes from the conversation I had with them on the evening of March 13.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The rules various languages have around construction and destruction of objects are &lt;em&gt;extremely&lt;/em&gt; important for programmer safety and ergonomics. I think it’s fair to say that both Swift and rust are actively trying to avoid some of the mistakes made in e.g. C++ which poorly affect both its safety and its ease of use for developers, albeit it in some superficially different ways. Both languages also support defining how types are destroyed, which we’ll come back to in a future discussion.&lt;/p&gt;
&lt;p&gt;The basic aim both Rust and Swift have in this area seems to be the same: avoid &lt;em&gt;partially&lt;/em&gt; initialized objects. (You don’t want partially initialized objects. Ask Objective C developers.)&lt;/p&gt;
&lt;p&gt;Swift does this via its rules around &lt;em&gt;initializers&lt;/em&gt;. Rust does it by requiring that all the values of a type be initialized at its creation. So, for example, the following &lt;em&gt;looks&lt;/em&gt; like it should work, but it doesn’t. You can initialize the variable piecemeal, but you cannot &lt;em&gt;use&lt;/em&gt; it:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;#[derive(Debug)]  // to make it printable.
struct Foo {
    pub a: i32,
    pub b: f64,
}

fn main() {
    // This will compmile, but `foo` will be useless.
    let mut foo: Foo;
    foo.a = 14;
    foo.b = 42.0;

    // This would actually fail to compile. Surprising? A bit!
    // println!(&amp;quot;{:?}&amp;quot;, foo);

    // This will work, though, because it fully constructs the type.
    let foo2 = Foo { a: 14, b: 42.0 };
    println!(&amp;quot;{:?}&amp;quot;, foo);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(The reasons why this is so are fairly complicated. See the addendum at the end for a brief discussion.)&lt;/p&gt;
&lt;p&gt;In any case, this means that especially with more complex data types, providing standard constructor-style methods like &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; is conventional and helpful. (If the type has non-public members, it’s also strictly necessary.)&lt;/p&gt;
&lt;p&gt;Swift has a number of options for initializers, which correspond to things you in most cases can do in Rust, but in a very different way.&lt;/p&gt;
&lt;p&gt;First, Swift allows you to overload the &lt;code&gt;init&lt;/code&gt; method on a type, so that you can have different constructors for different starting conditions. (This is, to my recollection, the first time any kind of overloading has come up so far in the Swift book—but that could just be my memory failing me. Certainly I haven’t referenced it in any previous discussion, though.)&lt;/p&gt;
&lt;p&gt;The example offered by the Swift book is illuminating for the different approaches the languages take, so we’ll run with it. Here’s a class defining a Celsius type in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Celsius {
    let temp: Double

    init(fromFahrenheit f: Double) {
       temp = 1.8 * (f - 32.0)
    }

    init(fromKelvin k: Double) {
        temp = k - 273.15
    }
}

// Create an instance each way
let freezing = Celsius(temp: 0)
let balmy = Celsius(fromFahrenheit: 75.0)
let absoluteZero = Celsius(fromKelvin: 0.0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the internal and external parameter names. This is a common idiom Swift keeps (albeit with some non-trivial modification, and with &lt;a href="%7B%3E%3E%20TODO:%20Swift%203%20naming%20changes%20%3C%3C%7D"&gt;more to come&lt;/a&gt;). More on this below; first, the same basic functionality in Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Celsius {
    temp: f64
}

impl Celsius {
    fn from_fahrenheit(f: f64) -&amp;gt; Celsius {
        Celsius { temp: 1.8 * (f - 32.0) }
    }

    fn from_kelvin(k: f64) -&amp;gt; Celsius {
        Celsius { temp: k - 273.15 }
    }
}

// Create an instance each way
let freezing = Celsius { temp: 0 };
let balmy = Celsius::from_fahrenheit(75.0);
let absoluteZero = Celsius::from_kelvin(0.0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note that there might be other considerations in implementing such types, like using a &lt;code&gt;Temperature&lt;/code&gt; base &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;protocol&lt;/code&gt;, or employing type aliases, but those are for later entries!)&lt;/p&gt;
&lt;p&gt;You can see a point I made about Swift’s initializer syntax back in &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-x.html"&gt;part x&lt;/a&gt;: the way Rust reuses normal struct methods while Swift has the special initializers. Neither is clearly the “winner” here. Rust gets to use existing language machinery, simplifying our mental model a bit by not adding more syntax. On the other hand, the addition of initializer syntax lets Swift use a fairly familiar type construction syntax even for special initializer cases, and a leaves us with a bit less noise in the constructor method. Note, though, that initializers in Swift &lt;em&gt;are&lt;/em&gt; special syntax; they’re not just a special kind of method (as the absence of the &lt;code&gt;func&lt;/code&gt; keyword emphasizes)—unlike Rust, where initializers really are just normal struct or instance methods.&lt;/p&gt;
&lt;p&gt;The Swift book notes this distinction:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In its simplest form, an initializer is like an instance method with no parameters, written using the &lt;code&gt;init&lt;/code&gt; keyword.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The new keyword is the thing I could do without. Perhaps it’s just years of writing Python, but I really prefer it when constructors for types are just sugar and you can therefore reimplement them yourself, provide custom variations, etc. as it suits you. Introducing syntax instead of just picking a standard function to call at object instantiation means you lose that. At the same time, and in Swift’s defense, I’ve only rarely wanted or needed to use those facilities in work in Python. It’s a pragmatic decision—and it makes sense as such; it’s just not where my preference lies. The cost is a bit higher than I’d prefer relative to the gain in convenience.&lt;/p&gt;
&lt;p&gt;Back to the initializers and the issue of overloading: the external parameter names (the &lt;em&gt;first&lt;/em&gt; parameter) is one of the main ways Swift tells apart the initializers. This is necessitated, of course, by the choice of a keyword for the initializer; Rust doesn’t have any &lt;em&gt;need&lt;/em&gt; for this, and since Rust doesn’t have overloading, it also &lt;em&gt;can’t&lt;/em&gt; do this. In Rust, different constructors/initializers will have different names, because they will simply be different methods.&lt;/p&gt;
&lt;p&gt;[&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I’m leaving this here for posterity, but it’s incomplete. See below.&lt;/i&gt;] One other important thing falls out of this: the external parameter names are &lt;em&gt;required&lt;/em&gt; when initializing a type in Swift. Because those parameter names are used to tell apart the constructor, this is not just necessary for the compiler. It’s also an essential element of making the item readable for humans. Imagine if this were &lt;em&gt;not&lt;/em&gt; the case—look again at the &lt;code&gt;Celsius&lt;/code&gt; example:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Celsius {
    let temp: Double

    init(fromFahrenheit f: Double) {
       temp = 1.8 * (f - 32.0)
    }

    init(fromKelvin k: Double) {
        temp = k - 273.15
    }
}

// Create an instance each way
let freezing = Celsius(0)
let balmy = Celsius(75.0)  // our old fromFahrenheit example
let absoluteZero = Celsius(0.0)  // our old &amp;quot;fromKelvin example&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We as humans would have no idea what the constructors are supposed to do, and really at this point there would &lt;em&gt;necessarily&lt;/em&gt; just be one constructor unless the later options took elements of another &lt;em&gt;type&lt;/em&gt;. That would be fairly similar to how overloading works in C++, Java, or C&lt;sup&gt;♯&lt;/sup&gt;, and while method overloading in those langauges is very &lt;em&gt;powerful&lt;/em&gt;, it can also make it incredibly difficult to figure out exactly what method is being called. That includes when the constructor is being called. Take a look at the &lt;em&gt;long&lt;/em&gt; list of &lt;a href="https://msdn.microsoft.com/en-us/library/system.datetime(v=vs.110)"&gt;C&lt;sup&gt;♯&lt;/sup&gt; &lt;code&gt;DateTime&lt;/code&gt; constructors&lt;/a&gt;, for example: you have to either have this memorized, have the documentation open, or be able simply to infer from context what is going on.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Given&lt;/em&gt; the choice of a keyword to mark initializers, then, Swift’s rule about external parameter name usage wherever there is more than one initializer is quite sensible.&lt;/p&gt;
&lt;p&gt;[&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; several readers, most notably including &lt;a href="https://twitter.com/jckarter/status/740763363626586112"&gt;Joe Groff&lt;/a&gt;, who works on Swift for Apple, pointed out that Swift &lt;em&gt;does&lt;/em&gt; support overloading, including in &lt;code&gt;init()&lt;/code&gt; calls, and uses types to distinguish them. Moreover, you can leave off the label for the parameter. My initial summary was simply incorrect. I think this is a function of my not having finished the chapter yet.&lt;/i&gt;]&lt;/p&gt;
&lt;p&gt;Second, both languages support supplying default values for a constructed type. Swift does this via default values defined at the site of the property definition itself, or simply set directly from within an initializer:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Kelvin {
    var temp: Double = 0.0  // zero kinetic energy!!!
    init () {
        temp = 305.0  // Change of plans: maybe just freezing is better
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you can not supply default values directly on a property, but you can define any number of custom constructors:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Kelvin {
    temp: f64,
}

impl Kelvin {
    fn abs_zero() -&amp;gt; Kelvin {
        Kelvin { temp: 0.0 }
    }

    fn freezing() -&amp;gt; Kelvin {
        Kelvin { temp: 305.0 }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could of course shorten each of those two one line, so:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn abs_zero() -&amp;gt; Kelvin { Kelvin { temp: 0.0 } }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Rust is definitely a little noisier, and that is the downside of this tack. The upside is that these are just functions like any other. This is, in short, &lt;em&gt;exactly&lt;/em&gt; the usual trade off we see in the languages.&lt;/p&gt;
&lt;p&gt;Rust also has the &lt;code&gt;Default&lt;/code&gt; trait and the &lt;code&gt;#[derive(default)]&lt;/code&gt; attribute for getting some basic defaults for a given value. You can either define a &lt;code&gt;Default&lt;/code&gt; implementation yourself, or let Rust automatically do so if the underlying types have &lt;code&gt;Default&lt;/code&gt; implemented:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Kelvin {
    temp: f64,
}

// Do it ourselves
impl Default for Kelvin {
    fn default() -&amp;gt; Kelvin {
        Kelvin { temp: 305.0 }
    }
}

// Let Rust do it for us: calling `Celsius::default()` will get us a default
// temp of 0.0, since that&amp;#39;s what `f64::default()` returns.
#[derive(default)]
struct Celsius {
    temp: f64,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn’t get you quite the same thing as Swift’s initializer values. It requires you to be slightly more explicit, but the tradeoff is that you also get a bit more control and flexibility.&lt;/p&gt;
&lt;p&gt;There’s actually a lot more to say about initializers—there are &lt;em&gt;many&lt;/em&gt; more pages in the Swift book about them—but this is already about 1,700 words long, and I’ve been slowly chipping away at it since March (!), so I’m going to split this chapter of the Swift book into multiple posts. More to come shortly!&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Inheritance: a Swiftian specialty (for now).&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2016/rust-and-swift-xvii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; More on initializers!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;section id="addendum-no-late-initialization-in-rust" class="level2"&gt;
&lt;h2&gt;Addendum: No Late Initialization in Rust&lt;/h2&gt;
&lt;p&gt;Returning to the first Rust example—&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;#[derive(Debug)]  // to make it printable.
struct Foo {
    pub a: i32,
    pub b: f64,
}

fn main() {
    // This will compmile, but `foo` will be useless.
    let mut foo: Foo;
    foo.a = 14;
    foo.b = 42.0;

    // This would actually fail to compile. Surprising? A bit!
    // println!(&amp;quot;{:?}&amp;quot;, foo);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can’t do anything with that data for a few reasons (most of this discussion coming from ubsan, aatch, and niconii on the &lt;a href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;amp;channel=%23rust"&gt;#rust-lang IRC&lt;/a&gt; back in March):&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Rust lets you “move” data out of a struct on a per-field basis. (Rust’s concept of “ownership” and “borrowing” is something we haven’t discussed a lot so far in this series; my &lt;a href="http://www.newrustacean.com/show_notes/e002/index.html" title="New Rustacean e002: Something borrowed, something... moved?"&gt;podcast episode&lt;/a&gt; about it is probably a good starting point.) The main takeaway here is that you could return &lt;code&gt;foo.a&lt;/code&gt; distinctly from returning &lt;code&gt;foo&lt;/code&gt;, and doing so would hand that data over while running the &lt;code&gt;foo&lt;/code&gt; destructor mechanism. Likewise, you could pass &lt;code&gt;foo.b&lt;/code&gt; to the function created by the &lt;code&gt;println!&lt;/code&gt; macro&lt;/li&gt;
&lt;li&gt;Rust allows you to re-initialize moved variables. I haven’t dug enough to have an idea of what that would look like in practice.&lt;/li&gt;
&lt;li&gt;Rust treats uninitialized variables the same as moved-from variables. This seems to be closely related to reason #2. The same “I’m not sure how to elaborate” qualification applies here.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I’ll see if I can add some further comments on (2) and (3) as I hit the later points in the Swift initialization chapter.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 07 Jun 2016 23:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-07:/2016/rust-and-swift-xvi.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and C++ function definitions</title><link>http://www.chriskrycho.com/2016/03-1801.html</link><description>&lt;p&gt;I just put my finger on one of the (many) reasons Rust reads better than C++: the visual consistency of its function definitions. Compare—&lt;/p&gt;
&lt;p&gt;Rust has:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn foo() -&amp;gt; i32 { /* implementation */ }
fn bar() -&amp;gt; f32 { /* implementation */ }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++ has:&lt;/p&gt;
&lt;pre class="cpp"&gt;&lt;code&gt;int foo() { /* implementation */ }
double bar() { /* implementation */ }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That consistency adds up over many lines of code. There are many other such choices; the net effect is that Rust is &lt;em&gt;much&lt;/em&gt; more pleasant to read than C++.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Note: I’m aware that C++11 added the &lt;code&gt;auto foo() -&amp;gt; &amp;lt;type&amp;gt;&lt;/code&gt; syntax. But this actually &lt;em&gt;worsens&lt;/em&gt; the problem. A totally new codebase which uses that form exclusively (which may not always be possible, because the semantics aren’t the same) would have roughly the same visual consistency as Rust &lt;em&gt;in that particular category&lt;/em&gt;. (Plenty of others would still be a mess.) But the vast majority of C++ codebases are &lt;em&gt;not&lt;/em&gt; totally new. Adding the form means your codebase is more likely to look this this:&lt;/p&gt;
&lt;pre class="cpp"&gt;&lt;code&gt;int foo() { /* implementation */ }
auto quux() -&amp;gt; uint32_t { /* implementation */ }
double bar() { /* implementation */ }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is, for the record, &lt;em&gt;more&lt;/em&gt; visual inconsistency—not less!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 03 Jun 2016 18:01:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-03:/2016/03-1801.html</guid><category>programming languages</category><category>rust</category><category>cplusplus</category></item><item><title>Ember.js: "Introducing Subteams"</title><link>http://www.chriskrycho.com/2016/emberjs-introducing-subteams.html</link><description>&lt;p&gt;In which one tech I really like (&lt;a href="http://emberjs.com"&gt;Ember.js&lt;/a&gt;) steals a great idea from another tech I really like (&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 24 May 2016 19:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-05-24:/2016/emberjs-introducing-subteams.html</guid><category>links</category><category>programming languages</category><category>emberjs</category><category>rust</category></item><item><title>Rust and Swift (xv)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The next chapter in the Swift book focuses on &lt;em&gt;inheritance&lt;/em&gt;, a concept which does not yet exist in Rust.&lt;/p&gt;
&lt;p&gt;Swift embraces classical inheritance for &lt;code&gt;class&lt;/code&gt; data types. As noted &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;previously&lt;/a&gt;, Rust’s &lt;code&gt;struct&lt;/code&gt; covers much of the ground covered by Swift’s &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; types together (value and reference types, etc.). However, what Swift’s &lt;code&gt;class&lt;/code&gt; types bring to the table is inheritance-based (and not just composition-based) extension of types.&lt;/p&gt;
&lt;p&gt;This is a bit of an interesting point: it is an area where, &lt;em&gt;as of today&lt;/em&gt;, Swift can do something that is flat impossible in Rust—a rarity.&lt;/p&gt;
&lt;p&gt;However, the &lt;em&gt;status quo&lt;/em&gt; will be changing sometime in the next year or so, as there is a &lt;a href="https://github.com/rust-lang/rfcs/pull/1210"&gt;Rust RFC&lt;/a&gt; which has been accepted and is in the process of being implemented which paves the way for inheritance. (Discussions are &lt;a href="https://aturon.github.io/blog/2015/09/18/reuse/"&gt;ongoing&lt;/a&gt; as to the best way to implement it for Rust. Classical inheritance with vtables as in Swift is probably &lt;em&gt;not&lt;/em&gt; going to be the approach.)&lt;/p&gt;
&lt;p&gt;The reason Rust’s core team chose to proceed without inheritance for the 1.0 release of the language last May is simple: at a philosophical level, they prefer (as in general most developers increasingly acknowledge that we should all prefer) composition over inheritance. &lt;em&gt;Prefer&lt;/em&gt;, not &lt;em&gt;universally choose&lt;/em&gt;, because there are situations in which inheritance is the correct choice. But there is a reason that programming with interfaces rather than via sub-classing is a “best practice” for many scenarios in languages like Java or C#.&lt;/p&gt;
&lt;p&gt;Rust’s &lt;code&gt;trait&lt;/code&gt; system gives you &lt;em&gt;composition&lt;/em&gt; in some remarkably powerful ways, allowing you to do things that in C++, for example, have to be accomplished via a combination of inheritance and overloading. Swift, likewise, supplies a &lt;code&gt;protocol&lt;/code&gt; system and allows extensions to define further behavior on top of existing data structures. From what I’ve gathered, those approaches are preferred over inheritance in Swift for the same reason Rust shipped 1.0 without it!&lt;/p&gt;
&lt;p&gt;But Swift does have inheritance, so it’s worth seeing how it works.&lt;/p&gt;
&lt;p&gt;First, any &lt;code&gt;class&lt;/code&gt; which doesn’t declare a parent from which to inherit is a base class. This is an important difference from, say, Python, where all classes inherit from &lt;code&gt;Object&lt;/code&gt; (leaving aside custom metaclasses).&lt;/p&gt;
&lt;p&gt;The syntax choices Swift has made around sub-class declarations are sensible and readable: &lt;code&gt;class SubClass: ParentClass&lt;/code&gt; is eminently readable and doesn’t have any obvious points of overlap with other elements in the language.&lt;/p&gt;
&lt;p&gt;Indeed, &lt;em&gt;many&lt;/em&gt; of the choices made around classes are quite sensible. Overrides, for example, are made explicit via the &lt;code&gt;override&lt;/code&gt; keyword. While I’ve sometimes poked fun at Swift’s tendency to add keywords everywhere, this seems like a reasonable place to have one, and it’s nice that overrides are explicit rather than implicit. The same is true of the use of &lt;code&gt;super&lt;/code&gt; to refer to the superclass. I’m not sure of the implementation details, but &lt;code&gt;super&lt;/code&gt; &lt;em&gt;appears&lt;/em&gt; to act as just a special/reserved name for an object: all the syntax around it is normal object instance syntax, which is as it should be.&lt;/p&gt;
&lt;p&gt;The limitations around overriding properties all make sense. You can override a read- or write-only parent property as both readable and writable, but you can’t override a readable or writable property &lt;em&gt;not&lt;/em&gt; to be readable or writable respectively. Presumably this is because the method lookup for properties always checks up the inheritance chain for getters or setters, so if one is present, you can’t just get rid of it. (You could of course override with a no-op function that spews a warning or some such, but that would pretty clearly be an abuse of the parent API. There might be times you would do that with a third-party library parent class, but in your own code it should be avoided: it indicates a problem in your API design that you need to address instead.)&lt;/p&gt;
&lt;p&gt;Finally, we have Swift’s &lt;code&gt;final&lt;/code&gt; keyword—and yes, pun intended. It marks whatever block-level item it is attached to—whether class, method, or property—as non-overridable. Attempts to override an item marked final are compile-time failures. (The same kind of thing exists in Java and C#.) In and of itself, this isn’t especially interesting. It is interesting to ponder whether you should make classes subclass-able or not in your API design. There has been &lt;a href="http://mjtsai.com/blog/2015/12/21/swift-proposal-for-default-final/"&gt;an active debate&lt;/a&gt;, in fact, whether classes in Swift should become final &lt;em&gt;by default&lt;/em&gt; in Swift 3.0, rather than open by default. The debate centers on the danger of unintended consequences of overriding, which ultimately takes us back around to the preference for composition, of course.&lt;/p&gt;
&lt;p&gt;All of this, among other things, raises the very interesting question of what this will look like in Rust when, eventually, we get inheritance there. After all, we know it will be quite different in some ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It presumably won’t involve a distinct data type constructor, &lt;em&gt;a la&lt;/em&gt; Swift’s distinction between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;: there may be syntactic sugar involved, and there will definitely be new functionality present, but it will certainly be built on the existing language features as well. There’s a good chance it will basically &lt;em&gt;look&lt;/em&gt; like just a special case of &lt;code&gt;impl SomeTrait for SomeStruct&lt;/code&gt;, which would fit very well with the ways Rust solves so many other problems.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust doesn’t have many of the things which Swift takes care to special-case for overriding with &lt;code&gt;final&lt;/code&gt;, but it will need to address that case for inherited methods and data in some way. (The proposal linked above uses a distinction between &lt;code&gt;default&lt;/code&gt; and blanket implementations for trait specialization to pull this off; if those words don’t mean anything to you, don’t worry: I’ve read that post and RFC half a dozen times before I got a really solid handle on all the pieces involved.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It will be a relative latecomer to the language, rather than baked in from the start, and therefore will likely seem a secondary way of solving problems, especially at first. (This is, I think, both intentional and good.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Indexing and subscripts, or: traits vs. keywords again.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvi.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Initialization: another area where Swift has a lot more going on than Rust.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Mar 2016 14:45:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-12:/2016/rust-and-swift-xv.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (xiv)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xiv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Rust and Swift both support defining subscript access to a given data type, like &lt;code&gt;SomeType[accessedByIndex]&lt;/code&gt;. Unsurprisingly, given &lt;a href="/rust-and-swift.html"&gt;everything we’ve seen so far&lt;/a&gt;, Rust does this with traits, and Swift with a keyword.&lt;/p&gt;
&lt;p&gt;In Rust, you can define subscript-style access to a type by implementing the &lt;code&gt;Index&lt;/code&gt; and/or &lt;code&gt;IndexMut&lt;/code&gt; traits, which allow &lt;em&gt;indexing&lt;/em&gt; into a given location in a kind of type. The implementation simply requires one function, which is called when you use the &lt;code&gt;[]&lt;/code&gt; operator. That function, &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;index_mut&lt;/code&gt;, implements how to do the lookup for the specific type. The &lt;code&gt;impl&lt;/code&gt; block indicates not only that &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;IndexMut&lt;/code&gt; is being implemented, but also the type of the &lt;em&gt;key&lt;/em&gt; used: &lt;code&gt;impl Index&amp;lt;Bar&amp;gt; for Foo { ... }&lt;/code&gt;, where access would look like &lt;code&gt;a_foo[some_bar]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The two kinds of traits and corresponding methods define the behavior for immutable and mutable data type, as their name suggest.&lt;/p&gt;
&lt;p&gt;Since the trait is defined generically, you can implement whatever kinds of accessors you like to the same underlying data structure, including generics accessors with trait bounds.&lt;/p&gt;
&lt;p&gt;It is perhaps telling that in Rust you just find these traits in the general &lt;code&gt;std::ops&lt;/code&gt; module, where all the core language operations and associated operators are defined. Rust doesn’t do “operator overloading” so much as it simply provides operators as one more class of trait potentially applicable to your type. (The family resemblance to Haskell’s type classes and similar in other languages is obvious.)&lt;/p&gt;
&lt;p&gt;In Swift, you define indexing behavior with the &lt;code&gt;subscript&lt;/code&gt; keyword. Subscripts act very similarly to Swift’s &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;computed properties&lt;/a&gt;. They can be made read- or write-only by including or excluding &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; function definitions, just like computed properties.&lt;/p&gt;
&lt;p&gt;The behavior is in fact so closely aligned with the computed property syntax and behavior that I initially wondered if it wasn’t just a special case. It is not (though I’m sure much of the parsing machinery can be shared). As the designation of &lt;code&gt;subscript&lt;/code&gt; as a keyword strongly implies, and unlike in Rust, this is a separate language construct, not building on existing language machinery.&lt;/p&gt;
&lt;p&gt;Swift, like Rust, allows you to define arbitrary accessors. However, since the behavior relies on the &lt;code&gt;subscript&lt;/code&gt; construct rather than generics and protocols (Swift’s equivalent to Rust’s traits), you define different kinds of accessors via multiple &lt;code&gt;subscript&lt;/code&gt; blocks. (Presumably these could take generic arguments, but I haven’t tested that to be sure.)&lt;/p&gt;
&lt;p&gt;Both languages proceed to use these as ways of accessing types as makes sense—e.g. for not only arrays or vectors, but also dictionaries in Swift and &lt;code&gt;HashMap&lt;/code&gt; types in Rust.&lt;/p&gt;
&lt;p&gt;Since you can define the behavior yourself, you can also use complex types as keys. The languages approach this a bit differently, though. In Rust, if you wanted a compound key, you would need to define either a simple container &lt;code&gt;struct&lt;/code&gt; or use a tuple as the argument. In Swift, because it uses the same basic syntax as computed properties, you can just define as many method arguments, of whatever type, as you want.&lt;/p&gt;
&lt;p&gt;Takeaway: Rust uses traits; Swift uses a keyword. We probably could have guessed that when we started, at this point!&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Methods, instance and otherwise.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Inheritance: a Swiftian specialty (for now).&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Mar 2016 21:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-10:/2016/rust-and-swift-xiv.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Static Site Generators and Podcasting</title><link>http://www.chriskrycho.com/2016/static-site-generators-and-podcasting.html</link><description>&lt;p&gt;Presently, I publish both &lt;a href="http://www.winningslowly.org/"&gt;Winning Slowly&lt;/a&gt; and &lt;a href="http://www.newrustacean.com/"&gt;New Rustacean&lt;/a&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; using what is admittedly a bit of a quirky approach. It works well for me, and I think it’s worth documenting for other nerdy types out there, but if you’re just getting going with podcasting and you’re looking for the easy way to do it, let me warn you: &lt;em&gt;this isn’t it&lt;/em&gt;. Something like &lt;a href="https://soundcloud.com/for/podcasting"&gt;SoundCloud&lt;/a&gt; and a blog for show notes, or &lt;a href="https://wordpress.org"&gt;WordPress&lt;/a&gt; with &lt;a href="https://wordpress.org/plugins/powerpress/"&gt;Blubrry PowerPress&lt;/a&gt; is what you want instead. This approach works &lt;em&gt;extremely&lt;/em&gt; well for statically-generated sites, however, and I imagine a few people out there might find it useful.&lt;/p&gt;
&lt;section id="the-short-version" class="level2"&gt;
&lt;h2&gt;The short version&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generate the feeds with &lt;a href="http://reinventedsoftware.com/feeder/"&gt;Feeder&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Generate the site statically with something else (and it &lt;em&gt;really&lt;/em&gt; doesn’t matter what).&lt;/li&gt;
&lt;li&gt;Copy the feed into the generated site.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="the-long-version" class="level2"&gt;
&lt;h2&gt;The long version&lt;/h2&gt;
&lt;p&gt;I generate the sites themselves with &lt;a href="http://docs.getpelican.com/en/3.6.3/"&gt;Pelican&lt;/a&gt; and &lt;a href="http://www.newrustacean.com/show_notes/e001/index.html"&gt;&lt;code&gt;cargo doc&lt;/code&gt;&lt;/a&gt;, respectively. I was already comfortable with Pelican because it’s what I use to generate &lt;em&gt;this&lt;/em&gt; site (with a few &lt;a href="https://github.com/chriskrycho/chriskrycho.com/blob/master/pelicanconf.py"&gt;tweaks&lt;/a&gt; to the standard configuration, especially using &lt;a href="http://pandoc.org/"&gt;Pandoc&lt;/a&gt; rather than the Python Markdown implementation), so I ran with it for building the Winning Slowly site, and it has worked quite well for building the site itself. It just gets built locally and deployed via &lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, it does not have built-in support for generating &lt;a href="https://en.wikipedia.org/wiki/RSS_enclosure"&gt;podcast feeds&lt;/a&gt;, even just the general case with enclosures. &lt;a href="https://itunespartner.apple.com/en/podcasts/overview"&gt;iTunes podcast support&lt;/a&gt; would have taken a lot of work to add.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Instead, I chose to build the RSS feed semi-manually. &lt;em&gt;Semi&lt;/em&gt;-manually, because doing it totally manually is a recipe for making mistakes. XML is many things, but “easy to write correctly by hand” is not one of them. I use &lt;a href="http://reinventedsoftware.com/feeder/"&gt;Feeder&lt;/a&gt; to manage the feeds, and &lt;em&gt;it&lt;/em&gt; makes sure that the enclosure and iTunes elements are set correctly.&lt;/p&gt;
&lt;p&gt;The biggest upside to this is that I can use Pelican without modification to how it generates feeds (apart from optionally turning them off entirely). It just &lt;a href="https://github.com/WinningSlowly/winningslowly.org/blob/master/pelicanconf.py#L99"&gt;copies&lt;/a&gt; the feed I generate to the output file during its normal build process. As suggested above, I also &lt;em&gt;don’t&lt;/em&gt; generate the other feeds which Pelican supports, as we have no need for them; we only care about the podcast feed.&lt;/p&gt;
&lt;p&gt;This process works equally well, with very little modification, for New Rustacean. In that case, I’m generating the content by running Rust’s documentation tool, &lt;code&gt;cargo doc&lt;/code&gt;&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; to render the “API docs” which serve as show notes. Notice the family resemblance between &lt;a href="http://www.newrustacean.com/show_notes/"&gt;my “show notes”&lt;/a&gt; and, say, the &lt;a href="http://sgrif.github.io/diesel/diesel/index.html"&gt;Diesel docs&lt;/a&gt;, which are both generated the same way. This is &lt;em&gt;not&lt;/em&gt; a normal way of building a podcast website; you can hear me explain why I did it this way in &lt;a href="http://www.newrustacean.com/show_notes/e001/index.html"&gt;New Rustacean e001: Document all the things!&lt;/a&gt; In any case, I just take the show note-relevant parts of the documentation and put it in Feeder, generate the feed, and &lt;a href="https://github.com/chriskrycho/newrustacean.com/blob/master/Makefile#L32"&gt;copy that as part of the build process&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That’s it!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;And, incidentally, &lt;a href="http://www.sap-py.com"&gt;Sap.py&lt;/a&gt; and my &lt;a href="http://www.chriskrycho.com/sermons.xml"&gt;sermons&lt;/a&gt; feed.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;If I stick with Pelican long-term, I might look into adding it anyway, but honestly, I don’t love Pelican. The reasons have little to do with Pelican for itself, and a lot more to do with my particular and somewhat peculiar needs. That’s a post for another day. In any case, I’m likelier to use another generator—even one I write myself!—than to do the work to make Pelican do what I want.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Technically, Rust’s documentation tool is &lt;code&gt;rustdoc&lt;/code&gt;, which &lt;code&gt;cargo doc&lt;/code&gt; wraps around. I never actually use &lt;code&gt;rustdoc&lt;/code&gt; directly, though.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 28 Feb 2016 12:50:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-02-28:/2016/static-site-generators-and-podcasting.html</guid><category>software development</category><category>podcasting</category><category>python</category><category>rust</category></item><item><title>Rust and Swift (xiii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xiii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Rust and Swift both have methods which are attached to given data types. However, whereas Rust takes its notion of separation of data and functions rather strictly, Swift implements them on the relevant data structures (classes, structs, or enums) directly. In other words, the implementation of a given type’s methods is within the body of the type definition itself in swift, whereas in Rust it is in an &lt;code&gt;impl&lt;/code&gt; block, usually but not always immediately adjacent in the code.&lt;/p&gt;
&lt;p&gt;This goes to one of the philosophical differences between the two languages. As we’ve discussed often in the series, Rust reuses a smaller set of concepts—language-level primitives—to build up its functionality. So methods on a type and methods for a trait on a type are basically the same thing in Rust; they’re defined in almost exactly the same way (the latter includes &lt;code&gt;for SomeTrait&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; expression). In Swift, a method is defined differently from a protocol definition, which we’ll get to in the future. The point is simply this: the two take distinct approaches to the relationship between a given type definition and the implementations of any functions which may be attached to it.&lt;/p&gt;
&lt;p&gt;Another important difference: access to other members of a given data type from within a method is &lt;em&gt;explicit&lt;/em&gt; in Rust and &lt;em&gt;implicit&lt;/em&gt; in Swift. In Rust, the first parameter to an instance method is always &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;&amp;amp;self&lt;/code&gt; (or a mutable version of either of course), much as in Python. This explicitness distinction is by now exactly what we expect from the two languages.&lt;/p&gt;
&lt;p&gt;Both use dot notation, in line with most other languages with a C-like syntax, for method calls, e.g. &lt;code&gt;instance.method()&lt;/code&gt; in Swift and &lt;code&gt;instance.method()&lt;/code&gt; in Rust. The latter is just syntactical sugar for &lt;code&gt;T::method(&amp;amp;instance)&lt;/code&gt; or &lt;code&gt;T::method(instance)&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the type of the instance (depending on whether the item is being borrowed or moved). Given its implicit knowledge of/access to instance-local data, and the distinctive behavior of Swift methods (see below), I don’t &lt;em&gt;think&lt;/em&gt; the same is, or even could be, true of Swift.&lt;/p&gt;
&lt;p&gt;All of Swift’s &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;other behaviors around functions&lt;/a&gt;—internal and external names, and all the distinctions that go with those—are equally applicable to methods. Similarly, with the sole change that the first parameter is always the instance being acted on, a Rust methods follow all the same rules as ordinary Rust functions (which is why you can call the struct or enum method with an instance parameter as in the example above).&lt;/p&gt;
&lt;p&gt;Swift does &lt;em&gt;have&lt;/em&gt; a &lt;code&gt;self&lt;/code&gt;—it is, of course, implicit. It’s useful at times for disambiguation—basically, when a parameter name shadows an instance name. This will look familiar to people coming from Ruby.&lt;/p&gt;
&lt;p&gt;The strong distinction Swift makes &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;between reference and value types&lt;/a&gt; comes into play on methods, as you might expect, as does its approach to mutability. Methods which change the values in value types (&lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; instances) have to be declared &lt;code&gt;mutating func&lt;/code&gt;. This kind of explicit-ness is good. As we discussed in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;Part 10&lt;/a&gt;, Rust approaches this entire problem differently: types are not value or reference types; they are either mutable and passed mutably (including as &lt;code&gt;mut self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or they are not. If an instance is mutable and passed mutably, a method is free to act on instance data. And in fact both languages require that the instance in question not be immutable. In fact, everything we said in Part 10 about both languages applies here, just with the addendum that private properties are available to methods.&lt;/p&gt;
&lt;p&gt;The distinction, you’ll note, is in where the indication that there’s a mutation happens. Swift has a special keyword combination (&lt;code&gt;mutating func&lt;/code&gt;) for this. With Rust, it’s the same as every other function which mutates an argument. This makes Rust slightly more verbose, but it also means that in cases like this, the existing language tooling is perfectly capable of handling what has to be a special syntactical case in Swift.&lt;/p&gt;
&lt;p&gt;Both Swift and Rust let you out-and-out change the instance by assigning to &lt;code&gt;self&lt;/code&gt;, albeit in fairly different ways. In Swift, you’d write a mutating method which updates the instance proper like this:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x = 0.0, y = 0.0
    mutating func changeSelf(x: Double, y: Double) {
        self = Point(x: x, y: y)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you’d need to explicitly pass a mutable reference and dereference it. (If you tried to pass &lt;code&gt;mut self&lt;/code&gt; instead of &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, it would fail unless you returned the newly created object and assigned it outside.) Note that while the full implementation here is a couple lines longer, because of the data-vs.-method separation discussed earlier, the implementation of the method itself is roughly the same length.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;pub struct Point {
    pub x: f64,
    pub y: f64,
}

impl Point {
    pub fn change_self(&amp;amp;mut self, x: i32, y: i32) {
        *self = Point { x: x, y: y };
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that though you &lt;em&gt;can&lt;/em&gt; do this, I’m not sure it’s particularly Rustic. My own instinct would be to get a &lt;em&gt;new&lt;/em&gt; &lt;code&gt;Point&lt;/code&gt; rather than mutate an existing one, in either language, and let the other be cleaned up “behind the scenes” as it were (with automatic memory management in Swift or the compiler’s automatic destruction of the type in Rust)—purer functions being my preference these days.&lt;/p&gt;
&lt;p&gt;You can do this with &lt;code&gt;enum&lt;/code&gt; types as well, which the Swift book illustrates with a three-state switch which updates the value type passed to a new value when calling its &lt;code&gt;next()&lt;/code&gt; method. You can do the same in Rust, with the same reference/dereference approach as above.&lt;/p&gt;
&lt;p&gt;Here’s a three-state switch in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;enum ThreeState {
    case First, Second, Third
    mutating func next() {
        switch self {
        case First:
            self = Second
        case Second:
            self = Third
        case Third
            self = First
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the same in Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum ThreeState { First, Second, Third }
impl ThreeState {
    pub fn next(&amp;amp;mut self) {
        match *self {
            ThreeState::First =&amp;gt; *self = ThreeState::Second,
            ThreeState::Second =&amp;gt; *self = ThreeState::Third,
            ThreeState::Third =&amp;gt; *self = ThreeState::First,
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both languages also have what Swift calls “type methods”, and which you might think of as “static class methods” coming from a language like Java or C♯. In Swift, you define them by adding the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; keywords to the &lt;code&gt;func&lt;/code&gt; definition. The &lt;code&gt;class func&lt;/code&gt; keyword combo is only applicable in &lt;code&gt;class&lt;/code&gt; bodies, and indicates that sub-classes may override the method definition.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Bar {
    static func quux() { print(&amp;quot;Seriously, what&amp;#39;s a `quux`?&amp;quot;) }
}

func main() {
    Bar.quux()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you simply drop &lt;code&gt;self&lt;/code&gt; as a first parameter and call it with &lt;code&gt;::&lt;/code&gt; syntax instead of &lt;code&gt;.&lt;/code&gt; syntax:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Bar;
impl Bar {
    pub fn quux() { println!(&amp;quot;Seriously, what&amp;#39;s a `quux`?&amp;quot;); }
}

fn main() {
    Bar::quux();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, Rust chooses to use existing language machinery; Swift uses new (combinations of) keywords.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Properties: type and instance, stored and computed.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Indexing and subscripts, or: traits vs. keywords again.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 28 Feb 2016 11:15:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-02-28:/2016/rust-and-swift-xiii.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (xii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class="editorial"&gt;A note on publication: I had this drafted in early January and simply forgot to publish it. Whoops!&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;As noted in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;my discussion of the product types in Rust and Swift&lt;/a&gt;, Swift distinguishes between classes and structs, with the former being reference types and the latter being value types. All structs are value types in Rust. (That you can wrap them in a pointer for heap-allocation with one of the smart pointer types, e.g. &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;, doesn’t change this fundamental reality.) This underlying difference gives rise to one the big difference between Swift classes and Rust structs: a constant &lt;code&gt;class&lt;/code&gt; instance in Swift can still have its fields mutated; not so with a Rust &lt;code&gt;struct&lt;/code&gt; instance. But also not so with a &lt;em&gt;Swift&lt;/em&gt; &lt;code&gt;struct&lt;/code&gt; instance, as it turns out! There isn’t a straightforward way to do this with &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in Rust; you &lt;em&gt;could&lt;/em&gt; do it with something like an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift’s &lt;code&gt;lazy&lt;/code&gt; keyword, and associated delayed initialization of properties has, as far as I know, no equivalent whatsoever in Rust. And while I can see the utility in principle, I’m hard-pressed to think of any time in my working experience where the behavior would actually be useful. Rather than having &lt;code&gt;lazy&lt;/code&gt; properties, I would be far more inclined to separate the behavior which should be initialized at a later time into its own data structure, and supplying it via &lt;em&gt;inversion of control&lt;/em&gt; if it is necessary for an actions taken by other data structures. (This seems—at first blush at least—to be a way of supporting the un- or partially-initialized data types possible in Objective C?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has computed properties, a concept familiar to Python developers (and relatively recently introduced in JavaScript). These can e quite handy, as they let you define a property to be accessed like any other (&lt;code&gt;someInstance.theProperty&lt;/code&gt;) while being defined with functions which compute the value dynamically. A common, trivial example: if you defined a &lt;code&gt;Person&lt;/code&gt; with &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; members, you could define a computed property, &lt;code&gt;fullName&lt;/code&gt;, which was built using the existing values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust doesn’t have computed properties at all. This is because of its design decision to deeply separate &lt;em&gt;data&lt;/em&gt; from &lt;em&gt;behavior&lt;/em&gt;, essentially stealing a page from more pure-functional languages (Haskell etc.). This is (one reason) why you don’t define the implementation of a &lt;code&gt;struct&lt;/code&gt; method in the same block as the members of the struct. See an excellent explanation &lt;a href="https://www.reddit.com/r/rust/comments/2uvfic/why_doesnt_rust_have_properti%20es/cocmunq"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It’s also closely related the way Rust favors composition over inheritance (by making the latter impossible, at least for now!). By separating &lt;code&gt;impl&lt;/code&gt; from &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;enum&lt;/code&gt;, Rust makes it not only straightforward but &lt;em&gt;normal&lt;/em&gt; to define new behavior for a given item separately from the data description. This, combined with the use of traits (like Swift’s protocols) as the primary way of sharing behavior between objects, means that you don’t have to worry about conforming to some interface when you define a given type; it can always&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; be defined later, even by entirely other modules or even other crates (packages).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In any case, the result is that it’s not at all Rustic&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; to have something like getters or setters or computed properties. It makes sense to have them in Swift, though, which has a more traditionally object-oriented type system (though with some neat additions in the form of its &lt;code&gt;protocol&lt;/code&gt; type classes, which are analogous to Rust’s &lt;code&gt;trait&lt;/code&gt;s—but we’ll come to those in a future post). This is a wash: it’s just a function of the slightly different approaches taken in object design in the two systems. If you have a Swift-style type system, you should have computed properties. If you have a Rust-like type system, you shouldn’t.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’m shocked—utterly shocked!—to find that Swift provides a default &lt;code&gt;newValue&lt;/code&gt; argument for setters for computed properties, and shorthand for defining read-only properties. By which I mean: I find this kind of thing entirely unsurprising at this point in Swift, but I don’t like it any better. Making so much implicit just rubs me the wrong way. Once you know the language, it’s fine of course: you’ll recognize all the patterns. It just seems, in an interesting way, to add cognitive load rather than reducing it. That may just be me, though!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Interestingly, Swift also allows you to set watchers on given properties—functions called with the new or the removed value whenever the value of the computed property is updated or touched for any reason. It has two of these built in: &lt;code&gt;willSet&lt;/code&gt; and &lt;code&gt;didSet&lt;/code&gt;. You can override these to get custom behavior when a normal property is about to change. (You can of course just implement the desired behavior yourself in the &lt;code&gt;set&lt;/code&gt; method for a computed property.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Since Rust doesn’t have properties, it doesn’t have anything analogous. I can’t think of a particularly straightforward way to implement it, either, though you might be able do some chicanery with a trait. Of course you can always define a setter method which takes a value and optional callbacks for actions to take before and after setting the value; the thing that’s nice in Swift is that it gives you these as built-in capabilities within the language itself. (Now I’m wondering if or how you could implement an &lt;code&gt;Observable&lt;/code&gt; trait, though! Might have to play with that idea more later.) It’s worth remembering , in any case, that Rust doesn’t have these &lt;em&gt;because it doesn’t have properties&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Curiously, Swift provides the same functionality for “global” and “local” variables in a given context. In both cases, this is suggestive of the underlying object model for both modules and functions in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now I’m curious what the representation of a module is in Swift; is it part of the general object system in some way?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This likewise gets me asking: what &lt;em&gt;is&lt;/em&gt; a module in Rust? It’s a block item, clearly, and accordingly defines a scope (as do functions, if and match expressions, and so on). It’s &lt;em&gt;not&lt;/em&gt; a compilation unit (as it is in C or C++). What other machinery is attached to it?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both of these questions can be answered by reading the source code for the languages (&lt;a href="https://github.com/rust-lang/rust"&gt;Rust&lt;/a&gt;, &lt;a href="https://github.com/apple/swift"&gt;Swift&lt;/a&gt;), of course. Putting that on my to-do list.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift also has &lt;em&gt;type properties&lt;/em&gt;: values common to all instances of a given type. These are directly analogous to &lt;em&gt;class properties&lt;/em&gt; (or &lt;em&gt;class attributes&lt;/em&gt;) in Python or prototype properties in JavaScript.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust doesn’t have anything like this to my knowledge. You could accomplish something similar using a module-level variable with a &lt;code&gt;'static&lt;/code&gt; lifetime,&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; much as you could in C—but that wouldn’t be an item on the type itself, of course.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;static&lt;/code&gt; declaration of item in Swift suggests what a possible implementation might look like in Rust: defining a member like &lt;code&gt;a_static_long: 'static i64&lt;/code&gt;. There might be some interesting challenges around that, though; I don’t know enough to comment meaningfully. At the least, it seems like it would be an odd fit with the rest of the memory management approach Rust takes, and it would make it a bit harder to reason correctly about the behavior of data in a given type. (There are certainly issues there around mutability guarantees and lifetime checking!)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because of the differences in underlying approach to data types and implementation, this is one of the areas where the superficially (and sometimes actually) similar languages diverge &lt;em&gt;a lot&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xi.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Hopes for the next generation of systems programming.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Methods, instance and otherwise.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;leaving aside details about &lt;code&gt;trait&lt;/code&gt; specialization &lt;a href="https://github.com/aturon/rfcs/blob/impl-specialization/text/0000-impl-specialization.md"&gt;still being hashed out&lt;/a&gt; in Rust&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;This is now my preferred term for “idiomatic Rust”—directly analogous to “Pythonic,” but with the upside of being an actual word, and one with pleasantly evocative connotations to boot.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;There’s nothing analogous to Rust’s concept of explicit lifetimes in Swift, as far as I can tell. The &lt;code&gt;static&lt;/code&gt; keyword in Swift, like that in C, Objective-C, and C++, is &lt;em&gt;sort of&lt;/em&gt; like Rust’s &lt;code&gt;'static&lt;/code&gt; lifetime specifically, for variables at least—but Rust’s lifetime is substantially more sophisticated and complex than that analogy might suggest.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 27 Feb 2016 22:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-02-27:/2016/rust-and-swift-xii.html</guid><category>listicles</category><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>“I Don't Know When I'd Use That”</title><link>http://www.chriskrycho.com/2016/i-dont-know-when-id-use-that.html</link><description>&lt;p&gt;I was reading an interesting Stack Overflow &lt;a href="http://stackoverflow.com/questions/21170493/when-are-higher-kinded-types-useful"&gt;discussion&lt;/a&gt; of the value of &lt;a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala"&gt;higher-kinded types&lt;/a&gt; (hereafter &lt;abbr&gt;HKTs&lt;/abbr&gt;), and noted someone repeatedly commenting, “But when would you use this in a &lt;em&gt;real app&lt;/em&gt;?” To put it the way another &lt;a href="https://m4rw3r.github.io/rust-and-monad-trait/"&gt;blog post&lt;/a&gt; about &lt;abbr&gt;HKTs&lt;/abbr&gt; (in Rust), they are “a feature people do not really know what to do with.”&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: I’m sympathetic to that desire for concrete examples. I’m interested in these kinds of things not primarily for their intellectual value but for their pragmatic value (though I don’t think those two are as distinct as many people do). I’d &lt;em&gt;also&lt;/em&gt; love to see some more real-world examples in those discussions. All too often, the discussions of types in Haskell end up being quite abstract and academic—no surprise, given the language’s origin. But I’m also aware that quite often it’s difficult to see how a given kind of abstraction is useful without jumping into a language which has that abstraction available and &lt;em&gt;using&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;People often get turned off by Haskell (and other similarly high-abstraction languages like Scala) because of challenging terms like &lt;em&gt;monad&lt;/em&gt;, &lt;em&gt;applicative&lt;/em&gt;, &lt;em&gt;functor&lt;/em&gt;, and so on. And again: I get that. To grok Haskell, you need to wrap your head around a lot of &lt;em&gt;math&lt;/em&gt; ideas—mainly various properties of &lt;em&gt;sets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But I remember feeling the same way six years ago when I started playing with JavaScript and jQuery and every tutorial out there simply assumed existing familiarity and comfort with functions as arguments or return values. Coming from the world of Fortran and C, my head ached for weeks as I tried to make sense of what I was seeing. Even when I finally got it, &lt;em&gt;I didn’t like it&lt;/em&gt;. Over the last several years, though, I’ve become increasingly comfortable and even reliant on closures, composition of functions to transform data, and so on as I worked regularly in Python and JavaScript.&lt;/p&gt;
&lt;p&gt;That experience has taught me that my current inability to see the utility of a given abstraction means little about the abstraction. It’s primarily an indicator of my own inexperience.&lt;/p&gt;
&lt;p&gt;To the question of the utility &lt;abbr&gt;HKTs&lt;/abbr&gt; in general—in Haskell, Rust, or somewhere else—I don’t have the knowledge myself (yet) to supply a good answer. Heck, I can’t even &lt;em&gt;explain&lt;/em&gt; them very well. (&lt;a href="http://adriaanm.github.io/research/2010/10/06/new-in-scala-2.8-type-constructor-inference/"&gt;Other people can, though!&lt;/a&gt;) But I can say that reading &lt;a href="https://gumroad.com/l/maybe-haskell"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt; showed me clearly that such things can be very useful. Even if I am not yet comfortable using that tool, I see how learning to use it would be profitable in the long-term. And like any good tool, even if you don’t need it every day… when you want it, you &lt;em&gt;really&lt;/em&gt; want it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 17 Jan 2016 10:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-01-17:/2016/i-dont-know-when-id-use-that.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>haskell</category></item><item><title>Women in Rust</title><link>http://www.chriskrycho.com/2016/women-in-rust.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I posted these bullet points last night as a series of tweets on my &lt;a href="https://www.twitter.com/chriskrycho"&gt;main account&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686007510147309568"&gt;∞ January 9, 2016 21:11&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A thing I’d really, really like to see change—this is from the &lt;a href="http://www.newrustacean.com/"&gt;New Rustacean&lt;/a&gt; Twitter data. Unsurprising, but awful:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="//cdn.chriskrycho.com/images/new-rustacean-followers.png" alt="@newrustacean Twitter follower gender data" /&gt;&lt;figcaption&gt;&lt;a href="https://www.twitter.com/newrustacean"&gt;@newrustacean&lt;/a&gt; Twitter follower gender data&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686007729371148289"&gt;∞ January 9, 2016 21:12&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Takeaway: the &lt;a href="https://www.twitter.com/rustlang"&gt;@rustlang&lt;/a&gt; community has many strengths, but like every tech community, we need to improve here—a lot.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686008145752272896"&gt;∞ January 9, 2016 21:14&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Standing offer: if you’re a female &lt;a href="https://www.twitter.com/rustlang"&gt;@rustlang&lt;/a&gt; dev, I’d &lt;em&gt;love&lt;/em&gt; to feature your experience learning Rust on the show.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://twitter.com/chriskrycho/status/686008527937245185"&gt;∞ January 9, 2016, 21:15&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I’ll be doing some interview &lt;a href="https://www.twitter.com/newrustacean"&gt;@newrustacean&lt;/a&gt; episodes soon-ish—I want as many female voices in the mix as possible.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 10 Jan 2016 15:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-01-10:/2016/women-in-rust.html</guid><category>podcasting</category><category>tweetstorm</category><category>rust</category></item><item><title>Rust and Swift (xi)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I’ve still been (slowly) working through the Swift book and comparing Swift and Rust; I have another draft started which I’ll hopefully finish this week. And I still find the comparison deeply profitable. The two languages continue to evolve in interesting ways, and the comparison is all the more interesting &lt;a href="https://github.com/apple/swift"&gt;now that Swift is open-source&lt;/a&gt; and its future &lt;a href="https://github.com/apple/swift-evolution"&gt;open for community input&lt;/a&gt; (just as &lt;a href="https://github.com/rust-lang/rfcs"&gt;Rust is&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Something I’ve been thinking about for several months, and which the &lt;a href="https://overcast.fm/+CdSzsTIY/1:16:42"&gt;brief discussion of Swift, Go, and Rust&lt;/a&gt; at the end of the latest &lt;a href="http://atp.fm/episodes/151"&gt;Accidental Tech Podcast&lt;/a&gt; brought back to my mind, is the question of what the next generation of systems-level programming language should be. And my answer is: there shouldn’t be &lt;em&gt;just one&lt;/em&gt;. The best possible thing for the space, in many ways, is for there to be a healthy diversity of options and lots of competition in the space. We don’t want to have &lt;em&gt;ten&lt;/em&gt; different systems programming languages to deal with, I think—but three or four or five would be &lt;em&gt;much&lt;/em&gt; preferable to having one or two (closely related) as we have in the decades of C and C++ dominance.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: both languages (and perhaps especially C) do many things exceptionally well. For all that they are (justly) maligned for some of their problems, the longevity of both C and C++ has a great deal to do with how well they fit the problem domain, and how much they’ve empowered developers to accomplish within that space (which is very, &lt;em&gt;very&lt;/em&gt; large).&lt;/p&gt;
&lt;p&gt;The problem, though, at least as I see it, is that the existence of only two really serious systems programming languages for the last several decades has led a lot of developers to think that C and C++‘s ways of solving problems are the &lt;em&gt;only&lt;/em&gt; way to solve problems. The languages we use shape the way we think about possible solutions, and when a given language doesn’t recognize entire classes of different approaches, that deeply limits developers’ ability to tackle certain issues. (See also the interesting CppCast &lt;a href="http://cppcast.com/2015/10/andrei-alexandrescu/"&gt;interview with D’s Andrei Alexandrescu&lt;/a&gt; in which he makes similar points.)&lt;/p&gt;
&lt;p&gt;The most obvious thing missing from both is the ability to do truly functional-style programming. C of course is also lacking classes and thus is much more difficult to use for any sort of object-oriented programming.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Neither has anything remotely like Rust’s traits or Swift’s extensions; C++ has only gotten lambdas recently.&lt;/p&gt;
&lt;p&gt;All of this comes out to mean that the set of &lt;em&gt;tools&lt;/em&gt; available to systems programmer has necessarily been missing any number of things available in languages outside that context. In some cases, this may be a necessary consequence of the kinds of programming being done: when you need totally deterministic memory and compiler behavior, dynamic typing and a non-trivial runtime are simply not options. But in many cases, they are simply a function of the history of the languages’ development and history. Being an ALGOL descendant, and especially a C descendant, means there are some fundamental choices about the language which will differ from those made in a language descended from ML.&lt;/p&gt;
&lt;p&gt;All of which is to say: C and C++ have been really useful tools in many ways, but having &lt;em&gt;only&lt;/em&gt; C and C++ available for serious systems programming work over the last decades has left many developers blind to or simply unaware of the real advantages other paradigms might offer them.&lt;/p&gt;
&lt;p&gt;So going forward, I don’t want there to be &lt;em&gt;a winner&lt;/em&gt; in the systems programming space. I’d rather see D, Rust, Swift, Go, and maybe even a few other contenders all stay strong—finding their own niches and continually pushing each other and learning from each other. That will give us a space in which different languages are free to try out different approaches to the same problems, without being tied to the specific constraints faced by other languages. Built-in greenthreading? Go! Hindley-Milner types, memory safety, and zero runtime? Rust! Something in beween, highly expressive and with different type systems and tradeoffs around memory management, etc.? Swift, or D!&lt;/p&gt;
&lt;p&gt;Having a robust, thriving set of competitors in the market will be good for the languages themselves. But it will also be good for developers. It will take off some of the blinders that come from a single language (or a pair of very closely related languages) dominating the ecosystem. It will make it likelier that people will be more familiar with different programming paradigms. And that can only be a good thing, as far as I’m concerned.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Properties: type and instance, stored and computed.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;It is of course entirely possible to do non-classical OOP; the point is that C entirely lacks &lt;em&gt;language-level&lt;/em&gt; facilities for OOP, inheritance, etc.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 10 Jan 2016 10:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-01-10:/2016/rust-and-swift-xi.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming-languages</category></item><item><title>Thoughts on 2015 (and 2016)</title><link>http://www.chriskrycho.com/2015/thoughts-on-2015-and-2016.html</link><description>&lt;p&gt;As we come to the end of the year, I have been reflecting on the things I set out to do this year, and on my hopes for the coming year. At the start of the year, I posted a number of goals for my “public” life this year, and I also wrote up a number of personal goals for myself. Goals are well and good, but if I do not evaluate how I did on them, and think about areas I succeeded and areas I failed, and on how I might do better in the future, those goals will not make much difference. (&lt;em&gt;Much&lt;/em&gt; difference, I say, because I have long found that even just having goals makes a difference in how I approach the year.)&lt;/p&gt;
&lt;p&gt;At the start of the year, I posted a list of &lt;a href="http://www.chriskrycho.com/2015/public-ish-plans.html"&gt;“Public-ish Plans”&lt;/a&gt;. My self-evaluation on those counts isn’t amazing. The Winning Slowly goals, I managed: we have separate pages for each season, and we recorded two more seasons—each one better than those before. Hosting things on Digital Ocean and migrating my wife’s blogs off of Blogger and WordPress, not so much (read: not at all, though I did &lt;em&gt;start&lt;/em&gt; writing a Ghost theme for her current WordPress site… and haven’t touched it in at least six months.) I wrote some music this year, but not three minutes worth—you &lt;em&gt;can&lt;/em&gt; hear all 37 seconds of it &lt;a href="https://soundcloud.com/chriskrycho"&gt;on SoundCloud&lt;/a&gt;. I wrote &lt;a href="http://www.chriskrycho.com/poetry/"&gt;poetry&lt;/a&gt;; I managed to average about one poem a month starting in March. I wrote a few essays, but nothing close to one per month. I posted a whopping two book reviews (out of the six I hoped for), and both of those were written for school. I managed to add a picture to the About page, but I didn’t even come close to blogging about the family on a monthly basis.&lt;/p&gt;
&lt;p&gt;In sum: about 50/50 on those goals.&lt;/p&gt;
&lt;p&gt;That said, I managed quite a few other things &lt;em&gt;not&lt;/em&gt; on that list this year. I started learning Rust, and started &lt;a href="http://newrustacean.com/"&gt;a podcast about it&lt;/a&gt; which is easily the most successful online endeavor I’ve ever undertaken, with a good 500 regular listeners. (That’s a small crowd on the internet, but massively more than any writing I’ve done, and actually larger than Winning Slowly’s current audience.) I have basically carried home a major transition effort for my main software development client, and helped them bring a new developer up to speed. I landed a new software development job, doing things I’m much more passionate about, which I’ll be starting in mid-January. I ran a triathlon (and placed third in my age group), and I set another personal record in the half-marathon I ran this fall.&lt;/p&gt;
&lt;p&gt;One of the lessons I take away from this last year, then, is that it’s important to set goals, but it’s also important to let those goals change over time. Some of those goals are still things I’d like to accomplish—like migrating us to DigitalOcean, and getting Jaimie’s sites off of Blogger especially. Another (fairly obvious one) is prioritizing. I had a lot of major goals for last year, and in retrospect, I think I had &lt;em&gt;too many&lt;/em&gt;. It’s hard to keep all of those in sight of the course of the year, especially with other professional and scholastic demands to meet (themselves often good in their own right).&lt;/p&gt;
&lt;p&gt;With all of these things in mind, I’m planning to approach 2016 a little differently. I haven’t made formal goals yet, but I have come up with the basic outline I want to use going forward.&lt;/p&gt;
&lt;p&gt;First, I am going to set a single goal in each of five major categories in my life:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;spiritual:&lt;/strong&gt; everything in my walk with God, including my own personal devotions, my involvement in the life of the church, and my “ministry” actions in general&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;family:&lt;/strong&gt; both quantity and quality time spent with my wife and my quickly-growing-up little girls&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;personal:&lt;/strong&gt; podcasting, blogging, and writing for &lt;a href="http://mereorthodoxy.com/author/chris-krycho/"&gt;other outlets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;professional:&lt;/strong&gt; working in my new job and as a consultant, and carrying on toward the conclusion of my M. Div.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;health/fitness:&lt;/strong&gt; continuing to stay healthy, including eating well and continuing to stay fit by running and doing triathlon work&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that this list is intentionally &lt;em&gt;unordered&lt;/em&gt;.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; My spiritual life remains the highest priority, because if my walk with God falters, everything else will go amok. Beyond that, however, the amount of time and effort I invest in each category not only can but should vary over time. Family will broadly remain in the second of those slots, though there may be days or the occasional week where one of the other concerns &lt;em&gt;very temporarily&lt;/em&gt; takes a higher priority. The others will adjust relative to each other as need be: there will be times when school requires more, and so my own writing gets less time, and there will be times when I have more flexibility and so am able to devote more to those personal interests, and so on. The goal here is not the mythical notion of “balance” but rather faithfulness, which has some superficial similarities but ultimately &lt;a href="http://www.chriskrycho.com/2015/faithfulness.html"&gt;plays out rather differently&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I’m hoping, in light of those goals, to set annual, monthly, and daily goals in each of those categories. The daily goals should help me move toward the monthly goals, and the monthly goals toward the yearly goals. I only get to set one goal in each of those categories for each tier: at five goals, that’s already plenty! I hope that evaluating each day will help me be more focused and faithful, and that situating daily and monthly goals each in light of larger goals will help me actually accomplish those larger goals. We’ll see how it goes, of course. I’ll be back in a week or so with whatever goals I decide to make public in those categories, and again in a year with an evaluation rather like this one.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Under the covers, it’s literally an HTML unordered list.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 26 Dec 2015 13:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-12-26:/2015/thoughts-on-2015-and-2016.html</guid><category>family</category><category>rust</category><category>podcasting</category></item><item><title>Rust and Swift (x)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-x.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift and Rust both have “product types” as well as the &lt;code&gt;enum&lt;/code&gt; “sum types.” In Rust, these are &lt;code&gt;struct&lt;/code&gt; types; Swift splits them into &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Product types” will be much more familiar to programmers coming from a C-like background, or indeed most object-oriented programming languages: these are the same basic kind of thing as classes, structs, and objects in other languages. These include &lt;em&gt;all&lt;/em&gt; the value types which compose them, unlike sum types—&lt;code&gt;enum&lt;/code&gt;—which have &lt;em&gt;only one&lt;/em&gt; of the value types which compose them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Right off the bat, I note the Swift book’s somewhat amusing reticence to call out C and C-descended languages:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike other programming languages, Swift does not require you to create separate interface and implementation files for custom classes and structures.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because there’s such a long list of languages not directly descended from C which do that, right? 😉&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust differs not only from Swift but from every other modern language I have used in not having a constructor &lt;em&gt;syntax&lt;/em&gt; for its instantiations. Whereas C++ has &lt;code&gt;new NameOfType()&lt;/code&gt; and Python and Swift both have &lt;code&gt;NameOfType()&lt;/code&gt;, “constructors” for Rust &lt;code&gt;struct&lt;/code&gt;s are just functions which return an instance constructed using literal syntax, by convention &lt;code&gt;NameOfType::new()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let’s make a &lt;code&gt;struct&lt;/code&gt; defining a location in a plane, you might do this in Swift (leaving aside initializer values; I’ll come back to those later). These definitions look &lt;em&gt;very&lt;/em&gt; similar. Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x: Double var y: Double
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Point {
    x: f64,
    y: f64,
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Creating the types looks a little different, though. Here’s a constructor in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;let point = Point(x: 0, y: 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the two ways we could construct the type in Rust, a literal constructor (fairly similar to constructing &lt;code&gt;dict&lt;/code&gt; literals in Python or object literals in JavaScript):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let point = Point { x: 0.0, y: 0.0 };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or a constructor method, &lt;code&gt;new&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// &amp;quot;Constructor&amp;quot;
impl Point {
    fn new(x: f64, y: f64) -&amp;gt; Point {
        Point { x: x, y: y }
    }
}

let another_point = Point::new(0, 0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observe: these two things in Rust are the same under the covers (though if &lt;code&gt;Point&lt;/code&gt;s had non-public internals, they would be non-trivially different: you couldn’t construct it with its private members externally). As usual, Rust opts to keep the language relatively small in these core areas. Given the plethora of ways you can construct something in e.g. C++, I count that a big win.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another difference: Swift has &lt;em&gt;syntax&lt;/em&gt; for default values; Rust uses a &lt;code&gt;trait&lt;/code&gt; instead. In Swift, you simply supply the default value in the definition of the &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x = 0.0 var y = 0.0
}

let point = Point()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you use &lt;code&gt;std::default::Default&lt;/code&gt;, which provides a standard value for a given type, and for simple types can be supplied by the compiler even for custom types. Here is the equivalent Rust code:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::default::Default;

#[derive(Default)]
struct Point {
    x: f64,
    y: f64,
}

let point = Point::default();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is reasonable enough, but we can also supply our own custom implementation if we so desire:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::default::Default;

struct Point {
    x: f64,
    y: f64,
}

impl Default for Point {
    fn default() -&amp;gt; Point {
        Point { x: 0.0, y: 0.0 }
    }
}

let point = Point::default();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, this is trivial for this type, but you can see how it could be useful for more complex types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The tradeoffs here are our usual suspects: Rust’s re-use of an existing concept/tool within the language (&lt;code&gt;trait&lt;/code&gt;) vs. Swift’s use of syntax. Rust is slightly more explicit, making it obvious that a default value is being created—but Swift is perfectly readable and the syntax is consistent with many other languages, and it &lt;em&gt;is&lt;/em&gt; shorter.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages use &lt;code&gt;.&lt;/code&gt; syntax for member access. Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;println(&amp;quot;The point is: \(point.x), \(point.y)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;println!(&amp;quot;The point is {:}, {:}&amp;quot;, point.x, point.y);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift lets you define items &lt;em&gt;within&lt;/em&gt; a struct as mutable or constant. So you can create a variable struct instance, with some of its items immutable:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct PointOnZAxis {
    var x: Double var y: Double let z = 0.0
}

var point = PointOnZAxis(x: 4.0, 5.0)
point.x = 5.0 point.y = 6.0
// This wouldn&amp;#39;t compile, though:
// point.z = 1.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is pretty handy for a lot of object-oriented programming approaches.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And Rust doesn’t have it. There are ways to accomplish the same thing; this isn’t the end of the world. Still, it’s an interesting omission, and it’s very much by design. Rust &lt;em&gt;used&lt;/em&gt; to have this feature, and dropped it—and for good reason. Say you had a mutable field in a mutable struct, and then an immutable reference to it; should the mutable field be mutable, or immutable, with that reference?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Rusty way to do this is to differentiate between public and private data. The above examples don’t make the public/private distinction particularly clear, because they assume everything is within the same module. However, many times, this will not be the case.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;mod geometry {
    pub struct Point {
        x: f64,
        pub y: f64,
    }

    impl Point {
        pub fn new() -&amp;gt; Point {
            Point { x: 0.0, y: 0.0 }
        }

        pub fn set_x(&amp;amp;mut self, x: f64) {
            self.x = x;
        }
    }
}

fn main() {
    // Won&amp;#39;t compile: the `x` field is private.
    // let mut p = geometry::Point { x: 0.0, y: 0.0 };

    // Will compile: the `new` method is public.
    let mut p = geometry::Point::new();

    // Won&amp;#39;t compile: `x` isn&amp;#39;t public.
    // p.x = 4.0;
    // You can use the setter, though:
    p.set_x(4.0);

    // You *can* set `y` directly, though, because it&amp;#39;s public.
    p.y = 14.0;

    // You can&amp;#39;t set fields either way if the instance is immutable.
    let q = geometry::Point::new();

    // This fails because `set_x` requires a mutable reference, but `q` is
    // immutable.
    // q.set_x(4.0);

    // This fails because `q` is immutable, and so all its fields are, too.
    // q.y = 14.0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This is an interesting way of handling this issue. Rust takes the fairly standard use of information hiding (one of the basic principles of most object-oriented programming techniques) and combines it with the language’s normal mutability rules to make it so that the mutability of any given instance data is quite clear: all public members are just as mutable as the struct. If a member isn’t potentially publicly mutable, it isn’t publicly accessible. I really like this, though it took some mental readjustment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There’s one other difference here, and it’s actually one of the areas Swift and Rust diverge substantially. Rust has &lt;code&gt;struct&lt;/code&gt; for all product types; Swift splits them into &lt;code&gt;struct&lt;/code&gt; types and &lt;code&gt;class&lt;/code&gt; types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift &lt;code&gt;class&lt;/code&gt;es have inheritance; there is presently &lt;em&gt;no&lt;/em&gt; inheritance in Rust.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Additionally, whereas Rust determines whether to use pass-by-reference or-value depending on details of the type (whether it implements the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt;) and expected arguments to a function, Swift makes that distinction between &lt;code&gt;class&lt;/code&gt; (pass-by-reference) and &lt;code&gt;struct&lt;/code&gt; (pass-by-value) types. Quirky.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Not bad, &lt;em&gt;per se&lt;/em&gt;. But quirky.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I recently bumped into some discussion of data types in C♯ along with C, C++, and Java (&lt;a href="http://joeduffyblog.com/2015/12/19/safe-native-code/"&gt;here&lt;/a&gt;) and discovered that Swift is stealing this idea from C♯, which &lt;a href="https://msdn.microsoft.com/en-us/library/0taef578.aspx"&gt;makes the same copy/reference distinction&lt;/a&gt; between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One consequence of this: in Rust, you’re always rather explicit about whether you’re accessing things by value vs. by reference. Not so in Swift; you have to remember whether the item you’re touching is a &lt;code&gt;struct&lt;/code&gt; type or a &lt;code&gt;class&lt;/code&gt; type, so that you can &lt;em&gt;remember&lt;/em&gt; whether a given assignment or function call results in a reference or a copy. This is necessary because Swift doesn’t let you make that explicit (trying to hide the memory management from you). And it’s not alone in that, of course; many other high-level languages obscure that for convenience but still require you to think about it in certain circumstances. I’ve been bitten in the past by the value/reference distinction when thinking through the behavior of Python objects, for example, so that’s not a critique of Swift. Moreover, having the distinction between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; types does let you be &lt;em&gt;more&lt;/em&gt; explicit than you might in e.g. Python about how given data will be handled.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I won’t lie, though: I like Rust’s approach better. (Shocking, I know.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All that nice initializer syntax for Swift &lt;code&gt;struct&lt;/code&gt; types is absent for its &lt;code&gt;class&lt;/code&gt; types, which seems strange to me.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift supplies some syntax for object identity, since it’s useful to know not only whether two &lt;code&gt;class&lt;/code&gt; instances have the same data, but are in fact the same instance. You can use &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt;. Handy enough. To get at this kind of equivalence in Rust, you have to use raw pointers (which are often but not always &lt;code&gt;unsafe&lt;/code&gt;; you can do this specific comparison &lt;em&gt;without&lt;/em&gt; being &lt;code&gt;unsafe&lt;/code&gt;, for example) to check whether the memory addresses are the same.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ix.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xi.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Hopes for the next generation of systems programming.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Dec 2015 11:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-12-06:/2015/rust-and-swift-x.html</guid><category>listicles</category><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (ix)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ix.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Right off the bat when looking at the definitions for Swift’s and Rust’s &lt;code&gt;enum&lt;/code&gt; types, a difference pops out: the use of the keyword &lt;code&gt;case&lt;/code&gt; to introduce an enum member in Swift. In one sense, this overloads that keyword, but in another sense it’s fine: pattern matching and enums go hand in hand, so the use in both cases is fairly natural. Rust doesn’t have any special syntax to designate the elements of an enum; they’re just separated by commas.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I am not at all shocked to find that Swift has a variant syntax for its unit type case declarations, where a single &lt;code&gt;case&lt;/code&gt; keyword precedes a list of comma-separated cases defined on a single line. (At this point, I would be more surprised &lt;em&gt;not&lt;/em&gt; to find a variant syntax for something in Swift!)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Something truly wonderful about both a Rust and Swift: enumerated types aren’t just wrappers around integer values. They’re real types of their own. This is powerful.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust and Swift also share in having enumerated types that can hold values. The most prominent of these so far in the Swift book are optionals, the &lt;code&gt;Optional&lt;/code&gt; enum type, corresponding very closely to Rust’s &lt;code&gt;Option&lt;/code&gt; type. Having had these for a bit in playing with Rust, and having gotten familiar with the utility of types like these while reading &lt;a href="https://gumroad.com/l/maybe-haskell"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt;—a delightful book which introduces Haskell and functional programming using Haskell’s &lt;code&gt;Maybe&lt;/code&gt; type—I now miss them profoundly in languages which don’t have them. (Which is to say: every language I use on a regular basis professionally: C, C++, Python, JavaScript, etc.).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift’s enum types don’t have integer values &lt;em&gt;by default&lt;/em&gt;—but they can have them if you define a type and assign a value to each enum case at the definition. These “raw values” are distinct from the “associated values” noted just above. I expect these exist primarily for ease of interoperation with Objective-C.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;Rust doesn’t have anything like this, at least that I can think of. The main place it would be useful would be for foreign function interfaces (as in Swift), and this is one of several such gaps in Rust,&lt;/del&gt; along with the lack of a straightforward way to map to C’s &lt;code&gt;union&lt;/code&gt; types. &lt;del&gt;There are trade offs in terms of adding the functionality to the language, though, as it substantially increases the complexity of what an enum value can be, I think.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; This was incorrect. From the &lt;a href="https://doc.rust-lang.org/reference.html"&gt;Rust Reference&lt;/a&gt; section on &lt;a href="https://doc.rust-lang.org/reference.html#enumerations"&gt;Enumerations&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Enums have a discriminant. You can assign them explicitly:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum Foo {
    Bar = 123,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a discriminant isn’t assigned, they start at zero, and add one for each variant, in order.&lt;/p&gt;
&lt;p&gt;You can cast an enum to get this value:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let x = Foo::Bar as u32; // x is now 123u32&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This only works as long as none of the variants have data attached. If it were &lt;code&gt;Bar(i32)&lt;/code&gt;, this is disallowed.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Initialization of Swift’s raw-valued enum type is quite similar, and pleasantly so, to Python’s initialization of enums.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In a surprising change from the usual, Swift’s syntax for binding variable names when pattern matching against an enum is &lt;em&gt;more&lt;/em&gt; verbose than Rust’s, requiring the use of either a leading &lt;code&gt;let&lt;/code&gt; on the &lt;code&gt;case&lt;/code&gt; statement if all the elements are of the same type, or a &lt;code&gt;let&lt;/code&gt; in front of each element otherwise:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;var matchedValue: String
let matchee = 3.14159
switch matchee {
case 3.14159:
    matchedValue = &amp;quot;pi&amp;quot;
case _:
    matchedValue = &amp;quot;not pi&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, a matched pattern can simply bind its value directly:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let matchee = 3.14159;
let matchedValue = match matchee {
    3.14159 =&amp;gt; &amp;quot;pi&amp;quot;.to_string(),
    _ =&amp;gt; &amp;quot;not pi&amp;quot;.to_string()
};&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has the ability to do recursive enumerations with its &lt;code&gt;indirect&lt;/code&gt; type. This is conceptually interesting, but off the top of my head I can’t think of a time when this would have been useful at any point since I started programming seven and a half years ago. The book’s example of a recursive function a aliasing arithmetic expressions is fine, but not particularly illuminating to me. I suspect, though, that it might make more sense if I were more familiar with pure functional programming paradigms.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; a friend &lt;a href="https://alpha.app.net/jws/post/65990633"&gt;points out&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Indirect enums are useful for recursive types in general. There are a lot of these: Lists, trees, and streams are the big ones that come to mind.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All those same lines: Rust does &lt;em&gt;not&lt;/em&gt; have the ability to have recursive enumerations at present (or recursive &lt;code&gt;struct&lt;/code&gt; types, for that matter), at least without heap-allocating with &lt;code&gt;Box&lt;/code&gt; along the way. You &lt;em&gt;can&lt;/em&gt; construct such a type, in other words, but you have to be explicit about how you’re handling the memory, and it can’t be stack-allocated.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For an example of a recursive enumeration type (as well as an interesting/hilarious example of how you can easily confuse the compiler if you do this wrong), see &lt;a href="https://users.rust-lang.org/t/recursive-enum-types/2938"&gt;this Rust forum post&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For some discussion on stack- and heap-allocated memory in Rust, I’ll shamelessly promote my Rust podcast, &lt;a href="http://www.newrustacean.com"&gt;New Rustacean&lt;/a&gt;: take a listen to &lt;a href="http://www.newrustacean.com/show_notes/e005/index.html"&gt;e005: Allocate it where?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 09 Nov 2015 22:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-11-09:/2015/rust-and-swift-ix.html</guid><category>software development</category><category>listicles</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (viii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-viii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Rust and Swift handle function definition fairly similarly, at least for basic function definitions. In fact, for most basic functions, the only difference between the two is the keyword used to indicate that you’re declaring a function: &lt;code&gt;fn&lt;/code&gt; in Rust and &lt;code&gt;func&lt;/code&gt; in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Likewise, both return an empty tuple, &lt;code&gt;()&lt;/code&gt;, called the &lt;em&gt;unit type&lt;/em&gt; in Rust or &lt;code&gt;Void&lt;/code&gt; in Swift. Note, however, that this unit/&lt;code&gt;Void&lt;/code&gt; type is &lt;em&gt;not&lt;/em&gt; like C(++)’s &lt;code&gt;void&lt;/code&gt; or Java’s &lt;code&gt;null&lt;/code&gt;: you cannot coerce other types to it; it really is an empty tuple.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Type declarations on functions are basically identical for simple cases, though they vary into the details as you get into generics and constraints in generics.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have no idea why the Swift team chooses to represent function names like this: &lt;code&gt;function_name(_:second_param:third_param:&amp;lt;etc.&amp;gt;)&lt;/code&gt;. Perhaps it’s a convention from other languages I’m simply unfamiliar with, but it seems both odd and unhelpful: eliding the first parameter name obscures important information. Also, why use colons for the delimiter?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I’m informed via Twitter and App.net that this reflects how function names work in Objective C, and derives ultimately from Smalltalk.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Being able to name the items in a returned type in Swift is quite handy; it’s something I have often wanted and had to work around with dictionaries or other similar types in Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We’ll see how I feel once I’ve been writing both for a while, but initially I &lt;em&gt;strongly&lt;/em&gt; prefer Rust’s more-obvious (if also somewhat longer) &lt;code&gt;-&amp;gt; Option&amp;lt;i32&amp;gt;&lt;/code&gt; to return an optional integer to Swift’s &lt;code&gt;-&amp;gt; Int?&lt;/code&gt;. I am quite confident that I’ll miss that trailing &lt;code&gt;?&lt;/code&gt; somewhere along the way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’m sure there’s a reason for Swift’s internal and external parameter names and the rules about using &lt;code&gt;_&lt;/code&gt; to elide the need to use keyword arguments (but automatically eliding the first one) and so on… but I really can’t see the utility, overall. It seems like it would be better just to have Python-like args and keyword args.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That’s doubly so given that Swift’s rules for default-valued parameters map exactly to Python’s: they need to go at the end, after any parameters which don’t have default values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift’s variadic parameters are nice—though of course limited, since if you have more than one, the compiler may not know how to resolve which destination parameter a given argument belongs with. (I imagine the compiler &lt;em&gt;could&lt;/em&gt; be extended to be able to handle multiple variadic parameters as long as they were all of different types, but that’s probably not worth the work or the potential confusion it would introduce.) In any case, it’s a small nicety that I do wish Rust had.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift’s variable parameters are… interesting. I can see the utility, sort of, but (probably from years of habit with C and Python and pass-by-reference types), it’s just not a pattern that makes a lot of sense to me right now. No doubt I’ll get used to them in idiomatic Swift, but while Rust doesn’t have a similar feature, I suspect I won’t miss it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In/out parameters—that is, mutable pass-by-reference types—are available in both languages. The syntax is &lt;em&gt;very&lt;/em&gt; different here, as are the semantics.&lt;/p&gt;
&lt;p&gt;Swift has the &lt;code&gt;inout&lt;/code&gt; keyword, supplied before a parameter definition:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;func adds4ToInput(inout num: Int) {
    num += 4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rust has instead a variation on every other type definition, declaring the type in this case to be a mutable reference:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn adds_4_to_input(num: &amp;amp;mut i32) {
    num += 4;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, in other words, Swift opts to use new syntax (in this case, a dedicated keyword) while Rust opts to use the same syntax used everywhere else to denote a mutable reference. In fairness to Swift, though, this is something of a necessity there. From what I’ve seen so far, Swift generally doesn’t (and perhaps can’t?) do pointers or references explicitly (though of course it’s handling lots of things that way under the covers); arguments to functions are a special case, presumably present primarily for interoperability with Objective-C.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift’s function type definitions, as used in e.g. function parameter definitions, are quite nice, and reminiscent of Haskell in the best way. Rust’s are pretty similar, and add in its &lt;code&gt;trait&lt;/code&gt; usage—because functions types &lt;em&gt;are&lt;/em&gt; &lt;code&gt;trait&lt;/code&gt;s. Once again, I really appreciate how Rust builds more complicated pieces of functionality on lower-level constructs in the language. (Swift may be doing similar under the covers, but the Swift book doesn’t say.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Again, though, the downside to Rust’s sophistication is that it sometimes bundles in some complexity. Returning a function in Swift is incredibly straightforward:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;func getDoubler() -&amp;gt; (Int) -&amp;gt; Int {
    func doubler(number: Int) -&amp;gt; Int {
        return number * 2
    }

    return doubler
}

func main() {
    let doubler = getDoubler()
    println(&amp;quot;\(doubler(14))&amp;quot;)  // -&amp;gt; 28
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Doing the same in Rust is a bit harder, because—as of the 1.3 stable/1.5 nightly timeframe—it requires you to explicitly heap-allocate the function. Swift just takes care of this for you.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn get_doubler() -&amp;gt; Box&amp;lt;Fn(i32) -&amp;gt; i32&amp;gt; {
    fn doubler(number: i32) -&amp;gt; i32 {
        number * 2
    }

    Box::new(doubler)
}

fn main() {
    let doubler = get_doubler();
    println!(&amp;quot;{:}&amp;quot;, doubler(14));  // -&amp;gt; 28
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you understand what’s going on under the covers here, this makes sense: Rust normally stack-allocates a function in a scope, and therefore the &lt;code&gt;doubler&lt;/code&gt; function goes out of scope entirely when the &lt;code&gt;get_doubler&lt;/code&gt; function returns if you don’t heap-allocate it with &lt;code&gt;Box::new&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In both languages, closures and “ordinary” functions are variations on the same underlying functionality (as it should be). In Rust’s case, functions and closures both implement the &lt;code&gt;Fn&lt;/code&gt; trait. In Swift’s case, named functions are a special case of closures.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Swift syntax for a closure is, well, a bit odd to my eye. The basic form is like this (with the same “doubler” functionality as above):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ (n: Int) -&amp;gt; Int in return n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For brevity, this can collapse down to the shorter form with types inferred from context, parentheses dropped and the &lt;code&gt;return&lt;/code&gt; keyword inferred from the fact that the closure has only a single expression (note that this wouldn’t be valid unless in a context where the type of &lt;code&gt;n&lt;/code&gt; could be inferred):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ n in n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The simplicity here is nice, reminiscent in a good way of closures/lambdas in other languages.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; The fact that it’s a special case is less to my taste.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust’s closure syntax is fairly similar to Swift’s brief syntax. More importantly, there’s no special handling for closures’ final expressions. Remember: the final expression of &lt;em&gt;any&lt;/em&gt; block is always returned in Rust.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;|n| n * 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to fully annotate the types, as in the first Swift example, it would be like so:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;|n: i32| -&amp;gt; i32 { n * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are even &lt;em&gt;more&lt;/em&gt; differences between the two, because of Rust’s ownership notion and the associated need to think about whether a given closure is being borrowed or moved (if the latter, explicitly using the &lt;code&gt;move&lt;/code&gt; keyword).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift has the notion of shorthand argument names for use with closures.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; The arguments to a closure get the default names &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, etc. This gets you even &lt;em&gt;more&lt;/em&gt; brevity, and is quite convenient in cases where closures get used a lot (&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc.).&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;{ $0 * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If that weren’t enough, Swift will go so far as to simply reuse operators (which are special syntax for functions) as closures. So a closure call could simply be &lt;code&gt;+&lt;/code&gt; for a function expecting a closure operating on two numbers; Swift will infer that it needs to map back to the relevant method definition on the appropriate type.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The upside to this is that the code can be incredibly brief, and—once you’re used to it, at least—still fairly clear. The downside to this is yet &lt;em&gt;more&lt;/em&gt; syntax for Swift, and the ever-growing list of things to remember and ways to write the same thing I expect will lead to quite a bit of instability as the community sorts out some expectations for what is idiomatic in any given instance.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And if that weren’t enough, there is more than one way to supply the body of a closure to a Swift function that expects it: you can supply a block (&lt;code&gt;{ /* closure body */ }&lt;/code&gt;) &lt;em&gt;after&lt;/em&gt; the function which expects it. Yes, this can end up looking nearly identical to the form for declaring a function:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;someFunctionExpectingAnIntegerClosure() { n * 2 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But you can also drop the parentheses if that’s the only argument.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;someFunctionExpectingAnIntegerClosure { n * 2 }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In terms of the &lt;em&gt;mechanics&lt;/em&gt; of closures, and not just the syntax, the one significant difference between Rust and Swift is the same one we’ve seen in general between the two languages: Swift handles the memory issues automatically; Rust makes you be explicit about ownership. That is, as noted above about the closures themselves, in Rust you may have to &lt;code&gt;move&lt;/code&gt; ownership to get the expected behavior. Both behave basically like closures in any other language, though; nothing surprising here. Both also automatically copy values, rather than using references, whever it makes sense to do so.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift autoclosures allow for lazy evaluation, which is neat, but: &lt;em&gt;yet more syntax&lt;/em&gt;! Seriously. But I think all its other closure syntaxes &lt;em&gt;also&lt;/em&gt; allow for lazy evaluation. The only reason I can see to have the special attribute (&lt;code&gt;@autoclosure&lt;/code&gt;) here is because they added this syntax. And this syntax exists so that you can call functions which take closures as if they &lt;em&gt;don’t&lt;/em&gt; take closures, but rather the argument the closure itself takes. But of course, this leads the Swift book to include the following warning:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Overusing autoclosures can make your code hard to understand. The context and function name should make it clear that the evaluation is being deferred.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yes, care needed indeed. (Or, perhaps, you could just avoid adding more special syntax that leads to unexpected behaviors?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Good grief. I’m tired now. That’s a half-dozen variants on &lt;em&gt;closure syntax&lt;/em&gt; in Swift.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remember: there’s still just one way to write and use a closure in Rust.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This takes me back to something I noticed &lt;a href="/2015/rust-and-swift-ii.html"&gt;early on&lt;/a&gt; in my analysis of the two languages. In Swift, there’s nearly always more than one way to do things. In Rust, there’s usually one way to do things. Swift prefers brevity. Rust prefers to be explicit. In other words, Swift borrows more of its philosophy from Perl; Rust more from Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’m a Python guy, through and through. Perl drives me crazy every time I try to learn it. You could guess (even if you hadn’t already seen) where this lands me between Rust and Swift.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is incredibly long, but I blame that on the (frankly incredible) number of variants Swift has on the same concept.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ix.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Sum types (&lt;code&gt;enum&lt;/code&gt;s) and more on pattern matching.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Compare the closure syntaxes especially in Ruby and ES6+.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;For a similar example in another up-and-coming language, see &lt;a href="http://elixir-lang.org/getting-started/modules.html#function-capturing"&gt;Elixir&lt;/a&gt;, which does almost exactly the same but with &lt;code&gt;&amp;amp;&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 18 Oct 2015 11:50:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-10-18:/2015/rust-and-swift-viii.html</guid><category>software development</category><category>listicles</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (vii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-vii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Both Rust and Swift have &lt;em&gt;pattern-matching&lt;/em&gt;, and with what appears to be fairly similar basic behavior. (I touched on this briefly in my &lt;a href="/2015/rust-and-swift-i.html"&gt;first post in the series&lt;/a&gt;.) In Rust this goes under the &lt;code&gt;match&lt;/code&gt; construct, with matches specified like &lt;code&gt;&amp;lt;pattern&amp;gt; =&amp;gt; &amp;lt;expression|statement&amp;gt;&lt;/code&gt;, optionally with guards specified with &lt;code&gt;if&lt;/code&gt; expressions. In Swift, patterns are matched using the &lt;code&gt;switch&lt;/code&gt; construct, with matches specified like &lt;code&gt;case &amp;lt;pattern&amp;gt;: &amp;lt;expression|statement&amp;gt;&lt;/code&gt;, optionally with guards specified with &lt;code&gt;where&lt;/code&gt; expressions. (&lt;code&gt;where&lt;/code&gt; is also used in Rust, but for generic constraints, not pattern match guards.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages allow you to bind names to a matched pattern: Swift with &lt;code&gt;case let &amp;lt;name&amp;gt;&lt;/code&gt; and Rust simply by using the name in a normal destructuring expression as part of the match definition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; that’s not &lt;em&gt;quite&lt;/em&gt; right. In Rust, you use the &lt;code&gt;@&lt;/code&gt; operator with the variable name you want to bind in the match.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit the second:&lt;/strong&gt; I was mixed up, because Rust actually has &lt;em&gt;both&lt;/em&gt; of those options. You can either match directly, e.g. when getting the value of an &lt;code&gt;Option&lt;/code&gt; type: &lt;code&gt;Some(value)&lt;/code&gt; as the pattern will bind &lt;code&gt;value&lt;/code&gt;. But if you need to bind a specific part of more complicated data structure, the &lt;code&gt;@&lt;/code&gt; operator is present to let you do it in a fairly straightforward way.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages allow for the use of &lt;code&gt;_&lt;/code&gt; as a “wildcard” in match definitions. Since match definitions in Rust use the patterns directly, the equivalent of Swift’s C-like &lt;code&gt;default&lt;/code&gt; is simply a wildcard match pattern (&lt;code&gt;_ =&amp;gt; &amp;lt;-expression|statement&amp;gt;&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;One significant difference: like its &lt;code&gt;if&lt;/code&gt; blocks, Rust’s &lt;code&gt;match&lt;/code&gt; blocks are expressions, so they can be assigned. I.e., you can write this:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let test = 5u32;
let description = match test {
    0..10 =&amp;gt; &amp;quot;less than ten&amp;quot;,
        _ =&amp;gt; &amp;quot;greater than ten&amp;quot;,
}
println!(&amp;quot;{?:}&amp;quot;);  // &amp;quot;less than ten&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift doesn’t let you do this; the same thing there would be written like this:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;let test: UInt32 = 5
var description: String
switch test {
    case 0..&amp;lt;10:
        description = &amp;quot;less than ten&amp;quot;
    default:
        description = &amp;quot;greater than ten&amp;quot;
}
println(&amp;quot;\(description)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages have &lt;code&gt;break&lt;/code&gt; statements, but in Rust they’re only used in loop constructs, while Swift (like C) uses them to escape &lt;code&gt;case&lt;/code&gt;s as well. The Swift book gives an example of one place they’re necessary in a &lt;code&gt;switch&lt;/code&gt;: to match a case and do nothing there (e.g. &lt;code&gt;default: break&lt;/code&gt;). In Rust, you would simply supply an empty block for that scenario (e.g. &lt;code&gt;_ =&amp;gt; {}&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Correctly, both languages force you to match exhaustively on relevant patterns. If you’re matching an enumerated type, for example, you must handle every enumerated value. You can of course do this with wildcard patterns or with Swift’s &lt;code&gt;default&lt;/code&gt;, but the good thing is that both languages will refuse even to compile if a given pattern isn’t matched.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swift’s default behavior around its &lt;code&gt;switch&lt;/code&gt; statements is sane: it does &lt;em&gt;not&lt;/em&gt; automatically fall through into the next statement. It does let you do this, without checking the condition on the next statement (as in C), using the &lt;code&gt;fallthrough&lt;/code&gt; keyword. Rust, by contrast, simply doesn’t allow this at all.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Both languages supply named control statements (loops, etc.), with slightly different syntax for naming them. Rust’s, curiously, shares its syntax with lifetime definitions—more on those in a future post.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I don’t believe Rust has anything quite like Swift’s &lt;code&gt;guard&lt;/code&gt;s, which allow you to leave normal or expected control flow in the main body of a block, with a secondary block for cases where the &lt;code&gt;guard&lt;/code&gt; isn’t matched. This isn’t a huge deal, but it does fit as a nice convenience into the typical &lt;code&gt;if let&lt;/code&gt; pattern in Swift. Basically, it just lets you elide an empty &lt;code&gt;if&lt;/code&gt; block and supply only the &lt;code&gt;else&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; a friend &lt;a href="https://alpha.app.net/jws/post/64804111"&gt;points out&lt;/a&gt; that Swift &lt;code&gt;guard&lt;/code&gt;s also require you to exit the current scope, so it’s unambiguous what you’re doing if you use them.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vi.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Functions, closures, and an awful lot of Swift syntax.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 Sep 2015 15:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-19:/2015/rust-and-swift-vii.html</guid><category>software development</category><category>listicles</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (vi)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-vi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;It kind of feels like this summarizes a &lt;em&gt;lot&lt;/em&gt; of things about the overall design of Swift:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array. —&lt;em&gt;The Swift Programming Language (Swift 2 Prerelease)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The documentation for the various types in Rust’s &lt;code&gt;std::collections&lt;/code&gt; module is hilarious and great. Highly recommended.&lt;/p&gt;
&lt;p&gt;One thing that jumped out at me reading this chapter of the Swift book (though I don’t think it’s been explicitly discussed yet): Rust doesn’t have named parameters; Swift does. There are good reasons for that in both cases, but I suspect this is one of the small details I’ll miss the most in Rust. I’ve been spoiled by Python.&lt;/p&gt;
&lt;p&gt;Swift’s &lt;code&gt;Array&lt;/code&gt; type is analogous to Rust’s &lt;code&gt;Vec&lt;/code&gt; type (usually created with the &lt;code&gt;vec!&lt;/code&gt; macro), &lt;em&gt;not&lt;/em&gt; its &lt;code&gt;Array&lt;/code&gt; type. Rust &lt;code&gt;Vec&lt;/code&gt;s and Swift &lt;code&gt;Array&lt;/code&gt;s are dynamically sized and created on the heap, whereas Rust’s &lt;code&gt;Array&lt;/code&gt;s are statically sized and created on the stack. Syntax for creating &lt;code&gt;Array&lt;/code&gt;s in both languages is quite similar (though the results are different):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift:
&lt;ul&gt;
&lt;li&gt;Fixed size: &lt;code&gt;let an_array: [Int] = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Variable size: &lt;code&gt;var an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rust:
&lt;ul&gt;
&lt;li&gt;Array: &lt;code&gt;let an_array: [i32, 3] = [1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector: &lt;code&gt;let a_vector: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That’s the long form, of course; both languages have type inference, so you’d rarely write it like that. The usual form would be with the type in all of those cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Swift:
&lt;ul&gt;
&lt;li&gt;Fixed size: &lt;code&gt;let an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Variable size: &lt;code&gt;var an_array = [1, 2, 3]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rust:
&lt;ul&gt;
&lt;li&gt;Array: &lt;code&gt;let an_array = [1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Vector: &lt;code&gt;let a_vector = vec![1, 2, 3];&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rust also adds the concept of “slices,” which provide access to segments of arrays, and are heap-allocated as pointers to a given item in the array and a length (number of elements) included.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Array&lt;/code&gt; operations in Swift are all pretty reasonable, and surprisingly descriptive. They remind me in a good way of Python’s &lt;code&gt;list&lt;/code&gt; methods.&lt;/p&gt;
&lt;p&gt;There are a &lt;em&gt;lot&lt;/em&gt; of &lt;a href="http://doc.rust-lang.org/stable/std/vec/struct.Vec.html"&gt;ways to interact with &lt;code&gt;Vec&lt;/code&gt;s in Rust&lt;/a&gt;. (That’s not a bad thing.) A bit surprising to me was the absence of an &lt;code&gt;enumerate&lt;/code&gt; method, on &lt;code&gt;Vec&lt;/code&gt; itself, but then I discovered that it exists in the &lt;code&gt;IntoIter&lt;/code&gt; struct in the same module, which fully implements the &lt;code&gt;Iterator&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt;. As a result, it has an &lt;code&gt;enumerate&lt;/code&gt; function returning an &lt;code&gt;Enumerate&lt;/code&gt; &lt;code&gt;struct&lt;/code&gt; instance. (Under the covers, I suspect Swift &lt;code&gt;Array&lt;/code&gt;s just implement an &lt;code&gt;Iterable&lt;/code&gt; &lt;code&gt;protocol&lt;/code&gt;, which is similar to this approach in some ways.)&lt;/p&gt;
&lt;p&gt;This makes a point I’m coming back to fairly often: Rust doesn’t necessarily put everything on a single object definition, but rather into a set of related &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; types and &lt;code&gt;trait&lt;/code&gt;s. This is really powerful, but it’s going to take some mental adjustment. In this way, Swift’s structure and semantics are much more like the languages I’m used to than Rust’s are (but even there, the use of &lt;code&gt;protocols&lt;/code&gt; gives it considerable new flexibility).&lt;/p&gt;
&lt;p&gt;Note that I said &lt;em&gt;semantics&lt;/em&gt;, not syntax. Swift and Rust are a great example of how very similar syntax can mask differences in semantics. (For another such example, compare JavaScript’s syntax and semantics to Java’s: they’re superficially similar syntactically, and light years apart semantically.)&lt;/p&gt;
&lt;p&gt;Swift’s &lt;code&gt;Set&lt;/code&gt; type and Rust’s roughly analogous &lt;code&gt;HashSet&lt;/code&gt; both have a &lt;code&gt;contains&lt;/code&gt; method which behaves much like Python’s &lt;code&gt;in&lt;/code&gt; keyword. Indeed, and perhaps unsurprisingly, the two types implement many of the same methods in general. This is perhaps to be expected given that the language around sets (as a mathematical concept being mapped down into a representation in a program) is quite standardized.&lt;/p&gt;
&lt;p&gt;Because of their stricter typing systems, both Rust and Swift require you to specify the types used in their mapping constructs (Rust has &lt;code&gt;HashMap&lt;/code&gt; and Swift has &lt;code&gt;Dictionary&lt;/code&gt;), though of course both can infer this as well in certain cases. At the most basic level, you can’t use arbitrary (hashable) types as keys in mixed fashion like you can in e.g. Python’s &lt;code&gt;dict&lt;/code&gt; type, but in practice this shouldn’t matter, for two reasons:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It’s generally inadvisable to use different types for keys in the same dictionary anyway. To me, at least, that usually indicates the need to step back and think more carefully about the types and data structures I’m using.&lt;/li&gt;
&lt;li&gt;For the occasional case where it &lt;em&gt;is&lt;/em&gt; appropriate, I wonder if you could declare the type as generic in either Rust or Swift. I’m putting this down as a TODO item for myself to find out!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I really wish that Swift used the Python-style curly-brace delimited syntax (&lt;code&gt;{'key': 'value'}&lt;/code&gt;) for its dictionary literal initializers. I can see, from a syntax reason, why it doesn’t: that would overload the block syntax (which Python can avoid because it’s white-space delimited). But it’s &lt;em&gt;really&lt;/em&gt; convenient.&lt;/p&gt;
&lt;p&gt;Along similar lines, I can see why the Swift designers chose to make all iterables have literal initializers using braces (&lt;code&gt;[...]&lt;/code&gt;); it makes parsing fairly straightforward. However, the result is that it’s pretty difficult to see at first glance what you’re dealing with. It could quite easily be an &lt;code&gt;Array&lt;/code&gt;, a &lt;code&gt;Set&lt;/code&gt;, or a &lt;code&gt;Dictionary&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This highlights a too-little-appreciated aspect of programming language design: &lt;em&gt;readability&lt;/em&gt;. However much we programmers enjoy writing code, the reality is that we will all spend a great deal of our time—probably even a majority of it—reading it instead. Thus, while we should care about conveniences for writing code, and being overly verbose can be a pain, we should also concern ourselves with the ease of comprehending code when it is read, and the syntax and conventions a language embraces are a big part of this.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Dictionary&lt;/code&gt; type in Swift is a pretty close analog to Python’s &lt;code&gt;dict&lt;/code&gt;, right down to several of the method names. the same is true of Rust’s &lt;code&gt;HashMap&lt;/code&gt;. That’s not a bad thing by any stretch of the imagination.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Pattern matching and the value of expression blocks.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 Sep 2015 09:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-19:/2015/rust-and-swift-vi.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (v)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-v.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I’ve been working on learning Swift over the past couple weeks, and had spent the month prior to that doing a deep first dive on Rust. This kind of approach, learning two languages basically at the same time, is entirely new to me, and for good reason. Programming languages are not trivial to learn, and to learn them meaningfully one must practice with them a great deal.&lt;/p&gt;
&lt;p&gt;I’m doing this largely of necessity. I’m hoping to build an application with a very capable, performant cross-platform core language (Rust), but planning to ship a native OS X app (first) when all is said and done. My desire to make the core libraries portable rules out Swift immediately. To be frank, so does the fact that it’s an Apple language: I am happy to use Apple’s tools on its platform, but I don’t want to shackle myself to their choices in the long run. Too, having good Rust experience is likely to be valuable in many other contexts.&lt;/p&gt;
&lt;p&gt;So I need to learn both.&lt;/p&gt;
&lt;p&gt;And, while I wouldn’t ordinarily recommend this course of action—indeed, unless you already have a fair bit of programming experience and already know several languages, I’d actively recommend against it—I’m finding it enormously profitable. The languages have been designed in roughly the same time frame, cite many of the same influences, and overlap substantially in terms of audience and goals. Yet they are, as this series has already highlighted, quite different languages in many ways.&lt;/p&gt;
&lt;p&gt;Learning them in parallel is helping me see the trade-offs each one has made, and force me to think about &lt;em&gt;why&lt;/em&gt; they differ in the ways they do. In particular, I think I have a much better idea what’s going on “under the covers” in each language and therefore know what to expect of them better. This, in turn, has dramatically deepened my grasp of the languages relative to the amount I’ve been looking at them, compared to previous language-learning efforts. (It also helps that I’ve already learned a number of languages, of course, and that I’ve been pushing my brain into the learning-programming-languages space via reading about Haskell, functional patterns in JavaScript, and so on this year.)&lt;/p&gt;
&lt;p&gt;I have a long way to go in both languages, of course. Reading on nights and weekends, and the little bit of playing I’ve been able to do with each of them, is no replacement for just sinking my teeth into a project and finding the pain points. Nonetheless, I’m really glad to be learning these two languages &lt;em&gt;together&lt;/em&gt;. If you’re up for a challenge, try it sometime! You’ll be surprised how much you learn.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vi.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Sep 2015 13:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-12:/2015/rust-and-swift-v.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>If-expressions in Rust</title><link>http://www.chriskrycho.com/2015/if-expressions-in-rust.html</link><description>&lt;p&gt;I love the fact that all &lt;code&gt;if&lt;/code&gt; statements in Rust are expressions. It gives you a great deal of expressitivity in the language.&lt;/p&gt;
&lt;p&gt;Let’s contrast with Python (which I love, for the record). In Python, you can do something like this:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;some_condition = True
if some_condition:
    a_value = &amp;quot;Yeah!&amp;quot;
else:
    a_value = &amp;quot;Oh, sads.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Those are &lt;em&gt;statements&lt;/em&gt; in the body of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; block; you can’t assign the block itself to &lt;code&gt;a_value&lt;/code&gt;. However, like C, C++, Java, etc., Python does provide an &lt;em&gt;expression&lt;/em&gt;-type conditional, a ternary expression.&lt;/p&gt;
&lt;p&gt;So you can also do this:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;some_condition = True
a_value = &amp;quot;Yeah&amp;quot; if some_condition else &amp;quot;Oh, sads.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This expression form of the &lt;code&gt;if&lt;/code&gt; block is what all Rust &lt;code&gt;if&lt;/code&gt; blocks are. So in Rust, the normal long form is:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition {
    &amp;quot;Yeah!&amp;quot;
}
else {
    &amp;quot;Oh, sads.&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You could also write this with a &lt;code&gt;let mut a_value&lt;/code&gt; and then set its value inside the conditional blocks, but that’s not at all good form in Rust.)&lt;/p&gt;
&lt;p&gt;And of course, you can shorten that rather nicely where the expressions are brief enough:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition { &amp;quot;Yeah!&amp;quot; } else { &amp;quot;Oh, sads.&amp;quot; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this gets really nice when you have more complicated work to do in a Rust conditional. It doesn’t matter how many things going on inside an &lt;code&gt;if&lt;/code&gt; expression; it’s still an expression. As such, you can also write this:&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition {
    let the_answer = 42;
    let theme = &amp;quot;Take my love, take my land...&amp;quot;;
    &amp;quot;Yeah!&amp;quot;  // An expression!
}
else {
    let the_question = &amp;quot;What do you get when you multiply six by nine?&amp;quot;;
    let song = &amp;quot;You can&amp;#39;t take the sky from me!&amp;quot;;
    &amp;quot;Oh, sads.&amp;quot;  // An expression!
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously this is totally contrived and silly; the point is that no matter what the internals are, &lt;code&gt;if&lt;/code&gt; blocks are expressions, and their final expressions can be assigned like any other.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;As a note: I got here because I was originally thinking you couldn’t do a one-liner like you can in Python. As shown above, that’s totally false, and in fact the Rust version is much more capable than Python’s, because you don’t need a dedicated ternary when all &lt;code&gt;if&lt;/code&gt; blocks are expressions. Rust used to have a C-style ternary (&lt;code&gt;&amp;lt;condition&amp;gt; ? &amp;lt;value if true&amp;gt; : &amp;lt;value if false&amp;gt;&lt;/code&gt;) but it was &lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;removed&lt;/a&gt; during the lead-up to the 1.0 release—a decision I wholeheartedly affirm.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note that under normal conditions the compiler won’t actually accept this because of the unused names.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Sep 2015 11:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-12:/2015/if-expressions-in-rust.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>python</category></item><item><title>Rust and Swift (iv)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Both Swift and Rust directly address the issue of having to worry about memory allocation and safety. They do it in different ways, though: Swift by automatic reference counting, Rust by its concept of ownership. For a lot of day-to-day development, I can see the Swift approach being a win for the same reason a language like Python or Ruby is: having that all handled for you is &lt;em&gt;nice&lt;/em&gt;. Having the power Rust gives you comes at the price of increased cognitive load from having to reason about ownership.&lt;/p&gt;
&lt;p&gt;To put it another way: all programming languages have to make trade offs. Although I like Rust’s better than Swift’s so far, I’ve no doubt I will find any number of things to appreciate about Swift over Rust. You can’t have everything.&lt;/p&gt;
&lt;p&gt;This caught my attention in part because dealing with things like strings (or other pass-by-value types) in Swift is rather more straightforward than in Rust. The outcomes are much the same, but since &lt;em&gt;all&lt;/em&gt; &lt;code&gt;String&lt;/code&gt;s in Swift are passed by value (never by reference), you simply don’t have to think about modification—even safe modification!&lt;/p&gt;
&lt;p&gt;Rust of course had the &lt;code&gt;Copy&lt;/code&gt; trait which lets you do this, but the point is that the “ergonomics” are slightly nicer in Swift.&lt;/p&gt;
&lt;p&gt;Also, the string interpolation Swift does is &lt;em&gt;nice&lt;/em&gt;. That’s one thing I really wish Rust had. It’s Python-style string formatting macro is great, but being able to interpolate values (&lt;code&gt;&amp;quot;strings with \(variables)&amp;quot;&lt;/code&gt; or even &lt;code&gt;&amp;quot;embedded expressions like \(2 + 4)&amp;quot;&lt;/code&gt;) is very nice.&lt;/p&gt;
&lt;p&gt;Swift’s approach to strings in general seems well-thought-through and gives appropriate levels of attention to the details which make handling complex or non-Western languages much more manageable. As a typography geek, I appreciate this a great deal.&lt;/p&gt;
&lt;p&gt;That said, since Swift’s strings &lt;em&gt;do&lt;/em&gt; handle all those edge cases for Unicode, you lose some standard string access patterns and lose much (maybe all?) insight into the internal structure of the string. That may be good, and may be bad, depending on the circumstance. Like I said: trade-offs.&lt;/p&gt;
&lt;p&gt;Actually, on reading further, the way Swift handles Unicode strings is pretty nice. It &lt;em&gt;does&lt;/em&gt; give you insight into those, via specific methods for different representations. I particularly appreciate that it’s you deal with them as the standalone &lt;code&gt;String&lt;/code&gt; type as well as giving you direct access to the code points—and not just one Unicode code point set, but any of &lt;abbr&gt;UTF8&lt;/abbr&gt;, &lt;abbr&gt;UTF16&lt;/abbr&gt;, or &lt;abbr&gt;UTF32&lt;/abbr&gt; (Unicode scalars). Trust Apple to pay close attention to text.&lt;/p&gt;
&lt;p&gt;Rust’s strings are &lt;em&gt;good&lt;/em&gt;, but not quite as sophisticated (presumably for simplicity around the memory mapping). All Rust &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;str&lt;/code&gt; instances are composed of &lt;abbr&gt;UTF32&lt;/abbr&gt; Unicode scalars, encoded as &lt;abbr&gt;UTF8&lt;/abbr&gt; sequences. It doesn’t have some of the convenience methods Swift does for getting any of the other representations. That said, I expect this should show up rarely if at all in my ordinary usage. Importantly, the fundamental storage is the same: both use scalars.&lt;/p&gt;
&lt;p&gt;This was the first section where it didn’t feel like Rust was just a clear overall “winner” over Swift. Some of the trade offs between the language designs are more apparent here, and I do appreciate the “ergonomics” of Swift in a number of these things.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Sep 2015 21:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-10:/2015/rust-and-swift-iv.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (iii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I just hit operators in the Swift book. First question: are operators special syntax, or are they sugar for &lt;code&gt;protocol&lt;/code&gt;s? (Every modern language I use or even have played with handles them as sugar for another language construct—Python, Ruby, Io, Elixir, and Rust, to name just a few ranging over a substantial variety of ages and styles.)&lt;/p&gt;
&lt;p&gt;Oh. I did the requisite digging, and operators are functions (which is okay) defined in the &lt;del&gt;global namespace (&lt;em&gt;:sigh:&lt;/em&gt;)&lt;/del&gt; Swift module.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I say “okay” rather than good because the justification offered is that this is the only way to make the operators work as binary operators between existing instances of types. But that elides the fact that, if that’s the case, it is so because of other language design decisions. This seems like a perfect place to use a &lt;code&gt;protocol&lt;/code&gt;, but perhaps (unlike Rust’s &lt;code&gt;trait&lt;/code&gt;) they’re not sufficiently capable to handle this? That’s an open question; I have no idea about the answer.&lt;/p&gt;
&lt;p&gt;Interestingly, Rust has several fewer operators than Swift, even apart from those mentioned in my &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;previous post&lt;/a&gt;. It drops the pre- and post-increment operators entirely (as does Python), since their results can always be accomplished in other ways with less potential for confusion. Swift keeps them, no doubt in part because most (Objective) C programs are deeply familiar with them and with idioms associated with them.&lt;/p&gt;
&lt;p&gt;I learned a few new things about Rust’s operators as well: the Boolean &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators and its bitwise &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operators differ not only in that the former are &lt;em&gt;short-circuit&lt;/em&gt; operators and the latter are not. Obviously you can also do things like bit-wise flag operations with the latter, but the reference emphasizes the short-circuiting behavior. This makes perfect sense, but it wasn’t something I’d ever considered explicitly before.&lt;/p&gt;
&lt;p&gt;There is no ternary operator in Rust, because of how it handles the relationship between expressions and statements. Swift keeps it. That’s an interesting reflection of differences in design: Rust dropped it because &lt;code&gt;if&lt;/code&gt; blocks are expressions, so it’s redundant, and they have had a goal of removing unnecessary features. (See the discussion on dropping the ternary operator—with an interesting aside from Brendan Eich on JavaScript—&lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;here&lt;/a&gt;). Note that this is not a criticism of Swift, just an observation, though I do really like Rust’s expression-driven approach.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;??&lt;/code&gt; “nil coalescing operator”, on the other hand, I actively dislike. This seems like shorthand for the sake of shorthand, partly necessitated by the existing drive toward shorthand with optional types in Swift. Sometimes brevity can lead to decreased clarity. Eliding too much, or subsuming it into shorthand, makes the language harder to hold in your head and requires you to slow down more for parsing each line.&lt;/p&gt;
&lt;p&gt;Nothing surprising (or different) between the standard boolean operators in the two languages.&lt;/p&gt;
&lt;p&gt;I wonder how many times the word “concise” (or synonyms of it) appear in the Swift book? It’s increasingly clear to me reading that brevity is one of the primary design goals. Maybe it’s just me, but that actually seems a little weird. Brevity is good so far as it goes, but &lt;em&gt;legibility&lt;/em&gt; is much better.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;See edit in discussion of functions and global namespace in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;part ii&lt;/a&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 07 Sep 2015 11:55:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-07:/2015/rust-and-swift-iii.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (ii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;At first blush, I find the extra syntax around optionals in Swift more confusing than helpful. I think this comes down to my preference for a more Python-like approach: “Explicit is better than implicit” and “There should be one– and preferably only one –obvious way to do it” both militate against the multiple different ways you can handle optional values in Swift. &lt;code&gt;Optional&lt;/code&gt; types are created in one of two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with the &lt;code&gt;?&lt;/code&gt; operator on a type definition, creating an explicitly wrapped type which must be checked in some way.&lt;/li&gt;
&lt;li&gt;with the &lt;code&gt;!&lt;/code&gt; operator on a type definition, creating an “implicitly unwrapped optional” by forcibly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After creating an optional, you can get at its contents by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using the &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;while let&lt;/code&gt; constructs to bind the optional value’s non-&lt;code&gt;nil&lt;/code&gt; value for a block&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;!&lt;/code&gt; operator on a variable name, explicitly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By contrast, in Rust you always have to explicitly unwrap the item, using the &lt;code&gt;unwrap&lt;/code&gt; method or pattern matching. There are no implicitly unwrapped types. Moreover, there is no special syntax around creating optional types in Rust: you just declare them with an &lt;code&gt;Option&lt;/code&gt; type or another type that &lt;code&gt;impl&lt;/code&gt;s the &lt;code&gt;Option&lt;/code&gt; behavior. The “shortcut” behavior around error handling, &lt;code&gt;try!&lt;/code&gt;, isn’t special syntax, but application of another standard language construct (in this case, a macro).&lt;/p&gt;
&lt;p&gt;The discussion of &lt;code&gt;assert&lt;/code&gt; in the Swift book re-raises the question about the global namespace:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“You write an assertion by calling the global &lt;code&gt;assert(_:_:)&lt;/code&gt; function.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This continues to suggest strongly that Swift does in fact have a true global namespace, &lt;em&gt;not&lt;/em&gt; an automatically-imported prelude. That can make a big difference for applications in certain spaces (e.g. systems programming), when you might have good reason to want to replace the standard library’s approach with a different one. (See Rust’s &lt;a href="https://doc.rust-lang.org/book/no-stdlib.html"&gt;&lt;code&gt;#[no_std]&lt;/code&gt;&lt;/a&gt; docs and the &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md"&gt;related RFC&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; “strongly suggests” or no, I have now been &lt;a href="https://twitter.com/jckarter/status/708765262309228544" title="Tweet by one of the Swift developers"&gt;reliably informed&lt;/a&gt; that I was mistaken—and am happy to have been wrong here. As in Haskell, these functions are implicitly imported and belong to the &lt;code&gt;Swift&lt;/code&gt; module.&lt;/p&gt;
&lt;p&gt;In Rust, &lt;code&gt;assert!&lt;/code&gt; is a macro, not a function, which is an interesting but perhaps not &lt;em&gt;especially&lt;/em&gt; important distinction in this particular case. (It might be, though; I’d have to see the implementation of each to see how they play out differently.)&lt;/p&gt;
&lt;p&gt;In any case, this also highlights another large difference between the two: testing is &lt;a href="https://doc.rust-lang.org/stable/book/testing.html"&gt;front and center&lt;/a&gt; in Rust, and barely receives a mention so far in the Swift book (and isn’t in the table of contents). Having language-level support for testing is a big deal.&lt;/p&gt;
&lt;p&gt;Language tour and first chapter of the language guide down, my sense is that Swift is a substantially better language than C or C++ (and presumably than Objective C, but since I don’t know that language I can’t speak to it) for app design, but that Rust is a better language yet. Both a far more modern than their predecessors, but they approach the same problems in surprisingly different ways, relatively similar syntax notwithstanding. So far, I like the Rust approach better.&lt;/p&gt;
&lt;p&gt;In particular, more syntax is not my preferred way to tackle these things. Providing good language constructs and primitives on which to build seems better in &lt;em&gt;many&lt;/em&gt; ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It substantially reduces the cognitive load for the developer, by keeping the number of constructs small and simply varying how they are applied.&lt;/li&gt;
&lt;li&gt;It increases the quality of those primitives, because it forces the language deadness to make sure they actually address the full problem space.&lt;/li&gt;
&lt;li&gt;It lets developers approach the same problem in ways the language design team may not have anticipated, and over time the community may find shared conventions that improve on the &lt;code&gt;std&lt;/code&gt; approach, and nothing has to change in the language spec (or the compiler!) to adopt those changes.&lt;/li&gt;
&lt;li&gt;In general, then, it makes change much easier to manage, and change can be community-driven rather than requiring the language design team to manage it.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-i.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This may of course be intentional on Apple’s part with Swift. Maintaining tight control over its tooling is very typical of modern Apple.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Sep 2015 10:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-06:/2015/rust-and-swift-ii.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (i)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-i.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I started writing these responses in a Slack channel of developers I participate in as I worked through the &lt;a href="https://developer.apple.com/swift/"&gt;Swift&lt;/a&gt; &lt;a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/"&gt;book&lt;/a&gt;. I realized after a bit that it would make a better blog post than chat room content, so here we are. This is all entirely off-the-cuff: me just thinking out loud as I read; this is by no means expert opinion.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;I later turned this into the first part of a whole &lt;a href="/rust-and-swift.html"&gt;series&lt;/a&gt; comparing Rust and Swift!&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;..&amp;lt;&lt;/code&gt; – seriously?&lt;/p&gt;
&lt;p&gt;That has to be one of the most annoying operators I’ve ever seen. It ends up with cognitive noise because &lt;code&gt;&amp;lt;name&lt;/code&gt; initially processes as “starting a generic” and you have to re-parse it visually and mentally.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After the first chapter of the Swift book, my impression is “a poor man’s Rust”; my gut feel based on that first pass and everything I’ve seen and read about Swift over the past two years is that it’s roughly what you would get if you took Rust’s syntax and replaced Rust’s hard safety goals with the aim of mapping to ObjC semantics. (To be fair to Apple, that interoperability was probably necessary.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An example that jumps out at me as immediately illustrative of the difference in approach the languages take is the way you pass structures by reference vs. copy. In Swift, that’s done via two completely distinct language constructs, &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es respectively.&lt;/p&gt;
&lt;p&gt;In Rust, there is just the &lt;code&gt;struct&lt;/code&gt; type to handle both of those. They’re immutable unless you declare them with &lt;code&gt;mut&lt;/code&gt;, and you can pass them via copy simply by implementing the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt; (which seems roughly analogous to Swift’s &lt;code&gt;protocol&lt;/code&gt;, but I’ve not yet dig deeply enough to see how they differ). Those things aren’t baked into the language, but use simpler language building blocks to define behavior into he library.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I saw someone do a write up a while back arguing that Go isn’t a &lt;em&gt;bad&lt;/em&gt; language, it just isn’t a &lt;em&gt;good&lt;/em&gt; language. My first impression of Swift, after having spent the last month with Rust, is very much along those lines.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Huh. Here’s something that I appreciate about Rust, Haskell, and others now that I didn’t before: there’s a difference between implicitly/automatically importing a prelude or a given set of standard library functions, and having actually global functions. Does Swift actually have functions like &lt;code&gt;print&lt;/code&gt; in a global namespace, as the book seems to imply, or they being imported automatically &lt;em&gt;a la&lt;/em&gt; Rust/Haskell/etc.?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; it appears Swift does likewise, but that you can’t access the relevant module directly. Which is halfway there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hmm. Why have &lt;code&gt;Double&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;Float&lt;/code&gt;—just for ObjC interop, I guess?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; follow-up from a conversation with a friend: it’s because you have 32- and 64-bit architectures out there; sometimes you don’t want 64 bits of floating point precision for that reason. Note that Rust &lt;em&gt;also&lt;/em&gt; has this distinction; you can declare things as &lt;code&gt;f32&lt;/code&gt; or &lt;code&gt;f64&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extending the above note on &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;protocol&lt;/code&gt;s vs. Rust’s approach: the same thing is true about &lt;code&gt;extension&lt;/code&gt;, which is a distinct concept from implementing a &lt;code&gt;protocol&lt;/code&gt;; again, in Rust these are both just handled with a single language construct, &lt;code&gt;impl&lt;/code&gt;. That’s not because &lt;code&gt;impl&lt;/code&gt; is overloaded, but rather because the underlying language machinery is the same for the two things. (edited)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(I’ve a feeling learning Swift is going to turn me into even more of a Rust fanboy.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reading the two books in close sequence like this is proving really productive mentally for thinking about how the two handle the same issues. I’ve never done anything quite like this before, and it’s fascinating.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have an increased appreciation for Rust’s use of semi-colons to turn expressions into statements, and thereby to distinguish clearly between the two (among other things, allowing for implicit return of anything that’s an expression).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another interesting comparison: Rust’s &lt;code&gt;match&lt;/code&gt; and Swift’s &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; fill the same role of pattern matching. I’m curious to see how they differ. Does Swift do matching on arbitrary expressions?&lt;/p&gt;
&lt;p&gt;Also, I see where the syntax choices came from in both, and while I slightly prefer Rust’s, I think both make reasonably good sense; Swift’s will understandably be more familiar to C and ObjC programmers, and that’s a perfectly defensible approach. Seen that way, it is expanding on the C-style construct (even if it’s actually doing something substantially more sophisticated than that under the hood by being a form of actual pattern matching).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 04 Sep 2015 22:59:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-04:/2015/rust-and-swift-i.html</guid><category>listicles</category><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>High- and Low-Level Programming Languages</title><link>http://www.chriskrycho.com/2015/high-and-low-level-programming-languages.html</link><description>&lt;p&gt;It occurred to me while listening to &lt;a href="https://edwinb.wordpress.com"&gt;Edwin Brady&lt;/a&gt; talk about &lt;a href="http://www.idris-lang.org"&gt;Idris&lt;/a&gt; on the &lt;a href="http://typetheorypodcast.com"&gt;Type Theory Podcast&lt;/a&gt;,&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; having just spent a few weeks starting to learn &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;: “low-level” has at least two meanings in software. One is whether something has manual memory management or is garbage collected, reference counted, or otherwise manages memory itself. This is what people often mean when they talk about C, C++, etc. as being “low-level” and languages like Python or Ruby or C♯ being high-level.&lt;/p&gt;
&lt;p&gt;But then you toss in a language like &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;, and things start to get a little more complicated. Rust can do the same kind of direct memory management that makes C or C++ a good language for things like writing operating system kernels. [&lt;a href="https://github.com/torvalds/linux"&gt;1&lt;/a&gt;,&lt;a href="https://en.wikipedia.org/wiki/Architecture_of_Windows_NT"&gt;2&lt;/a&gt;,&lt;a href="http://www.opensource.apple.com/source/xnu/xnu-2782.10.72/"&gt;3&lt;/a&gt;] But it is also memory-safe, at least in ordinary usage. Like C♯, you have to be explicit about any unsafe code, with the &lt;code&gt;unsafe&lt;/code&gt; keyword on any blocks that do memory management that isn’t safe. And the vast majority of Rust code &lt;em&gt;is&lt;/em&gt; safe.&lt;/p&gt;
&lt;p&gt;More than that, though, Rust &lt;em&gt;feels&lt;/em&gt; like a high-level language. It gives you higher-kinded functions, generics, traits-based composition of types, hygienic macros, and the implementation of many important parts the essentials of the language in the library. If you need to patch something, or extend something, you can do that in a straightforward way. In short, it gives you lots of good abstractions like you would expect in a high-level language.&lt;/p&gt;
&lt;p&gt;Rust is low-level in that you can write (and people are writing) systems-level programs in it. It is high-level in that it lets you express things in ways normally associated with languages like Haskell or OCaml or Python or Ruby. To put it simply: it’s &lt;em&gt;low-level&lt;/em&gt; in its ability to address the computer, and &lt;em&gt;high-level&lt;/em&gt; in the abstractions it hands to a programmer. That’s a powerful combination, and I hope more languages embrace it in the years to come.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Yes, I know that’s insanely nerdy. What did you expect?&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Aug 2015 20:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-08-07:/2015/high-and-low-level-programming-languages.html</guid><category>programming languages</category><category>rust</category><category>python</category><category>ruby</category><category>c</category><category>cplusplus</category></item></channel></rss>