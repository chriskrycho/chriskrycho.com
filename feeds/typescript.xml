<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - TypeScript</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Thu, 20 Dec 2018 18:45:00 -0500</lastBuildDate><item><title>JavaScript is C</title><link>http://www.chriskrycho.com/2018/javascript-is-c.html</link><description>&lt;p&gt;&lt;i&gt;&lt;b&gt;&lt;a href="https://www.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience:&lt;/a&gt;&lt;/b&gt; software developers, especially those interested in modern, typed programming languages.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Earlier this week, I was working on a problem in the Ember app where I spend most of my day job, and realized: &lt;i&gt;JavaScript is the same as C.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;That probably doesn’t make any sense, so let’s back up. The scenario I was dealing with was one where there was a bit of invariant around a piece of data that I &lt;em&gt;had&lt;/em&gt; to maintain for the application not to blow up in horrible ways, but had no good way to enforce with the language’s tools. &lt;em&gt;This&lt;/em&gt; action on &lt;em&gt;that&lt;/em&gt; piece of data was only valid if &lt;em&gt;this&lt;/em&gt; condition held true… but even with the fully-type-checked TypeScript application we now have, the action (because of the entire application’s architecture and indeed the entire way that Ember apps are wired together!) could not be statically verified to be safe.&lt;/p&gt;
&lt;p&gt;As I considered the best way to handle this—I ended up having the function involved in the action just throw an error if the invariant wasn’t properly maintained—I was reminded of the years I spent writing C. In C, it’s quite &lt;em&gt;possible&lt;/em&gt; to write safe code around memory management. I managed it fine in the applications I worked on, by carefully documenting the invariants a given function required to be safe. &lt;em&gt;This&lt;/em&gt; piece of data is allocated by &lt;em&gt;that&lt;/em&gt; function and then released to &lt;em&gt;the caller&lt;/em&gt; to manage. Even with every bit of static analysis I threw at those kinds of things, it was possible to get it wrong.&lt;/p&gt;
&lt;p&gt;The exact same kinds of problems I had in C, I have in JavaScript or even TypeScript today. Experientially, JavaScript&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; &lt;em&gt;is&lt;/em&gt; C, as far as having to deal with these kinds of invariants goes.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enter &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;: the kinds of management of memory that I was always having to keep track of in my head (or, better, with detailed documentation comments along the way—but with the same problem that it was easy to get wrong), I could now have statically guaranteed by a compiler. Given that I spent the first six years of my career managing and carefully tracking all of that by hand, it’s no wonder I &lt;a href="https://newrustacean.com"&gt;fell in love&lt;/a&gt; with Rust. I could have the &lt;em&gt;compiler&lt;/em&gt; guarantee the invariants I needed around memory management.&lt;/p&gt;
&lt;p&gt;And it turns out, this same dynamic exists in the world of front-end web development. People sometimes wonder why (and colleagues are often bemused that) I get so excited by &lt;a href="https://elm-lang.org"&gt;Elm&lt;/a&gt;. But the step from JavaScript (or even TypeScript) to Elm is just like the step from C to Rust. It’s a real and profound shift in what kinds of things you can &lt;em&gt;know for certain&lt;/em&gt; about your program.&lt;/p&gt;
&lt;p&gt;In a C application, try as hard as I may, at the end of the day I am always on my own, making sure the invariants I need for memory safety hold. In a JavaScript or TypeScript application, try as hard as I may, at the end of the day I am always on my own, making sure the invariants I need for state management hold.&lt;/p&gt;
&lt;p&gt;In Rust, I can be 100% confident that I will not have memory-unsafe code. Not 98%-and-I’d-better-check-those-last-2%-really-closely. One hundred percent. That’s a game-changer.&lt;/p&gt;
&lt;p&gt;In Elm, I can be 100% confident that I will not have code which needs a given invariant about a piece of state to hold break the way it could in this TypeScript application. Because I can’t even apply the relevant transformations in question if it isn’t! That’s a game-changer.&lt;/p&gt;
&lt;p&gt;Neither of those is a guarantee I won’t have bugs. (A compiler that could guarantee that would have to be sentient and far smarter than any human!) Neither of them means I can’t intentionally do stupid things that violate invariants in ways that get the program into broken states from the user’s point of view. But both of them give me the tools and the confidence that I can absolutely guarantee that certain, very important kinds of invariants hold. We’re not looking for an absence of all bugs or a system which can prevent us from making any kind of mistake. We’re looking to be able to spend our times on the things that matter, &lt;em&gt;not&lt;/em&gt; on minutiae the computer can check for us.&lt;/p&gt;
&lt;p&gt;So: I’m not going back to C, and I’m ready to move past JavaScript and TypeScript.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This goes for plenty of languages that aren’t JavaScript, too. It’s equally true of c&lt;sup&gt;♯&lt;/sup&gt; or Python.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Obviously there are some kinds of things you don’t have to worry about in JS that you do in C: memory management, for one. The point is that the manual-verification-of-every-invariant-you-care-about is the same.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 20 Dec 2018 18:45:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-12-20:/2018/javascript-is-c.html</guid><category>JavaScript</category><category>TypeScript</category><category>Elm</category><category>Rust</category><category>C</category><category>software development</category></item><item><title>Internal and External Parameter Names in JavaScript and TypeScript</title><link>http://www.chriskrycho.com/2018/internal-and-external-parameter-names-in-javascript-and-typescript.html</link><description>&lt;p&gt;Earlier this month I was working on a fairly thorny problem for work—taking a total value and splitting it into numbers which summed up to it, possibly including with a rule about what the split-up values had to be a multiple of. E.g. you want to order 50 Buffalo wings, and you have to choose the flavors for the wings in increments of 5.&lt;/p&gt;
&lt;p&gt;I spent a lot of time thinking about the implementation of the algorithm for that, but I also spent a lot of time thinking about what its &lt;abbr&gt;API&lt;/abbr&gt; should look like. Here, it’s the latter I want to dive into (the former is a little tricky but not all that interesting).&lt;/p&gt;
&lt;p&gt;I started out with just simple parameters to the function:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function splitNicely(
  total: number, components: number, factor?: number
): number {
  // the implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is nice enough to use internally. But calling it is pretty confusing:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const result = splitNicely(50, 5, 2);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which number is what value here? Who knows!&lt;/p&gt;
&lt;p&gt;So then I just exposed &lt;em&gt;all&lt;/em&gt; of the items as an options hash:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;interface SplitArgs {
  total: number;
  components: number;
  factor?: number;
}

function splitNicely(
  { total, components, factor }: SplitArgs
): number {
  // the implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This was a lot nicer to call:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;splitNicely({ total: 50, components: 5, factor: 2 });&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, it was a bit verbose, and I realized that it’s fairly obvious that the first argument should be the value we’re splitting up, so I simplified a bit:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;interface SplitArgs {
  components: number;
  factor?: number;
}

function splitNicely(
  total: number,
  { components, factor }: SplitArgs
): number {
  // the implementation
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now calling it read &lt;em&gt;relatively&lt;/em&gt; well:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;splitNicely(10, { components: 5, factor: 2 });&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the names were not my favorite for invoking the function. Really, what I wanted was for the function invocation to describe what I was doing, when reading it from the outside—while having these useful names for operating on the implementation internally.&lt;/p&gt;
&lt;p&gt;At this point, I remembered two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Swift and Objective-C have the nice notion of internal and external parameter names.&lt;/li&gt;
&lt;li&gt;JavaScript (and thus TypeScript) let you rename values in “destructuring assignment.”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second one lets us get the same basic effect in JavaScript or TypeScript as we get in Swift, if we’re using an options argument! Here’s how destructuring works in the function definition. Let’s see it first with just JavaScript. The object passed as a parameter has a key named &lt;code&gt;of&lt;/code&gt;, which has a string value—but &lt;code&gt;of&lt;/code&gt; is a bad name inside the function; there, we can just call it &lt;code&gt;str&lt;/code&gt; and it’s perfectly clear.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function length({ of: str }) {
  return str.length;
}

console.log(length({ of: &amp;quot;waffles&amp;quot; }));  // 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s the equivalent of a function that looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function length({ of }) {
  const str = of;
  return str.length
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the same code but in TypeScript:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function length({ of: str }: { of: string }): number {
  return str.length;
}

console.log(length({ of: &amp;quot;waffles&amp;quot; }));  // 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a big more annoying to write out in TypeScript, because we need to supply the type of the whole object after the object we’ve destructured, but the effect is the same once we get past the declaration. It’s also pretty silly to do this kind of thing at all in this example—but it becomes much more useful in more complicated functions, like the one that motivated me to explore this in the first place.&lt;/p&gt;
&lt;p&gt;Recall that I &lt;em&gt;liked&lt;/em&gt; having &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;factor&lt;/code&gt; as the internal names. They weren’t great for &lt;em&gt;calling&lt;/em&gt; the function, though. After some consideration, I decided invoking the function should look like this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;splitNicely(10, { into: 5, byMultiplesOf: 2 });&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By using the destructuring technique, we can get exactly this, while keeping &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;factor&lt;/code&gt; internally:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;interface SplitArgs = {
  into: number;
  byMultiplesOf?: number;
}

function splitNicely(
  total: number,
  { into: components, byMultiplesOf: factor }: SplitArgs
): number {
  // the implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a great pattern to put in your toolbox. You can of course overdo it with this, as with any technique, but it’s a nice tool for these kinds of cases where you really want to make an expressive &lt;abbr&gt;API&lt;/abbr&gt; for both callers and the internal implementation of a function.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 26 Nov 2018 20:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-11-26:/2018/internal-and-external-parameter-names-in-javascript-and-typescript.html</guid><category>javascript</category><category>typescript</category><category>swift</category><category>software development</category></item><item><title>ember-cli-typescript v2 beta</title><link>http://www.chriskrycho.com/2018/ember-cli-typescript-v2-beta.html</link><description>&lt;p&gt;A few weeks ago, the Typed Ember team published the first beta releases of &lt;code&gt;ember-cli-typescript&lt;/code&gt; v2 (currently at beta 3). The new version brings much faster and more reliable builds, with nicer error reporting to boot.&lt;/p&gt;
&lt;p&gt;In this post:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#testing-the-upgrade"&gt;Testing the Upgrade&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#under-the-hood"&gt;Under the Hood&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="testing-the-upgrade" class="level2"&gt;
&lt;h2&gt;Testing the Upgrade&lt;/h2&gt;
&lt;p&gt;I emphasize: &lt;strong&gt;&lt;em&gt;this is a beta release.&lt;/em&gt;&lt;/strong&gt; We have tested it in two large apps (including the one I work on every day) and a number of addons, and it seems to work correctly, but that does &lt;em&gt;not&lt;/em&gt; mean it is ready for production. We need your help to &lt;em&gt;get&lt;/em&gt; it ready for production. Accordingly, please &lt;em&gt;do&lt;/em&gt; test it in your apps, and please &lt;em&gt;do not&lt;/em&gt; run it in production! (If you do, and something breaks, we will not feel bad for you! You have been warned!)&lt;/p&gt;
&lt;p&gt;This upgrade &lt;em&gt;requires&lt;/em&gt; that you be using Babel 7. As such, we suggest you start by doing that upgrade:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;ember install ember-cli-babel@7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There may be a couple things you find different with your app with Babel 7, so resolve those first. Then, and only then, upgrade &lt;code&gt;ember-cli-typescript&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To test the &lt;code&gt;ember-cli-typescript&lt;/code&gt; v2 beta in an app:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;ember install ember-cli-typescript@beta&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To test it in an addon:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;ember install ember-cli-typescript@beta --save&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(This will add the addon to your addon’s runtime dependencies, not just its development-time dependencies, which is necessary because of the changes we made to how the build pipeline works. See &lt;a href="#under-the-hood"&gt;below&lt;/a&gt; for details.)&lt;/p&gt;
&lt;p&gt;Then run your test suite and poke around! Note that on your first run, there are &lt;em&gt;almost certainly&lt;/em&gt; going to be some things that break. In both of the large apps this has been tested in, there were a number of small changes we had to make to get everything working again. (We’re marking this as a breaking &lt;a href="http://www.semver.org/spec/v2.0.0.html"&gt;semver&lt;/a&gt; change for a reason!)&lt;/p&gt;
&lt;p&gt;In general, most apps will only have a few places they need to make changes, but because a certain kind of imports are included in the things affected, you may see your test suite explode. Don’t panic! You will probably make a couple a couple changes and see everything go back to working again.&lt;/p&gt;
&lt;p&gt;Here are the changes you need to know about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We now build the application using Babel 7’s TypeScript plugin. This has a few important limitations—some of them bugs (linked below); others are conscious decisions on the part of Babel. The changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;const enum&lt;/code&gt; types are unsupported. You should switch to constants or regular &lt;code&gt;enum&lt;/code&gt; types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;trailing commas after rest function parameters (&lt;code&gt;function foo(...bar[],) {}&lt;/code&gt;) are disallowed by the ECMAScript spec, so Babel also disallows them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;re-exports of types have to be disambiguated to be &lt;em&gt;types&lt;/em&gt;, rather than values. Neither of these will work:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;export { FooType } from &amp;#39;foo&amp;#39;;
import { FooType } from &amp;#39;foo&amp;#39;;
export { FooType };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In both cases, Babel attempts to emit a &lt;em&gt;value&lt;/em&gt; export, not just a &lt;em&gt;type&lt;/em&gt; export, and fails because there is no actual value to emit. You can do this instead as a workaround:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import * as Foo from &amp;#39;foo&amp;#39;;
export type FooType = Foo.FooType;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Other bugs you should be aware of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If an enum has a member with the same name as an imported type (&lt;a href="https://github.com/babel/babel/issues/8881"&gt;babel/babel#8881&lt;/a&gt;), it will fail to compile.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; types in ES5 getters and setters do not work (&lt;a href="https://github.com/babel/babel/issues/8069"&gt;babel/babel#8069&lt;/a&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Destructuring of parameters in function signatures currently do not work (&lt;a href="https://github.com/babel/babel/issues/8099"&gt;babel/babel#8099&lt;/a&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ember-cli-typescript&lt;/code&gt; must be in &lt;code&gt;dependencies&lt;/code&gt; instead of &lt;code&gt;devDependencies&lt;/code&gt; for addons, since we now hook into the normal Broccoli + Babel build pipeline instead of doing an end-run around it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Addons can no longer use &lt;code&gt;.ts&lt;/code&gt; in app, because an addon’s &lt;code&gt;app&lt;/code&gt; directory gets merged with and uses the &lt;em&gt;host’s&lt;/em&gt; (i.e. the other addon or app’s) preprocessors, and we cannot guarantee the host has TS support. Note that everything will continue to work for in-repo addons because of the app build works with the host’s (i.e. the app’s, not the addon’s) preprocessors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apps need to use &lt;code&gt;.js&lt;/code&gt; for addon overrides in the &lt;code&gt;app&lt;/code&gt; directory, since the different file extension means apps no longer consistently “win” over addon versions (a limitation of how Babel + app merging interact)—note that this won’t be a problem with Module Unification apps.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That’s it. Again, please test it out in your app and &lt;a href="https://github.com/typed-ember/ember-cli-typescript/issues/new/choose"&gt;report any issues&lt;/a&gt; you find!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="under-the-hood" class="level2"&gt;
&lt;h2&gt;Under the Hood&lt;/h2&gt;
&lt;p&gt;In the 1.x series of releases, we used TypeScript’s own build tooling, including its &lt;code&gt;--watch&lt;/code&gt; setting, and then fed the results of that into Ember’s build pipeline. We made this work, but it was pretty fragile. Worse, it was &lt;em&gt;slow&lt;/em&gt;, because we had to compile your code twice: once with TypeScript, and once with Babel in the normal Ember &lt;abbr&gt;CLI&lt;/abbr&gt; pipeline.&lt;/p&gt;
&lt;p&gt;In v2, we’re &lt;a href="https://blogs.msdn.microsoft.com/typescript/2018/08/27/typescript-and-babel-7/"&gt;now able&lt;/a&gt; to use Babel to do the actual &lt;em&gt;build&lt;/em&gt; of your TypeScript code, while using the TypeScript compiler in parallel to type-check it. This meant we were able to throw away most of that fragile custom code wiring TypeScript and Ember &lt;abbr&gt;CLI&lt;/abbr&gt;’s file-watching and build pipelines together, so it’s much less fragile. And of course it’s much &lt;em&gt;faster&lt;/em&gt;. What’s more, because Babel 7 is itself substantially faster than Babel 6 was, build times see an even &lt;em&gt;larger&lt;/em&gt; speedup.&lt;/p&gt;
&lt;p&gt;While we were at it, we added some extra nice error reporting for your type errors:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://user-images.githubusercontent.com/108688/47465007-19687d80-d7b9-11e8-8541-395ad82ceb67.gif" title="build errors" alt="An example of TypeScript build errors in an Ember app" /&gt;&lt;figcaption&gt;An example of TypeScript build errors in an Ember app&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;These changes are why the addon is now back to being part of the runtime dependencies for addons. In the 1.x series, we did a complicated dance to make sure you could use TypeScript in an addon without burdening consumers with the full size of each distinct version of the TypeScript compiler in use by addons they consumed. (For more on that, see &lt;a href="https://www.chriskrycho.com/2018/announcing-ember-cli-typescript-110.html#addon-development"&gt;my blog post on the 1.1 release&lt;/a&gt;.) We still want to keep that commitment, and we do: TypeScript is only a dev dependency. &lt;code&gt;ember-cli-typescript&lt;/code&gt;, however, is a full dependency for addons, because we’re just part of the regular Babel/Ember &lt;abbr&gt;CLI&lt;/abbr&gt; pipeline now! We play exactly the same role that other Babel transforms in the Ember ecosystem do, including e.g. the &lt;a href="https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill"&gt;modules &lt;abbr&gt;API&lt;/abbr&gt; polyfill&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In short, this update simplifies our internals &lt;em&gt;and&lt;/em&gt; makes your experience as a developer better. That’s about as good an outcome as we could hope for. We as a team have been thinking through this for quite some time—ever since we learned that Babel 7 was &lt;a href="https://github.com/facebook/create-react-app/pull/4837"&gt;adding TypeScript support&lt;/a&gt;—but the actual implementation was almost all &lt;a href="https://twitter.com/__dfreeman"&gt;Dan Freeman&lt;/a&gt;’s excellent work, so say thank you to him if you get a chance!&lt;/p&gt;
&lt;p&gt;We’re eager to get it to a production-ready state, so please test it!&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 19 Nov 2018 21:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-11-19:/2018/ember-cli-typescript-v2-beta.html</guid><category>ember.js</category><category>typescript</category><category>ember-cli-typescript</category><category>open-source software</category></item><item><title>True Myth 2.2</title><link>http://www.chriskrycho.com/2018/true-myth-22.html</link><description>&lt;p&gt;I just released v2.2&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; of True Myth, with two new pairs of helpers to deal with &lt;a href="#safe-java-script-object-property-lookup"&gt;safe JavaScript object property lookup with &lt;code&gt;Maybe&lt;/code&gt;s&lt;/a&gt; and &lt;a href="#handling-exception-throwing-functions"&gt;handling exception-throwing code with &lt;code&gt;Result&lt;/code&gt;s&lt;/a&gt;.&lt;/p&gt;
&lt;section id="safe-javascript-object-property-lookup" class="level2"&gt;
&lt;h2&gt;Safe JavaScript object property lookup&lt;/h2&gt;
&lt;p&gt;We often deal with &lt;em&gt;optional properties&lt;/em&gt; on JavaScript objects, and by default JavaScript just gives us &lt;code&gt;undefined&lt;/code&gt; if a property doesn’t exist on an object and we look it up:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;type Person = {
  name?: string;
};

let me: Person = { name: &amp;#39;Chris&amp;#39; };
console.log(me.name); // Chris

let anonymous: Person = {};
console.log(anonymous.name); // undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can already work around that with &lt;code&gt;Maybe.of&lt;/code&gt;, of course:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function printName(p: Person) {
  let name = Maybe.of(p.name);
  console.log(name.unwrapOr(&amp;#39;&amp;lt;anonymous&amp;gt;&amp;#39;));
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this is a &lt;em&gt;really&lt;/em&gt; common pattern! &lt;code&gt;Maybe.property&lt;/code&gt; is a convenience method for dealing with this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function printName(p: Person) {
  let name = Maybe.property(&amp;#39;name&amp;#39;, p);
  console.log(name.unwrapOr(&amp;#39;&amp;lt;anonymous&amp;gt;&amp;#39;));
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At first blush, this might be a head-scratcher: after all, it’s actually slightly &lt;em&gt;longer&lt;/em&gt; than doing it with &lt;code&gt;Maybe.of&lt;/code&gt;. However, it ends up showing its convenience when you’re using the curried form in a functional pipeline. For example, if we had a &lt;em&gt;list&lt;/em&gt; of people, and wanted to get a list of just the people’s names (ignoring anonymous people), we might do this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function justNames(people: Person[]): string[] {
  return people
    .map(Maybe.property(&amp;#39;name&amp;#39;))
    .filter(Maybe.isJust)
    .map(Just.unwrap);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another common scenario is dealing with the same kind of lookup, but in the context of a &lt;code&gt;Maybe&lt;/code&gt; of an object. Prior to 2.2.0, we could do this with a combination of &lt;code&gt;Maybe.of&lt;/code&gt; and &lt;code&gt;andThen&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function getName(maybePerson: Maybe&amp;lt;Person&amp;gt;): string {
  return maybePerson.andThen(p =&amp;gt; Maybe.of(p.name));
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is harder to compose than we might like, and we &lt;em&gt;can’t&lt;/em&gt; really write it in a “point free” style, even if that’s more convenient. We also end up repeating the &lt;code&gt;andThen&lt;/code&gt; invocation every time we go down a layer if we have a more deeply nested object than this. Accordingly, 2.2.0 also adds another convenience method for dealing with deeply nested lookups on objects in a type-safe way: &lt;code&gt;Maybe.get&lt;/code&gt; (and the corresponding instance methods).&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;// Function version:
function getNameFn(maybePerson: Maybe&amp;lt;Person&amp;gt;): string {
  return Maybe.get(&amp;#39;name&amp;#39;, maybePerson);
}

// Method version
function getNameM(maybePerson: Maybe&amp;lt;Person&amp;gt;): string {
  return maybePerson.get(&amp;#39;name&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, since the function version is curried, we can use this to create other little helper functions along the way:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const getName = Maybe.get(&amp;#39;name&amp;#39;);

function getAllNames(people: Maybe&amp;lt;Person&amp;gt;[]): string[] {
  return people
    .map(getName)
    .filter(Maybe.isJust)
    .map(Just.unwrap);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if our object is a deeper type:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;type ComplicatedPerson = {
  name?: {
    first?: string;
    last?: string;
  };
};

let none: Maybe&amp;lt;ComplicatedPerson&amp;gt; = Maybe.nothing();
console.log(none.get(&amp;#39;name&amp;#39;).toString());
// Nothing
console.log(none.get(&amp;#39;name&amp;#39;).get(&amp;#39;first&amp;#39;).toString());
// Nothing

let nameless: Maybe&amp;lt;ComplicatedPerson&amp;gt; = Maybe.just({});
console.log(nameless.get(&amp;#39;name&amp;#39;).toString());
// Just([object Object]);
console.log(nameless.get(&amp;#39;name&amp;#39;).get(&amp;#39;first&amp;#39;).toString());
// Nothing

let firstOnly: Maybe&amp;lt;ComplicatedPerson&amp;gt; = Maybe.just({
  name: {
    first: &amp;#39;Chris&amp;#39;,
  },
});
console.log(firstOnly.get(&amp;#39;name&amp;#39;).toString());
// Just([object Object]);
console.log(firstOnly.get(&amp;#39;name&amp;#39;).get(&amp;#39;first&amp;#39;).toString());
// Just(Chris);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in these cases, since the type we’re dealing with is some kind of object with specific keys, if you try to pass in a key which doesn’t existing on the relevant object type, you’ll get a type error. (Or, if you’re using the curried version, if you try to pass an object which doesn’t have that key, you’ll get a type error.) However, we also often use JavaScript objects as &lt;em&gt;dictionaries&lt;/em&gt;, mapping from a key to a value (most often, but not always, a &lt;em&gt;string&lt;/em&gt; key to a specific value type). &lt;code&gt;Maybe.property&lt;/code&gt; and &lt;code&gt;Maybe.get&lt;/code&gt; both work with dictionary types as well.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;type Dict&amp;lt;T&amp;gt; = { [key: string]: T };

let ages: Dict&amp;lt;number&amp;gt; = {
  &amp;#39;chris&amp;#39;: 31,
};

console.log(Maybe.property(&amp;#39;chris&amp;#39;, ages)); // Just(31)
console.log(Maybe.property(&amp;#39;joe&amp;#39;, ages)); // Nothing

let maybeAges: Maybe&amp;lt;Dict&amp;lt;number&amp;gt;&amp;gt; = Maybe.of(ages);
console.log(ages.get(&amp;#39;chris&amp;#39;)); // Just(31)
console.log(ages.get(&amp;#39;joe&amp;#39;)); // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hopefully you’ll find these helpful! I ran into the motivating concerns for them pretty regularly in the codebase I work with each day, so I’m looking forward to integrating them into that app!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="handling-exception-throwing-functions" class="level2"&gt;
&lt;h2&gt;Handling exception-throwing functions&lt;/h2&gt;
&lt;p&gt;The other big additions are the &lt;code&gt;Result.tryOr&lt;/code&gt; and &lt;code&gt;Result.tryOrElse&lt;/code&gt; functions. Both of these help us deal with functions which throw exceptions. Since JavaScript doesn’t have any &lt;em&gt;native&lt;/em&gt; construct like &lt;code&gt;Result&lt;/code&gt;, idiomatic JavaScript &lt;em&gt;does&lt;/em&gt; often throw exceptions. And that can be frustrating you want to have a value type like a &lt;code&gt;Result&lt;/code&gt; to deal with instead.&lt;/p&gt;
&lt;p&gt;Sometimes, you don’t care &lt;em&gt;what&lt;/em&gt; the exception was; you just want a default value (or a value constructed from the local state of your program, but either way just one value) you can use as the error to keep moving along through your program. In that case, you wrap a function which throws an error in &lt;code&gt;Result.tryOr&lt;/code&gt;. Let’s assume we have a function either returns a number of throws an error, which we’ll just call &lt;code&gt;badFunction&lt;/code&gt; because the details here don’t really matter.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const err = &amp;#39;whoops! something went wrong!&amp;#39;;
const result = Result.tryOr(err, badFunction());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;result&lt;/code&gt; value has the type &lt;code&gt;Result&amp;lt;number, string&amp;gt;&lt;/code&gt;. If &lt;code&gt;badFunction&lt;/code&gt; through an error, we have an &lt;code&gt;Err&lt;/code&gt; with the value &lt;code&gt;'whoops! something went wrong!'&lt;/code&gt; in it. If it &lt;em&gt;didn’t&lt;/em&gt; throw an error, we have an &lt;code&gt;Ok&lt;/code&gt; with the number returned from &lt;code&gt;badFunction&lt;/code&gt; in it. Handy!&lt;/p&gt;
&lt;p&gt;Of course, we often want to &lt;em&gt;do something&lt;/em&gt; with the exception that gets thrown. For example, we might want to log an error to a bug-tracking service, or display a nice message to the user, or any number of other things. In that case, we can use the &lt;code&gt;Result.tryOrElse&lt;/code&gt; function. Let’s imagine we have a function &lt;code&gt;throwsHelpfulErrors&lt;/code&gt; which returns a &lt;code&gt;number&lt;/code&gt; or does just what it says on the tin: it throws a bunch of different kinds of errors, which are helpfully distinct and carry around useful information with them. Note that the type of the error-handling callback we pass in is &lt;code&gt;(error: unknown) =&amp;gt; E&lt;/code&gt;, because JS functions can throw &lt;em&gt;anything&lt;/em&gt; as their error.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const handleErr = (e: unknown): string =&amp;gt; {
  if (e instanceof Error) {
    return e.message;
  } else if (typeof e === &amp;#39;string&amp;#39;) {
    return e;
  } else if (typeof e === &amp;#39;number&amp;#39;) {
    return `Status code: ${e}`;
  } else {
    return &amp;#39;Unknown error&amp;#39;;
  }
}

const result = Result.tryOrElse(handleErr, throwsHelpfulErrors);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, &lt;code&gt;result&lt;/code&gt; is once again a &lt;code&gt;Result&amp;lt;number, string&amp;gt;&lt;/code&gt;, but the error side has whatever explanatory information the exception provided to us, plus some massaging we did ourselves. This is particularly handy for converting exceptions to &lt;code&gt;Result&lt;/code&gt;s when you have a library which uses exceptions extensively, but in a carefully structured way. (You could, in fact, just use an identity function to return whatever error the library throws—as long as you write your types carefully and accurately as a union of those error types for the &lt;code&gt;E&lt;/code&gt; type parameter! However, doing that would require you to explicitly opt into the use of &lt;code&gt;any&lt;/code&gt; to write it as a simple identity function, so I’m not sure I’d &lt;em&gt;recommend&lt;/em&gt; it. If you go down that path, do it with care.)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;And that’s it for True Myth 2.2! Enjoy, and of course please &lt;a href="https://github.com/true-myth/true-myth/issues"&gt;open an issue&lt;/a&gt; if you run into any bugs!&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href="https://github.com/bmakuh"&gt;Ben Makuh&lt;/a&gt; for implementing &lt;code&gt;Result.tryOr&lt;/code&gt; and &lt;code&gt;Result.tryOrElse&lt;/code&gt;. Thanks to Ben and also &lt;a href="https://github.com/tansongyang"&gt;Frank Tan&lt;/a&gt; for helpful input on the &lt;code&gt;Maybe.get&lt;/code&gt; and &lt;code&gt;Maybe.property&lt;/code&gt; &lt;abbr&gt;API&lt;/abbr&gt; design!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I published both &lt;code&gt;2.2.0&lt;/code&gt; and &lt;code&gt;2.2.1&lt;/code&gt;, because once again I missed something along the way. This time it was making sure all the new functions were optionally curried to support partial application.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 27 Oct 2018 17:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-10-27:/2018/true-myth-22.html</guid><category>typescript</category><category>true myth</category><category>open source software</category><category>functional programming</category></item><item><title>A Real Victory</title><link>http://www.chriskrycho.com/2018/a-real-victory.html</link><description>&lt;p&gt;On September 29, 2016, I started working on adding (&lt;a href="https://flow.org"&gt;Flow&lt;/a&gt;) types to the &lt;a href="https://emberjs.com"&gt;Ember&lt;/a&gt; app I had been working on since the start of the year. Throughout the rest of the year I worked on adding some basic Flow types to our app and for Ember. For my last commit in 2016, I switched us to TypeScript and began the rest of the long journey to fully type-checking our app. In early 2018, we made it to “the app type-checks”… in the loosest strictness settings.&lt;/p&gt;
&lt;p&gt;And as of 6pm today—September 5, 2018, almost two full years later, and 21 months after we switched from Flow to TypeScript (more on this below)—we have a fully type-checked TypeScript Ember application, with the strictness notches dialed as strict as they will go.&lt;/p&gt;
&lt;p&gt;It took almost two full years for us to get there, and I’m incredibly proud of that work.&lt;/p&gt;
&lt;p&gt;It took almost two full years because it was a lot of work, and slow work to do at that, and it was rare that I could block out any large chunks of time for that work—we had to sneak in improvements between features we were working urgently on for our clients and our own internally goals. More, it wasn’t just the work of adding types to our application. It was also the work of writing types for Ember itself, and for the surrounding ecosystem—which thankfully I did not finish alone, but which I did have to start alone. It was the work of integrating (and reintegrating) TypeScript into Ember’s build pipeline.&lt;/p&gt;
&lt;p&gt;Happily, I did &lt;em&gt;not&lt;/em&gt; do most of that work alone, and even on our app I’ve had a ton of help getting the types in place. But it has been a massive task, and finishing it today was a real victory. It’s not perfect. We have 200-or-so instances of &lt;code&gt;any&lt;/code&gt; in the application (most of them in semi-legitimate places, to be fair), and I wish it were more like 20. We have a number of places in the app with the &lt;code&gt;!&lt;/code&gt; “I promise this isn’t &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; here” operator on some nullable field, with long comments explaining &lt;em&gt;why&lt;/em&gt; it’s not possible for it to be null there.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But it type-checks today, and type errors fail the builds, and that &lt;em&gt;is&lt;/em&gt; a real victory.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;You can consider this “part 1” of my thoughts on what feels to me like a pretty significant achievement. I’ll hopefully follow this up with some backstory sometime in the next few weeks.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;See my &lt;a href="https://www.chriskrycho.com/2018/type-informed-design.html"&gt;recent post&lt;/a&gt; on thinking a lot about design decisions I would have made differently with TypeScript’s strict null checking available from day one!&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 05 Sep 2018 21:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-09-05:/2018/a-real-victory.html</guid><category>TypeScript</category><category>JavaScript</category><category>Flow</category><category>Ember.js</category><category>software development</category></item><item><title>True Myth 2.1.0 Released</title><link>http://www.chriskrycho.com/2018/true-myth-210-released.html</link><description>&lt;p&gt;I’ve just released True Myth 2.1.0 (&lt;a href="https://github.com/chriskrycho/true-myth/tree/v2.1.0"&gt;source&lt;/a&gt;, &lt;a href="https://true-myth.js.org"&gt;docs&lt;/a&gt;), which includes a handful of new utility functions for use with the &lt;code&gt;Maybe&lt;/code&gt; types and arrays or tuples. Note that to make use of these you’ll need to be on at least TypeScript 3.0: they take advantage of the some of the shiny new features in the type system!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; and, five minutes later, versions 2.1.1 and 2.1.2 are out with bugfixes consisting of “I forgot to export two functions. Now they’re exported.” Because that’s how this &lt;em&gt;always&lt;/em&gt; works, right?&lt;/p&gt;
&lt;p&gt;Here’s what’s new:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.find&lt;/code&gt;:&lt;/strong&gt; for those times when you want to do &lt;code&gt;Array.prototype.find&lt;/code&gt; and would love to not have to wrap up the result with a &lt;code&gt;Maybe&lt;/code&gt; explicitly every time. As with most functions in True Myth, it’s curried so you can easily use it in a functional programming style.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

let foundRegular = Maybe.find(n =&amp;gt; n &amp;gt; 1, [1, 2, 3]);
console.log(foundRegular.toString());  // Just(2)

let notFound = Maybe.find(n = n &amp;lt; 1, [1, 2, 3]);
console.log(notFound.toString());  // Nothing

let findAtLeast5 = Maybe.find((n: number) =&amp;gt; n &amp;gt; 5);
let foundCurried = findAtLeastFive([2, 4, 6, 8, 10]);
console.log(foundCurried.toString());  // Just(6)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.head&lt;/code&gt; (aliased as &lt;code&gt;Maybe.first&lt;/code&gt;):&lt;/strong&gt; for getting the first item of an array safely. Like lodash’s &lt;code&gt;_.head&lt;/code&gt; (or &lt;code&gt;someArray[0]&lt;/code&gt;) but it returns a &lt;code&gt;Maybe&lt;/code&gt; instead of possibly giving you back &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

let empty = Maybe.head([]);
console.log(empty.toString());  // Nothing

let hasItems = Maybe.head([1, 2, 3]);
console.log(hasItems.toString());  // Just(1)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.last&lt;/code&gt;:&lt;/strong&gt; the same as &lt;code&gt;Maybe.head&lt;/code&gt;, but for getting the &lt;em&gt;last&lt;/em&gt; element in an array.&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

let empty = Maybe.last([]);
console.log(empty.toString());  // Nothing

let hasItems = Maybe.last([1, 2, 3]);
console.log(hasItems.toString());  // Just(3)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.all&lt;/code&gt;:&lt;/strong&gt; for converting an array of &lt;code&gt;Maybe&lt;/code&gt;s to a &lt;code&gt;Maybe&lt;/code&gt; of an array. If you have an array whose contents are all &lt;code&gt;Maybe&lt;/code&gt;s, it’s sometimes useful to be able to flip that around so that if all of the items are &lt;code&gt;Just&lt;/code&gt;s, you get back a single &lt;code&gt;Just&lt;/code&gt; wrapping the array of the values which were wrapped in all the &lt;code&gt;Just&lt;/code&gt;s in the array, but if any were &lt;code&gt;Nothing&lt;/code&gt;, the whole thing is a single &lt;code&gt;Nothing&lt;/code&gt;. This works for both heterogeneous and homogenous arrays, which is pretty cool. A code sample will make this a lot clearer:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { just, nothing } from &amp;#39;true-myth/maybe&amp;#39;;

let includesNothing = Maybe.all(just(2), nothing&amp;lt;string&amp;gt;());
console.log(includesNothing.toString());  // Nothing

let allJusts = Maybe.all(just(2), just(&amp;#39;hi&amp;#39;), just([42]));
console.log(allJusts.toString());  // Just([2, &amp;#39;hi&amp;#39;, [42]]);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting type of both &lt;code&gt;includesNothing&lt;/code&gt; and &lt;code&gt;allJusts&lt;/code&gt; here is &lt;code&gt;Maybe&amp;lt;Array&amp;lt;string | number | Array&amp;lt;number&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Maybe.tuple&lt;/code&gt;:&lt;/strong&gt; just like &lt;code&gt;Maybe.all&lt;/code&gt; except it works in tuples (preserving their types’ order) for up to five-item tuples. (As the docs I wrote say: if you’re doing a larger tuple than that I don’t want to know what you’re doing but I won’t help with it!)&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { just, nothing } from &amp;#39;true-myth/maybe&amp;#39;;

type Tuple = [Maybe&amp;lt;number&amp;gt;, Maybe&amp;lt;string&amp;gt;, Maybe&amp;lt;number[]&amp;gt;];

let withNothing: Tuple = [just(2), nothing(), just([42])];
let withNothingResult = Maybe.tuple(withNothing);
console.log(withNothingResult.toString());  // Nothing

let allJusts: Tuple = [just(2), just(&amp;#39;hi&amp;#39;), just([42])];
let allJustsResult = Maybe.tuple(allJusts);
console.log(allJustsResult.toString());  // Just([2, &amp;quot;hi&amp;quot;, [42]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These have the same &lt;em&gt;output&lt;/em&gt; (i.e. the same underlying representation) as the array output, but a different type. The resulting type of both &lt;code&gt;includesNothing&lt;/code&gt; and &lt;code&gt;allJusts&lt;/code&gt; here is &lt;code&gt;Maybe&amp;lt;[number, string, Array&amp;lt;number&amp;gt;]&amp;gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once TypeScript 3.1 is out, I should be able to collapse these into a single &lt;code&gt;all&lt;/code&gt;, and &lt;code&gt;tuple&lt;/code&gt; will just become an alias for it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 02 Sep 2018 16:25:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-09-02:/2018/true-myth-210-released.html</guid><category>TypeScript</category><category>functional programming</category><category>monads</category><category>libraries</category><category>software development</category><category>open source software</category><category>True Myth</category></item><item><title>Type-Informed Design</title><link>http://www.chriskrycho.com/2018/type-informed-design.html</link><description>&lt;p&gt;I’ve been working on getting the Ember app I work on fully type-checked in strict mode this week, and noticed something interesting along the way: there are a lot of design decisions—a few of them really core to the behavior of the app!—which we never, &lt;em&gt;ever&lt;/em&gt; would have made if we had been using Typescript in the first place.&lt;/p&gt;
&lt;p&gt;One of these is pervasive references to certain optional properties that appear in services throughout our app—the basket, for example. These can indeed be inset and at certain times they are. However, many of our components pull in this property from the service and simply assume it’s there to use. We’ve known for a while that this was a problem at times: &lt;a href="https://raygun.com/"&gt;Raygun&lt;/a&gt; has told us loud and clear. But it wasn’t obvious how pervasive this was—and how badly we were just assuming the presence of something that may well be absent &lt;em&gt;all over the app&lt;/em&gt;!—until I saw the type errors from it. Dozens of them.&lt;/p&gt;
&lt;p&gt;Some of them are places where we should have built the components differently: to take the item as an argument, for example, and to require it as an input, because the component just doesn’t make any sense without it, indeed lives in a part of the app such that it’s not even possible to render the component without it.&lt;/p&gt;
&lt;p&gt;And sure, we could document that invariant and use TypeScript’s override tools to carry on. (What do you think I’m doing this week?)&lt;/p&gt;
&lt;p&gt;But, and this is the thing that really caught my attention in thinking about all of this: it would be much better &lt;em&gt;not&lt;/em&gt; to have to do that. Had we had TypeScript in place when we started, we simply would have designed large swaths of the app differently because we’d have seen these kinds of things when we were building it in the first place!&lt;/p&gt;
&lt;p&gt;That’s a bit of wishing for the impossible in one sense: we literally couldn’t have done that when we started on the app, because TS didn’t have the necessary pieces to support typing the Ember libraries. My team helped &lt;em&gt;build&lt;/em&gt; the TS and Ember story over the last 18 months! But at a minimum I have a pretty good idea how the process will be different next time around, with this tool available and providing this kind of helpful design feedback from the outset!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 30 Aug 2018 19:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-08-30:/2018/type-informed-design.html</guid><category>TypeScript</category><category>JavaScript</category><category>functional programming</category><category>types</category><category>software development</category><category>Ember.js</category></item><item><title>Ember.js, TypeScript, and Class Properties</title><link>http://www.chriskrycho.com/2018/ember-ts-class-properties.html</link><description>&lt;p&gt;A few months ago, I wrote a mostly-complete series describing the state of using &lt;a href="https://typescriptlang.org"&gt;TypeScript&lt;/a&gt; with &lt;a href="https://emberjs.com"&gt;Ember&lt;/a&gt; in 2018. I got one &lt;em&gt;very&lt;/em&gt; important thing wrong in that series, and I’m back with the correction!&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In that series, I showed an example of a component definition; it looked like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;
import Computed from &amp;#39;@ember/object/computed&amp;#39;;
import { inject as service } from &amp;#39;@ember/service&amp;#39;;
import { assert } from &amp;#39;@ember/debug&amp;#39;;
import { isNone } from &amp;#39;@ember/utils&amp;#39;;

import Session from &amp;#39;my-app/services/session&amp;#39;;
import Person from &amp;#39;my-app/models/person&amp;#39;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &amp;#39;firstName&amp;#39;)};`;
    }
  );

  aComputed = computed(&amp;#39;aString&amp;#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&amp;#39;session.user&amp;#39;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;#39;session.user&amp;#39;);

  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&amp;#39;aCollection&amp;#39;);
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(value));
    }
  };

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.get(&amp;#39;aCollection&amp;#39;).includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(&amp;#39;ahoy&amp;#39;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem here is all the computed property assignments and the actions hash assignments. The fact that this sample code ever worked at all was… an accident. It wasn’t &lt;em&gt;supposed&lt;/em&gt; to work. I &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html#computed-properties"&gt;noted at the time&lt;/a&gt; that this way of doing things had a performance tradeoff because computed properties ended up installed on every &lt;em&gt;instance&lt;/em&gt; rather than on the &lt;em&gt;prototype&lt;/em&gt;… and as it turns out, that was never intended to work. Only the prototype installation was supposed to work. And as it turns out, the &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0281-es5-getters.md" title="RFC #0281"&gt;&lt;abbr&gt;ES5&lt;/abbr&gt; getters implementation of computed properties&lt;/a&gt; which landed in Ember 3.1 broke every computed property set up this way.&lt;/p&gt;
&lt;p&gt;So if you can’t use class properties for this… how &lt;em&gt;do&lt;/em&gt; you do it? There are two ways: the &lt;code&gt;.extend()&lt;/code&gt; hack I mentioned &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html#computed-properties-1"&gt;previously&lt;/a&gt;, and &lt;a href="http://ember-decorators.github.io/ember-decorators/latest/"&gt;decorators&lt;/a&gt;. (The Ember Decorators docs include a discussion of this topic as well—see &lt;a href="http://ember-decorators.github.io/ember-decorators/latest/docs/class-fields"&gt;their discussion of class fields&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Note that throughout I’m assuming Ember 3.1+ and therefore &lt;abbr&gt;ES5&lt;/abbr&gt; getter syntax (&lt;code&gt;this.property&lt;/code&gt; instead of &lt;code&gt;this.get('property')&lt;/code&gt;).&lt;/p&gt;
&lt;section id="extend" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;.extend()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The first workaround uses &lt;code&gt;.extend()&lt;/code&gt; in conjunction with a class definition. I originally wrote about this approach:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you need the absolute best performance, you can continue to install them on the prototype by doing this instead…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As it turns out, it’s more like “If you want your app to work at all…”&lt;/p&gt;
&lt;p&gt;Here’s how that would look with our full example from above. Note that there are three things which &lt;em&gt;must&lt;/em&gt; go in the &lt;code&gt;.extend()&lt;/code&gt; block with this approach: injections, computed properties, and the &lt;code&gt;actions&lt;/code&gt; hash.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;
import { inject as service } from &amp;#39;@ember/service&amp;#39;;
import { assert } from &amp;#39;@ember/debug&amp;#39;;
import { isNone } from &amp;#39;@ember/utils&amp;#39;;

import Person from &amp;#39;my-app/models/person&amp;#39;;

export default class AnExample extends Component.extend({
  // -- Injections -- //
  session: service(&amp;#39;session&amp;#39;),

    // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel: computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${this.model.firstName};`;
    }
  ),

  aComputed: computed(&amp;#39;aString&amp;#39;, function(this: AnExample): number {
    return this.lookAString.length;
  }),

  isLoggedIn: bool(&amp;#39;session.user&amp;#39;),
  savedUser: alias(&amp;#39;session.user&amp;#39;) as Person,

  actions: {
    addToCollection(this: AnExample, value: string) {
      this.set(&amp;#39;aCollection&amp;#39;, this.aCollection.concat(value));
    }
  },
}) {
  // -- Component arguments -- //
  model!: Person;     // required
  modifier?: string;  // optional, thus the `?`

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.aCollection.includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, this.aCollection.concat(&amp;#39;ahoy&amp;#39;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are three main things to note here.&lt;/p&gt;
&lt;p&gt;First, check out the &lt;code&gt;session('service')&lt;/code&gt; injection. We need the name of the service being injected for TypeScript to be able to resolve the type correctly (which it does by using “type registries,” as discussed briefly &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html#fn1"&gt;in this footnote&lt;/a&gt; in my series earlier this year). The alternative is writing &lt;code&gt;session: service() as Session&lt;/code&gt;—a type cast—which is &lt;em&gt;fine&lt;/em&gt; but isn’t particularly idiomatic TypeScript.&lt;/p&gt;
&lt;p&gt;Second, notice that we do have to use a type cast, &lt;code&gt;as Person&lt;/code&gt;, for the &lt;code&gt;savedUser&lt;/code&gt; definition. While many computed property macros and the &lt;code&gt;computed&lt;/code&gt; helper itself can properly infer the type of the resulting computed property, macros which accept nested keys do not and cannot. Thus, &lt;code&gt;bool&lt;/code&gt; can resolve its type to a &lt;code&gt;boolean&lt;/code&gt;, but &lt;code&gt;readOnly&lt;/code&gt; or &lt;code&gt;alias&lt;/code&gt; have to resolve their type as &lt;code&gt;any&lt;/code&gt;. The value passed to them could be a strangely shaped string key on the local object (&lt;code&gt;['like.a.path']: true&lt;/code&gt;) or an actual path through multiple objects. (This is the same limitation that means we cannot do nested &lt;code&gt;get&lt;/code&gt; lookups.)&lt;/p&gt;
&lt;p&gt;Third, as I noted even when we were doing this the &lt;em&gt;wrong&lt;/em&gt; way, with class field assignment, we need to explicitly specify the type of &lt;code&gt;this&lt;/code&gt; for callback passed in to define the computed properties. In the context of a &lt;code&gt;.extend()&lt;/code&gt; invocation, though, this sometimes falls down. You’ll see an error like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‘AnExample’ is referenced directly or indirectly in its own base expression.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This doesn’t happen for &lt;em&gt;all&lt;/em&gt; computed properties, but it happens often enough to be very annoying—and it &lt;em&gt;always&lt;/em&gt; happens with Ember Concurrency tasks. (More on this &lt;a href="#ember-concurrency"&gt;below&lt;/a&gt;.) This problem was actually the original motivation for my experimentation with assigning computed properties to class fields.&lt;/p&gt;
&lt;p&gt;This set of problems with defining computed properties and injections in an &lt;code&gt;.extend()&lt;/code&gt; invocation is a major motivator for my team in eagerly adopting decorators.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="decorators" class="level2"&gt;
&lt;h2&gt;Decorators&lt;/h2&gt;
&lt;p&gt;The cleaner, but currently still experimental, way to do this is to use Ember Decorators.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; To use these, you should run &lt;code&gt;ember install ember-decorators&lt;/code&gt; and then set the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once you’ve installed the decorators package, you can update your component. In general, the imports match exactly to the Ember module imports, just with &lt;code&gt;@ember-decorators&lt;/code&gt; as the top-level package rather than &lt;code&gt;@ember&lt;/code&gt;. Here’s how our component looks using decorators:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { assert } from &amp;#39;@ember/debug&amp;#39;;
import { isNone } from &amp;#39;@ember/utils&amp;#39;;

import { action, computed } from &amp;#39;@ember-decorators/object&amp;#39;;
import { alias, bool } from &amp;#39;@ember-decorators/object/computed&amp;#39;;
import { service } from &amp;#39;@ember-decorators/service&amp;#39;;

import Session from &amp;#39;my-app/services/session&amp;#39;;
import Person from &amp;#39;my-app/models/person&amp;#39;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model!: Person;     // required
  modifier?: string;  // optional, thus the `?`

  // -- Injections -- //
  @service session: Session;

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  @computed(&amp;#39;model.firstName&amp;#39;)
  get fromModel(): string {
    return `My name is ${this.model.firstName}`;
  }

  @computed(&amp;#39;aString&amp;#39;)
  get aComputed(): number {
    return this.aString.length;
  }

  @bool(&amp;#39;session.user&amp;#39;) isLoggedIn: boolean;
  @alias(&amp;#39;session.user&amp;#39;) savedUser: Person;

  @action
  addToCollection(this: AnExample, value: string) {
    this.set(&amp;#39;aCollection&amp;#39;, this.aCollection.concat(value));
  }

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.aCollection.includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, this.aCollection.concat(&amp;#39;ahoy&amp;#39;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, notice that using decorators switches us to using actual &lt;abbr&gt;ES5&lt;/abbr&gt; getters. This is &lt;em&gt;exactly&lt;/em&gt; the same thing that &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0281-es5-getters.md" title="RFC #0281"&gt;&lt;abbr&gt;RFC&lt;/abbr&gt; #0281&lt;/a&gt; specified, and which was implemented for Ember’s traditional computed property and injection functions in Ember 3.1 to unlock . What’s extra nice, though, is that decorators are backwards compatible &lt;a href="http://ember-decorators.github.io/ember-decorators/latest/docs/stability-and-support#ember-support"&gt;all the way to Ember 1.11&lt;/a&gt;. (You won’t get the &lt;abbr&gt;ES5&lt;/abbr&gt; getters on versions prior to to Ember 3.1—there the decorators &lt;em&gt;just&lt;/em&gt; install things on the prototype—but you will at least get the correct behavior.)&lt;/p&gt;
&lt;p&gt;Second, note that we don’t get type inference for the computed property macros like &lt;code&gt;@bool&lt;/code&gt; here. That’s because decorators are not currently allowed to modify the &lt;em&gt;type&lt;/em&gt; of the thing they’re decorating from TypeScript’s perspective. Now, decorators can—and &lt;em&gt;do&lt;/em&gt;!—modify the type of the thing they decorate at runtime; it’s just that &lt;abbr&gt;TS&lt;/abbr&gt; doesn’t yet capture that. This means that &lt;em&gt;all&lt;/em&gt; decorated fields will still require type annotations, not just a subset as in the &lt;code&gt;.extend()&lt;/code&gt; world. It’s annoying—especially in the case of things like &lt;code&gt;@bool&lt;/code&gt;, where it &lt;em&gt;really&lt;/em&gt; seems like we ought to be able to just tell TypeScript that this means the thing is a boolean rather than writing &lt;code&gt;@bool('dependentKey') someProp: boolean&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This leads us to our final point to notice: we also need the type annotations for service (or controller) injections—but we do &lt;em&gt;not&lt;/em&gt; need the string keys for them service injections.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; The net of this is that the injections themselves roughly equally ergonomic.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;// the old way
session: service(&amp;#39;session&amp;#39;),
// the new way
@service session: Session;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="ember-concurrency" class="level2"&gt;
&lt;h2&gt;Ember Concurrency&lt;/h2&gt;
&lt;p&gt;One other thing I need to draw your attention to here: I and a few others have taken a stab at writing type definitions for &lt;a href="http://ember-concurrency.com/docs/introduction/"&gt;Ember Concurrency&lt;/a&gt;. Unfortunately, typings that &lt;em&gt;type-check&lt;/em&gt; run smack dab into the fact that as of 3.1 that style doesn’t &lt;em&gt;work&lt;/em&gt;; and typings that &lt;em&gt;work&lt;/em&gt; cannot be type-checked at present. You can’t even use decorators to push your way to a solution. Nor is there a lot of hope on the horizon for this reality to change.&lt;/p&gt;
&lt;p&gt;You can see some of the discussion as to &lt;em&gt;why&lt;/em&gt; &lt;a href="https://github.com/machty/ember-concurrency/pull/209#issuecomment-403246551"&gt;starting here&lt;/a&gt; in one pull request for them; it all gets back to the limitation I mentioned above: TypeScript doesn’t let you change the types of things with decorators. Unfortunately, there’s no reason to believe that will change anytime soon. This is a &lt;em&gt;fundamental&lt;/em&gt; conflict between the Ember Object model and modern JavaScript—and specifically TypeScript’s understanding of it.&lt;/p&gt;
&lt;p&gt;I am still mulling over solutions to that problem (as are others), and we’ll be continuing to work on this idea in &lt;a href="https://embercommunity.slack.com/messages/C2F8Q3SK1"&gt;#-topic-typescript&lt;/a&gt; in the Ember Community Slack (and publicizing any good ideas we come up with there in a searchable location, of course). For today, the best thing you can do is explicitly set the &lt;code&gt;this&lt;/code&gt; type to &lt;code&gt;any&lt;/code&gt; for the task property generator function callback, and use type casts internally if you look up services or other properties from the containing object.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="summary-mea-culpa" class="level2"&gt;
&lt;h2&gt;Summary: &lt;em&gt;mea culpa&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Sorry again to everyone I misled along the way with my earlier, very wrong advice! Hopefully this helps clear up the state of things and will help you keep from falling into this tar pit going forward!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I don’t feel too bad about having gotten in wrong: no one who read the posts noticed the problem at the time, and it was subtle and easy to miss… because, at the time, everything actually &lt;em&gt;worked&lt;/em&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;It’s experimental because decorators are still only at Stage 2 in the &lt;abbr&gt;TC39&lt;/abbr&gt; process. They &lt;em&gt;may&lt;/em&gt; advance at this month’s meeting.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;If you’re using a non-default name, like &lt;code&gt;specialSession&lt;/code&gt;, for the name of the property, the usual rules apply for injections. In that case, you’d write the injection like this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { service } from &amp;#39;@ember-decorators/service&amp;#39;;
import Session from &amp;#39;my-app/services/session&amp;#39;;

export default class AnExample extends Component {
  @service(&amp;#39;session&amp;#39;) specialSession: Session;
}&lt;/code&gt;&lt;/pre&gt;
&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Files do get an extra import in the decorator version… but as it happens, I’m more than okay with that; I’d actually &lt;em&gt;prefer&lt;/em&gt; explicit imports of dependencies personally.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 10 Jul 2018 20:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-07-10:/2018/ember-ts-class-properties.html</guid><category>TypeScript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>Sum Type Constructors in TypeScript</title><link>http://www.chriskrycho.com/2018/sum-type-constructors-in-typescript.html</link><description>&lt;p&gt;A pretty common pattern I’ve seen is to have three basic states for some kind of &lt;abbr&gt;HTTP&lt;/abbr&gt; request: &lt;em&gt;loading&lt;/em&gt;, &lt;em&gt;failure&lt;/em&gt;, and &lt;em&gt;success&lt;/em&gt;. Since each of these has its own associated date, it’s a really good fit for a discriminated union or sum type. In a language like Elm (or F&lt;sup&gt;♯&lt;/sup&gt; or Haskell or PureScript or…) you’d write that basically like this:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;module Fetch exposing (State)

type alias HTTPStatusCode = Int
type alias ErrorData = { code: HTTPStatusCode, reason: String }

type State a
    = Loading
    | Failure ErrorData
    | Success a&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because I find that pattern extremely helpful, I’ve at times gone out of my way to replicate it in TypeScript. And what you get is… verbose. It’s a necessary evil, given what TypeScript is doing (layering on top of JavaScript), and so much so that I wouldn’t actually recommend this unless you’re already doing this kind of programming a lot and find it pretty natural. If you are, though, here’s how you get the equivalent of those four lines of Elm in TypeScript:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type HttpStatusCode = number;

export enum Type { Loading, Failure, Success }

export class Loading {
  readonly type: Type.Loading = Type.Loading;

  static new() {
    return new Loading();
  }
}

type ErrorData = { code: HttpStatusCode, reason: string };

export class Failure {
  readonly type: Type.Failure = Type.Failure;
  constructor(readonly value: ErrorData) {}

  static new(value: ErrorData) {
    return new Failure(value);
  }
}

export class Success&amp;lt;T&amp;gt; {
  readonly type: Type.Success = Type.Success;
  constructor(readonly value: T) {}

  static new&amp;lt;A&amp;gt;(value: A) {
    return new Success(value);
  }
}

export type FetchState&amp;lt;T&amp;gt; = Loading | Failure | Success&amp;lt;T&amp;gt;;
export const FetchState = {
  Type,
  Loading,
  Failure,
  Success,
};

export default FetchState;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s a &lt;em&gt;lot&lt;/em&gt; more code to do the same thing. Even if you dropped the static constructors—which you really don’t want to do, because then you can’t use them in a functional style but &lt;em&gt;have&lt;/em&gt; to use &lt;code&gt;new Loading()&lt;/code&gt; or whatever to construct them.&lt;/p&gt;
&lt;p&gt;You can make this work. And I do. And honestly, it’s amazing that TypeScript can do this at all—a real testament to the sophistication of the TypeScript type system and the ingenuity that has gone into it.&lt;/p&gt;
&lt;p&gt;But have I mentioned recently that I’d &lt;em&gt;really&lt;/em&gt; prefer to be writing something like F&lt;sup&gt;♯&lt;/sup&gt; or Elm than TypeScript?&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 31 May 2018 07:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-31:/2018/sum-type-constructors-in-typescript.html</guid><category>elm</category><category>typescript</category><category>programming languages</category></item><item><title>#EmberJS2018, Part 4</title><link>http://www.chriskrycho.com/2018/emberjs2018-part-4.html</link><description>&lt;p&gt;Following &lt;a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html"&gt;the example&lt;/a&gt; of the Rust community, the &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; team has &lt;a href="https://emberjs.com/blog/2018/05/02/ember-2018-roadmap-call-for-posts.html" title="Ember&amp;#39;s 2018 Roadmap: A Call for Blog Posts"&gt;called for blog posts&lt;/a&gt; as the first step in setting the 2018 roadmap (which will formally happen through the normal &lt;a href="https://github.com/emberjs/rfcs"&gt;&lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process&lt;/a&gt;). This is my contribution.&lt;/p&gt;
&lt;p&gt;There are three major themes I think should characterize the Ember.js community and project for the rest of 2018:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-1.html"&gt;&lt;strong&gt;Finishing What We’ve Started&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-2.html"&gt;&lt;strong&gt;Doubling Down on Documentation&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-3.html"&gt;&lt;strong&gt;Defaulting to Public for Discussions&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embracing the Ecosystem&lt;/strong&gt; (this post)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Over the last few weeks, I’ve talked about a few big ideas that I think the Ember.js community should go after in 2018 which will help the framework excel over the next few years. This last one (like Part 3 before it) is more a &lt;em&gt;culture shift&lt;/em&gt; than a matter of &lt;em&gt;things to build&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We need to shift from a posture of defensiveness about Ember.js to one of embracing the ecosystem, and embracing our role in the ecosystem.&lt;/p&gt;
&lt;p&gt;It’s easy to end up in an us-vs.-them mentality when looking at different libraries and frameworks. It’s doubly easy to go there when you often hear “Isn’t Ember dead?” or variations on that theme. We should avoid that way of thinking anyway. And there are three big pieces to this: &lt;em&gt;contributing outwards&lt;/em&gt;, &lt;em&gt;smoothing the paths into Ember&lt;/em&gt; from other ecosystems, and &lt;em&gt;embracing the rest of the ecosystem&lt;/em&gt;.&lt;/p&gt;
&lt;section id="contributing-outwards" class="level3"&gt;
&lt;h3&gt;Contributing outwards&lt;/h3&gt;
&lt;p&gt;There is genuinely great stuff happening all over the place in the front-end, and many of the things we love about working with Ember today have come directly out of e.g. React—hello, “data-down-actions-up”! The same is true in reverse: Ember has contributed many important ideas to the broader front-end ecosystem, from its early emphasis on rigorously linking URLs and application state to helping pioneer and popularize the use of good command line tooling, to more recent emphasis on &lt;em&gt;compilation&lt;/em&gt; as a way of solving certain classes of problems.&lt;/p&gt;
&lt;p&gt;So as we build all of these things, one of the best things to do—and, I believe, one of the ways we help Ember grow!—is think about how our work can benefit the larger ecosystem. When you build a library, you should consider whether there are parts of it that &lt;em&gt;don’t&lt;/em&gt; have to be Ember specific. For example, a colleague and I recently built out the foundation of a solution for well-rationalized form-handling.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; We build it in two pieces, though: a core library in TypeScript that will work as well in Vue or React as in Ember, and an Ember component library that consumes that core functionality.&lt;/p&gt;
&lt;p&gt;The more we can take that tack in &lt;em&gt;general&lt;/em&gt;, the better. It’s the first piece of making the gap between people’s experience in other parts of the front-end ecosystem and the Ember part smaller. Ember will seem much more interesting if people find themselves &lt;em&gt;often&lt;/em&gt; getting value out of things we’ve built.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="smoothing-the-paths-in" class="level3"&gt;
&lt;h3&gt;Smoothing the paths in&lt;/h3&gt;
&lt;p&gt;The flip side of this is figuring out ways to make it easier for people coming &lt;em&gt;into&lt;/em&gt; Ember.js to map patterns from their existing experience onto the framework’s tools and patterns. The simple reality is that there are far, far more developers familiar with React, Angular, and Vue than with modern Ember.js. Ember genuinely has a lot to offer there, but we need to make it easier for people to see that value and to recognize how it’s a lot like the good parts of what they already know!&lt;/p&gt;
&lt;p&gt;This is primarily a communications effort; it means changes to the docs and to the homepage, but also to what we do in blog posts and tutorials and talks as a community!&lt;/p&gt;
&lt;p&gt;At the highest level, I cannot recommend strongly enough the model suggested by Chris Garrett in &lt;a href="https://medium.com/@pzuraq/emberjs-2018-ember-as-a-component-service-framework-2e49492734f1"&gt;his #EmberJS2018 post&lt;/a&gt;: treat Ember.js (both in the docs and also in our presentations and communications about it) as a &lt;em&gt;component-service&lt;/em&gt; framework. This not only maps more easily to patterns people know from other communities, it has the really important effect of demystifying a lot of the “magic” that seems perplexing in the framework, especially around Ember Data—which is, after all, just a service you can inject!&lt;/p&gt;
&lt;p&gt;When we write blog posts, we can accomplish a lot of this simply by being aware of the rest of the ecosystem and making analogies there. You can see an example of how I’ve started trying to do this in my recent blog post on &lt;a href="http://www.chriskrycho.com/2018/higher-order-components-in-emberjs.html"&gt;higher-order components in Ember.js&lt;/a&gt;. It was just one little line:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In React, the [higher-order components] pattern as a whole is often known as the &lt;code&gt;renderProps&lt;/code&gt; pattern, for the way you most often accomplish it. It’s all the same idea, though!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That’s not a lot of extra work, but it means that if someone searches for “renderProps Ember.js” there now exists a blog post which will help someone map there existing knowledge over! I wasn’t writing a “how to do React renderProps in Ember” post—but I still smoothed the path in just a little bit. We should be doing that everywhere we can. It’s usually not a lot of effort to make those kinds of moves in talks or blog posts, but the yield is high: Ember stops being some super weird foreign entity and starts looking like a variation on a theme.&lt;/p&gt;
&lt;p&gt;There is also a much larger effort we &lt;em&gt;do&lt;/em&gt; need to undertake to make that story clearer on the home page and in the documentation—an effort that I know is already very much in consideration from chatting with the really amazing crew in &lt;code&gt;#-team-learning&lt;/code&gt; on Slack. In the &lt;strong&gt;how you can help&lt;/strong&gt; bucket: seriously please go into that channel and start chipping away at small tasks! There’s (&lt;a href="https://m.youtube.com/watch?v=Abu2BNixXak" title="“Becoming a Contributor”, my Rust Belt Rust 2017 talk"&gt;always!&lt;/a&gt;) way more work to be done than hands to do it.&lt;/p&gt;
&lt;p&gt;I think this also means prioritizing technical work that eases this. The sooner we can land the Glimmer component model, the better. The sooner we can hash out a more cogent story on routes and controllers and components, the better. The sooner we can make “npm-install-your-way-to-Ember” an actually viable strategy, the better. Because each of those things makes Ember dramatically more accessible to people working in other ecosystems today; each lowers the barrier to entry in some substantial way; and the combination of them all makes it far more viable for someone to &lt;em&gt;try&lt;/em&gt; Ember in an existing application.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="embracing-the-rest-of-the-ecosystem" class="level3"&gt;
&lt;h3&gt;Embracing the rest of the ecosystem&lt;/h3&gt;
&lt;p&gt;The final piece of this is actively embracing the best parts of the rest of the ecosystem.&lt;/p&gt;
&lt;p&gt;We as a community need to avoid defensiveness and recognize that there’s a &lt;em&gt;lot&lt;/em&gt; of good in the rest of the front-end space. I understand how it can be easy to feel defensive. Being dismissed, having people be surprised that the project even still exists, etc. gets really old after a while. But however reasonable that defensiveness is, it’s ultimately counterproductive. It makes us hold onto things we don’t need to hold onto, and it makes us ignore things that might benefit us, and as a result it can make us &lt;em&gt;needlessly weird&lt;/em&gt; technically.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Needless weirdness&lt;/em&gt; is an important idea I’d love for us to keep in mind. Any time you’re willing to move more slowly, to let the “new shiny” bake for a while to see whether it’s genuinely worth investing in, you’re going to seem weird. Likewise when you strongly embrace stability, in a broader ecosystem which hasn’t. Likewise when you value convention over configuration, in a broader ecosystem which hasn’t. But it’s important to be able to distinguish between &lt;em&gt;needful&lt;/em&gt; and &lt;em&gt;needless&lt;/em&gt; weirdness.&lt;/p&gt;
&lt;p&gt;We should have regular conversations as a community—through &lt;abbr title="request for comments"&gt;RFC&lt;/abbr&gt;s, through forum threads, through blog post arguments, etc.—about what’s &lt;em&gt;needful&lt;/em&gt; weirdness, and what has become &lt;em&gt;needless&lt;/em&gt; weirdness. (Because which weird things are needful change over time!) We should gleefully embrace the needful weirdness. But we should equally gleefully drop the needless weirdness.&lt;/p&gt;
&lt;p&gt;What makes Ember special is, by and large, &lt;em&gt;not&lt;/em&gt; the specific technical implementations we’ve landed on.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; What makes Ember valuable is having a coherent top-to-bottom story and a rich community with a commitment to aggressively seeking out shared solutions, and an even deeper commitment to providing good migration paths forward when we change things.&lt;/p&gt;
&lt;p&gt;But here’s the thing: those values are increasingly (if slowly) being embraced &lt;em&gt;outside&lt;/em&gt; the Ember ecosystem as well. Ember can contribute and even lead in many ways here—but only if we start actively embracing the good of other parts of the front-end ecosystem.&lt;/p&gt;
&lt;p&gt;For example: I’ve heard more times than I can count over the last few years that our use of Broccoli.js is really important for Ember, and the reality is… that isn’t true. We could have built on top of just about &lt;em&gt;any&lt;/em&gt; solution, and it would have been &lt;em&gt;fine&lt;/em&gt;. Broccoli &lt;em&gt;does&lt;/em&gt; have some advantages; it also has some real disadvantages (one of which is that we’re the only ones using it!), and we should forthrightly acknowledge those. By the same token, if Webpack is working well for many people, let’s neither trash it in discussion nor ignore it in implementation. Instead, let’s make it easy for people to integrate Webpack into the Ember world.&lt;/p&gt;
&lt;p&gt;That doesn’t oblige us to chuck out our existing build tooling! It just means making our own build pipelines robust enough to interoperate well with other packaging systems. And that’s precisely what the Ember &lt;abbr&gt;CLI&lt;/abbr&gt; team has been doing! This needs to be our pattern across the board going forward.&lt;/p&gt;
&lt;p&gt;It’s truly well and good to have made a call a few years ago, and to be going out of our way to mitigate the costs of churn. At the same time, we need to communicate—to a degree that probably feels like &lt;em&gt;over&lt;/em&gt;communicating to the people who already understand all these decisions!—so that both the original rationales and the current status are accessible to all the people who &lt;em&gt;weren’t&lt;/em&gt; there when the decisions were made.&lt;/p&gt;
&lt;p&gt;Insofar as it’s true that Broccoli and Webpack solve different problems, &lt;em&gt;explaining&lt;/em&gt; how Broccoli and Webpack actually solve meaningfully different problems —or at least, &lt;em&gt;excel&lt;/em&gt; at solving different problems—is one of the most important things we can do as well. Props to Chris Thoburn (&lt;a href="https://twitter.com/runspired"&gt;@runspired&lt;/a&gt;) for doing this in a few different contexts recently, but we need a lot more of it—because it’s one example I think most people both inside and outside the Ember community have just kind of scratched their heads at for a long time (me included).&lt;/p&gt;
&lt;p&gt;Again: I take the Broccoli/Webpack example simply because it’s an obvious one. The broader point is that we need to find ways to embrace the shared solutions which emerge not only in the Ember community but in the front-end ecosystem as a whole, even as we also do the hard work to make our own shared solutions useful to the rest of the front-end ecosystem. That two-way exchange will benefit us, and smooth the paths in for newcomers, and benefit the rest of the ecosystem, too—and that’s a huge win. Because in a very real sense, we front-end developers are all in this together.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Keep your eyes open; you’ll see a blog post announcing that along with a full set of documentation for it sometime in the next month or so!&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;To be clear: many, though certainly not all, of those specific implementations I like, but that’s beside the point.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 29 May 2018 07:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-29:/2018/emberjs2018-part-4.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category><category>emberjs2018</category></item><item><title>Higher-Order Components in Ember.js</title><link>http://www.chriskrycho.com/2018/higher-order-components-in-emberjs.html</link><description>&lt;p&gt;One of the most powerful patterns in programming is the idea of &lt;em&gt;higher-order functions&lt;/em&gt;: functions which can take other functions as arguments or return them as their return values. If you’ve spent much time at all working in JavaScript, you’ve certainly encountered these—whether you’re using &lt;code&gt;Array.map&lt;/code&gt; to transform the values in an array, or passing a function as an argument to an event handler.&lt;/p&gt;
&lt;p&gt;The same pattern is incredibly useful in building components, and most modern front-end frameworks support it—including Ember.js! (In React, the pattern as a whole is often known as the &lt;code&gt;renderProps&lt;/code&gt; pattern, for the way you most often accomplish it. It’s all the same idea, though!)&lt;/p&gt;
&lt;p&gt;In this little post, I’ll show you how to build a small “higher-order component” in Ember.js, hopefully demystifying that term a little bit a long the way. (If you just want to see how the pieces fit together, you can see the finished app &lt;a href="https://github.com/chriskrycho/ember-hoc-example"&gt;in this repo&lt;/a&gt;.)&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;I’m going to be using classes and decorators throughout. Both are very much ready-to-go in Ember, and I commend them to you! I’m also going to be using some of the new &lt;a href="https://emberjs.com/blog/2018/04/13/ember-3-1-released.html#toc_introducing-optional-features-3-of-4"&gt;optional features&lt;/a&gt; available in Ember 3.1+ to use template-only components!&lt;/p&gt;
&lt;p&gt;Note that one of the most important consequences of this is that arguments have to be referenced as &lt;code&gt;@theArgumentName&lt;/code&gt; rather than just &lt;code&gt;theArgumentName&lt;/code&gt; in templates. The reason is precisely that there is no backing JavaScript component. In old-school Ember.js components, &lt;code&gt;{{theArgumentName}}&lt;/code&gt; is implicitly turned into &lt;code&gt;{{this.argumentName}}&lt;/code&gt;, which does a lookup on the backing component. In Glimmer-style components—of which these are the first part—arguments live on a designated &lt;code&gt;args&lt;/code&gt; property and are accessible in templates via &lt;code&gt;@theArgumentName&lt;/code&gt; instead.&lt;/p&gt;
&lt;/aside&gt;
&lt;section id="higher-order-components-what-are-they" class="level2"&gt;
&lt;h2&gt;Higher-Order Components, What Are They&lt;/h2&gt;
&lt;p&gt;Just like with a “higher-order function,” all we mean when we talk about a “higher-order component” is a component which takes other components as arguments, returns other components itself (in Ember’s case via &lt;code&gt;yield&lt;/code&gt; in a template), or both.&lt;/p&gt;
&lt;p&gt;The thing we’re actually going to build here is a “modal” which accepts an optional button as an arguments, and which yields out a component for dividing the modal into sections visually so you can pass your own content in and have it look just right. This is closely based on a component my colleagues and I at Olo built recently, just with some of our specific details stripped away to get at the actually important bits. Here’s what it looks like in practice:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/hoc-rendered.png" alt="a modal with sectioned text and a close button" /&gt;&lt;figcaption&gt;a modal with sectioned text and a close button&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The goal for the button arguments is to let the modal be able to render the button the caller passes in, while not being concerned with the &lt;em&gt;functionality&lt;/em&gt; of the button. Otherwise, we’d have to tie the “API” of the modal to the details of button behavior, bind more actions into it, etc.&lt;/p&gt;
&lt;p&gt;The goal for the yielded sectioning component is for whatever is rendering the modal itself to be able to pass content in and get it chunked up however the modal decides is appropriate—the modal can display its own styles, etc.—without having to worry about the details of applying classes or sectioning up the content itself.&lt;/p&gt;
&lt;p&gt;In short, we want to &lt;em&gt;separate our concerns&lt;/em&gt;: the modal knows how to lay out its contents and where to put buttons, but it doesn’t want to have to know &lt;em&gt;anything&lt;/em&gt; about what the buttons do. The most complicated interaction in the world could be going on, and the modal won’t have to care. Likewise, things &lt;em&gt;using&lt;/em&gt; the modal can pass content and buttons into it, and let the modal manage its own layout and so on without having to be concerned with the details of that. So what does that look like in practice?&lt;/p&gt;
&lt;p&gt;The approach I use here builds on the “contextual components” pattern in Ember.js. The main new idea is that the &lt;em&gt;context&lt;/em&gt; includes components!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="implementing-it" class="level2"&gt;
&lt;h2&gt;Implementing It&lt;/h2&gt;
&lt;p&gt;We have three components here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a button&lt;/li&gt;
&lt;li&gt;a modal&lt;/li&gt;
&lt;li&gt;a modal section&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since Ember.js still (for now!) requires component names to be at least two words separated by a dash, we’ll just call these &lt;code&gt;x-button&lt;/code&gt;, &lt;code&gt;x-modal&lt;/code&gt;, and &lt;code&gt;x-modal-section&lt;/code&gt;.&lt;/p&gt;
&lt;section id="x-button" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;x-button&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The button component, we’ll keep pretty simple: it’s just a button element with a given label and an action bound to it:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;&amp;lt;button class={{@buttonClass}} type=&amp;#39;button&amp;#39; {{action @onClick}}&amp;gt;
  {{@label}}
&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="x-modal" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;x-modal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;x-modal&lt;/code&gt; has the meat of the implementation.&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;&amp;lt;div class=&amp;#39;modal-backdrop&amp;#39;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;#39;modal&amp;#39;&amp;gt;
  &amp;lt;div class=&amp;#39;modal-content&amp;#39;&amp;gt;
    {{yield (hash section=(component &amp;#39;x-modal-section&amp;#39;))}}
  &amp;lt;/div&amp;gt;

  {{#if @button}}
    {{component @button buttonClass=&amp;#39;modal-button&amp;#39;}}
  {{/if}}
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The two things two notice here are the &lt;code&gt;yield&lt;/code&gt; and the &lt;code&gt;component&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;yield&lt;/code&gt; statement yields a &lt;a href="https://www.emberjs.com/api/ember/3.1/classes/Ember.Templates.helpers"&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; with one property: &lt;code&gt;section&lt;/code&gt;. Yielding a hash is a convenient pattern in general. Here, we’re doing it to make the &lt;abbr&gt;API&lt;/abbr&gt; nicer for users of this component. It means that if we name the yielded value &lt;code&gt;|modal|&lt;/code&gt; when we invoke this, we’ll be able to write &lt;code&gt;modal.section&lt;/code&gt; to name this particular yielded item. (You’ll see exactly this below.)&lt;/p&gt;
&lt;p&gt;We use the &lt;code&gt;component&lt;/code&gt; helper twice: once as the value of the &lt;code&gt;section&lt;/code&gt; key in the yielded hash, and once for the &lt;code&gt;button&lt;/code&gt; below. In both cases, the helper does the same thing: invokes a component! While the most common way to render a component is with its name, inline—like &lt;code&gt;{{x-modal}}&lt;/code&gt;—you can always render it with the &lt;code&gt;component&lt;/code&gt; helper and the name as a string: &lt;code&gt;{{component 'x-modal'}}&lt;/code&gt;. This lets you render different components dynamically!&lt;/p&gt;
&lt;p&gt;Let’s remember our initial analogy: the same way you can pass different functions to a higher-order function like &lt;code&gt;Array.prototype.map&lt;/code&gt;, you can pass different components to a higher-order component like our &lt;code&gt;x-modal&lt;/code&gt; here. And just like you can &lt;em&gt;return&lt;/em&gt; a function from a higher-order function, we can &lt;em&gt;yield&lt;/em&gt; a component from a higher-order component. Just like higher-order functions, the function passed in or returned just has to have the right shape.&lt;/p&gt;
&lt;p&gt;For example, the argument to &lt;code&gt;Array.prototype.map&lt;/code&gt; needs to be a function which performs an operation on a single item in the array (and maybe also the index) and hands back the result of that operation. Similarly, the &lt;code&gt;button&lt;/code&gt; argument to our &lt;code&gt;x-modal&lt;/code&gt; needs to accept a &lt;code&gt;buttonClass&lt;/code&gt; component so that the modal can apply some styling to it. The same thing holds for the component being yielded back out: it has an &lt;abbr&gt;API&lt;/abbr&gt; you should use to invoke it, just like any other.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All of this gets at something really important: you can think of components as just being &lt;em&gt;pure functions&lt;/em&gt;: they take some input in the form of arguments, and give you the output of what they &lt;em&gt;render&lt;/em&gt; and what they &lt;em&gt;yield&lt;/em&gt;—and they always give you the same rendered &lt;abbr&gt;HTML&lt;/abbr&gt; and the same yielded values for the same inputs. They’re just functions!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="x-modal-section" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;x-modal-section&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;x-modal-section&lt;/code&gt; component is the simplest of all of these: it has no behavior, just some styling to actually chunk up the content:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;&amp;lt;div class=&amp;#39;modal-section&amp;#39;&amp;gt;
  {{yield}}
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="application-controller-and-template" class="level3"&gt;
&lt;h3&gt;Application controller and template&lt;/h3&gt;
&lt;p&gt;Now, let’s use in the context of the application template, where we can see how the pieces all fit together. First, let’s see the application controller backing it—nothing unusual here, just a simple toggle to show or hide the modal.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Controller from &amp;quot;@ember/controller&amp;quot;;
import { action } from &amp;quot;@ember-decorators/object&amp;quot;;

export default class Application extends Controller {
  constructor() {
    super(...arguments);
    this.showModal = false;
  }

  @action
  showIt() {
    this.set(&amp;quot;showModal&amp;quot;, true);
  }

  @action
  hideIt() {
    this.set(&amp;quot;showModal&amp;quot;, false);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now for the interesting bit—the template where we invoke &lt;code&gt;x-modal&lt;/code&gt; and use its higher-order-component functionality:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;{{#if showModal}}
  {{#x-modal
      button=(component &amp;#39;x-button&amp;#39;
        label=&amp;#39;Close modal!&amp;#39;
        onClick=(action &amp;#39;hideIt&amp;#39;)
      )
      as |modal|
  }}
    {{#modal.section}}
      Here is some content!
    {{/modal.section}}

    {{#modal.section}}
      Here is some other content.
    {{/modal.section}}

    {{#modal.section}}
      &amp;lt;p&amp;gt;The content can have its own sections, as you&amp;#39;d expect!&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;Nothing crazy going on here. Just a normal template!&amp;lt;/p&amp;gt;
    {{/modal.section}}
  {{/x-modal}}
{{/if}}

&amp;lt;button class=&amp;#39;button&amp;#39; {{action &amp;#39;showIt&amp;#39;}}&amp;gt;Show modal&amp;lt;/button&amp;gt;

&amp;lt;!-- some other content on the page --&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We invoke the block form of &lt;code&gt;x-modal&lt;/code&gt; just like we would any block component, and we get back the thing it yields with &lt;code&gt;as |modal|&lt;/code&gt;. However, one of the arguments we pass to it is a component. But &lt;code&gt;modal&lt;/code&gt; is a &lt;code&gt;hash&lt;/code&gt; (an object!) with a property named &lt;code&gt;section&lt;/code&gt;, which is the &lt;code&gt;x-modal-section&lt;/code&gt; component.&lt;/p&gt;
&lt;p&gt;Again, you can think of this like calling a function with one function as an argument and getting another function back as its return value—that returned function being something we could call over and over again once we had it.&lt;/p&gt;
&lt;p&gt;Here, we “call the function”—invoke the &lt;code&gt;x-modal&lt;/code&gt; component—with &lt;code&gt;component 'x-button'&lt;/code&gt; as its argument, and the returned &lt;code&gt;modal.section&lt;/code&gt; is a component we can invoke like a normal component.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; We could even pass it into some &lt;em&gt;other&lt;/em&gt; component itself if we so desired.&lt;/p&gt;
&lt;p&gt;And that’s really all there is to it!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;“Higher-order components” aren’t necessarily something you need all the time, but they’re really convenient and very powerful when you &lt;em&gt;do&lt;/em&gt; need them. They’re also a lot less complicated than the name might seem! Components are just things you can pass around in the context of a component template—they’re the &lt;em&gt;functions&lt;/em&gt; of Handlebars.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Splitting things into components like this does increase complexity, and in particular it can increase the mental overhead of keeping track of how the pieces fit together. However, they also let us cleanly separate different pieces of functionality from each other. Doing it this way means that our modal can be concerned about &lt;em&gt;positioning&lt;/em&gt; a button without needing to expose an &lt;abbr&gt;API&lt;/abbr&gt; for all of the button’s own mechanics for handling clicks and performing whatever actions necessary. That makes our modal &lt;em&gt;and&lt;/em&gt; our button way more reusable across our application. The button can be used &lt;em&gt;wherever&lt;/em&gt; a button is useful, and the modal doesn’t need to know or care anything about it. Likewise, the button has no need to know anything about the context where it’s being used; from the button component’s perspective, it just gets wired up to some actions as usual. The same thing goes for the modal sections: they let us abstract over how the DOM is laid out, what classes are applied to it, and so on—they chunk up the modal, but the modal itself maintains responsibility for how that chunking up happens. And the caller doesn’t even &lt;em&gt;have&lt;/em&gt; to use that; it’s just a tool that’s available for that purpose.&lt;/p&gt;
&lt;p&gt;To sum it all up, I’ll just reiterate my earlier description: components are just like pure functions: the same inputs give you the same outputs—and, just like functions, those inputs and outputs can be other functions, that is, other components.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you want a good way to document the things a component &lt;code&gt;yield&lt;/code&gt;s, check out &lt;a href="https://ember-learn.github.io/ember-cli-addon-docs/latest/docs/api/components/docs-demo"&gt;ember-cli-addon-docs&lt;/a&gt;, which can read an &lt;code&gt;@yield&lt;/code&gt; JSDoc annotation.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;And it could just as well be a component; the top-level controller template is just where we put our main app functionality.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;We could also simplify this since we’re only returning one component, and if we had the full Glimmer component story, this could look &lt;em&gt;very&lt;/em&gt; nice:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;&amp;lt;Modal @button={{component &amp;#39;Button&amp;#39;}} as |Section|&amp;gt;
  &amp;lt;Section&amp;gt;
    Some content!
  &amp;lt;/Section&amp;gt;
  &amp;lt;Section&amp;gt;
    Some more content!
  &amp;lt;/Section&amp;gt;

  &amp;lt;Section&amp;gt;
    &amp;lt;p&amp;gt;The content can have its own sections, as you&amp;#39;d expect!&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;Nothing crazy going on here. Just a normal template!&amp;lt;/p&amp;gt;
  &amp;lt;/Section&amp;gt;
&amp;lt;/Modal&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;If you’re inclined to “well actually” me about &lt;em&gt;helpers&lt;/em&gt; being the real functions of Handlebars templates: in the Glimmer &lt;abbr&gt;VM&lt;/abbr&gt; world, helpers are just a kind of component.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 26 May 2018 14:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-26:/2018/higher-order-components-in-emberjs.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category></item><item><title>How To Bundle TypeScript Type Definitions</title><link>http://www.chriskrycho.com/2018/how-to-bundle-typescript-type-definitions.html</link><description>&lt;p&gt;One of the lessons that led to the True Myth 2.0.0 release was the difficulty of consuming the library under its original packaging strategy. There are a few things that are &lt;em&gt;not&lt;/em&gt; obvious about how TypeScript type definitions get consumed when you’re first starting out, and a few things that seem like they should work &lt;em&gt;don’t&lt;/em&gt;. This is my attempt to help &lt;em&gt;you&lt;/em&gt; (and the people consuming your TypeScript libraries!) avoid the same pain I (and the people consuming mine) have felt.&lt;/p&gt;
&lt;section id="the-problem" class="level2"&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;The problem is the result of the ways TypeScript resolves type definitions, and the kinds of type definition files it can (and cannot) generate for you.&lt;/p&gt;
&lt;p&gt;TypeScript only properly resolves two kinds of type definition distributions automatically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A single-file type definition, located anywhere in the package as long as &lt;code&gt;package.json&lt;/code&gt; has a &lt;code&gt;types&lt;/code&gt; key pointing to it.&lt;/li&gt;
&lt;li&gt;Type definition module files in the &lt;em&gt;root&lt;/em&gt; of the distributed package, mapping to the distributed modules of the package (wherever they live).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TypeScript will only generate a single-file type definition for the &lt;abbr&gt;AMD&lt;/abbr&gt; and SystemJS standards—which &lt;em&gt;cannot&lt;/em&gt; be imported with ES6 module imports. If you want to use an output mode which generates a JS file per originating TS file—Node, ES6, etc.—you will get individual TS module file type definitions as well. It is not that the type definition files themselves can’t be written to support Node or ES6-style module layouts in a single-file definition. To the contrary: hand-written definitions for libraries &lt;em&gt;often&lt;/em&gt; do just that. It is just a matter of what the compiler supports generating.&lt;/p&gt;
&lt;p&gt;The net of this is: if you want module type definitions to go with ES6 modules to import, they &lt;em&gt;must&lt;/em&gt; live in the root of your distributed bundle.&lt;/p&gt;
&lt;p&gt;However, most libraries I’m familiar with—because I work in the &lt;em&gt;browser&lt;/em&gt; ecosystem, not the &lt;em&gt;Node&lt;/em&gt; ecosystem—do not work with the root of their repository as the place where their source lives, or for the place where the output of their build process lives. It’s far more common to have a &lt;code&gt;src&lt;/code&gt; directory and &lt;code&gt;dist&lt;/code&gt; or &lt;code&gt;build&lt;/code&gt; directory, the latter of which is where the build artifacts go.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-solution" class="level2"&gt;
&lt;h2&gt;The Solution&lt;/h2&gt;
&lt;p&gt;The solution—which we shipped for ember-cli-typescript some time ago, and which I switched to this past week for True Myth—is to have separate build artifacts for the type definitions and the JavaScript output. Put the JavaScript output in the &lt;code&gt;dist&lt;/code&gt; or &lt;code&gt;build&lt;/code&gt; directory as usual, without type declarations. Then, put the type definitions in the root of the repository.&lt;/p&gt;
&lt;p&gt;In the case of both ember-cli-typescript and True Myth, we’re doing the type generation step in the &lt;code&gt;prepublishOnly&lt;/code&gt; hook and cleaning it up in the &lt;code&gt;postpublish&lt;/code&gt; hook. Your &lt;code&gt;package.json&lt;/code&gt; might look like something like this, assuming your &lt;code&gt;tsconfig.json&lt;/code&gt; is set to generate JavaScript artifacts in &lt;code&gt;dist&lt;/code&gt; as your build directory.&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;ts:js&amp;quot;: &amp;quot;tsc&amp;quot;,
    &amp;quot;ts:defs&amp;quot;: &amp;quot;tsc --declaration --outDir . --emitDeclarationOnly&amp;quot;,
    &amp;quot;prepublishOnly&amp;quot;: &amp;quot;yarn ts:js &amp;amp;&amp;amp; yarn ts:defs&amp;quot;,
    &amp;quot;postpublish&amp;quot;: &amp;quot;rm -r *.d.ts dist&amp;quot;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(If you have nested modules, your &lt;code&gt;postpublish&lt;/code&gt; hook there should clean up the generated folders as well as the generated files.)&lt;/p&gt;
&lt;p&gt;You can see the full setup I built for True Myth—which generates type defs along these lines, as well as both CommonJS and ES6 modules—in the repository:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/package.json"&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt;—note especially the &lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/package.json#L32:L42"&gt;&lt;code&gt;&amp;quot;scripts&amp;quot;&lt;/code&gt;&lt;/a&gt; configuration&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/tsconfig.json"&gt;root &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt;, with derived&lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/ts/cjs.tsconfig.json"&gt;CommonJS &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://github.com/chriskrycho/true-myth/blob/v2.0.0/ts/es.tsconfig.json"&gt;ES6 &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;This isn’t an especially complicated thing, but the scenario leading to the need for this is common enough, and the dance frustrating enough and easy enough to get wrong, that I really wish the TypeScript team would make it possible to generate single-file type definitions for &lt;em&gt;all&lt;/em&gt; kinds of JavaScript module systems.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 21 May 2018 07:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-21:/2018/how-to-bundle-typescript-type-definitions.html</guid><category>typescript</category><category>programming languages</category><category>true myth</category></item><item><title>Destructuring with True Myth 1.3+</title><link>http://www.chriskrycho.com/2018/destructuring-with-true-myth-13.html</link><description>&lt;p&gt;I just realized a neat capability that &lt;a href="#"&gt;True Myth 1.3+&lt;/a&gt; unlocks: you can now use destructuring of the &lt;code&gt;value&lt;/code&gt; property on &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; and the &lt;code&gt;error&lt;/code&gt; property on &lt;code&gt;Error&lt;/code&gt; instances.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Maybe&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { just, nothing, isJust } from &amp;#39;true-myth/maybe&amp;#39;;

const maybeStrings: Maybe&amp;lt;string&amp;gt;[] =
  [just(&amp;#39;hello&amp;#39;), nothing(), just(&amp;#39;bye&amp;#39;), nothing()];

const lengths = maybeStrings
  .filter(Maybe.isJust)
  .map(({ value }) =&amp;gt; value.length);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;Result&lt;/code&gt; instances:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Result, { ok, err } from &amp;#39;true-myth/result&amp;#39;;

const results: Result&amp;lt;number, string&amp;gt;[] =
  [ok(12), err(&amp;#39;wat&amp;#39;), err(&amp;#39;oh teh noes&amp;#39;), ok(42)];

const okDoubles = results
  .filter(Result.isOk)
  .map(({ value }) =&amp;gt; value * 2);

const errLengths = results
  .filter(Result.isErr)
  .map(({ error }) =&amp;gt; error.length);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;None of this is especially novel or anything. It was just a neat thing to realize after the fact, because it wasn’t something I had in mind when I was making these changes!&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This was a very strange experience. There’s nothing quite like learning something about a library &lt;em&gt;you wrote&lt;/em&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 19 May 2018 12:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-19:/2018/destructuring-with-true-myth-13.html</guid><category>functional programming</category><category>typescript</category><category>open source software</category><category>libraries</category><category>true myth</category></item><item><title>#EmberJS2018, Part 2</title><link>http://www.chriskrycho.com/2018/emberjs2018-part-2.html</link><description>&lt;p&gt;Following &lt;a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html"&gt;the example&lt;/a&gt; of the Rust community, the &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; team has &lt;a href="https://emberjs.com/blog/2018/05/02/ember-2018-roadmap-call-for-posts.html" title="Ember&amp;#39;s 2018 Roadmap: A Call for Blog Posts"&gt;called for blog posts&lt;/a&gt; as the first step in setting the 2018 roadmap (which will formally happen through the normal &lt;a href="https://github.com/emberjs/rfcs"&gt;&lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process&lt;/a&gt;). This is my contribution.&lt;/p&gt;
&lt;p&gt;There are three major themes I think should characterize the Ember.js community and project for the rest of 2018:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-1.html"&gt;&lt;strong&gt;Finishing What We’ve Started&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doubling Down on Documentation&lt;/strong&gt; (this post)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-3.html"&gt;&lt;strong&gt;Defaulting to Public for Discussions&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-4.html"&gt;&lt;strong&gt;Embracing the Ecosystem&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;section id="part-2-double-down-on-docs" class="level2"&gt;
&lt;h2&gt;Part 2: Double down on docs&lt;/h2&gt;
&lt;p&gt;The best project in the world is useless without documentation. As such, my &lt;em&gt;second&lt;/em&gt; major goal for Ember.js this year is to see our documentation story improve dramatically across a number of fronts. This is not just the kind of thing that’s important in principle or because we care about doing the right thing, though those alone &lt;em&gt;are&lt;/em&gt; sufficient motivation. It’s &lt;em&gt;also&lt;/em&gt; absolutely necessary for Ember to grow and thrive in the ways it deserves to in the years ahead.&lt;/p&gt;
&lt;p&gt;To be clear: Ember’s story around documentation is &lt;em&gt;pretty good&lt;/em&gt; and it continues to improve all the time. A few years ago, the base documentation was a mess and even figuring out where to start was hard. Today, Ember.js itself has great guides along with versioned-and-searchable &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; documentation. The gaps now are in the &lt;em&gt;surrounding ecosystem&lt;/em&gt; and in the &lt;em&gt;framework internals&lt;/em&gt;. That’s huge progress! But if we want Ember to excel, we need to go after both of these with gusto.&lt;/p&gt;
&lt;section id="the-surrounding-ecosystem" class="level3"&gt;
&lt;h3&gt;The surrounding ecosystem&lt;/h3&gt;
&lt;p&gt;Ember Data, Ember Engines, and perhaps most important Ember &lt;abbr title="command line interface"&gt;CLI&lt;/abbr&gt; and its core dependency Broccoli all &lt;em&gt;desperately&lt;/em&gt; need documentation work just at the “how do you even use these things level.”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Broccoli.js&lt;/strong&gt; in particular is core to pretty much everything in Ember’s ecosystem, and its docs today are in roughly the state Webpack’s were back in its sad 1.0 days. We should take a page out of our own history (and Webpack’s for that matter!) and make it easy for people to use Broccoli in whatever ways their apps need, and that mostly means documenting it!&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Oli Griffith’s recent &lt;a href="http://www.oligriffiths.com/broccolijs/"&gt;blog post series&lt;/a&gt; is an incredibly valuable first step in that direction. But we need really solid documentation for &lt;a href="http://broccolijs.com"&gt;Broccoli itself&lt;/a&gt;, and also for the equally important &lt;a href="https://www.npmjs.com/search?q=keywords:broccoli-plugin"&gt;plugin ecosystem&lt;/a&gt; which is the primary way people interact with it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;The docs for &lt;strong&gt;Ember &lt;abbr&gt;CLI&lt;/abbr&gt;&lt;/strong&gt; itself are &lt;em&gt;decent&lt;/em&gt;, but they’re quite out of date and are about to be a lot more so because of the previously-mentioned packager bits. We need accurate and up-to-date guides and &lt;abbr&gt;API&lt;/abbr&gt; docs for the &lt;abbr&gt;CLI&lt;/abbr&gt;, and we also need clarity about the seams between Ember &lt;abbr&gt;CLI&lt;/abbr&gt; and Broccoli—something I’ve only begun to become clear on after a year of hacking on &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;! This includes a number of kinds of documentation:
&lt;ul&gt;
&lt;li&gt;up-to-date guides&lt;/li&gt;
&lt;li&gt;complete &lt;abbr&gt;API&lt;/abbr&gt; documentation&lt;/li&gt;
&lt;li&gt;a “cookbook” of common patterns to use&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;Ember Data&lt;/strong&gt; docs need to be split into two parts: one for &lt;em&gt;users&lt;/em&gt; of Ember Data, and one for people building Ember Data integrations and addons. Right now, all the docs are targeted squarely at implementors of Ember Data addons. This means that one of the pieces of the Ember ecosystem that’s in widest use (and is &lt;em&gt;most&lt;/em&gt; distinct from the rest of the JS ecosystem!) is really, really hard to learn. This is the part of the framework I still struggle the most with, despite having worked full time on an Ember app for over two years now.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ember Engines&lt;/strong&gt; are really need for manually breaking up your app into discrete sections which can be worked on independently and even loaded dynamically as you need them, and they provide a different level of abstraction than route-splitting and other similar approaches. (Not necessarily better or worse, but different.) Unfortunately, most of the documentation hasn’t been touched in over a year. That means if you &lt;em&gt;want&lt;/em&gt; to use Ember Engines, almost all of the information is in an example here and a Slack conversation there. We need to turn that sort of “tribal knowledge” into actual docs!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To be clear, the Ember docs team is doing great work and is already going after a lot of these areas; but there’s an enormous amount of ground to cover. They could use your help! Because if Ember is going to flourish in the year(s) ahead, we need good docs. And users are the people best-placed in all the world to help write docs.&lt;/p&gt;
&lt;p&gt;So &lt;strong&gt;how you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Open issues about things you don’t understand.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you see an error in the documentation, open a pull request to fix it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Volunteer to proofread or edit as new materials are produced. Yes, seriously: proofreading is &lt;em&gt;incredibly&lt;/em&gt; valuable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Volunteer to write documentation of things you &lt;em&gt;do&lt;/em&gt; understand where you see gaps.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="framework-internals" class="level3"&gt;
&lt;h3&gt;Framework internals&lt;/h3&gt;
&lt;p&gt;Every time I have started poking into Ember’s own codebase—to ship a fix for some small bug, or simply to understand the behavior of my own application—I have found myself stymied by a really serious issue. &lt;em&gt;Almost nothing is documented.&lt;/em&gt; This is true of Ember proper, of Ember Data, of Ember &lt;abbr&gt;CLI&lt;/abbr&gt;, of Broccoli’s internals… Everything I named above as being in need of &lt;em&gt;user&lt;/em&gt;-facing documentation also desperately needs &lt;em&gt;developer&lt;/em&gt;-facing documentation.&lt;/p&gt;
&lt;p&gt;A lot of this happens naturally in projects developed organically by small teams. I’ve seen it in my own current job: the &lt;em&gt;vast&lt;/em&gt; majority of our codebase is without any formal documentation, because it didn’t &lt;em&gt;require&lt;/em&gt; it when we were a much smaller organization working on a much smaller codebase. But no project—whether private or open-source—can grow or thrive unless it becomes possible for new contributors to come in, understand the system as it exists, and start making changes effectively. “Tribal knowledge” is &lt;em&gt;not&lt;/em&gt; a bad thing in some contexts, but it does not scale.&lt;/p&gt;
&lt;p&gt;The Ember.js ecosystem needs developer documentation of several sorts, then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Architecture documents:&lt;/strong&gt; what are the pieces of the framework or library in question, and how do they fit together? This is often the hardest piece to maintain, simply because it changes organically over time, and unlike the next couple examples it doesn’t have an inherent attachment to the code. However, it’s also the piece that’s absolutely the most important, because it’s what gives anyone trying to dive in and contribute the orientation they need to be effective.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;“Why” comments:&lt;/strong&gt; The internals of the core libraries very often have good reasons for doing things even in apparently odd ways. However, the reasons for those are &lt;em&gt;very&lt;/em&gt; rarely written down anywhere. This is &lt;em&gt;precisely&lt;/em&gt; what comments are for! If some implementation actually &lt;em&gt;can’t&lt;/em&gt; be simplified in the way it looks like it can, write it down right there in a comment! This will save both you and other developers lots of wasted time with false starts and useless pull requests and so on.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Documentation of private &lt;abbr&gt;API&lt;/abbr&gt;:&lt;/strong&gt; Much of the public-facing &lt;abbr&gt;API&lt;/abbr&gt; for Ember is fairly clear (modulo caveats around completeness and accuracy). However, most internal &lt;abbr&gt;API&lt;/abbr&gt; is essentially entirely undocumented. This makes it &lt;em&gt;extremely&lt;/em&gt; difficult for someone to know how to use the internal &lt;abbr&gt;API&lt;/abbr&gt;s when working on internal code!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these things came home to me pretty sharply as I started poking at the Glimmer VM project to see where and how I can pull together my knowledge of both TypeScript and Rust to drive some of those efforts forward. The core team folks I’ve interacted with have all been &lt;em&gt;extremely&lt;/em&gt; helpful—and that’s always been true all along the way!—but they’re also busy, and taking the time to write down something &lt;em&gt;once&lt;/em&gt; ends up being a major “force multiplier”. You can explain the same thing to multiple different people via multiple different conversations, or you can write it down &lt;em&gt;once&lt;/em&gt; and make it a resource that anyone can use to start working effectively in the system!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you’re a current Ember developer in any part of the ecosystem: &lt;em&gt;start writing down what you know.&lt;/em&gt; If a question comes up more than once, put it in a document somewhere. If nothing else, then you can link to it instead of typing it up one more time in Slack!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re just getting started on developing core Ember functionality: &lt;em&gt;write down what you learn.&lt;/em&gt; If you’re working through some section of the codebase, don’t understand it, and then come to understand it by way of asking questions, add documentation for that! You’ll help the next person coming along behind you!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;In short: please write more things down! We need user-facing and developer-facing documentation; they need to be different and distinct from each other; and we need the whole range in both. That’s an &lt;em&gt;enormous&lt;/em&gt; amount of work, and it’s very different from programming (and therefore harder for many of us).&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But it’s also work that will pay equally enormous dividends in enabling the Ember community to grow in both the &lt;em&gt;number&lt;/em&gt; and the &lt;em&gt;effectiveness&lt;/em&gt; of its contributors—and that’s something we very much need!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Most of Webpack’s bad reputation is long-since undeserved: it &lt;em&gt;was&lt;/em&gt; poorly documented… a few years ago. So was Ember!&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;I’ll let you draw your own conclusions about my own relationship to writing given the absurd number of words I put out on this site.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 18 May 2018 22:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-18:/2018/emberjs2018-part-2.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category><category>emberjs2018</category></item><item><title>True Myth 1.3.0 and 2.0.0</title><link>http://www.chriskrycho.com/2018/true-myth-130-and-200.html</link><description>&lt;p&gt;Today I released two versions of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth&lt;/a&gt;: &lt;a href="https://github.com/chriskrycho/true-myth/releases/tag/v1.3.0"&gt;1.3.0&lt;/a&gt; and &lt;a href="https://github.com/chriskrycho/true-myth/releases/tag/v2.0.0"&gt;2.0.0&lt;/a&gt;. You can read the &lt;a href="https://www.chriskrycho.com/2017/announcing-true-myth-10.html"&gt;1.0 announcement&lt;/a&gt; from last November for an overview of the library and a discussion of why you might want to use the library in the first place!&lt;/p&gt;
&lt;p&gt;Since its initial release last November, True Myth has gone through a number of small &lt;a href="https://github.com/chriskrycho/true-myth/releases" title="True Myth releases on GitHub"&gt;feature and bug fix releases&lt;/a&gt;, each of which is more interesting in its own right than 2.0 is—because there are almost no new “features” here, and the changes to the &lt;em&gt;functionality&lt;/em&gt; which are in 2.0 are purely additive and could readily have gone in 1.3 instead.&lt;/p&gt;
&lt;p&gt;In fact, the act of writing that sentence made me realize that there really &lt;em&gt;should&lt;/em&gt; be a 1.3 which people can trivially upgrade to and then take on the changes in 2.0 later.&lt;/p&gt;
&lt;section id="section" class="level2"&gt;
&lt;h2&gt;– 1.3.0 –&lt;/h2&gt;
&lt;p&gt;There are a few very small changes in 1.3 that are just nice ergonomic wins. (You may also be interested in looking back at the &lt;a href="https://github.com/chriskrycho/true-myth/releases"&gt;list of other releases&lt;/a&gt; to see what else has landed since 1.0.)&lt;/p&gt;
&lt;section id="expose-value-and-error" class="level3"&gt;
&lt;h3&gt;Expose &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;value&lt;/code&gt; property in &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Result.Ok&lt;/code&gt; instances, and the &lt;code&gt;error&lt;/code&gt; property in &lt;code&gt;Result.Err&lt;/code&gt; instances, are now &lt;em&gt;public, readonly properties&lt;/em&gt; instead of &lt;em&gt;private properties&lt;/em&gt;. I made those private in the initial implementation because I thought it made more sense to expose them via methods, but experience showed that this is a relatively common pattern in practice:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function dealsWithAMaybe(couldBeAString: Maybe&amp;lt;string&amp;gt;) {
  if (couldBeAString.isJust()) {
    console.log(`It was! ${couldBeAString.unsafelyUnwrap()}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a contrived example of course, but I and my colleagues found in practice that this is a scenario that comes up relatively often, &lt;em&gt;especially&lt;/em&gt; when integrating with existing code rather than writing new code – control flow patterns there tend to assume early-return-on-&lt;code&gt;null&lt;/code&gt; or similar instead.&lt;/p&gt;
&lt;p&gt;So I made a change (leaning on TypeScript’s notion of &lt;a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" title="“User-Defined Type Guards” in the TypeScript handbook"&gt;“type narrowing”&lt;/a&gt;) so that you don’t have to use &lt;code&gt;unsafelyUnwrap&lt;/code&gt; in this scenario anymore! You can use the method types, the standalone functions, or direct matching against the variants on the property&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

function dealsWithAMaybe(maybe: Maybe&amp;lt;string&amp;gt;) {
  if (maybe.isJust()) {
    console.log(`It was! ${maybe.value}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;Result&lt;/code&gt; case this is even nicer (notice that I’m using the variant, rather than a function, to discriminate between the two and narrow the types here):&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Result, { Variant } from &amp;#39;true-myth/result&amp;#39;;

function dealsWithAResult(result: Result&amp;lt;string, Error&amp;gt;) {
  if (result.variant === Variant.Ok) {
    console.log(`Huzzah: ${result.value}`);
  } else {
    console.log(`Alas: ${result.error.message}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically: you now have more options for handling these scenarios, a nicer &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt;, and—not that it should &lt;em&gt;usually&lt;/em&gt; matter that much, but for whatever it’s worth—better performance by way of doing things with property lookups instead of function invocations in quite a few places.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="static-helper-methods" class="level3"&gt;
&lt;h3&gt;Static helper methods&lt;/h3&gt;
&lt;p&gt;At my friend and collaborator &lt;a href="https://mobile.twitter.com/bmakuh"&gt;Ben Makuh&lt;/a&gt;’s suggestion, I built a couple static helper methods to go with those. These helpers just give you nice abstractions to drop into functional pipelines. For example, you can lean on the type-narrowing capabilities described above while working through a &lt;em&gt;list&lt;/em&gt; of &lt;code&gt;Maybe&lt;/code&gt;s to &lt;em&gt;know&lt;/em&gt; that an item is a &lt;code&gt;Just&lt;/code&gt; and use the new &lt;code&gt;Just.unwrap&lt;/code&gt; static method in the pipeline:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Maybe, { Just } from &amp;#39;true-myth/maybe&amp;#39;;

function justLengths(maybeStrings: Array&amp;lt;Maybe&amp;lt;string&amp;gt;&amp;gt;) {
  return maybeStrings
    .filter(Maybe.isJust)
.map(Just.unwrap)
    .map(s =&amp;gt; s.length);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Analogous helpers exist for &lt;code&gt;Result&lt;/code&gt; in the form of the &lt;code&gt;Ok.unwrap&lt;/code&gt; and &lt;code&gt;Err.unwrapErr&lt;/code&gt; methods. (&lt;code&gt;Nothing&lt;/code&gt; has no analog for what I hope are obvious reasons!)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="tweaks-to-the-variant-properties" class="level3"&gt;
&lt;h3&gt;Tweaks to the &lt;code&gt;variant&lt;/code&gt; properties&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;variant&lt;/code&gt; property on both &lt;code&gt;Maybe&lt;/code&gt; and &lt;code&gt;Result&lt;/code&gt; has changed in two ways:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It is now &lt;code&gt;readonly&lt;/code&gt;. This was an implicit invariant previously—you would break &lt;em&gt;everything&lt;/em&gt; in the library if you changed the &lt;code&gt;variant&lt;/code&gt; value—and I’ve just made it explicit in the type system.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It is now properly constrained with a &lt;em&gt;literal type&lt;/em&gt; on the concrete instances. That is, the type of &lt;code&gt;Just.variant&lt;/code&gt; is no longer &lt;code&gt;Variant&lt;/code&gt; but specifically &lt;code&gt;Variant.Just&lt;/code&gt;. (This is what enables you to use the variant for narrowing as demonstrated above. I should have done this in 1.0, and just forgot to!)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that’s it for 1.3.0!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="section-1" class="level2"&gt;
&lt;h2&gt;– 2.0.0 –&lt;/h2&gt;
&lt;p&gt;The 2.0 release is identical in &lt;em&gt;features&lt;/em&gt; with the 1.3 release. However, it makes a breaking change to how consumers interact with the application, requiring updates to your &lt;code&gt;tsconfig.json&lt;/code&gt; file and your bundler configuration, and removing support for Flow types.&lt;/p&gt;
&lt;section id="configuration-file-updates" class="level3"&gt;
&lt;h3&gt;Configuration file updates&lt;/h3&gt;
&lt;p&gt;Getting True Myth working nicely with consuming TypeScript packages has been a source of frustration for me &lt;em&gt;and&lt;/em&gt; others. In short, requiring you to use the &lt;code&gt;&amp;quot;paths&amp;quot;&lt;/code&gt; key in the &lt;code&gt;&amp;quot;compilerOptions&amp;quot;&lt;/code&gt; section of the &lt;code&gt;tsconfig.json&lt;/code&gt; made for an annoying amount of setup work, &lt;em&gt;and&lt;/em&gt; it meant that using True Myth in a library &lt;em&gt;required&lt;/em&gt; you to set it up in any consuming app. No good.&lt;/p&gt;
&lt;p&gt;For type resolution to Just Work™, the types &lt;em&gt;must&lt;/em&gt; be at the root of the distributed package.&lt;/p&gt;
&lt;p&gt;As a result, I’ve stopped using &lt;a href="https://github.com/tildeio/libkit"&gt;libkit&lt;/a&gt;, which put the generated types in a reasonable-seeming but (in my experience) painful-to-use place, and have simplified the build layout substantially.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The types themselves are generated only when publishing an update to npm. They go in the root at that point, and they get cleaned up after publishing. (This is pretty much identical to the solution we came up in &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;.)&lt;/li&gt;
&lt;li&gt;The other build files no longer get dropped in a nested &lt;code&gt;src&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;Since I was already at it, I renamed the two build directories from &lt;code&gt;commonjs&lt;/code&gt; to &lt;code&gt;cjs&lt;/code&gt; and from &lt;code&gt;modules&lt;/code&gt; to &lt;code&gt;es&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the distributed build now looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/
  index.d.ts
  maybe.d.ts
  result.d.ts
  unit.d.ts
  utils.d.ts
  dist/
    cjs/
      index.js
      maybe.js
      result.js
      unit.js
      utils.js
    es/
      index.js
      maybe.js
      result.js
      unit.js
      utils.js&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll just need to completely remove the &lt;code&gt;&amp;quot;paths&amp;quot;&lt;/code&gt; mapping for True Myth from your &lt;code&gt;tsconfig.json&lt;/code&gt; and, if you’ve done anything unusual with it, update your bundler configuration to point to the new build location, i.e. &lt;code&gt;dist/commonjs/src&lt;/code&gt; should now just be &lt;code&gt;dist/cjs&lt;/code&gt;. Bundlers which respect the &lt;code&gt;modules&lt;/code&gt; key in &lt;code&gt;package.json&lt;/code&gt; will pick it up automatically, as will Ember &lt;abbr&gt;CLI&lt;/abbr&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="removing-flow-types" class="level3"&gt;
&lt;h3&gt;Removing Flow types&lt;/h3&gt;
&lt;p&gt;To my knowledge, no one is actually using the Flow types for the library. When I first started on it, my collaborator &lt;a href="https://github.com/bmakuh"&gt;Ben Makuh&lt;/a&gt; &lt;em&gt;was&lt;/em&gt; using Flow, but he ended up migrating to TypeScript in the intervening time, and there are no consumers I know of. I was always relatively unsure of their correctness, &lt;em&gt;and&lt;/em&gt; I don’t have a good way to validate their correctness, &lt;em&gt;and&lt;/em&gt; maintaining them involved doing manual work on every release to update the types by hand.&lt;/p&gt;
&lt;p&gt;If you &lt;em&gt;do&lt;/em&gt; use True Myth with Flow, and you’re missing the types, please let me know. I just can’t maintain them myself at this point!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;And that’s it! We’ve been using True Myth in production at Olo for quite some time, and it’s proved to be a really valuable tool. Give it a spin and let me know how these latest versions work for you!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I’ve made some changes under the hood to take advantage of this as well, so the library should be faster. Probably &lt;em&gt;trivially&lt;/em&gt; faster, but my philosophy around library code is very much &lt;em&gt;be as fast as you can&lt;/em&gt;; it’s a way of considering the people using your code—not just the developers, but the end users.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 18 May 2018 19:15:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-18:/2018/true-myth-130-and-200.html</guid><category>TypeScript</category><category>functional programming</category><category>libraries</category><category>software development</category><category>open source software</category><category>versioning</category><category>True Myth</category></item><item><title>#EmberJS2018, Part 1</title><link>http://www.chriskrycho.com/2018/emberjs2018-part-1.html</link><description>&lt;p&gt;Following &lt;a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html"&gt;the example&lt;/a&gt; of the Rust community, the &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; team has &lt;a href="https://emberjs.com/blog/2018/05/02/ember-2018-roadmap-call-for-posts.html" title="Ember&amp;#39;s 2018 Roadmap: A Call for Blog Posts"&gt;called for blog posts&lt;/a&gt; as the first step in setting the 2018 roadmap (which will formally happen through the normal &lt;a href="https://github.com/emberjs/rfcs"&gt;&lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process&lt;/a&gt;). This is my contribution.&lt;/p&gt;
&lt;p&gt;There are three major themes I think should characterize the Ember.js community and project for the rest of 2018:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;strong&gt;Finishing What We’ve Started&lt;/strong&gt; (this post)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-2.html"&gt;&lt;strong&gt;Doubling Down on Docs&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-3.html"&gt;&lt;strong&gt;Defaulting to Public for Discussions&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-4.html"&gt;&lt;strong&gt;Embracing the Ecosystem&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;section id="finishing-what-weve-started" class="level2"&gt;
&lt;h2&gt;Finishing What We’ve Started&lt;/h2&gt;
&lt;p&gt;What I want, more than any new feature anyone could come up with, is for this to be the year Ember.js commits to &lt;em&gt;finishing what we have started&lt;/em&gt;. The last few years have seen the Ember team do a lot of really important exploratory work, including projects like &lt;a href="https://glimmerjs.com"&gt;Glimmer.js&lt;/a&gt;; and we have landed some of the initiatives we have started. But I think it’s fair to say that focus has not been our strong suit. It’s time for a year of &lt;em&gt;shipping&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We need to land all the things we have in flight, and as much as possible avoid the temptation (much though I feel it myself!) to go haring off after interesting new ideas. As such, literally everything I list below is an effort &lt;em&gt;already in progress&lt;/em&gt;. It’s just a matter of making concerted efforts as a community to land them.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And that way of putting it is important: we have to make concerted efforts &lt;em&gt;as a community&lt;/em&gt; to land these things. Very, very few people are paid to work on Ember.js full time—far too few to accomplish all of this! If these things matter to you and your company, find a way to carve out time for it. Even if it’s just a few hours a week, even if it’s “just” (and there’s no “just” about these!) helping out with triage of open issues or answering questions in Slack or Discourse or Stack Overflow, even if it doesn’t &lt;em&gt;feel&lt;/em&gt; like a lot… it adds up.&lt;/p&gt;
&lt;p&gt;To be very clear, before I go any further: none of this is a knock on everything that the Ember core team and community have done in the last couple years. A lot of things that have landed along the way—dropping in the Glimmer rendering engine midway through the 2.x series, landing ES5 getters just weeks ago in Ember 3.1, and so on—are genuinely great! &lt;em&gt;All&lt;/em&gt; that I mean is, a year where we land and polish everything would make everything that much more awesome (and make Ember that much more competitive a choice in the client-side framework world).&lt;/p&gt;
&lt;p&gt;So: what do we need to ship this year?&lt;/p&gt;
&lt;section id="land-glimmer-components-in-ember.js-proper" class="level3"&gt;
&lt;h3&gt;Land Glimmer &lt;code&gt;&amp;lt;Component&amp;gt;&lt;/code&gt;s in Ember.js proper&lt;/h3&gt;
&lt;p&gt;We’ve taken the first steps toward this already via a number of &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt;s that were written late last year and merged since. We need to finish the implementation for these. That means getting the &lt;a href="https://github.com/emberjs/ember.js/issues/16301"&gt;Glimmer Components in Ember&lt;/a&gt; quest across the finish line.&lt;/p&gt;
&lt;p&gt;The whole story here will make Ember &lt;em&gt;feel&lt;/em&gt; much more modern in a variety of ways, as well as enabling some great performance and programming model wins: Immutable component arguments! Auto-tracked class properties! &lt;code&gt;&amp;lt;AngleBracketComponent&amp;gt;&lt;/code&gt; invocation! Clear semantic distinctions between arguments and local context! So many good things. We just need to land it! &lt;a href="https://github.com/emberjs/ember.js/issues/16301"&gt;The quest&lt;/a&gt; needs to be moving forward, not stagnant.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Show up and volunteer to go after pieces of the quest. There are people willing to mentor you through the work that needs to be done!&lt;/li&gt;
&lt;li&gt;Test it as it lands! You don’t have to commit to &lt;em&gt;shipping&lt;/em&gt; things in your app to &lt;em&gt;test&lt;/em&gt; them in your app.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="land-a-lot-of-ember-cli-efforts" class="level3"&gt;
&lt;h3&gt;Land a &lt;em&gt;lot&lt;/em&gt; of Ember CLI efforts&lt;/h3&gt;
&lt;p&gt;There are a great many Ember CLI efforts in flight. Every last one of them should be on stable and in use before the end of the year.&lt;/p&gt;
&lt;section id="module-unification" class="level4"&gt;
&lt;h4&gt;Module Unification&lt;/h4&gt;
&lt;p&gt;The &lt;a href="https://github.com/dgeb/rfcs/blob/module-unification/text/0000-module-unification.md"&gt;Module Unification &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt;&lt;/a&gt; was opened in May 2016 and merged October 2016. There has been a lot of progress made, but we need to &lt;em&gt;ship it&lt;/em&gt;—from where I stand, it’d be nice if it landed less than 2 years after we approved it! And we’re &lt;a href="https://github.com/emberjs/ember.js/issues/16373"&gt;getting pretty close&lt;/a&gt;; you can actually use the Module Unification blueprint in an Ember application today. Some stuff doesn’t work &lt;em&gt;quite&lt;/em&gt; right yet, but it’s getting close.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; try it out! Spin up new apps with the module unification blueprint flag, and try running the migrator codemod, and report back on what breaks.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="broccoli-1.0" class="level4"&gt;
&lt;h4&gt;Broccoli 1.0&lt;/h4&gt;
&lt;p&gt;We’re &lt;em&gt;super&lt;/em&gt; close on this one—Oli Griffiths has done some heroic work on this since EmberConf—but we need to finish it. Ember CLI, for historical reasons, has been using a fork of Broccoli.js for quite some time. This divergence has caused all manner of trouble, including compatibility issues between Broccoli plugins and an inability to take advantage of the best things that have landed in Broccoli since the fork happened.&lt;/p&gt;
&lt;p&gt;Perhaps the single most important example of that is that Broccoli 1.0 supports the use of the system &lt;code&gt;tmp&lt;/code&gt; directory. That single change will improve the performance of Ember CLI &lt;em&gt;dramatically&lt;/em&gt;, especially on Windows. It will also flat-out eliminate a number of bugs and odd behaviors that appear when trying to integrate Ember CLI with other file watching tools (e.g. TypeScript’s &lt;code&gt;--watch&lt;/code&gt; invocation).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; once the Ember CLI team says it’s ready for testing, test your app and addons with it! Make sure that everything works as it should—specifically, that you’re not making any assumptions that depend on either the forked &lt;abbr&gt;API&lt;/abbr&gt; or the location of the &lt;code&gt;tmp&lt;/code&gt; directory used for intermediate build steps.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-new-packager-setup-with-tree-shaking-and-app-splitting" class="level4"&gt;
&lt;h4&gt;The new &lt;code&gt;Packager&lt;/code&gt; setup, with tree-shaking and app-splitting&lt;/h4&gt;
&lt;p&gt;One of the current major pain points with Ember’s build pipeline is that it’s hard to extend, and not really documented at all. (I’ll have a &lt;em&gt;lot&lt;/em&gt; more to say on the question of documentation in the next post!) However, work is in progress to change that, too!&lt;/p&gt;
&lt;p&gt;The accepted-and-actively-being-worked-on &lt;a href="https://github.com/ember-cli/rfcs/blob/master/active/0051-packaging.md"&gt;Packaging Ember CLI &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt;&lt;/a&gt; aims to fix both of these. Quoting from it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The current application build process merges and concatenates input broccoli trees. This behaviour is not well documented and is a tribal knowledge. While the simplicity of this approach is nice, it doesn’t allow for extension. We can refactor our build process and provide more flexibility when desired.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A few of the things we can expect to be possible once that effort lands:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tree-shaking – we can lean on Rollup.js to get &lt;em&gt;only&lt;/em&gt; the code we actually need, cutting shipped file size dramatically&lt;/li&gt;
&lt;li&gt;app-splitting – lots of different strategies to explore, including route-based or “section”-based, etc.&lt;/li&gt;
&lt;li&gt;static-build-asset-splitting – no reason to cache-bust your &lt;em&gt;dependencies&lt;/em&gt; every time the app releases!&lt;/li&gt;
&lt;li&gt;distinct app builds – you could ship one build of your app for browsers which support ES Modules and one for browsers which don’t (heeeeey, IE11) – letting you minimize the payload size for the ones that do&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you know Ember CLI internals: pop into #-dev-ember-cli and ask how you can help land the features&lt;/li&gt;
&lt;li&gt;If you don’t know Ember CLI internals: also pop into #-dev-ember-cli, but ask instead how you can &lt;em&gt;test&lt;/em&gt; the changes&lt;/li&gt;
&lt;li&gt;Help document those internals (see the next post in this series)&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="install-your-way-to-ember" class="level3"&gt;
&lt;h3&gt;Install-your-way-to-Ember&lt;/h3&gt;
&lt;p&gt;We need to finish splitting apart the Ember source from its current state of still being fairly monolith and get it turned into a true set of packages. The new Modules API which landed last year was a huge step toward this and made the experience on the developer side &lt;em&gt;look&lt;/em&gt; like this should be possible—but that’s still a shim around the actual non-modularized Ember core code. The process of splitting it apart &lt;em&gt;is happening&lt;/em&gt;, but we need to finish it.&lt;/p&gt;
&lt;p&gt;The promise here is huge: Ember will be able to be the kind of thing you can progressively add to your existing applications and slowly convert them, rather than something that comes along all as a large bundle. It’s technically possible to do this today, but you cannot drop in &lt;em&gt;just the view layer&lt;/em&gt;, for example, and that’s a huge value for people who want to try out the programming model or add it for just one feature in an existing application.&lt;/p&gt;
&lt;p&gt;Making it possible for people to install Glimmer components, then the service layer, then the router, and so on as they need it will make adoption easier for people who are curious about the framework. But it will also be a huge boon to those of us already using Ember and wanting to migrate existing applications (often a tangled mix of server-side rendering and massive jQuery spaghetti files!) to Ember progressively. I’ve had multiple scenarios come up at my own job in just the last month where this would have been hugely useful.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; make it known that you’re willing to help work on breaking apart Ember into its constituent pieces, and as that effort lands (hopefully over the rest of this year!) test it in your own apps and addons, and find the pain points in the install-your-way-to-the-framework process.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="make-typescript-great-everywhere" class="level3"&gt;
&lt;h3&gt;Make TypeScript &lt;em&gt;great&lt;/em&gt; everywhere&lt;/h3&gt;
&lt;p&gt;This one is near and dear to my heart… and it also really falls in no small part to me and the rest of the group working on ember-cli-typescript and type definitions for the Ember ecosystem!&lt;/p&gt;
&lt;p&gt;There are two big wins we can land this year:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Built-in support in Ember.js itself.&lt;/li&gt;
&lt;li&gt;Solid type definitions for the rest of the Ember.js ecosystem&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you don’t like TypeScript, don’t panic! The upshot here will actually be a better experience for &lt;em&gt;all&lt;/em&gt; users of Ember.js.&lt;/p&gt;
&lt;section id="built-in-support-in-ember.js-itself" class="level4"&gt;
&lt;h4&gt;1. Built-in support in Ember.js itself&lt;/h4&gt;
&lt;p&gt;One of my goals for this summer&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; is to finish an &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; making TypeScript a first-class citizen of the Ember.js ecosystem. To clarify what this will and won’t entail (assuming it’s accepted, assuming I ever manage to finish writing it!):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ember will &lt;em&gt;always&lt;/em&gt; be JS-first, and it will &lt;em&gt;never&lt;/em&gt; require type metadata reflected to runtime, unlike e.g. Angular. No one will ever have a &lt;em&gt;worse&lt;/em&gt; experience because they prefer JS to TS. The idea will be to make TypeScript an &lt;em&gt;equally&lt;/em&gt; good experience, and to include it for consideration when thinking about design choices for new features.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember users, both JS and TS, will get the &lt;em&gt;benefits&lt;/em&gt; of having good types available right out of the box: many editors and IDEs can use TypeScript type definitions to enable better docs, autocompletion, etc.—and we may even be able to leverage it for &lt;a href="https://twitter.com/__dfreeman/status/994410180661170177"&gt;better validation of Handlebars templates&lt;/a&gt;!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We’ll have (because we’ll have to have!) a story on what we support in terms of backwards compatibility and SemVer for TypeScript and Ember and the type definitions. Necessarily, it has been the Wild West for the first year of concentrated effort here, trying to get our type definitions from “barely exist and not useful” to “full coverage and 99% right.” But as TypeScript becomes more widely used, we have to have a stability story, and we very soon will.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There’s also ongoing work to convert Ember’s own internals to TypeScript, and landing that will help guarantee that the type definitions for Ember are actually &lt;em&gt;correct&lt;/em&gt;, which in turn will make the experience for everyone better. (Bad type definitions are worse than &lt;em&gt;no&lt;/em&gt; type definitions!)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; engage in the &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process once we get it started, and if you are up for it show up to help convert the Ember internals to TypeScript as well.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="solid-type-definitions-for-the-rest-of-the-ember.js-ecosystem" class="level4"&gt;
&lt;h4&gt;2. Solid type definitions for the rest of the Ember.js ecosystem&lt;/h4&gt;
&lt;p&gt;Closely related to making TypeScript a first-class citizen for Ember.js itself is getting the pieces in place for the rest of the ecosystem as well. That means we need type definitions for addons—a &lt;em&gt;lot&lt;/em&gt; of them! The ember-cli-typescript team will (hopefully late this month or in early June) be launching a quest issue to get type definitions for the whole Ember ecosystem in place—by helping convert addons to TS if their authors desire it, or by adding type definitions to the addons if they’re up for it, or by getting them up on DefinitelyTyped if they’re totally disinterested. (And, as I’ll note again in that quest issue, it’s totally fine for people &lt;em&gt;not&lt;/em&gt; to be interested: there &lt;em&gt;is&lt;/em&gt; a maintenance burden there!) The goal, again, is that when you’re using &lt;em&gt;any&lt;/em&gt; part of the Ember ecosystem it’ll be easy to get all the benefits of TypeScript—and indeed that in many cases you’ll get a fair number of those benefits as a JS user.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; participate in the quest issue once it’s live! We’ll help mentor you through the process of converting addons to TypeScript, writing type definitions and getting them well-validated, and so on!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;That’s a lot to do. More than enough all by itself, and a lot of moving parts. As such, I’ll reiterate what I said at the start: we don’t need new features this year. &lt;strong&gt;It’s time for a year of &lt;em&gt;shipping&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;To put it in the terms the Rust community used for their similar push at the end of 2017, and which we have often used to describe the ongoing efforts in Rust to land the “Rust 2018 edition”: this is an “impl period”—a play on the Rust &lt;code&gt;impl&lt;/code&gt; keyword, used to describe the &lt;em&gt;implementation&lt;/em&gt; of the behavior associated with a given data type. You can think of this as the same: it’s the implementation of the good ideas we have.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Confession: it was a goal for the spring but I found myself utterly exhausted after EmberConf… and had a full month with &lt;em&gt;another&lt;/em&gt; major talk given for internal purposes afterwards. I’m worn out.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 11 May 2018 09:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-11:/2018/emberjs2018-part-1.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category><category>emberjs2018</category></item><item><title>Announcing ember-cli-typescript 1.1.0</title><link>http://www.chriskrycho.com/2018/announcing-ember-cli-typescript-110.html</link><description>&lt;p&gt;I’m delighted to announce the release of &lt;a href="https://github.com/typed-ember/ember-cli-typescript/releases/tag/v1.1.0"&gt;ember-cli-typescript 1.1.0&lt;/a&gt;. This first minor release since 1.0 includes the following shiny and awesome new features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#generators"&gt;Generators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#developing-addons"&gt;Support for developing addons in TypeScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#incremental-compilation"&gt;Incremental compilation (a.k.a. fast rebuilds in &lt;code&gt;ember serve&lt;/code&gt; mode)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="generators" class="level2"&gt;
&lt;h2&gt;Generators&lt;/h2&gt;
&lt;p&gt;We’ve now added support for generating &lt;em&gt;all&lt;/em&gt; standard Ember items as TypeScript files instead of JavaScript files. So now when you run &lt;code&gt;ember generate component user-profile&lt;/code&gt; for example, you’ll get &lt;code&gt;user-profile.ts&lt;/code&gt;, &lt;code&gt;user-profile-test.ts&lt;/code&gt;, and &lt;code&gt;user-profile.hbs&lt;/code&gt;. For most files, this is just a nicety—just two files you don’t have to rename!—but in the case of services, controllers, and Ember Data models, adapters, and serializers it will actually make a really big difference in your experience of using TypeScript in your app or addon.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Those generators are &lt;em&gt;mostly&lt;/em&gt; identical with ones in Ember and Ember Data, just with &lt;code&gt;.ts&lt;/code&gt; instead of &lt;code&gt;.js&lt;/code&gt; for the extension. The only changes we have made are: (a) we’ve tweaked them to use classes where possible, and (b) we have customized the controller, service, and Ember Data model, adapter, and serializer generators so you get the most mileage out of TypeScript for the least effort we can manage today. So when you do &lt;code&gt;ember generate service session&lt;/code&gt;, this is what you’ll see:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Service from &amp;quot;@ember/service&amp;quot;;

export default class Session extends Service.extend({
  // anything which *must* be merged on the prototype
}) {
  // normal class definition
}

// DO NOT DELETE: this is how TypeScript knows how to look up your services.
declare module &amp;quot;ember&amp;quot; {
  interface ServiceRegistry {
    session: Session;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Courtesy of these generators, you can now write &lt;em&gt;almost&lt;/em&gt; exactly what you’d write in vanilla Ember and get full support for autocompletion of properties and methods on the &lt;code&gt;Session&lt;/code&gt; service, as well as type-checking for how you use those. Service and controller injections just require you to explicitly name the service or controller being injected:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Component from &amp;quot;@ember/component&amp;quot;;
import { inject as service } from &amp;quot;@ember/service&amp;quot;;

export default class UserProfile extends Component {
  session = service(&amp;quot;session&amp;quot;);
  // note the string ^ naming the service explicitly
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, for example, if your &lt;code&gt;session&lt;/code&gt; service had a &lt;code&gt;login&lt;/code&gt; method on it:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Service from &amp;quot;@ember/service&amp;quot;;
import RSVP from &amp;quot;rsvp&amp;quot;;

export default class Session extends Service {
  login(email: string, password: string): RSVP.Promise&amp;lt;string&amp;gt; {
    // some API call to log in
  }
}

// DO NOT DELETE: this is how TypeScript knows how to look up your services.
declare module &amp;quot;ember&amp;quot; {
  interface ServiceRegistry {
    session: Session;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then anywhere you injected and used it, you’ll get auto-complete suggestions and type checking:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/ts-autocomplete.png" alt="autocompletion" /&gt;&lt;figcaption&gt;autocompletion&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/ts-type-checking.png" alt="type-checking" /&gt;&lt;figcaption&gt;type-checking&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;(You’ll see the same kinds of things in other editors, from Vim to IntelliJ IDEA. Visual Studio Code is just my current editor of choice.)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="addon-development" class="level2"&gt;
&lt;h2&gt;Addon development&lt;/h2&gt;
&lt;p&gt;As &lt;a href="http://www.chriskrycho.com/2017/announcing-ember-cli-typescript-100.html#the-roadmap"&gt;promised with the 1.0 release&lt;/a&gt;, 1.1 (though arriving much later than I hoped it would) includes support for developing addons with TypeScript.&lt;/p&gt;
&lt;p&gt;Strictly speaking, of course, you could &lt;em&gt;always&lt;/em&gt; develop addons using TypeScript, but there were two problems with it: (1) dependency management and (2) manual work required to deal with the dependency management problems.&lt;/p&gt;
&lt;section id="dependency-management" class="level3"&gt;
&lt;h3&gt;1. Dependency management&lt;/h3&gt;
&lt;p&gt;In the normal Ember CLI workflow, TypeScript had to be a &lt;code&gt;dependency&lt;/code&gt;—not a &lt;code&gt;devDependency&lt;/code&gt;—of the addon, because the normal pattern with Ember CLI is to ship the uncompiled files and have the consumer compile them all together at build time.&lt;/p&gt;
&lt;p&gt;This makes a certain amount of sense for Babel given the Ember community’s shared reliance on Babel: it’s just assumed to be part of every app build. In that case, it gives consumers control over their compilation target. If an app only needs to target evergreen browsers, it can do that and ship a smaller payload, because an addon won’t have pre-compiled in things like generator support, etc.&lt;/p&gt;
&lt;p&gt;In the case of TypeScript, however, this makes a lot less sense: many (probably &lt;em&gt;most&lt;/em&gt;) consumers of addons written in TypeScript will still be normal JavaScript consumers. We did not want to burden normal consumers with a TypeScript compile step. We &lt;em&gt;also&lt;/em&gt; didn’t want to burden any consumers with the reality that TypeScript is a &lt;em&gt;large&lt;/em&gt; install. TypeScript 2.6.2 is 32MB on disk for me. Even with some degree of deduplication by npm or yarn, if addons used a variety of versions of TypeScript for development—as they surely would!—the install cost for consumers would quickly spiral into a nasty spot. And again: that’s bad enough for someone who &lt;em&gt;wants&lt;/em&gt; to use TypeScript in their app; it’s far worse for someone who just wants to consume the compiled JavaScript.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="manual-workarounds" class="level3"&gt;
&lt;h3&gt;2. Manual workarounds&lt;/h3&gt;
&lt;p&gt;You could work around all of that by building the JavaScript (and TypeScript definitions) yourself. But as part of that, you had to do all the work of making sure both the JavaScript files and the type definitions you generated ended up in the right place for distribution and consumption. That was always possible, but it was also always going to be a lot of work. In practice, as far as I know, &lt;em&gt;no one has done this&lt;/em&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="solution" class="level3"&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;We now support TypeScript as a &lt;code&gt;devDependency&lt;/code&gt; and also manage the work of generating JavaScript and type definitions for you. All you have to do is install ember-cli-typescript into an addon, and then when you do your build step, we’ll automatically do the work (on prepublish) of generating TypeScript &lt;code&gt;.d.ts&lt;/code&gt; files and JavaScript source for you.&lt;/p&gt;
&lt;p&gt;Consumers of your addon, therefore, will (a) not know or care that the addon is written in TypeScript if they just want to consume it as normal JavaScript&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; or (b) will get the benefits of your having written the library in TypeScript without paying the penalty of having to have multiple versions of the TypeScript compiler downloaded to their own app.&lt;/p&gt;
&lt;p&gt;One important caveat: we do &lt;em&gt;not&lt;/em&gt; support TypeScript in an addon’s &lt;code&gt;app&lt;/code&gt; directory. However, for most addons, we don’t think this should be a problem. It’s rare for addons to put actual implementation in the &lt;code&gt;app&lt;/code&gt; directory; instead it has simply become conventional for the &lt;code&gt;app&lt;/code&gt; directory simply to have re-exports for convenient access to the functionality supplied by the addon.&lt;/p&gt;
&lt;p&gt;Also note that you can supply type definitions for your addon &lt;em&gt;without&lt;/em&gt; developing the addon itself in TypeScript.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; You do &lt;em&gt;not&lt;/em&gt; need ember-cli-typescript installed for that. You only need the addon if you actually want to take advantage of the opportunities TypeScript affords for developing your own addon.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="incremental-compilation" class="level2"&gt;
&lt;h2&gt;Incremental compilation&lt;/h2&gt;
&lt;p&gt;Last but not least, we’ve managed—mostly through the hard work of both Dan Freeman (&lt;a href="https://github.com/dfreeman"&gt;@dfreeman&lt;/a&gt;) and Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;—to get support for TypeScript’s &lt;code&gt;--watch&lt;/code&gt; mode integrated.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; What this means in practice is: &lt;em&gt;way&lt;/em&gt; faster iteration as you work.&lt;/p&gt;
&lt;p&gt;Previously, every time you triggered &lt;em&gt;any&lt;/em&gt; change in your app (even if it didn’t involve any TypeScript files at all), the TypeScript compiler would recompile &lt;em&gt;all&lt;/em&gt; the TypeScript files in your application. We didn’t initially have a good way to make TypeScript and Broccoli (and therefore Ember CLI) communicate clearly about what had changed. Now, courtesy of Dan and Derek’s hard work (and my cheerleading, testing, and fixing a few corner pieces along the way), we do! So when you change a &lt;code&gt;.hbs&lt;/code&gt; file or a &lt;code&gt;.js&lt;/code&gt; file… the TypeScript compiler won’t do anything. And when you change a TypeScript file, the TypeScript compiler will &lt;em&gt;only&lt;/em&gt; recompile that file.&lt;/p&gt;
&lt;p&gt;On my own app (~35,000 lines of TypeScript across ~700 files), that’s the difference between rebuilds involving TypeScript taking 15–20 seconds and their taking 1–2 seconds. Literally an order of magnitude faster! Over the course of a day of development, that saves a &lt;em&gt;huge&lt;/em&gt; amount of time.&lt;/p&gt;
&lt;p&gt;The way we did it also solved an incredibly annoying problem we had in the previous pass: &lt;em&gt;any&lt;/em&gt; change to your app was triggering &lt;code&gt;tsc&lt;/code&gt; to rebuild the entire TypeScript tree of your app, even if you didn’t so much as look at &lt;code&gt;.ts&lt;/code&gt; file. This was particularly annoying when combined with the long rebuild times: change a CSS file and wait for your TypeScript files to rebuild? Ugh. But not anymore!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="credit-and-thanks" class="level2"&gt;
&lt;h2&gt;Credit and Thanks&lt;/h2&gt;
&lt;p&gt;Massive credit goes to Dan Freeman (&lt;a href="https://github.com/dfreeman"&gt;@dfreeman&lt;/a&gt;) and Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;), who did most of the heavy lifting on the internals for this release, and together unlocked both incremental compilation and addon support. Derek also did the lion’s share of the work on writing the types for Ember and Ember Data.&lt;/p&gt;
&lt;p&gt;Thanks to Maarten Veenstra (&lt;a href="https://github.com/maerten"&gt;@maerten&lt;/a&gt;) for the original inspiration (and a spike last summer) for using a type registry, and to Mike North (&lt;a href="https://github.com/maerten"&gt;@mike-north&lt;/a&gt;) for some discussion and planning around the idea late in 2017. I may have implemented them, but the ideas came from the community!&lt;/p&gt;
&lt;p&gt;Thanks to Frank Tan (&lt;a href="https://github.com/tansongyang"&gt;@tansongyang&lt;/a&gt;) for doing a lot of the work on porting the generators from the Ember and Ember Data repositories to ember-cli-typescript, as well as converting them to TypeScript and to use the new formats. He also contributed the type definitions for the new (&lt;a href="https://github.com/emberjs/rfcs/pull/232/"&gt;RFC #232&lt;/a&gt;) QUnit testing API.&lt;/p&gt;
&lt;p&gt;Thanks to everyone who contributed to ember-cli-typescript or the Ember typings in any way since we released 1.0.0:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ember-cli-typescript contributors (note that I intentionally include here everyone who opened issues on the repository: that is &lt;em&gt;not&lt;/em&gt; a small thing and has helped us immensely):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bryan Crotaz (&lt;a href="https://github.com/BryanCrotaz"&gt;@BryanCrotaz&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Daniel Gratzl (&lt;a href="https://github.com/danielgratzl"&gt;@danielgratzl&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Guangda Zhang (&lt;a href="https://github.com/inkless"&gt;@inkless&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/guangda-prosperworks"&gt;@guangda-prosperworks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Krati Ahuja (&lt;a href="https://github.com/kratiahuja"&gt;@kratiahuja&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Martin Feckie (&lt;a href="https://github.com/mfeckie"&gt;@mfeckie&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Nikos Katsikanis (&lt;a href="https://github.com/QuantumInformation"&gt;@QuantumInformation&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Per Lundberg (&lt;a href="https://github.com/perlun"&gt;@perlun&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Prabhakar Poudel (&lt;a href="https://github.com/prabhakar-poudel"&gt;@Prabhakar-Poudel&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Ryan LaBouve (&lt;a href="https://github.com/ryanlabouve"&gt;@ryanlabouve&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Simon Ihmig (&lt;a href="https://github.com/simonihmig"&gt;@simonihmig&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Theron Cross (&lt;a href="https://github.com/theroncross"&gt;@theroncross&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Thomas Gossman (&lt;a href="https://github.com/gossi"&gt;@gossi&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Vince Cipriani (&lt;a href="https://github.com/vcipriani"&gt;@vcipriani&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember typings contributors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adnan Chowdhury (&lt;a href="https://github.com/bttf"&gt;@bttf&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Frank Tan (&lt;a href="https://github.com/tansongyang"&gt;@tansongyang&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Guangda Zhang (&lt;a href="https://github.com/inkless"&gt;@inkless&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Ignacio Bona Piedrabuena (&lt;a href="https://github.com/igbopie"&gt;@igbopie&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Leonard Thieu &lt;a href="https://github.com/leonard-thieu"&gt;@leonard-thieu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Logan Tegman &lt;a href="https://github.com/ltegman"&gt;@ltegman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Martin Feckie (&lt;a href="https://github.com/mfeckie"&gt;@mfeckie&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Mike North (&lt;a href="https://github.com/maerten"&gt;@mike-north&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Nathan Jacobson (&lt;a href="https://github.com/natecj"&gt;@natecj&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Per Lundberg (&lt;a href="https://github.com/perlun"&gt;@perlun&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Robin Ward (&lt;a href="https://github.com/eviltrout"&gt;@eviltrout&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks to Rob Jackson (&lt;a href="https://github.com/rwjblue"&gt;@rwjblue&lt;/a&gt;) and Tobias Bieniek (&lt;a href="https://github.com/Turbo87"&gt;@Turbo87&lt;/a&gt; on GitHub, @tbieniek in the Ember Slack) for answering tons of questions and putting up with regular pestering about Ember CLI.&lt;/p&gt;
&lt;p&gt;And last but not least, thanks to everyone who’s popped into #topic-typescript on the Ember Community Slack with questions, comments, problem reports, and the occasional word of encouragement. It really does help.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;For details on how this all works, see &lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html"&gt;TypeScript and Ember.js Update: Part 4&lt;/a&gt;, where I discuss these changes in detail.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;although they may actually get some benefits in a number of modern editors, since e.g. VS Code and the JetBrains IDEs will leverage types if they exist!&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;More on that in a post to be released in the next couple weeks—one I promised &lt;em&gt;long&lt;/em&gt; ago, but which we’re now in a place to actually do: a plan and a roadmap for typing the whole Ember ecosystem!&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;And of course, right as we finally landed our support for it, by hacking around the &lt;code&gt;--watch&lt;/code&gt; invocation in a lot of really weird ways, Microsoft shipped API-level support for it. We hope to switch to using that under the hood, but that shouldn’t make any difference at all to you as a consumer of the addon, except that if/when we land it at some point, you’ll just have a nicer experience.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 12 Feb 2018 07:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-02-12:/2018/announcing-ember-cli-typescript-110.html</guid><category>emberjs</category><category>typescript</category><category>javascript</category><category>typing-your-ember</category></item><item><title>TypeScript and Ember.js Update, Part 4</title><link>http://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the previous posts in this series, I introduced the big picture of how the story around TypeScript and Ember.js has improved over the last several months, walked through some important background on class properties, and dug deep on computed properties, actions, and mixins.&lt;/p&gt;
&lt;p&gt;In today’s post, we’ll look at how to write Ember Data models so they work correctly throughout your codebase, and see some improvements to how we can do &lt;code&gt;Service&lt;/code&gt; and &lt;code&gt;Controller&lt;/code&gt; injections even from a few weeks ago.&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;If you’re interested in all of this and would like to learn more in person, I’m &lt;a href="http://emberconf.com/speakers.html#chris-krycho"&gt;leading a workshop on it at EmberConf 2018&lt;/a&gt;—I’d love to see you there!&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Here’s the outline of this update sequence:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html"&gt;Overview, normal Ember objects, component arguments, and injections.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;Class properties—some notes on how things differ from the &lt;code&gt;Ember.Object&lt;/code&gt; world.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html"&gt;Computed properties, actions, mixins, and class methods.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html"&gt;&lt;strong&gt;Using Ember Data, and service and controller injections improvements.&lt;/strong&gt; (this post)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mixins and proxies; or: the really hard-to-type-check bits.&lt;/li&gt;
&lt;/ol&gt;
&lt;section id="ember-data" class="level2"&gt;
&lt;h2&gt;Ember Data&lt;/h2&gt;
&lt;p&gt;There remains one significant challenges to using Ember Data effectively with TypeScript today: Ember Data, for reasons I haven’t yet dug into myself, does not play nicely with ES6 classes. However, we &lt;em&gt;need&lt;/em&gt; named class exports for the sake of being able to use them as types elsewhere in our programs. The hack to work around this is much the same as anywhere else we need named exports but have to get things back into the prototype:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Model.extend({
  firstName: DS.attr(&amp;quot;string&amp;quot;),
  lastName: DS.attr(&amp;quot;string&amp;quot;)
}) {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can still define other items of the class normally, but attributes have to be prototypally bound or &lt;em&gt;you will have problems&lt;/em&gt;. Note that this only applies (as far as I can tell) to Ember Data &lt;code&gt;Model&lt;/code&gt;s specifically—&lt;code&gt;Adapter&lt;/code&gt; and &lt;code&gt;Serializer&lt;/code&gt; classes work just fine.&lt;/p&gt;
&lt;p&gt;The other problem we’ve historically had was dealing with lookups—the situation was similar to that I described in &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html"&gt;Part 3&lt;/a&gt; for service injection. However, as of &lt;em&gt;this week&lt;/em&gt;, we’re landing a solution that means you can drop the type coercions and just do a lookup like you would normally, and it will Just Work™️.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Keep your eyes open for the ember-cli-typescript 1.1 release in the next couple days!&lt;/p&gt;
&lt;p&gt;Once this release of both ember-cli-typescript and the updated typings land, when you generate an Ember Data model by doing &lt;code&gt;ember generate model person firstName:string lastName:string&lt;/code&gt;, it will look like this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Model.extend({
  firstName: DS.attr(&amp;quot;string&amp;quot;),
  lastName: DS.attr(&amp;quot;string&amp;quot;)
}) {
  // normal class body definition here
}

// DO NOT DELETE: this is how TypeScript knows how to look up your models.
declare module &amp;quot;ember-data&amp;quot; {
  interface ModelRegistry {
    person: Person;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That module and interface declaration at the bottom &lt;em&gt;merges&lt;/em&gt; the declaration for this model with the declarations for all the other models. You’ll see the same basic pattern for &lt;code&gt;DS.Adapter&lt;/code&gt; and &lt;code&gt;DS.Serializer&lt;/code&gt; instances. The result is that &lt;em&gt;using&lt;/em&gt; a model will now look like this. In addition to the &lt;code&gt;Person&lt;/code&gt; model definition just above, our adapter might be like this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Adapter {
  update(changes: { firstName?: string; lastName?: string }) {
    fetch(&amp;quot;the-url-to-change-it&amp;quot;, {
      method: &amp;quot;POST&amp;quot;,
      body: JSON.stringify(changes)
    });
  }
}

declare module &amp;quot;ember-data&amp;quot; {
  interface ModelRegistry {
    person: Person;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then putting the pieces together, our component definition will just look like this:&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;*&lt;strong&gt;Note:&lt;/strong&gt; please see the &lt;a href="https://www.chriskrycho.com/2018/ember-ts-class-properties.html"&gt;update about class properties published mid-2018&lt;/a&gt;. The examples below are incorrect in several important ways.&lt;/p&gt;
&lt;/aside&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Component from &amp;quot;@ember/component&amp;quot;;
import { inject as service } from &amp;quot;@ember/service&amp;quot;;

export default class PersonCard extends Component {
  id: string | number;

  store = service(&amp;quot;store&amp;quot;);
  model = this.store.findRecord(&amp;quot;person&amp;quot;, this.id);

  actions = {
    savePerson(changes: { firstName?: string; lastName?: string }) {
      this.store.adapterFor(&amp;quot;person&amp;quot;).update(changes);
    }
  };
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The type of &lt;code&gt;model&lt;/code&gt; here is now &lt;code&gt;Person &amp;amp; DS.PromiseObject&amp;lt;Person&amp;gt;&lt;/code&gt; (which is actually what Ember Data returns for these kinds of things!), and the &lt;code&gt;this.store.adapterFor&lt;/code&gt; actually correctly returns the &lt;code&gt;Person&lt;/code&gt; adapter as well, so the call to its &lt;code&gt;update&lt;/code&gt; method type-checks as well (including guaranteeing that the arguments to it are correct). That also means you’ll get autocompletion for those, including for their types, if you’re using an editor configured for it. And, happily for everyone, if you mistype a string (&lt;code&gt;preson&lt;/code&gt; instead of &lt;code&gt;person&lt;/code&gt;, for example), you’ll get a compile-time error!&lt;/p&gt;
&lt;p&gt;Notice as well that the service injection is much cleaner than it was in earlier examples in the series. That’s because we made the same “registry”-type changes—as I suggested we might back in &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html"&gt;Part 1&lt;/a&gt;!—for controller and service injections. Before, for this kind of thing:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;export default class PersonCard extends Component {
  store: Computed&amp;lt;DS.Store&amp;gt; = service();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;export default class PersonCard extends Component {
  store = service(&amp;quot;store&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s not &lt;em&gt;quite&lt;/em&gt; as minimalist as what you get in vanilla Ember (where the name of the property is used to do the lookup at runtime), but it’s pretty close, and a huge improvement! Not least since it’s &lt;em&gt;exactly&lt;/em&gt; as type-checked, and therefore as friendly to autocomplete/IntelliSense/etc. as it was before.&lt;/p&gt;
&lt;section id="migrating-existing-items" class="level3"&gt;
&lt;h3&gt;Migrating existing items&lt;/h3&gt;
&lt;p&gt;Your path forward for using the new approach is straightforward and fairly mechanical:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Add the module-and-interface declaration for each Ember Data &lt;code&gt;Model&lt;/code&gt;, &lt;code&gt;Adapter&lt;/code&gt;, and &lt;code&gt;Serializer&lt;/code&gt;; and also each Ember &lt;code&gt;Service&lt;/code&gt; and &lt;code&gt;Controller&lt;/code&gt; you have defined.&lt;/li&gt;
&lt;li&gt;Remove any type coercions you’ve written out already for these.&lt;/li&gt;
&lt;/ol&gt;
&lt;section id="add-declaration" class="level4"&gt;
&lt;h4&gt;1. Add declaration&lt;/h4&gt;
&lt;section id="ds.model" class="level5"&gt;
&lt;h5&gt;&lt;code&gt;DS.Model&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Model.extend({
  firstName: DS.attr(&amp;quot;string&amp;quot;),
  lastName: DS.attr(&amp;quot;string&amp;quot;)
}) {}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Now:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Model.extend({
  firstName: DS.attr(&amp;quot;string&amp;quot;),
  lastName: DS.attr(&amp;quot;string&amp;quot;)
}) {}

declare module &amp;quot;ember-data&amp;quot; {
  interface ModelRegistry {
    person: Person;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="ds.adapter" class="level5"&gt;
&lt;h5&gt;&lt;code&gt;DS.Adapter&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Adapter {
  // customization
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Now:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Adapter {
  // customization
}

declare module &amp;quot;ember-data&amp;quot; {
  interface AdapterRegistry {
    person: Person;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="ds.serializer" class="level5"&gt;
&lt;h5&gt;&lt;code&gt;DS.Serializer&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Serializer {
  // customization
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Now:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import DS from &amp;quot;ember-data&amp;quot;;

export default class Person extends DS.Serializer {
  // customization
}

declare module &amp;quot;ember-data&amp;quot; {
  interface SerializerRegistry {
    person: Person;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="service" class="level5"&gt;
&lt;h5&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Service from &amp;quot;@ember/service&amp;quot;;

export default class ExternalLogging extends Service {
  // implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Now:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Service from &amp;quot;@ember/service&amp;quot;;

export default class ExternalLogging extends Service {
  // implementation
}

declare module &amp;quot;ember&amp;quot; {
  interface ServiceRegistry {
    &amp;quot;external-logging&amp;quot;: ExternalLogging;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="controller" class="level5"&gt;
&lt;h5&gt;&lt;code&gt;Controller&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Before:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Controller from &amp;quot;@ember/controller&amp;quot;;

export default class Profile extends Controller {
  // implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Now:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Controller from &amp;quot;@ember/controller&amp;quot;;

export default class Profile extends Controller {
  // implementation
}

declare module &amp;quot;@ember/controller&amp;quot; {
  interface ControllerRegistry {
    profile: Profile;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you &lt;em&gt;don’t&lt;/em&gt; do add the type registry declarations, you’ll just get back:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;compiler errors&lt;/em&gt; for any use of a string key in your service and controller lookups&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Service&lt;/code&gt; and &lt;code&gt;Controller&lt;/code&gt; (the top-level classes we inherit from) instead of the specific class you created if you use the no-argument version of the &lt;code&gt;inject&lt;/code&gt; helpers&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;compiler errors&lt;/em&gt; for &lt;code&gt;DS.Model&lt;/code&gt;, &lt;code&gt;DS.Adapter&lt;/code&gt;, and &lt;code&gt;DS.Serializer&lt;/code&gt; lookups (since they always have a string key)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’re looking to allow your existing code to all just continue working while you &lt;em&gt;slowly&lt;/em&gt; migrate to TypeScript, you can add this as a fallback somewhere in your own project (adapted to whichever of the registries you need):&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;declare module &amp;quot;ember-data&amp;quot; {
  interface ModelRegistry {
    [key: string]: DS.Model;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will lose you the type-checking if you type a key that doesn’t exist, but it means that models you haven’t yet added the type definition for won’t throw compile errors. (We’ve made this opt-in because otherwise you’d never be able to get that type-checking for using an invalid key.)&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="remove-any-existing-coercions" class="level4"&gt;
&lt;h4&gt;2. Remove any existing coercions&lt;/h4&gt;
&lt;p&gt;Now that we have the necessary updates to be able to do these lookups automatically in the compiler, we need to remove any existing type coercions.&lt;/p&gt;
&lt;section id="service-and-controller" class="level5"&gt;
&lt;h5&gt;&lt;code&gt;Service&lt;/code&gt; and &lt;code&gt;Controller&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;This change is really straightforward (and actually just simplifies things a lot!) for &lt;code&gt;Service&lt;/code&gt; and &lt;code&gt;Controller&lt;/code&gt; injections.&lt;/p&gt;
&lt;pre class="diff"&gt;&lt;code&gt;  import Component from &amp;#39;@ember/component&amp;#39;;
  import { inject as service } from &amp;#39;@ember/service&amp;#39;;
- import Computed from &amp;#39;@ember/object/computed&amp;#39;;
-
- import ExternalLogging from &amp;#39;my-app/services/external-logging&amp;#39;;

  export default class UserProfile extends Component {
-   externalLogging: Computed&amp;lt;ExternalLogging&amp;gt; = service();
+   externalLogging = service(&amp;#39;external-logging&amp;#39;);
    // other implementation
  }&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="ember-data-1" class="level5"&gt;
&lt;h5&gt;Ember Data&lt;/h5&gt;
&lt;p&gt;This looks &lt;em&gt;slightly&lt;/em&gt; different for the Ember Data side.&lt;/p&gt;
&lt;p&gt;If you’ve been using the type coercion forms we shipped as a stopgap, like this—&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const person = this.store.findRecord&amp;lt;Person&amp;gt;(&amp;quot;person&amp;quot;, 123);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;—you’ll need to drop the type coercion on &lt;code&gt;findRecord&amp;lt;Person&amp;gt;&lt;/code&gt;, which will give you a type error:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[ts] Type ‘Person’ does not satisfy the constraint ‘string’.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is because, behind the scenes, &lt;code&gt;findRecord&lt;/code&gt; still takes a type parameter, but it’s now a string—the name of the model you’re looking up—&lt;em&gt;not&lt;/em&gt; the model itself. As such, you should &lt;em&gt;never&lt;/em&gt; supply that type parameter yourself; it’s taken care of automatically. As a result, your invocation should just be:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const person = this.store.findRecord(&amp;quot;person&amp;quot;, 123);&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="the-full-type-of-lookups" class="level3"&gt;
&lt;h3&gt;The full type of lookups&lt;/h3&gt;
&lt;p&gt;One last note on Ember Data: calls like &lt;code&gt;findRecord('person', 123)&lt;/code&gt; actually return the type &lt;code&gt;Person &amp;amp; DS.PromiseObject&amp;lt;Person&amp;gt;&lt;/code&gt; – i.e., a type that acts like both the model and a promise wrapping the model. This is, to be sure, &lt;em&gt;weird&lt;/em&gt;, but it’s the reality, so that’s what our types give you.&lt;/p&gt;
&lt;p&gt;If you find yourself needing to write out that type locally for some reason—e.g. because part of your app deals explicitly with the result of a lookup—you may find it convenient to define a global type alias like this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;type Loaded&amp;lt;T&amp;gt; = T &amp;amp; DS.PromiseObject&amp;lt;T&amp;gt;;
const person: Loaded&amp;lt;Person&amp;gt; = this.store.findRecord(&amp;quot;person&amp;quot;, 123);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given the new support for getting that type automatically, you shouldn’t &lt;em&gt;normally&lt;/em&gt; need that, but it’s convenient if or when you &lt;em&gt;do&lt;/em&gt; need it. For example, if a component is passed the result of a &lt;code&gt;Person&lt;/code&gt; lookup and needs to be able to treat it as a promise &lt;em&gt;or&lt;/em&gt; the model, you could write it like this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Component from &amp;quot;@ember/component&amp;quot;;

export default class PersonDisplay extends Component {
  model: Loaded&amp;lt;Person&amp;gt;; // instead of just `model: Person`
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="preview-mirage" class="level3"&gt;
&lt;h3&gt;Preview: Mirage&lt;/h3&gt;
&lt;p&gt;As it turns out, Ember CLI Mirage’s approach is a lot like Ember Data’s (although it’s actually a lot more dynamic!), so I have a very similar approach working in our codebase for doing lookups with Mirage’s database. Sometime in February or March, we hope to get that completed and upstreamed into Mirage itself, so that you can get these exact same benefits when using Mirage to write your tests.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;And that’s pretty much a wrap on Ember Data! The &lt;em&gt;next&lt;/em&gt; post you can expect in this series will be a break from nitty-gritty “how to use TS in Ember” posts for a very exciting, closely related announcement—probably tomorrow or Monday! The post after that will be a deep dive into (mostly the limitations of!) writing types for mixins and proxies.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re curious about the mechanics, we’re basically setting up a “type registry” which maps the string keys to the correct model, so that the type of e.g. &lt;code&gt;store.createRecord('some-model', { ... })&lt;/code&gt; will do a lookup in an interface which defines a mapping from model name, i.e. &lt;code&gt;some-model&lt;/code&gt; here, to the model type, e.g. &lt;code&gt;export default class SomeModel extends DS.Model.extend({ ... }) {}&lt;/code&gt;. I’ll write up a full blog post on the mechanics of that sometime soon.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 08 Feb 2018 07:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-02-08:/2018/typing-your-ember-update-part-4.html</guid><category>TypeScript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>TypeScript and Ember.js Update, Part 3</title><link>http://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; if you’re following along with this &lt;em&gt;as I publish it&lt;/em&gt; in late January 2018, please go back and read the end of &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;Part 2&lt;/a&gt;, which I updated substantially yesterday evening to include more material I missed in the first version of that post, but which belonged there and not here.&lt;/p&gt;
&lt;p&gt;In the previous posts in this series, I introduced the big picture of how the story around TypeScript and Ember.js has improved over the last several months and walked through some important background on class properties. In this post, I’ll build on that foundation to look closely at computed properties, actions, and mixins.&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;If you’re interested in all of this and would like to learn more in person, I’m &lt;a href="http://emberconf.com/speakers.html#chris-krycho"&gt;leading a workshop on it at EmberConf 2018&lt;/a&gt;—I’d love to see you there!&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Here’s the outline of this update sequence:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html"&gt;Overview, normal Ember objects, component arguments, and injections.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;Class properties—some notes on how things differ from the &lt;code&gt;Ember.Object&lt;/code&gt; world.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html"&gt;&lt;strong&gt;Computed properties, actions, mixins, and class methods (this post).&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html"&gt;Using Ember Data, and service and controller injections improvements.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mixins and proxies; or: the really hard-to-type-check bits.&lt;/li&gt;
&lt;/ol&gt;
&lt;section id="a-detailed-example-contd.-computed-properties-mixins-actions-and-class-methods" class="level2"&gt;
&lt;h2&gt;A detailed example (cont’d.) – computed properties, mixins, actions, and class methods&lt;/h2&gt;
&lt;aside&gt;
&lt;p&gt;*&lt;strong&gt;Note:&lt;/strong&gt; please see the &lt;a href="https://www.chriskrycho.com/2018/ember-ts-class-properties.html"&gt;update about class properties published mid-2018&lt;/a&gt;. The example below and in the following posts is incorrect in several important ways.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Let’s start by recalling the example Component we’re working through:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;
import Computed from &amp;#39;@ember/object/computed&amp;#39;;
import { inject as service } from &amp;#39;@ember/service&amp;#39;;
import { assert } from &amp;#39;@ember/debug&amp;#39;;
import { isNone } from &amp;#39;@ember/utils&amp;#39;;

import Session from &amp;#39;my-app/services/session&amp;#39;;
import Person from &amp;#39;my-app/models/person&amp;#39;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &amp;#39;firstName&amp;#39;)};`;
    }
  );

  aComputed = computed(&amp;#39;aString&amp;#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&amp;#39;session.user&amp;#39;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;#39;session.user&amp;#39;);

  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&amp;#39;aCollection&amp;#39;);
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(value));
    }
  };

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.get(&amp;#39;aCollection&amp;#39;).includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(&amp;#39;ahoy&amp;#39;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;section id="computed-properties" class="level3"&gt;
&lt;h3&gt;Computed properties&lt;/h3&gt;
&lt;p&gt;We already covered component arguments and injections as well as basic class properties and the exceptions to normal class-property ways of doing things, in Parts &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;1&lt;/a&gt; and &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;2&lt;/a&gt;. With that background out of the way, we can now turn to computed properties. I’m including the component arguments in this code sample because they’re referenced in the computed property. Assume &lt;code&gt;Person&lt;/code&gt; is a pretty “person” representation, with a &lt;code&gt;firstName&lt;/code&gt; and a &lt;code&gt;lastName&lt;/code&gt;and maybe a few other properties.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &amp;#39;firstName&amp;#39;)};`;
    }
  );

  aComputed = computed(&amp;#39;aString&amp;#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&amp;#39;session.user&amp;#39;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;#39;session.user&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;section id="computed-properties-1" class="level4"&gt;
&lt;h4&gt;&lt;code&gt;computed&lt;/code&gt; properties&lt;/h4&gt;
&lt;p&gt;When using a computed property in the brave new world of ES6 classes, we normally just assign them as instance properties. As mentioned in &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;the previous post&lt;/a&gt;, and in line with my comments above, this has some important tradeoffs around performance. If you need the absolute &lt;em&gt;best&lt;/em&gt; performance, you can continue to install them on the prototype by doing this instead:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class MyComponent extends Component.extend({
  fromModel: computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &amp;#39;firstName&amp;#39;)};`;
    }
  ),
}) {
  // other properties
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whichever way you do it, TypeScript will correctly infer the type of the computed property in question (here &lt;code&gt;fromModel&lt;/code&gt;) as long as you explicitly annotate the return type of the callback passed to &lt;code&gt;computed&lt;/code&gt;. Accordingly, in this case, the type of &lt;code&gt;fromModel&lt;/code&gt; is &lt;code&gt;ComputedProperty&amp;lt;string&amp;gt;&lt;/code&gt;. The fact that it’s a &lt;code&gt;ComputedProperty&lt;/code&gt; means if you try to treat it as a plain string, without using &lt;code&gt;Ember.get&lt;/code&gt; to unwrap it, TypeScript will complain at you.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// type checking error:
this.fromModel.length;

// type checking valid:
this.get(&amp;#39;fromModel&amp;#39;).length;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The other really important thing to note here is the use of &lt;code&gt;this: MyComputed&lt;/code&gt;. By doing this, we’re telling TypeScript explicitly that the type of &lt;code&gt;this&lt;/code&gt; in this particular function is the class context. We have to do this here, because we don’t have any way to tell the &lt;code&gt;computed&lt;/code&gt; helper itself that the function inside it will be bound to the &lt;code&gt;this&lt;/code&gt; context of the containing class. Put another way: we don’t have any &lt;em&gt;other&lt;/em&gt; way to tell TypeScript that one of the things &lt;code&gt;computed&lt;/code&gt; does is bind &lt;code&gt;this&lt;/code&gt; appropriately to the function passed into it; but gladly we do have &lt;em&gt;this&lt;/em&gt; way—otherwise we’d be out of luck entirely! (You’ll see the same thing below when we look at actions). The boilerplate is a bit annoying, admittedly—but it at least makes it type-check.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="computed-property-macros" class="level4"&gt;
&lt;h4&gt;Computed property macros&lt;/h4&gt;
&lt;p&gt;Beyond &lt;code&gt;computed&lt;/code&gt;, there are a lot of other computed property tools we use all the time. Some of them can (and therefore &lt;em&gt;do&lt;/em&gt;) infer the type of the resulting computed property correctly. But there are a bunch of idiomatic things that TypeScript does not and cannot validate – a number of the computed property macros are in this bucket, because they tend to be used for nested keys, and as noted above, TypeScript does not and &lt;em&gt;cannot&lt;/em&gt; validate nested keys like that.&lt;/p&gt;
&lt;p&gt;We have a representative of each of these scenarios:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  isLoggedIn = bool(&amp;#39;session.user&amp;#39;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;#39;session.user&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the case of &lt;code&gt;isLoggedIn&lt;/code&gt;, the &lt;code&gt;bool&lt;/code&gt; helper only ever returns a boolean, so the type of &lt;code&gt;isLoggedIn&lt;/code&gt; is &lt;code&gt;ComputedProperty&amp;lt;boolean&amp;gt;&lt;/code&gt;. In the case of &lt;code&gt;savedUser&lt;/code&gt;, since TypeScript can’t figure out what the nested key means, we have to specify it explicitly, using &lt;code&gt;Computed&amp;lt;Person&amp;gt;&lt;/code&gt;.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; In these cases, you have to do the work yourself to check that the type you specify is the &lt;em&gt;correct&lt;/em&gt; type. If you write down the wrong type here, TypeScript will believe you (it doesn’t have any other good option!) and you’ll be back to things blowing up unexpectedly at runtime.&lt;/p&gt;
&lt;p&gt;The typings supply the concrete (non-&lt;code&gt;any&lt;/code&gt;) return type for: &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;equal&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;gte&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;lte&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;notEmpty&lt;/code&gt;, &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;sum&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="on-nested-keys" class="level4"&gt;
&lt;h4&gt;On nested keys&lt;/h4&gt;
&lt;p&gt;As noted above, TypeScript cannot do a lookup for any place using nested keys—which means that &lt;code&gt;this.get('some.nested.key')&lt;/code&gt; won’t type-check, sadly. This is an inherent limitation of the type system as it stands today, and for any future I can foresee. The problem is this: what exactly &lt;em&gt;is&lt;/em&gt; &lt;code&gt;'some.nested.key'&lt;/code&gt;? It &lt;em&gt;could&lt;/em&gt; be what we use it for in the usual scenario in Ember, of course: a string representing a lookup on a property of a property of a property of whatever &lt;code&gt;this&lt;/code&gt; is. But it could equally well be a key named &lt;code&gt;'some.nested.key'&lt;/code&gt;. This is perfectly valid JavaScript, after all:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const foo = {
  [&amp;#39;some.nested.key&amp;#39;]: &amp;#39;Well, this is weird, but it works&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript does not today and presumably &lt;em&gt;never will&lt;/em&gt; be able to do that lookup. The workaround is to do one of two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;If you &lt;em&gt;know&lt;/em&gt; you have a valid parent, you can do the (catastrophically ugly, but functional) nested &lt;code&gt;Ember.get&lt;/code&gt; that now litters our codebase:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import { get } from &amp;#39;@ember/object&amp;#39;;
const value = get(get(get(anObject, &amp;#39;some&amp;#39;), &amp;#39;nested&amp;#39;), &amp;#39;key&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yes, it’s a nightmare. But… it type-checks, and it works well &lt;em&gt;enough&lt;/em&gt; in the interim until we get a decorators-based solution that lets us leverage &lt;a href="https://github.com/emberjs/rfcs/pull/281"&gt;RFC #281&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use the &lt;code&gt;// @ts-ignore&lt;/code&gt; to simply ignore the type-unsafety of the lookup. This approach is preferable when you don’t know if any of the keys might be missing. If, for example, either &lt;code&gt;some&lt;/code&gt; or &lt;code&gt;nested&lt;/code&gt; were &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, the lookup example above in (1) would fail.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import { get } from &amp;#39;@ember/object&amp;#39;;
// @ts-ignore -- deep lookup with possibly missing parents
const value = get(anObject, &amp;#39;some.nested.key&amp;#39;);&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="actions" class="level3"&gt;
&lt;h3&gt;Actions&lt;/h3&gt;
&lt;p&gt;What about actions? As usual, these just become class instance properties in the current scheme.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&amp;#39;aCollection&amp;#39;);
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(value));
    }
  };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with computed properties, we need the &lt;code&gt;this&lt;/code&gt; type declaration to tell TypeScript that this method is going to be automatically bound to the class instance. Otherwise, TypeScript thinks the &lt;code&gt;this&lt;/code&gt; here is the &lt;code&gt;actions&lt;/code&gt; hash, rather than the &lt;code&gt;MyComponent&lt;/code&gt; class.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Happily, that’s really all there is to it for actions: they’re quite straightforward other than needing the &lt;code&gt;this&lt;/code&gt; type specification.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="types-in-.extend...-blocks" class="level3"&gt;
&lt;h3&gt;Types in &lt;code&gt;.extend({...})&lt;/code&gt; blocks&lt;/h3&gt;
&lt;p&gt;By and large, you can get away with using the same &lt;code&gt;this: MyComponent&lt;/code&gt; trick when hacking around prototypal extension problems, or performance problems, by putting computed properties in a &lt;code&gt;.extend({...}&lt;/code&gt; block. However, you &lt;em&gt;will&lt;/em&gt; sometimes see a type error indicating that the class is referenced in its own definition expression. In that case, you may need to judiciously apply &lt;code&gt;any&lt;/code&gt;, if you can’t make it work by using normal class properties.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="constructor-and-class-methods" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;constructor&lt;/code&gt; and class methods&lt;/h3&gt;
&lt;p&gt;ES6 class constructors and class methods both work as you’d expect, though as we’ll see you’ll need an extra bit of boilerplate for methods, at least for now.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample): void {
    if (!this.get(&amp;#39;aCollection&amp;#39;).includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(&amp;#39;ahoy&amp;#39;));
    }
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the most part, you can just switch to using normal ES6 class constructors instead of the Ember &lt;code&gt;init&lt;/code&gt; method. You can, if you so desire, also move existing &lt;code&gt;init&lt;/code&gt; functions passed to a &lt;code&gt;.extends({ ...})&lt;/code&gt; hash to class methods, and they’ll work once you change &lt;code&gt;this._super(...arguments)&lt;/code&gt; to &lt;code&gt;super.init(...arguments)&lt;/code&gt;. It’s worth pausing to understand the relationship between &lt;code&gt;init&lt;/code&gt; and prototypal &lt;code&gt;init&lt;/code&gt; and the &lt;code&gt;constructor&lt;/code&gt;. An &lt;code&gt;init&lt;/code&gt; in the &lt;code&gt;.extends()&lt;/code&gt; hash runs first, then an &lt;code&gt;init&lt;/code&gt; method on the class, then the normal &lt;code&gt;constructor&lt;/code&gt;.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Note that you do not need to (and cannot) annotate the &lt;code&gt;constructor&lt;/code&gt; with &lt;code&gt;this: MyComponent&lt;/code&gt;. Depending on the class you’re building, you may &lt;em&gt;occasionally&lt;/em&gt; have type-checking problems that come up as a result of this. I’ve only ever seen that happen when using computed properties while defining a proxy,&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; but it does come up. In that case, you can fall back to using &lt;code&gt;init&lt;/code&gt; as a method, and set &lt;code&gt;this: MyComponent&lt;/code&gt; on &lt;em&gt;it&lt;/em&gt;, and things will generally fall out as working correctly at that point. When it comes up, this seems to be just a limitation of what &lt;code&gt;this&lt;/code&gt; is understood to be in a &lt;code&gt;constructor&lt;/code&gt; given Ember’s rather more-complex-than-normal-classes view of what a given item being constructed is.&lt;/p&gt;
&lt;p&gt;Other class methods do also need the &lt;code&gt;this&lt;/code&gt; type specified if they touch computed properties. (Normal property access is fine without it.) That’s because the lookups for &lt;code&gt;ComputedProperty&lt;/code&gt; instances (using &lt;code&gt;Ember.get&lt;/code&gt; or &lt;code&gt;Ember.set&lt;/code&gt;) need to know what &lt;code&gt;this&lt;/code&gt; is where they should do the lookup, and the full &lt;code&gt;this&lt;/code&gt; context isn’t inferred correctly at present. You can either write that on every invocation of &lt;code&gt;get&lt;/code&gt;and &lt;code&gt;set&lt;/code&gt;, like &lt;code&gt;(this as MyComponent).get(...)&lt;/code&gt;, or you can do it once at the start of the method. Again, a bit boiler-platey, but it gets the job done and once you’re used to it it’s minimal hassle.&lt;a href="#fn6" class="footnote-ref" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;One last note, which I didn’t include in the example: if you have a function (usually an action) passed into the component, you can define it most simply by just using &lt;code&gt;onSomeAction: Function;&lt;/code&gt; in the class definition, right with other class arguments. However, it’s usually most helpful to define what the type should actually &lt;em&gt;be&lt;/em&gt;, for your own sanity check if nothing else. As with e.g. &lt;code&gt;model&lt;/code&gt; in this example, we don’t actually have a good way to type-check that what is passed is correct. We can, however, at least verify in the constructor that the caller passed in a function using &lt;a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fdebug/methods/assert?anchor=assert"&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt;, just as with other arguments.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;So that’s a wrap on components (and controllers, which behave much the same way).&lt;/p&gt;
&lt;p&gt;In the next post, I’ll look at the elephant in the room: Ember Data (and closely related concern Ember CLI Mirage). While you &lt;em&gt;can&lt;/em&gt; make Ember Data stuff largely work today, it’s still a ways from &lt;em&gt;Just Works™️&lt;/em&gt;, sadly, but we’ll cover how to work around the missing pieces—we’ve gotten there in our own codebase, so you can, too!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;As mentioned in &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;Part 2&lt;/a&gt;, this problem doesn’t go away until we get decorators, unless you’re putting them on the prototype via &lt;code&gt;.extends()&lt;/code&gt;—but see below for the problems with &lt;em&gt;that&lt;/em&gt;. The short version is, we need decorators for this to actually be &lt;em&gt;nice&lt;/em&gt;. Once we get decorators, we will be able to combine them with the work done for &lt;a href="https://github.com/emberjs/rfcs/pull/281"&gt;RFC #281&lt;/a&gt; and normal lookup will just work:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;@computed(&amp;#39;model.firstName&amp;#39;)
get fromModel() {
  return `My name is ${this.model.firstName};`;
}&lt;/code&gt;&lt;/pre&gt;
&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;I’ve used &lt;code&gt;Computed&amp;lt;Person&amp;gt;&lt;/code&gt; and similar throughout here because it’s the most clear while still being reasonably concise. The actual type name in Ember’s own code is &lt;code&gt;ComputedProperty&lt;/code&gt;, but &lt;code&gt;ComputedProperty&amp;lt;Person&amp;gt;&lt;/code&gt; is &lt;em&gt;long&lt;/em&gt;, and it wouldn’t have added any real clarity here. In my own codebase, we use &lt;code&gt;CP&lt;/code&gt; (for “&lt;strong&gt;C&lt;/strong&gt;omputed &lt;strong&gt;P&lt;/strong&gt;roperty”) for the sake of brevity—so here that would just be &lt;code&gt;CP&amp;lt;Person&amp;gt;&lt;/code&gt;.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;In the future, this problem will hopefully be solved neatly by decorators:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  @action
  addToCollection(value: string) {
    const current = this.get(&amp;#39;aCollection&amp;#39;);
    this.set(&amp;#39;aCollection&amp;#39;, current.concat(value));
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For today, however, specifying a &lt;code&gt;this&lt;/code&gt; type is where it’s at.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;You can see this for yourself in &lt;a href="https://ember-twiddle.com/36844717dcc50d734139368edf2e87da"&gt;this Ember Twiddle&lt;/a&gt;—just open your developer tools and note the sequence.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Proxies, along with details of mixins, are a subject I’m leaving aside for Part 5, otherwise known as the “wow, this stuff is really weird to type” entry in the series.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;Not &lt;em&gt;no&lt;/em&gt; hassle, though, and I look forward to a future where we can drop it, as Ember moves more and more toward modern JavaScript ways of solving these same problems!&lt;a href="#fnref6" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 25 Jan 2018 07:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-25:/2018/typing-your-ember-update-part-3.html</guid><category>TypeScript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>TypeScript and Ember.js Update, Part 2</title><link>http://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the previous post in this series, I introduced the big picture of how the story around TypeScript and Ember.js has improved over the last several months. In this post, I’ll be pausing from TypeScript-specific to take a look at how things work with &lt;em&gt;class properties&lt;/em&gt;, since they have some big implications for how we work, which then have ripple effects on computed properties, actions, etc.&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;If you’re interested in all of this and would like to learn more in person, I’m &lt;a href="http://emberconf.com/speakers.html#chris-krycho"&gt;leading a workshop on it at EmberConf 2018&lt;/a&gt;—I’d love to see you there!&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Here’s the outline of this update sequence:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html"&gt;Overview, normal Ember objects, component arguments, and injections.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;&lt;strong&gt;Class properties—some notes on how things differ from the &lt;code&gt;Ember.Object&lt;/code&gt; world (this post).&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html"&gt;Computed properties, actions, mixins, and class methods.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html"&gt;Using Ember Data, and service and controller injections improvements.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mixins and proxies; or: the really hard-to-type-check bits.&lt;/li&gt;
&lt;/ol&gt;
&lt;section id="a-detailed-example-contd.-class-properties" class="level2"&gt;
&lt;h2&gt;A detailed example (cont’d.) – class properties&lt;/h2&gt;
&lt;aside&gt;
&lt;p&gt;*&lt;strong&gt;Note:&lt;/strong&gt; please see the &lt;a href="https://www.chriskrycho.com/2018/ember-ts-class-properties.html"&gt;update about class properties published mid-2018&lt;/a&gt;. The example below and in the following posts is incorrect in several important ways.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Let’s start by recalling the example Component we’re working through:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;
import Computed from &amp;#39;@ember/object/computed&amp;#39;;
import { inject as service } from &amp;#39;@ember/service&amp;#39;;
import { assert } from &amp;#39;@ember/debug&amp;#39;;
import { isNone } from &amp;#39;@ember/utils&amp;#39;;

import Session from &amp;#39;my-app/services/session&amp;#39;;
import Person from &amp;#39;my-app/models/person&amp;#39;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &amp;#39;firstName&amp;#39;)};`;
    }
  );

  aComputed = computed(&amp;#39;aString&amp;#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&amp;#39;session.user&amp;#39;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;#39;session.user&amp;#39;);

  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&amp;#39;aCollection&amp;#39;);
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(value));
    }
  };

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.get(&amp;#39;aCollection&amp;#39;).includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(&amp;#39;ahoy&amp;#39;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Throughout, you’ll note that we’re using &lt;em&gt;assignment&lt;/em&gt; to create these class properties—a big change from the key/value setup in the old &lt;code&gt;.extends({ ... })&lt;/code&gt; model:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Class properties like this are &lt;em&gt;instance properties&lt;/em&gt;. These are compiled to, because they are &lt;em&gt;equivalent to&lt;/em&gt;, assigning a property in the constructor. That is, these two ways of writing class property initialization are equivalent—&lt;/p&gt;
&lt;p&gt;At the property definition site:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // snip...

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // snip..

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  // snip...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the constructor:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // snip...

  // -- Class properties -- //
  aString: string;
  aCollection: string[];

  constructor() {
    super();

    this.aString = &amp;#39;this is fine&amp;#39;;
    this.aCollection = [];

    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  // snip...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see why the first one is preferable: if you don’t need any input to the component to set the value, you can simply set the definition inline where the property is declared.&lt;/p&gt;
&lt;p&gt;However, this is &lt;em&gt;quite&lt;/em&gt; unlike using &lt;code&gt;.extend&lt;/code&gt;, which installs the property on the prototype. Three very important differences from what you’re used to fall out of this, and &lt;em&gt;none of them are specific to TypeScript.&lt;/em&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section id="default-values" class="level3"&gt;
&lt;h3&gt;1. Default values&lt;/h3&gt;
&lt;p&gt;Since class property setup runs during the constructor, if you want the caller to be able to override it, you &lt;em&gt;must&lt;/em&gt; give it an explicit fallback that references what’s passed into the function. Something like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;class AnyClass {
  aDefaultProp = this.aDefaultProp || 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, translated back into the constructor form:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;class AnyClass {
  constructor() {
    this.aDefaultProp = this.aDefaultProp || 0;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, you can see that if something has &lt;em&gt;already set&lt;/em&gt; the &lt;code&gt;aDefaultProp&lt;/code&gt; value (before the class constructor is called), we’ll use that value; otherwise, we’ll use the default. You can think of this as being something like default arguments to a function. In our codebase, we have started using &lt;a href="https://lodash.com/docs/4.17.4#defaultTo"&gt;&lt;code&gt;_.defaultTo&lt;/code&gt;&lt;/a&gt;, which works quite nicely. In the old world of declaring props with their values in the &lt;code&gt;.extends({ ... })&lt;/code&gt; hash, we got this behavior “for free”—but without a lot of other benefits of classes, so not &lt;em&gt;actually&lt;/em&gt; for free.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="no-more-shared-state" class="level3"&gt;
&lt;h3&gt;2. No more shared state&lt;/h3&gt;
&lt;p&gt;Because these are instance properties, &lt;em&gt;not&lt;/em&gt; assigned on the prototype, you do not have to worry about the problem—&lt;a href="https://dockyard.com/blog/2014/04/17/ember-object-self-troll"&gt;well-known among experienced Ember.js developers, but prone to bite people new to the framework&lt;/a&gt;—where you assign an array or object in the &lt;code&gt;.extend()&lt;/code&gt; method and then find that it’s shared between instances.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default Component.extend({
  anArray: [],  // &amp;lt;- this *will* be shared between instances
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve long had to handle this by setting up those properties in our &lt;code&gt;init()&lt;/code&gt; method instead, so that they are created during object instantiation, rather than on the prototype. This problem goes away entirely with classes, including in TypeScript.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class MyComponent extends Component {
  anArray = [];  // &amp;lt;- this will *not* be shared between instances
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note that here, we don’t have a type for the array, so it’s of type &lt;code&gt;any[]&lt;/code&gt;; we &lt;em&gt;always&lt;/em&gt; need type annotations for empty arrays if we want them to be a “narrower,” or more specific, type than that.)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="performance-changes" class="level3"&gt;
&lt;h3&gt;3. Performance changes&lt;/h3&gt;
&lt;p&gt;The flip-side of this is that the only way we currently have to create computed property instances (until decorators stabilize) is &lt;em&gt;also&lt;/em&gt; as instance, not prototype, properties. I’ll look at computed properties (and their types) in more detail in the next post, so here mostly just note how the computed is set up on the class: by assignment, &lt;em&gt;not&lt;/em&gt; as a prototypal property.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class MyComponent extends Component {
  aString = &amp;#39;Hello, there!&amp;#39;;

  itsLength = computed(&amp;#39;aString&amp;#39;, function(this: MyComponent): number {
    return this.aString.length;
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;em&gt;does&lt;/em&gt; have a performance cost, which will be negligible in the ordinary case but pretty nasty if you’re rendering hundreds to thousands of these items onto the page. You can use this workaround for these as well as for any other properties which need to be prototypal (more on &lt;em&gt;that&lt;/em&gt; in the next post as well):&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class MyComponent extends Component.extend({
  itsLength: computed(&amp;#39;aString&amp;#39;, function(this: MyComponent): number {
      return this.aString.length;
    }
  );
}) {
  aString = &amp;#39;Hello, there!&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;em&gt;looks&lt;/em&gt; really weird, but it works exactly as you’d expect.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="class-property-variants" class="level2"&gt;
&lt;h2&gt;Class property variants&lt;/h2&gt;
&lt;p&gt;There are two times when things will look different from basic class properties. Both have to do with setting up the prototype to work the way other parts of the Ember object ecosystem expect.&lt;/p&gt;
&lt;section id="variant-1-prototypalmerged-properties" class="level3"&gt;
&lt;h3&gt;Variant 1: Prototypal/merged properties&lt;/h3&gt;
&lt;p&gt;The first is when you’re using properties that need to be merged with properties in the prototype chain, e.g. &lt;code&gt;attributeBindings&lt;/code&gt; or &lt;code&gt;classNameBindings&lt;/code&gt;, or which (because of details of how components are constructed) have to be set on the prototype rather than as instance properties, e.g. &lt;code&gt;tagClass&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For those, we can just leverage &lt;code&gt;.extend&lt;/code&gt; in conjunction with classes:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;

export default class MyListItem extends Component.extend({
  tagName: &amp;#39;li&amp;#39;,
  classNameBindings: [&amp;#39;itemClass&amp;#39;]
}) {
  itemClass = &amp;#39;this-be-a-list&amp;#39;;

  // etc.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is also how you’ll &lt;em&gt;use&lt;/em&gt; mixins (on defining them, see below):&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import MyMixin from &amp;#39;my-app/mixins/my-mixin&amp;#39;;

export default class AnExample extends Component.extend(MyMixin) {
  // the rest of the definition.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note, however—and this is very important—that you cannot &lt;code&gt;.extend&lt;/code&gt; an existing &lt;code&gt;class&lt;/code&gt; implementation. As a result, deep inheritance hierarchies &lt;em&gt;may&lt;/em&gt; make transitioning to classes in Ember painful. Most importantly: they may work &lt;em&gt;some&lt;/em&gt; of the time in &lt;em&gt;some&lt;/em&gt; ways, but will break when you least expect. So don’t do that! (This isn’t a TypeScript limitation; it’s a limitation of classes in Ember today.)&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="variant-2-mixins" class="level3"&gt;
&lt;h3&gt;Variant 2: Mixins&lt;/h3&gt;
&lt;p&gt;The other time you’ll have to take a different tack—and this falls directly out of the need for prototypal merging—is with &lt;code&gt;Mixin&lt;/code&gt;s, which don’t yet work properly with classes. Worse, it’s difficult (if not impossible) to get rigorous type-checking internally in &lt;code&gt;Mixin&lt;/code&gt; definitions, because you cannot define them as classes: you &lt;em&gt;have&lt;/em&gt; to use the old style throughout, because mixins are created with &lt;code&gt;.create()&lt;/code&gt;, not &lt;code&gt;.extend()&lt;/code&gt;.&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;Note that if you’re writing &lt;em&gt;new&lt;/em&gt; code in Ember.js—using TypeScript or not—I strongly encourage you to simply avoid using mixins at all. Instead, use services (or, occasionally, inheritance). This will require you to change how you write some of your code, but in my experience that change will make your codebase much easier to understand, and therefore much easier to maintain.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;I’ll have a lot more to say about these in part 5 of this series, including a detailed example of how to carefully type-annotate one and use it in another class. For now, suffice it to say that you’ll still need to incorporate &lt;code&gt;Mixin&lt;/code&gt;s via &lt;code&gt;.extend()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import MyMixin from &amp;#39;my-app/mixins/my-mixin&amp;#39;;

export default class SomeNewComponent extends Component.extend(MyMixin) {
  // normal class properties
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Those are the &lt;em&gt;biggest&lt;/em&gt; differences from &lt;code&gt;Ember.Object&lt;/code&gt; that you need to be aware of when working with class properties in Ember.js today, at least in my experience working with them day to day. These are not the only differences with &lt;em&gt;classes&lt;/em&gt;, though, especially when dealing with TypeScript, so in my next entry we’ll take a look at how classes work (and work well!) with most things in Ember.js and TypeScript together.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;You can use this same feature on classes using Babel, with the &lt;a href="https://babeljs.io/docs/plugins/transform-class-properties/"&gt;class properties transform&lt;/a&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Even when &lt;a href="https://github.com/emberjs/rfcs/pull/281"&gt;Ember.js RFC #281&lt;/a&gt; lands, this problem will not go away, at least under the current implementation, since &lt;a href="https://github.com/emberjs/rfcs/pull/281#issuecomment-360023258"&gt;&lt;em&gt;these&lt;/em&gt; will &lt;em&gt;not&lt;/em&gt; be transformed into getters on the prototype&lt;/a&gt;. We are waiting for decorators to solve this problem completely.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;In the future, we’ll (hopefully and presumably 🤞🏼) have an escape hatch for those merged or prototypally-set properties via decorators. That’ll look something like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { className, tagName } from &amp;#39;ember-decorators/component&amp;#39;;

@tagName(&amp;quot;li&amp;quot;)
export default class MyListItem extends Component {
  @className itemClass = &amp;#39;this-be-a-list&amp;#39;;

  @action
  sendAMessage(contents: string): void {

  }
  // etc.
}&lt;/code&gt;&lt;/pre&gt;
&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 24 Jan 2018 07:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-24:/2018/typing-your-ember-update-part-2.html</guid><category>TypeScript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>TypeScript and Ember.js Update, Part 1</title><link>http://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Back in July 2017, I wrote &lt;a href="https://www.chriskrycho.com/2017/typing-your-ember-part-3.html"&gt;a post&lt;/a&gt; on how to using TypeScript in your Ember.js apps. At the time, we were still busy working on getting the typings more solid for Ember itself, and &lt;code&gt;class&lt;/code&gt; syntax for Ember was apparently a long way away.&lt;/p&gt;
&lt;p&gt;Things have gotten quite a bit better since then, so I thought I’d update that post with recommendations for using TypeScript in an app &lt;em&gt;now&lt;/em&gt; with the updated typings, as well as with another six months of experience using TypeScript in our app at Olo (~20k lines of code in the app and another ~15k in tests).&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;If you’re interested in all of this and would like to learn more in person, I’m &lt;a href="http://emberconf.com/speakers.html#chris-krycho"&gt;leading a workshop on it at EmberConf 2018&lt;/a&gt;—I’d love to see you there!&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Here’s how I expect this update series to go:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html"&gt;&lt;strong&gt;Overview, normal Ember objects, component arguments, and injections (this post).&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;Class properties—some notes on how things differ from the &lt;code&gt;Ember.Object&lt;/code&gt; world.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html"&gt;Computed properties, actions, mixins, and class methods.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html"&gt;Using Ember Data, and service and controller injections improvements.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mixins and proxies; or: the really hard-to-type-check bits.&lt;/li&gt;
&lt;/ol&gt;
&lt;section id="normal-ember-objects" class="level2"&gt;
&lt;h2&gt;Normal Ember objects&lt;/h2&gt;
&lt;p&gt;For normal Ember objects, things now &lt;em&gt;mostly&lt;/em&gt; just work if you’re using class-based syntax, with a single (though very important) qualification I’ll get to in a minute. And you can use the class-based syntax &lt;em&gt;today&lt;/em&gt; in Ember.js—all the way back to 1.13, as it turns out. If you want to learn more, you can read &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0240-es-classes.md"&gt;this RFC&lt;/a&gt; or &lt;a href="https://medium.com/build-addepar/es-classes-in-ember-js-63e948e9d78e"&gt;this blog post&lt;/a&gt;, both by &lt;a href="https://github.com/pzuraq"&gt;@pzuraq (Chris Garrett)&lt;/a&gt;, who did most of the legwork to research this and flesh out the constraints, and who has also been doing a lot of work on &lt;a href="https://ember-decorators.github.io/ember-decorators/docs/index.html"&gt;Ember Decorators&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Accordingly, I’m assuming the use of ES6 &lt;code&gt;class&lt;/code&gt; syntax throughout. The big reason for this is that things mostly just &lt;em&gt;don’t work&lt;/em&gt; without it. And we’ll see (in a later post) some hacks to deal with places where parts of Ember’s ecosystem don’t yet support classes properly. In general, however, if you see an error like &lt;code&gt;&amp;quot;Cannot use 'new' with an expression whose type lacks a call or construct signature.&amp;quot;&lt;/code&gt;, the reason is almost certainly that you’ve done &lt;code&gt;export default Component.extend({...})&lt;/code&gt; rather than creating a class.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="a-detailed-example" class="level2"&gt;
&lt;h2&gt;A detailed example&lt;/h2&gt;
&lt;p&gt;That means that every new bit of code I write today in our app looks roughly like this, with only the obvious modifications for services, routes, and controllers—I picked components because they’re far and away the most common things in our applications.&lt;/p&gt;
&lt;p&gt;In order to explain all this clearly, I’m going to start by showing a whole component written in the new style. Then, over the rest of this post and the next post, I’ll zoom in on and explain specific parts of it.&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;*&lt;strong&gt;Note:&lt;/strong&gt; please see the &lt;a href="https://www.chriskrycho.com/2018/ember-ts-class-properties.html"&gt;update about class properties published mid-2018&lt;/a&gt;. The example below and in the following posts is incorrect in several important ways.&lt;/p&gt;
&lt;/aside&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;quot;@ember/component&amp;quot;;
import { computed, get } from &amp;quot;@ember/object&amp;quot;;
import Computed from &amp;quot;@ember/object/computed&amp;quot;;
import { inject as service } from &amp;quot;@ember/service&amp;quot;;
import { assert } from &amp;quot;@ember/debug&amp;quot;;
import { isNone } from &amp;quot;@ember/utils&amp;quot;;

import Session from &amp;quot;my-app/services/session&amp;quot;;
import Person from &amp;quot;my-app/models/person&amp;quot;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model: Person; // required
  modifier?: string; // optional, thus the `?`

  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();

  // -- Class properties -- //
  aString = &amp;quot;this is fine&amp;quot;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(&amp;quot;model.firstName&amp;quot;, function(this: AnExample): string {
    return `My name is ${get(this.model, &amp;quot;firstName&amp;quot;)};`;
  });

  aComputed = computed(&amp;quot;aString&amp;quot;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&amp;quot;session.user&amp;quot;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;quot;session.user&amp;quot;);

  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&amp;quot;aCollection&amp;quot;);
      this.set(&amp;quot;aCollection&amp;quot;, current.concat(value));
    }
  };

  constructor() {
    super();
    assert(&amp;quot;`model` is required&amp;quot;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.get(&amp;quot;aCollection&amp;quot;).includes(&amp;quot;ahoy&amp;quot;)) {
      this.set(&amp;quot;aCollection&amp;quot;, current.concat(&amp;quot;ahoy&amp;quot;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;section id="component-arguments" class="level3"&gt;
&lt;h3&gt;Component arguments&lt;/h3&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // Component arguments
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I always put these first so that the “interface” of the object is clear and obvious. You can do the same thing on a controller instance; in that case you would export a &lt;code&gt;Model&lt;/code&gt; from the corresponding &lt;code&gt;Route&lt;/code&gt; class and import it into the &lt;code&gt;Controller&lt;/code&gt;. It’s a bit of boilerplate, to be sure, but it lets you communicate your interface clearly to consumers of the &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;Controller&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An important note about these kind of arguments: you do &lt;em&gt;not&lt;/em&gt; have to do &lt;code&gt;this.get(...)&lt;/code&gt; (or, if you prefer, &lt;code&gt;get(this, ...)&lt;/code&gt;) to access the properties themselves: they’re class instance properties. You can simply access them as normal properties: &lt;code&gt;this.model&lt;/code&gt;, &lt;code&gt;this.modifier&lt;/code&gt;, etc. That even goes for referencing them as computed properties, as we’ll see below.&lt;/p&gt;
&lt;p&gt;For optional arguments, you use the &lt;code&gt;?&lt;/code&gt; operator to indicate they may be &lt;code&gt;undefined&lt;/code&gt;. To get the &lt;em&gt;most&lt;/em&gt; mileage out of this, you’ll want to enable &lt;code&gt;strictNullChecks&lt;/code&gt; in the compiler options.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; However, note that we don’t currently have any way to validate component argument invocation.[^ts-templates] The way I’ve been doing this is using Ember’s debug &lt;a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fdebug/methods/assert?anchor=assert"&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; in the constructor:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;assert(&amp;quot;`model` is required&amp;quot;, !isNone(this.model));&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;quot;@ember/component&amp;quot;;
import { Maybe } from &amp;quot;true-myth&amp;quot;;

export default class MyComponent extends Component {
  optionalArg?: string;
  optionalProperty = Maybe.of(this.optionalArg);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then if you invoke the property without the argument, it’ll construct a &lt;code&gt;Nothing&lt;/code&gt;; if you invoke it with the argument, it’ll be &lt;code&gt;Just&lt;/code&gt; with the value. [^ts-templates]: A few of us have batted around some ideas for how to solve that particular problem, but &lt;em&gt;if&lt;/em&gt; we manage those, it’ll probably be way, way later in 2018.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit, January 24, 2018:&lt;/strong&gt; Starting in TypeScript 2.7, you can enable a flag, &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;, which requires that all declared, non-optional properties on a class be initialized in the constructor or with a class property assignment. (There’s more on class property assignment in &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;part 2&lt;/a&gt; of this series.) If you do that, all &lt;em&gt;arguments&lt;/em&gt; to a component should be defined with the &lt;em&gt;definite assignment assertion modifier&lt;/em&gt;, a &lt;code&gt;!&lt;/code&gt; after the name of the property, as on &lt;code&gt;model&lt;/code&gt; here:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // Component arguments
  model!: Person;     // required
  modifier?: string;  // optional, thus the `?`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should still combine that with use of &lt;a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fdebug/methods/assert?anchor=assert"&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; so that any misses in template invocation will get caught in your tests.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="injections" class="level3"&gt;
&lt;h3&gt;Injections&lt;/h3&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the most important thing to note is the required type annotation. In principle, we could work around this by requiring you to explicitly name the service and using a “type registry” to look up what the service type is – more on that below in my discussion of using Ember Data – but I’m not yet persuaded that’s better than just writing the appropriate type annotation. Either way, there’s some duplication. 🤔 We (everyone working in the &lt;a href="https://github.com/typed-ember"&gt;typed-ember&lt;/a&gt; project) would welcome feedback here, because the one thing we &lt;em&gt;can’t&lt;/em&gt; do is get the proper type &lt;em&gt;without&lt;/em&gt; one or the other of these.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit, February 5, 2018:&lt;/strong&gt; see &lt;a href="https://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html"&gt;Part 4&lt;/a&gt; for some updates to this—I actually went ahead and built and implemented that approach, and everything is much nicer now.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  // the current approach -- requires importing `Session` so you can define it
  // on the property here
  session: Computed&amp;lt;Session&amp;gt; = service();

  // the alternative approach I&amp;#39;ve considered -- requires writing boilerplate
  // elsewhere, similar to what you&amp;#39;ll see below in the Ember Data section
  session = service(&amp;#39;session&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One other thing to notice here is that because TypeScript is a &lt;em&gt;structural&lt;/em&gt; type system, it doesn’t matter if what is injected is the actual &lt;code&gt;Session&lt;/code&gt; service; it just needs to be something that &lt;em&gt;matches the shape&lt;/em&gt; of the service – so your normal behavior around dependency injection, etc. is all still as expected.&lt;/p&gt;
&lt;p&gt;That’s enough for one post, I think. In the next entry, we’ll pick up with how you handle class properties, including computed properties, and then talk about mixins as well. In the post after that, we’ll look at Ember Data and some related concerns.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This isn’t my preferred way of handling optional types; &lt;a href="https://true-myth.js.org"&gt;a &lt;code&gt;Maybe&lt;/code&gt; type&lt;/a&gt; is. And you can, if you like, use &lt;code&gt;Maybe&lt;/code&gt; here:&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 22 Jan 2018 07:10:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-22:/2018/typing-your-ember-update-part-1.html</guid><category>TypeScript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>I Want JSON Decoders</title><link>http://www.chriskrycho.com/2017/i-want-json-decoders.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;This post was originally published at &lt;a href="https://www.dailydrip.com/blog/i-want-json-decoders.html"&gt;DailyDrip.com&lt;/a&gt;. They’re doing really great work over there, so I encourage you to check out their content and consider subscribing!&lt;/i&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;The other day, I got a report about the Ember.js app I’m working on: when a customer applied a coupon in the basket, they’d see an indication that the coupon was applied, but the basket total would still display as if it hadn’t been updated. Orders were &lt;em&gt;placed&lt;/em&gt; correctly, but they wouldn’t render right. I dug around for a bit, and then discovered that it was one of the (many) places where &lt;code&gt;undefined&lt;/code&gt; was biting us.&lt;/p&gt;
&lt;p&gt;How did this happen? It turned out it was a perfect storm: a confusingly-designed &lt;abbr&gt;API&lt;/abbr&gt; combined with a reasonable (but in this case, very unhelpful) assumption in our data layer. When the total on a given basket dropped to zero, our &lt;abbr&gt;API&lt;/abbr&gt; simply didn’t send back a value on the payload at all. Instead of &lt;code&gt;{ total: 0, ... }&lt;/code&gt;, there was just, well, &lt;code&gt;{ ... }&lt;/code&gt; – no &lt;code&gt;total&lt;/code&gt; field at all. Meanwhile, our data layer was designed to let a server send back only the fields which &lt;em&gt;required&lt;/em&gt; updating. That way, you can send back partial records to indicate only what has changed, instead of having to send back the whole of what might be a very large record, or a very large collection of records.&lt;/p&gt;
&lt;p&gt;The combination was terrible, though: because the server didn’t send back the &lt;code&gt;total&lt;/code&gt; field at all when it dropped to &lt;code&gt;0&lt;/code&gt;, the client never updated the total it displayed to the user: as far as it was concerned, the server was saying “no change here!”&lt;/p&gt;
&lt;p&gt;The first and most obvious solution here, of course, is the one we implemented: we had the &lt;abbr&gt;API&lt;/abbr&gt; always send back a value, even if that value was &lt;code&gt;0&lt;/code&gt;. But it seems like there should be a better way.&lt;/p&gt;
&lt;p&gt;Lots of languages have fairly nice facilities for parsing JavaScript. Several languages even have tools for automatically constructing local, strongly-typed data structures from the structure of a &lt;abbr&gt;JSON&lt;/abbr&gt; response on an &lt;abbr&gt;API&lt;/abbr&gt;. F♯’s &lt;a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/"&gt;type providers&lt;/a&gt; are like this and &lt;em&gt;really fancy&lt;/em&gt; in the way they’ll automatically derive the type for you so you don’t even have to write it out as you would in everything from Haskell to C#. But for the most part in JavaScript, you have at most a way to map data to a local record in your data store – certainly none of those type safe guarantees. In TypeScript, you can write the types you receive out carefully – though, as I discovered in this case, probably not carefully &lt;em&gt;enough&lt;/em&gt; unless you model &lt;em&gt;everything&lt;/em&gt; as an optional field, and then you’re back to checking for &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; everywhere, and &lt;em&gt;why isn’t this already a solved problem?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;And it turns out, it &lt;em&gt;is&lt;/em&gt; a solved problem – or at least, it is in Elm, &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;via&lt;/a&gt; those &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;&lt;abbr&gt;JSON&lt;/abbr&gt; Decoders&lt;/a&gt;. I don’t get to write Elm at work right now (or any time in the foreseeable future) – but if I can’t write Elm, I can at least try to steal a bunch of its great ideas and push them back into my TypeScript.&lt;/p&gt;
&lt;p&gt;So… what exactly are &lt;abbr&gt;JSON&lt;/abbr&gt; Decoders and how would they have solved this problem? (And why, if you’re already familiar a little with Elm and possibly feeling frustrated with decoding, are they actually worth it?)&lt;/p&gt;
&lt;p&gt;A &lt;abbr&gt;JSON&lt;/abbr&gt; Decoder is just a way of guaranteeing that once you’re inside the boundary of your program, you &lt;em&gt;always&lt;/em&gt; have a valid instance of the data type you’ve decoded it into, &lt;em&gt;or&lt;/em&gt; an error which tells you why you &lt;em&gt;don’t&lt;/em&gt; have a valid instance of the data. They’re composable, so you can stack them together and take smaller decoders to build bigger ones, so if you have a complex &lt;abbr&gt;JSON&lt;/abbr&gt; structure, you can define repeated substructures in it, or decoders for dissimilar sibling items in it, and use them to put together a grand decoder for your whole final structure. The decoders use the &lt;a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result"&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, and they hand back either &lt;code&gt;Ok&lt;/code&gt; with the decoded value or &lt;code&gt;Err&lt;/code&gt; with the reason for the failure – and if &lt;em&gt;any&lt;/em&gt; piece of a decoded type doesn’t match with what you’ve specified, you’ll end up with an &lt;code&gt;Err&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, initially that might sound like a recipe for disaster – &lt;abbr&gt;JSON&lt;/abbr&gt; payloads can be formed in weird ways all the time! – but in fact it encourages you to think through the various ways your payloads can be formed and to account for them. &lt;em&gt;Sometimes&lt;/em&gt;, if the payload doesn’t have what you expect, that really does mean something is wrong either in your request or in the server-side implementation. In that case, getting an &lt;code&gt;Err&lt;/code&gt; is &lt;em&gt;exactly&lt;/em&gt; what you want. Other times, the server might be perfectly legitimate in sending back a variety of shapes in its response, and your responsibility is to decide how to decode it to make sense in your app. Remember, the problem I had was that I received a payload which didn’t have the data. With Elm’s decoders, I would have had three choices:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;I could have treated this as an error, and passed that along to be dealt with in some way.&lt;/li&gt;
&lt;li&gt;I could have normalized it as a 0-value payload.&lt;/li&gt;
&lt;li&gt;I could have treated it &lt;em&gt;explicitly&lt;/em&gt; as a no-op, maintaining whatever previous state I had in the data store, i.e. the implicit behavior of my actual data store.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What I &lt;em&gt;couldn’t&lt;/em&gt; do, though, is do any one of those &lt;em&gt;accidentally&lt;/em&gt;. I could still support incomplete payloads (via option 3), but I’d be explicitly opting into that, and there would be an obvious place where that was the case. This would be particularly helpful in a scenario where I wasn’t also in charge of the &lt;abbr&gt;API&lt;/abbr&gt;: if I couldn’t just go change it so the &lt;abbr&gt;API&lt;/abbr&gt; itself had a more sensible behavior, I could enforce whichever desired behavior on my own end. More than that, with something modeled on the Elm &lt;abbr&gt;JSON&lt;/abbr&gt; Decoders, I would &lt;em&gt;have&lt;/em&gt; to: there would be no implicit consumption of raw &lt;abbr&gt;JSON&lt;/abbr&gt;.&lt;/p&gt;
&lt;p&gt;The first time I played with the Elm &lt;abbr&gt;JSON&lt;/abbr&gt; Decoder approach, I thought it was a lot of work. I was used to just doing &lt;code&gt;JSON.parse()&lt;/code&gt; in JS or &lt;code&gt;json.loads()&lt;/code&gt; in Python. Now I needed to define a whole series of decode steps explicitly for every field in a response? Good grief! But it grew on me. More than that, I now actively miss it in my apps; I’d have been really happy not to have to spend a morning hunting down this particular bug.&lt;/p&gt;
&lt;p&gt;Sometimes that explicitness can seem like quite a lot of boilerplate, and indeed it is: there’s a reason the Elm &lt;a href="https://github.com/NoRedInk/elm-decode-pipeline"&gt;elm-decode-pipeline&lt;/a&gt; project exists. But even given the &lt;em&gt;initial&lt;/em&gt; nicety of something like F♯ type providers, I think the Elm approach has a slight edge in the long-term for &lt;em&gt;maintainability&lt;/em&gt; specifically. It’s one thing to be able to just get to work right away and have a type definition you know to conform to a given &lt;abbr&gt;API&lt;/abbr&gt; response. It’s something else entirely to be able to &lt;em&gt;know&lt;/em&gt; that you’ve accounted for all the varieties of responses you might get (and without throwing an exception for failed &lt;abbr&gt;JSON&lt;/abbr&gt; decoding at that!).&lt;/p&gt;
&lt;p&gt;Given all of this, I’ve started mentally teasing out what such a &lt;abbr&gt;JSON&lt;/abbr&gt; decoding library for Ember.js might look like in TypeScript. It’s a long way off, but it’s the kind of thing that I &lt;em&gt;really&lt;/em&gt; want to experiment with, and that I think would make for a big win for the maintainability of our apps. Keep your eyes peeled, because I suspect this is another thing JS will steal from Elm, and that’s &lt;em&gt;great&lt;/em&gt; in my book.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 25 Dec 2017 19:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-25:/2017/i-want-json-decoders.html</guid><category>JavaScript</category><category>Elm</category><category>TypeScript</category><category>web development</category><category>software development</category></item><item><title>Announcing True Myth 1.0</title><link>http://www.chriskrycho.com/2017/announcing-true-myth-10.html</link><description>&lt;p&gt;I’m pleased to announce the release of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth 1.0&lt;/a&gt;! True Myth is a library I’ve been working on over the last month or so, for saner programming in JavaScript, with first-class support for TypeScript (and Flow).&lt;/p&gt;
&lt;p&gt;True Myth provides standard, type-safe wrappers and helper functions to help you with two &lt;em&gt;extremely&lt;/em&gt; common cases in programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not having a value—which it solves with a &lt;code&gt;Maybe&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;li&gt;having a &lt;em&gt;result&lt;/em&gt; where you need to deal with either success or failure—which it solves with a &lt;code&gt;Result&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You could implement all of these yourself – it’s not hard! – but it’s much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all.&lt;/p&gt;
&lt;p&gt;Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects—which we get by leaning hard on the type systems in TypeScript or Flow!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;/strong&gt; If you’re familiar with &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; or &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, this has a lot in common with them—its main differences are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Myth has a much smaller API surface than they do&lt;/li&gt;
&lt;li&gt;True Myth aims to be much more approachable for people who aren’t already super familiar with functional programming concepts and jargon&lt;/li&gt;
&lt;li&gt;True Myth does &lt;em&gt;no&lt;/em&gt; runtime checking of your types, whereas both those libraries do by default—it relies on TypeScript or Flow instead&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I really like both of those libraries, though, so you might check them out as well!&lt;/p&gt;
&lt;section id="maybe" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes you don’t have a value. In JavaScript land, we usually represent that with either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, and then trying to program defensively in the places we &lt;em&gt;think&lt;/em&gt; we might get &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: &amp;quot;Hello!&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But sometimes it might come over like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: null
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In normal JavaScript we’d write something like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function logThatValue(thePayload) {
  const length = !!thePayload.hopefullyAString
    ? thePayload.hopefullyAString.length
    : 0;
  
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn’t a big deal right here… but—and this &lt;em&gt;is&lt;/em&gt; a big deal—we have to remember to do this &lt;em&gt;everywhere&lt;/em&gt; we interact with this payload. &lt;code&gt;hopefullyAString&lt;/code&gt; can &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; everywhere we interact with it, anywhere in our program. 😬&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; is our escape hatch. If, instead of just naively interacting with the payload, we do a &lt;em&gt;very small&lt;/em&gt; amount of work up front to normalize the data and use a &lt;code&gt;Maybe&lt;/code&gt; instead of passing around &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; values, we can operate safely on the data throughout our application. If we have something, we get an instance called &lt;code&gt;Just&lt;/code&gt;—as in, “What’s in this field? Just a string” or “Just the string ‘hello’”. If there’s nothing there, we have an instance called &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just&lt;/code&gt; is a wrapper type that holds the actual value in it. &lt;code&gt;Nothing&lt;/code&gt; is a wrapper type which has no value in it. But both of them are concrete types and you’ll never get an &lt;code&gt;undefined is not an object&lt;/code&gt; error when trying to use them!&lt;/p&gt;
&lt;p&gt;Both of them have all the same methods available on them, and the same static functions to work on them. And, importantly, you can do a bunch of neat things with a &lt;code&gt;Maybe&lt;/code&gt; instance without checking whether it’s a &lt;code&gt;Nothing&lt;/code&gt; or a &lt;code&gt;Just&lt;/code&gt;. For example, if you want to double a number if it’s present and do nothing if it isn’t, you can use the &lt;code&gt;Maybe.map&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;
const hereIsANumber = Maybe.just(12);          // Just(12)
const noNumberHere = Maybe.nothing&amp;lt;number&amp;gt;();  // Nothing

const double = (n: number) =&amp;gt; n * 2;
hereIsANumber.map(double);  // Just(24)
noNumberHere.map(double);   // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;a href="https://true-myth.js.org/modules/_maybe_.html"&gt;a &lt;em&gt;lot&lt;/em&gt;&lt;/a&gt; of those helper functions and methods! Just about any way you would need to interact with a &lt;code&gt;Maybe&lt;/code&gt; is there.&lt;/p&gt;
&lt;p&gt;So now that we have a little idea what &lt;code&gt;Maybe&lt;/code&gt; is for and how to use it, here’s that same example, but rewritten to normalize the payload using a &lt;code&gt;Maybe&lt;/code&gt; instance. We’re using TypeScript, so we will get a compiler error if we don’t handle any of these cases right—or if we try to use the value at &lt;code&gt;hopefullyAString&lt;/code&gt; directly after we’ve normalized it!&lt;/p&gt;
&lt;p&gt;(Note that &lt;code&gt;Maybe.of&lt;/code&gt; will construct either a &lt;code&gt;Maybe.Just&lt;/code&gt; if the string is present, or &lt;code&gt;Maybe.Nothing&lt;/code&gt; if the value supplied to it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

type Payload = { hopefullyAString?: string };
type NormalizedPayload = { hopefullyAString: Maybe&amp;lt;string&amp;gt; };

function normalize(payload: Payload): NormalizedPayload {
  return {
    hopefullyAString: Maybe.of(payload.hopefullyAString)
  };
}

function logThatValue(payload: NormalizedPayload) {
  const length = payload.hopefullyAString.mapOr(0, s =&amp;gt; s.length);
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(normalize)
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you might be thinking, &lt;em&gt;Sure, but we could get the same effect by just supplying a default value when we deserialize the data.&lt;/em&gt; That’s true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. &lt;code&gt;Maybe&lt;/code&gt; is another tool in your toolbox, not something you’re &lt;em&gt;obligated&lt;/em&gt; to use everywhere you can.&lt;/p&gt;
&lt;p&gt;However, sometimes there isn’t a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat “no value” distinctly from “there’s a value present, and it’s an empty string”? &lt;em&gt;That’s&lt;/em&gt; where &lt;code&gt;Maybe&lt;/code&gt; comes in handy.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="result" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another common scenario we find ourselves in is dealing with operations which might fail. There are a couple patterns we often use to deal with this: &lt;em&gt;callbacks&lt;/em&gt; and &lt;em&gt;exceptions&lt;/em&gt;. There are major problems with both, especially around reusability and composability.&lt;/p&gt;
&lt;p&gt;The callback pattern (as in e.g. Node) encourages a style where literally every function starts with the exact same code:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function getMeAValue(err, data) {
  if (err) {
    return handleErr(err);
  }
  
  // do whatever the *actual* point of the function is
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two major problems with this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s incredibly repetitive – the very opposite of “Don’t Repeat Yourself”. We wouldn’t do this with &lt;em&gt;anything&lt;/em&gt; else in our codebase!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It puts the error-handling right up front and &lt;em&gt;not in a good way.&lt;/em&gt; While we want to have a failure case in mind when designing the behavior of our functions, it’s not usually the &lt;em&gt;point&lt;/em&gt; of most functions – things like &lt;code&gt;handleErr&lt;/code&gt; in the above example being the exception and not the rule. The actual meat of the function is always after the error handling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But if we’re not using some similar kind of callback pattern, we usually resort to exceptions. But exceptions are unpredictable: you can’t know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it’s a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it’s very easy to miss that. And then this happens:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// in one part of the codebase
function getMeAValue(url) {
  if (isMalformed(url)) {
    throw new Error(`The url `${url}` is malformed!`);
  }
  
  // do something else to load data from the URL
  return data;
}

function render(toRender) {
  // if toRender can&amp;#39;t generate valid HTML, throw Error(&amp;quot;invalid HTML&amp;quot;);
  // if it can, theRenderedHTML;
}

function setDom(html) {
  /* magic to render into DOM */
}

// somewhere else in the codebase -- throws an exception
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
const response = getMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
const htmlForPage = render(value);

// so we definitely can&amp;#39;t get here safely
setDom(htmlForPage);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice: there’s no way for the caller to know that the function will throw. Perhaps you’re very disciplined and write good docstrings for every function – &lt;em&gt;and&lt;/em&gt; moreover, perhaps everyone’s editor shows it to them &lt;em&gt;and&lt;/em&gt; they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data – and then you’re chasing down the problem through error logs.&lt;/p&gt;
&lt;p&gt;More, if you &lt;em&gt;do&lt;/em&gt; want to account for the reality that any function anywhere in JavaScript might actually throw, you’re going to write something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;try {
  const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
  const response = getMeAValue(badUrl);  // throws here
  
  // we never get here, but it could throw too
  const htmlForPage = render(value);
  
  // so we definitely can&amp;#39;t get here safely
  setDom(htmlForPage);
} catch (e) {
  handleErr(e);  // ends up here
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is like the Node example &lt;em&gt;but even worse&lt;/em&gt; for repetition!&lt;/p&gt;
&lt;p&gt;And TypeScript and Flow can’t help you here! They don’t have type signatures to say “This throws an exception!” (TypeScript’s &lt;code&gt;never&lt;/code&gt; might come to mind, but it might mean lots of things, not just exception-throwing.)&lt;/p&gt;
&lt;p&gt;Instead, we can use a &lt;code&gt;Result&lt;/code&gt; to get us a container type, much like &lt;code&gt;Maybe&lt;/code&gt;, to let us deal with this scenario. A &lt;code&gt;Result&lt;/code&gt; is either an &lt;code&gt;Ok&lt;/code&gt; wrapping around a value (like &lt;code&gt;Just&lt;/code&gt; does) or an &lt;code&gt;Err&lt;/code&gt; wrapping around some type defining what went wrong (&lt;em&gt;not&lt;/em&gt; like &lt;code&gt;Nothing&lt;/code&gt;, which has no contents). Both of them have the same sets of methods on them, and the same static functions which can operate on them.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Result from &amp;#39;true-myth/result&amp;#39;;

type Payload = {/* details of the payload...*/}

function getMeAValue(url: string): Result&amp;lt;Payload, string&amp;gt; {
  if (isMalformed(url)) {
    return Result.err(`The url &amp;#39;${url}&amp;#39; is malformed`);
  }
  
  // do something else to load data from the url
  return Result.ok(data);
}

function render(toRender: string): Result&amp;lt;HTMLElement, string&amp;gt; {
  // if toRender can&amp;#39;t generate valid HTML, return Err(&amp;quot;invalid HTML&amp;quot;);
  // if it can, return Ok(theRenderedHTML);
}

function setDom(html: HTMLElement) {
  
}

// somewhere else in the codebase -- no exception this time!
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash

// value = Err(The url &amp;#39;${http:/www.google.com}&amp;#39; is malformed)
const value = getMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
const htmlForPage = value.andThen(render);

// we can&amp;#39;t just invoke `setDom` because it doesn&amp;#39;t take a `Result`.
value.match({
  Ok: html =&amp;gt; setDom(html);
  Err: reason =&amp;gt; alert(`Something went seriously wrong here! ${reason}`);
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we have a &lt;code&gt;Result&lt;/code&gt; instance, we can perform tons of operations on whether it’s &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, just as we could with &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Maybe.Nothing&lt;/code&gt;, until we &lt;em&gt;need&lt;/em&gt; the value. Maybe that’s right away. Maybe we don’t need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Give it a spin!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yarn add true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can even just &lt;code&gt;ember install true-myth&lt;/code&gt; and use it if you’re using Ember (in which case I encourage you to also use &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think – if there’s stuff missing, &lt;a href="https://github.com/chriskrycho/true-myth"&gt;open issues&lt;/a&gt;! And if it’s just not to your taste, again, I encourage you to take a look at &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; and &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, which are both excellent and land in very different design spaces in many ways.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 01 Nov 2017 08:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-01:/2017/announcing-true-myth-10.html</guid><category>software development</category><category>libraries</category><category>programming languages</category><category>typescript</category><category>functional programming</category><category>true myth</category></item><item><title>Announcing ember-cli-typescript 1.0.0</title><link>http://www.chriskrycho.com/2017/announcing-ember-cli-typescript-100.html</link><description>&lt;p&gt;I’m extremely pleased to announce the release of &lt;a href="https://github.com/typed-ember/ember-cli-typescript/releases/tag/v1.0.0"&gt;ember-cli-typescript 1.0.0&lt;/a&gt;! You can get it the same way you do &lt;em&gt;any&lt;/em&gt; Ember addon:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;$ ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a detailed walkthrough of adding TypeScript to your projects, see:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-1.html"&gt;Typing Your Ember, Part 1: Set your Ember.js project up to use TypeScript.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-2.html"&gt;Typing Your Ember, Part 2: Adding TypeScript to an existing Ember.js project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what are we shipping today, and what’s on the roadmap?&lt;/p&gt;
&lt;section id="whats-in-1.0" class="level2"&gt;
&lt;h2&gt;What’s In 1.0?&lt;/h2&gt;
&lt;p&gt;This release is intentionally relatively minimal: the goal here is provide stable foundation for building Ember.js applications with TypeScript in the toolchain. This means that in any app you can install the add-on and just start &lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-3.html"&gt;progressively converting your app over to TypeScript&lt;/a&gt;. However, we don’t expect to change the way you &lt;em&gt;use&lt;/em&gt; the addon at all in the foreseeable future.&lt;/p&gt;
&lt;p&gt;I’ll give you fair warning that there is one &lt;em&gt;major&lt;/em&gt; challenge you will find as you work with ember-cli-typescript today: the lack of type definitions for most projects, and the limits of the existing type definitions for Ember.js itself. That’s not as bad as it sounds, though:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;See the &lt;a href="#the-roadmap"&gt;&lt;strong&gt;Roadmap&lt;/strong&gt;&lt;/a&gt; below—we’re working on that, and you can help!&lt;/li&gt;
&lt;li&gt;I’ve been using TypeScript successfully in the app I work on at my day job for the last nine months or so. While the lack of (good or any) typings has had its frustrations, &lt;a href="https://www.dailydrip.com/blog/domain-driven-design-and-typed-functional-programming-in-typescript"&gt;TypeScript has already added a &lt;em&gt;lot&lt;/em&gt; of value for us&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;section id="the-roadmap" class="level2"&gt;
&lt;h2&gt;The Roadmap&lt;/h2&gt;
&lt;p&gt;We have a bunch of things we’re actively working on and which you can expect to land in the next few weeks to months.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1-1-a-prepublish-build-process-for-addons"&gt;1.1: A prepublish build process for addons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#community-driven-work-on-typings"&gt;Community-driven work on typings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="a-prepublish-build-process-for-addons" class="level3"&gt;
&lt;h3&gt;1.1: A prepublish build process for addons&lt;/h3&gt;
&lt;p&gt;The major priority for the 1.1 release is an npm prepublication step to generate JavaScript and typing files from add-ons which are using TypeScript. Currently, addons have to take TypeScript as a full dependency, not a dev dependency, because they currently just ship the &lt;code&gt;.ts&lt;/code&gt; files up to npm and they have to be compiled in your app at build time.&lt;/p&gt;
&lt;p&gt;We really don’t want to make any app developer who is using your addon download either the TypeScript files or &lt;em&gt;especially&lt;/em&gt; the TypeScript compiler if we can avoid it. There are three reasons for this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;The fact that an add-on is developed in TypeScript really shouldn’t affect app developers. If they’re writing a plain-old JavaScript app, the fact that your addon is originally written in TypeScript is irrelevant to them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TypeScript is &lt;em&gt;large&lt;/em&gt;. The v2.4 installation I have in the app I’m working on right now weights 26MB. If I were using four add-ons which required TypeScript, my install cost could easily go up by a hundred megabytes. That’s not always a huge deal on a corporate network, but even where people &lt;em&gt;do&lt;/em&gt; have good download speeds, it’s a hit to developer time. Every time someone has to reinstall all the dependencies, those 26MB have to come down again. If TypeScript becomes common, you might suddenly find yourself with addons using 2.4, 2.5, 2.6, etc.; it’s not hard to see that ballooning up the size of your installation in a really non-trivial way: 26MB × &lt;em&gt;n&lt;/em&gt; versions of TypeScript = &lt;em&gt;do not want&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The TypeScript compilation step takes time. Addons can do this &lt;em&gt;once&lt;/em&gt; and save every consuming app build time. This isn’t the end of the world, but anything we can do to keep build times lower is a real win for developer productivity.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Accordingly the plan is to automatically add a build step which runs the TypeScript compiler on your addon and generates plain-old-JavaScript and the corresponding type definition files (&lt;code&gt;.d.ts&lt;/code&gt;) prior to publishing to npm. That way, TypeScript can remain a dev dependency (rather than a full dependency) of each addon, and not be installed alongside the addon for consumers. Just-JavaScript consumers can just consume the normal JavaScript generated by the build. TypeScript consumers will get the full benefits of the types via the generated typing files.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;should&lt;/em&gt; hopefully land by late August or early September. Fingers crossed.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="community-driven-work-on-typings" class="level3"&gt;
&lt;h3&gt;Community-driven work on typings&lt;/h3&gt;
&lt;p&gt;The process of getting type definitions in place for &lt;em&gt;all&lt;/em&gt; of Ember.js and its ecosystem is way, &lt;em&gt;way&lt;/em&gt; too big for any one person or even a small handful of people to manage alone. This is something we’re going to take on as a community.&lt;/p&gt;
&lt;section id="new-typings-for-ember.js-itself" class="level4"&gt;
&lt;h4&gt;New typings for Ember.js itself&lt;/h4&gt;
&lt;p&gt;We’re actively working on type definitions for Ember which will give us actually-useful-and-correct type checking for Ember’s custom object model. Today, if you use &lt;code&gt;Ember.get&lt;/code&gt; or &lt;code&gt;Ember.set&lt;/code&gt;, you get &lt;em&gt;no&lt;/em&gt; help from the type system. When we finish, those will be type-checked by the compiler and will error if you try to assign the wrong values!&lt;/p&gt;
&lt;p&gt;Importantly, the typings we’re shipping will be backwards compatible with the existing Ember API, but will also include support for the &lt;a href="https://github.com/emberjs/rfcs/pull/176"&gt;RFC #176 JavaScript Modules API&lt;/a&gt;. TypeScript’s module definition system will let us support both in parallel, and we will. Backwards compatibility and &lt;em&gt;stability without stagnation&lt;/em&gt; are things we value for this addon just as much as the rest of the Ember.js ecosystem does.&lt;/p&gt;
&lt;p&gt;This effort, led by Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;), is ongoing in the &lt;a href="https://github.com/typed-ember/ember-typings"&gt;typed-ember/ember-typings&lt;/a&gt; repository. (If you’re wondering why we’re not just doing it in the DefinitelyTyped repository, see below.) We probably won’t be able to get to 100% of everything the Ember Object model does—Ember’s custom object model is &lt;em&gt;incredibly&lt;/em&gt; sophisticated, and TypeScript actually &lt;a href="https://github.com/Microsoft/TypeScript/issues/16699"&gt;still can’t&lt;/a&gt; &lt;em&gt;totally&lt;/em&gt; express it—but Derek already has most of it working. This will be a &lt;em&gt;huge&lt;/em&gt; step forward.&lt;/p&gt;
&lt;p&gt;To be clear, we’re not forking the way you get types. We’ll upstream all of this work to DefinitelyTyped as soon as we have them working, but the DefinitelyTyped repo is &lt;em&gt;huge&lt;/em&gt; and very busy; it’s not a great place to do this kind of substantial rework of existing types. And we really don’t need to have all the &lt;em&gt;other&lt;/em&gt; type definitions DefinitelyTyped supplies in our way as we’re working, either. Having a separate repo gives us a place we can work on types, try them out as a community, etc. before creating PRs on DefinitelyTyped and publishing them officially.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="addon-typings" class="level4"&gt;
&lt;h4&gt;Addon typings&lt;/h4&gt;
&lt;p&gt;We need to get type definitions in place for the addons in the ecosystem! That way when you’re using, say, &lt;a href="https://github.com/simplabs/ember-test-selectors"&gt;ember-test-selectors&lt;/a&gt;, you’ll get an error if you try to use the functions it provides incorrectly. Right now, every addon out there is missing types entirely, so everything gets treated as taking the useless &lt;code&gt;any&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;In a week or so, I’ll have a blog post with a fleshed-out &lt;a href="https://github.com/typed-ember/ember-cli-typescript/issues/48"&gt;quest issue&lt;/a&gt; for tackling it in detail, but here’s the short version: we’re going to try to get type definitions for all the top addons in the ecosystem so that it’s &lt;em&gt;easy&lt;/em&gt; to use TypeScript in your Ember.js app. That blog post and quest issue will explain how to write good typings, and also how to contribute them to a project which may or may not be interested in using TypeScript itself.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 08 Aug 2017 09:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-08-08:/2017/announcing-ember-cli-typescript-100.html</guid><category>typing-your-ember</category><category>typescript</category><category>emberjs</category></item><item><title>Typing Your Ember, Part 4</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-4.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-3"&gt;previous post&lt;/a&gt; in this series, I noted that one of the most effective current strategies for using TypeScript effectively in an Ember app is to push as much of your logic possible &lt;em&gt;out&lt;/em&gt; of the Ember layer and into plain-old-TypeScript. Unsurprisingly, people had some questions about how to do this, so here’s a brief example.&lt;/p&gt;
&lt;p&gt;As I suggested in that post, we now have a &lt;code&gt;lib&lt;/code&gt; directory in our app, and all new business logic for the app lives there instead of directly on e.g. an &lt;code&gt;Ember.Service&lt;/code&gt; instance. Our current directory structure looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app/
  adapters/
  components/
  config/
  controllers/
  helpers/
  initializers/
  instance-initializers
  lib/    &amp;lt;-- this is the one we care about
    billing/
    utilities/
      numeric.ts
  routes/
  serializers/
  services/
  templates/
  transforms
  app.ts
  router.ts
tests/
package.json
bower.json
// etc.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main thing to notice here is that &lt;code&gt;lib&lt;/code&gt; is just a directory in the app like any other, and its child directories likewise. This means that Ember &lt;abbr title="command line interface"&gt;CLI&lt;/abbr&gt; will resolve it just like normal, too—there’s no need to mess with the resolver or anything.&lt;/p&gt;
&lt;p&gt;Say we had a set of numeric utilities in that &lt;code&gt;numeric.ts&lt;/code&gt; file like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Make text out of numbers, like &amp;quot;1st&amp;quot;, &amp;quot;2nd&amp;quot;, &amp;quot;3rd&amp;quot;, etc.
export const withEnding = (val: number): string =&amp;gt; {
  // boring implementation details elided
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then using it in an Ember component might look like this (where &lt;code&gt;currentNumber&lt;/code&gt; is passed into the component):&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { get, set } from &amp;#39;@ember/object&amp;#39;;
import * as Num from &amp;#39;../lib/utilities/numeric&amp;#39;;

export default Component.extend({
  init() {
    const currentNumber = get(this, &amp;#39;currentNumber&amp;#39;);
    const displayNumber = Num.withEnding(currentNumber);
    set(this, &amp;#39;displayNumber&amp;#39;, displayNumber);
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might wonder why we’d do this instead of using an &lt;code&gt;Ember.Service&lt;/code&gt;. In the above example, I could of course make &lt;code&gt;Num&lt;/code&gt; a service and inject it…&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { getProperties, set } from &amp;#39;@ember/object&amp;#39;;
import { inject } from &amp;#39;@ember/service&amp;#39;;

export default Component.extend({
  num: inject(),

  init() {
    const { currentNumber, num } =
      getProperties(this, &amp;#39;currentNumber&amp;#39;, &amp;#39;num&amp;#39;);

    const displayNumber = num.withEnding(currentNumber);
    set(this, &amp;#39;displayNumber&amp;#39;, displayNumber);
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…but that doesn’t actually &lt;em&gt;gain&lt;/em&gt; me anything—the service here is just a way of exposing a function, after all—and it actually makes everything a bit more verbose. It also decreases the overall analyzability of this for things like tree-shaking: that module dependency is now something that Ember itself has to manage, instead of being statically analyzable at build time. Taking this approach also diminishes the reusability of any numeric helpers I put in there. If we couple them to an &lt;code&gt;Ember.Service&lt;/code&gt;, instead of using an ES6 module, they would stop being things we can easily reuse in non-Ember projects. Instead, by using modules, we leave ourselves the ability to easily extract those numeric helpers, and publish them for either internal or external consumption.&lt;/p&gt;
&lt;p&gt;Along those lines, we actually have a module to support &lt;abbr title="Block-Element-Modifier"&gt;&lt;a href="https://en.bem.info/methodology/quick-start/"&gt;BEM&lt;/a&gt;&lt;/abbr&gt; with Ember Components—and we plan to extract both the basic TypeScript library as well as a &lt;code&gt;BemComponent&lt;/code&gt; Ember-specific wrapper as open-source libraries in the near future. Besides the Ember addon, &lt;em&gt;anyone&lt;/em&gt; will be able to consume and use the underlying TypeScript library, whatever their framework or library of choice. Importantly, that includes us in our other codebases, which include lots of old jQuery and some new React, and might include some Glimmer.js in the future. Any or all of our utilities for these kinds of things become reusable if they’re just TypeScript.&lt;/p&gt;
&lt;p&gt;Pragmatically, it’s also just easier to do and get good help from TypeScript by going this way. It also means that unit-testing requires &lt;em&gt;no&lt;/em&gt; context from Ember whatsoever, which keeps those tests lighter and faster. Even though Ember’s unit tests are already super quick, when you have hundreds or thousands of unit tests, every little bit matters. It also, and probably even more importantly, means there are fewer places where you could mess things up when configuring tests—not that I have any experience messing up test configurations in Ember!&lt;/p&gt;
&lt;p&gt;One important thing to note is that this all works best with Ember—by far—when your &lt;code&gt;lib&lt;/code&gt; modules aren’t managing stateful objects, but rather defining data structures and functions which just transform those structures in some way. This approach is a great fit for us, because we’re increasingly writing a lot of our business and even &lt;abbr title="user interface"&gt;UI&lt;/abbr&gt; logic in terms of &lt;a href="http://www.chriskrycho.com/2016/what-is-functional-programming.html#pure-functions"&gt;pure functions&lt;/a&gt; which transform simple “record” types. That keeps each controller, route, component, or service doing relatively little work: they are responsible for getting and passing around data in the application, and for triggering actions—but they’re not responsible for &lt;em&gt;understanding&lt;/em&gt; or &lt;em&gt;manipulating&lt;/em&gt; that data. Meanwhile the module code doesn’t do &lt;em&gt;any&lt;/em&gt; stateful work; there’s no mutation—just boring, input-to-output functions.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; By contrast, if you’re dealing with stateful objects, you’re apt to end up running into places where you have lifecycle concerns, and that’s where Ember excels.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In summary:&lt;/strong&gt; in this model, Ember handles all the lifecycle and view management, and is responsible for sending data in and out of the application. Plain old modules handle defining what the core internal data types are, and for manipulating, transforming, and creating data.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re wondering: we’re not using anything like Redux or Immutable.js yet, but both &lt;a href="https://github.com/ember-redux/ember-redux"&gt;ember-redux&lt;/a&gt; and &lt;a href="https://github.com/rtfeldman/seamless-immutable"&gt;seamless-immutable&lt;/a&gt; would be great fits for the way we’re building the app at this point, and it’s likely at least &lt;a href="https://github.com/ember-redux/ember-redux"&gt;ember-redux&lt;/a&gt; will become part of our stack in the relatively near future.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 31 Jul 2017 19:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-31:/2017/typing-your-ember-part-4.html</guid><category>emberjs</category><category>typescript</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 3</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-3.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-1"&gt;first&lt;/a&gt; of this series, I described how to set up a brand new Ember.js app to use TypeScript. In the &lt;a href="/2017/typing-your-ember-part-2"&gt;second&lt;/a&gt; part, walked through adding TypeScript to an existing Ember.js app. In this part, I’m going to talk about using TypeScript effectively in a modern Ember.js app.&lt;/p&gt;
&lt;section id="heavy-lifting-so-so-results" class="level2"&gt;
&lt;h2&gt;Heavy lifting, so-so results&lt;/h2&gt;
&lt;p&gt;Let’s get this out of the way up front: right now, using types in anything which extends &lt;code&gt;Ember.Object&lt;/code&gt; is going to be a lot of work for a relatively low reward. &lt;code&gt;Ember.Object&lt;/code&gt; laid the foundation for the modern JavaScript class system (and thus the TypeScript class system), but it has a huge downside: it’s string keys and referennces all the way down. This kind of thing is just normal Ember code—and note all the string keys:&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default Component.extend({
  someProperty: &amp;#39;with a string value&amp;#39;,
  someOther: computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty = get(this, &amp;#39;someProperty&amp;#39;);
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }),
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What this comes out to—even with a lot of the very helpful changes made to TypeScript itself in the 2.x series to help support object models like this one—is a lot of work adding types inline, and having to be really, really careful that your types are &lt;em&gt;correct&lt;/em&gt;. If that property you’re &lt;code&gt;Ember.get&lt;/code&gt;-ing can ever be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you’d better write the type as &lt;code&gt;string | void&lt;/code&gt; instead of just &lt;code&gt;string&lt;/code&gt;. For example: this code is written with the correct types:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default Component.extend({
  someProperty: &amp;#39;with a string value&amp;#39;,  // no type annotation
  someOther: computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty: string = get(this, &amp;#39;property&amp;#39;);
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }),
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note two important things about it, however:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;TypeScript does not (and, with the &lt;em&gt;current&lt;/em&gt; typings for Ember, cannot) figure out the type of &lt;code&gt;someProperty&lt;/code&gt; from this definition; &lt;code&gt;get&lt;/code&gt; currently just hands back &lt;code&gt;any&lt;/code&gt; as the type of these kinds of things. That type annotation is necessary for you to get any mileage out of TypeScript &lt;em&gt;at all&lt;/em&gt; in a computed property like this.&lt;/li&gt;
&lt;li&gt;If, anywhere in your code, you &lt;em&gt;set&lt;/em&gt; the value of &lt;code&gt;someProperty&lt;/code&gt;—including to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, or to &lt;code&gt;{ some: 'object' }&lt;/code&gt;—this could fail.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Unfortunately, this second point means that TypeScript actually &lt;em&gt;can’t&lt;/em&gt; guarantee this the way we’d like. There’s hope coming for this in the future in several ways—more on that in a moment—but for now, I’ll summarize this by saying TypeScript is really helpful &lt;em&gt;within&lt;/em&gt; a function, once you’ve correctly defined the types you’re using. That means that you have to continue to be &lt;em&gt;very&lt;/em&gt; careful in what you’re doing in the context of any &lt;code&gt;Ember.Object&lt;/code&gt; instance, including all the Ember types which descend from &lt;code&gt;Object&lt;/code&gt;, and therefore also any types &lt;em&gt;you&lt;/em&gt; define which extend those in turn.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="future-niceties" class="level2"&gt;
&lt;h2&gt;Future niceties&lt;/h2&gt;
&lt;p&gt;In the future, we’ll be able to get away from a lot of these difficulties by way of two changes coming down the line: Ember embracing ES6 classes to replace its current custom object system, and embracing decorators as a way of replacing the current approach to computed properties. Let’s take those in turn.&lt;/p&gt;
&lt;section id="class-syntax" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;class&lt;/code&gt; syntax&lt;/h3&gt;
&lt;p&gt;When Ember was birthed in the early 2010s (first as “SproutCore 2” and then “Amber.js” and finally “Ember.js”), the JavaScript world was a &lt;em&gt;remarkably&lt;/em&gt; different place. The current pace of change year to year is nothing short of astounding for any language, but doubly so for one that sat languishing for so long. When Ember came around, something like today’s &lt;code&gt;class&lt;/code&gt; syntax was unimaginable, and so essentially every framework had its own class system of some sort. Over the past few years, with the proposal and standardization of the &lt;code&gt;class&lt;/code&gt; syntax as nice sugar for JavaScript’s prototypal inheritance, the need for a custom object and inheritance model has essentially gone away entirely. However, Ember doesn’t do breaking changes to its API just because; we as a community and the core team in particular have chosen to place a high priority on backwards compatibility. So any adoption of ES6 classes had to work in such a way that we got it &lt;em&gt;without&lt;/em&gt; making everyone rewrite their code from scratch.&lt;/p&gt;
&lt;p&gt;All of this impacts our story with TypeScript because, well, TypeScript for a long time couldn’t even begin to handle this kind of complexity (it’s a lot for a static type system to be able to express, given how &lt;em&gt;very&lt;/em&gt; dynamic the types here can be). As of TS 2.3, it can express &lt;em&gt;most&lt;/em&gt; of this object model, which is great… but it’s forever out of step with the rest of the JS/TS ecosystem, which is not so great. ES6 classes are first-class items in TypeScript and the support for getting types right within them is much, &lt;em&gt;much&lt;/em&gt; stronger than the support for the mixin/extension style object model Ember currently uses. So moving over to ES6 classes will make it much easier for TS to do the work of telling you &lt;em&gt;you’re doing it wrong with that class&lt;/em&gt;—and most importantly, it’ll be able to do that automatically, without needing the incredibly hairy type definition files that we’re still trying to write to get Ember’s current model represented. It Will Just Work. That means less maintenance work and fewer places for bugs to creep in.&lt;/p&gt;
&lt;p&gt;Gladly, we’re getting there! Already today, in the most recent versions of Ember, you can write this, and it will work:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;

export default class MyComponent extends Component {
  theAnswer = 42;
  andTheQuestionIs =
    &amp;quot;What is the meaning of life, the universe, and everything?&amp;quot;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When I say “it will work,” I mean you can then turn around and write this in your &lt;code&gt;my-component.hbs&lt;/code&gt; and it’ll be exactly what you would expect from the old &lt;code&gt;Ember.Component.extend()&lt;/code&gt; approach:&lt;/p&gt;
&lt;pre class="hbs"&gt;&lt;code&gt;{{andTheQuestionIs}} {{the Answer}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is one serious limitation of that today: you can’t do that with a class you need to extend &lt;em&gt;further&lt;/em&gt;. So if, for example, you do like we do and customize the application route rinstance and then reuse that in a couple places, you’ll still have to use the old syntax:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Route from &amp;#39;@ember/route&amp;#39;;

export default Route.extend({
  // your customizations...
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But everywhere you consume that, you can use the new declaration:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import ApplicationRoute from &amp;#39;my-app/routes/application&amp;#39;;

export default class JustSomeRoute extends ApplicationRoute {
  model() {
    // etc.
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There’s more work afoot here, too, to make it so that these restrictions can go away entirely… but those changes will undoubtedly be covered in considerable detail on &lt;a href="http://www.emberjs.com/blog/"&gt;the official Ember blog&lt;/a&gt; when they roll out.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="decorators" class="level3"&gt;
&lt;h3&gt;Decorators&lt;/h3&gt;
&lt;p&gt;Now, that’s all well and good, but it doesn’t necessarily help with this scenario:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;is just a string&amp;#39;;

  someOtherProperty = computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty = get(this, &amp;#39;someProperty&amp;#39;);
    return someProperty + &amp;#39; and now I have appended to it&amp;#39;;
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re back in the same spot of having unreliable types there. And again: some really careful work writing type definitions to make sure that &lt;code&gt;computed&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; both play nicely together with the class definition would help somewhat, but… well, it’d be nice if the types could just be determined automatically by TypeScript. (Also, there’s an &lt;a href="https://github.com/Microsoft/TypeScript/issues/16699"&gt;open bug&lt;/a&gt; on the TypeScript repository for trying to deal with &lt;code&gt;computed&lt;/code&gt;; suffice it to say that computed as it currently stands is a sufficiently complicated thing that even with all the incredible type machinery TS 2.1, 2.2, and 2.3 have brought to bear on exactly these kinds of problems… it still can’t actually model &lt;code&gt;computed&lt;/code&gt; correctly.)&lt;/p&gt;
&lt;p&gt;For several years now, Rob Jackson has maintained [a small library] that let you write computed properties with decorators. Up till recently, those were incompatible with TypeScript, because they used to work in the context of object literals rather than classes—and TypeScript never supported that. However, as of about a month ago as I’m writing this, they’ve been updated and they &lt;em&gt;do&lt;/em&gt; work with ES6 classes. So, given the class syntax discussed above, you can now &lt;code&gt;ember install ember-decorators&lt;/code&gt; and then do this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed } from &amp;#39;ember-decorators/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;with a string value&amp;#39;;

  @computed(&amp;#39;someProperty&amp;#39;)
  someOther(someProperty: string) {
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we can provide a type on the parameter to &lt;code&gt;someOther&lt;/code&gt;, which at a minimum makes this enormously cleaner and less repetitive syntactically. More interestingly, however, we &lt;em&gt;should&lt;/em&gt; (though no one has done it just yet, to my knowledge) be able to write a type definition for &lt;code&gt;@computed&lt;/code&gt; such that TypeScript will already know that &lt;code&gt;someProperty&lt;/code&gt; here &lt;em&gt;is&lt;/em&gt; a string, because it’ll have the context of the class in which it’s operating. So that example will be even simpler:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed } from &amp;#39;ember-decorators/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;with a string value&amp;#39;;

  @computed(&amp;#39;someProperty&amp;#39;)
  someOther(someProperty) {
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in that imagined, wonderful future world, if we tried to do something that isn’t a valid string operation—say, we tried &lt;code&gt;someProperty / 3&lt;/code&gt;—TypeScript would complain to us, loudly.&lt;/p&gt;
&lt;p&gt;Although this is still a future plan, rather than a present reality, it’s not &lt;em&gt;that&lt;/em&gt; far off. We just need someone to write that type definition for the decorators, and we’ll be off to the races wherever we’re using the new ES6 class approach instead of the existing &lt;code&gt;Ember.Object&lt;/code&gt; approach. So: &lt;em&gt;soon&lt;/em&gt;. I don’t know how soon, but soon.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="current-ameliorations" class="level2"&gt;
&lt;h2&gt;Current ameliorations&lt;/h2&gt;
&lt;p&gt;In the meantime, of course, many of us are maintaining large codebases. I just checked, and our app (between the app itself and the tests) has around 850 files and 34,000 lines of code. Even as those new abilities land, we’re not going to be converting all of them all at once. And we want to get some real mileage out of TypeScript in the meantime. One of the best ways I’ve found to do this is to take a step back and think about the pieces of the puzzle which Ember is solving for you, and which it &lt;em&gt;isn’t&lt;/em&gt;. That is, Ember is really concerned with managing application state and lifecycle, and with rendering the UI. And it’s &lt;em&gt;fabulous&lt;/em&gt; about those things. What it’s not particularly concerned with (and what it shouldn’t be) is the particulars of how your business logic is implemented. And there’s no particular reason, &lt;em&gt;especially&lt;/em&gt; if most of that business logic is implemented in terms of a bunch of pure, straightforward, input-to-output functions that operate on well-defined data types, for all of your business logic to live in &lt;code&gt;Ember.Object&lt;/code&gt;-descended classes.&lt;/p&gt;
&lt;p&gt;Instead, we have increasingly chosen to write our business logic in bog-standard TypeScript files. These days, our app has a &lt;code&gt;lib&lt;/code&gt; directory in it, with packages like &lt;code&gt;utilities&lt;/code&gt; for commonly used tools… but also like &lt;code&gt;billing&lt;/code&gt;, where we implement &lt;em&gt;all&lt;/em&gt; of our client-side billing business logic. The display logic goes in the &lt;code&gt;Ember.Controller&lt;/code&gt; and &lt;code&gt;Ember.Component&lt;/code&gt; classes, and the routing and state management goes in the &lt;code&gt;Ember.Route&lt;/code&gt; and &lt;code&gt;Ember.Data&lt;/code&gt; pieces as you’d expect. But none of the business logic lives there. That means that we’re entirely free of the aforementioned constraints for the majority of the time dealing with that data. If we do a good job making sure the data is good at the boundaries—route loads, for example, and when we send it back to the server—then we can effectively treat everything else as just boring old (new?) TypeScript.&lt;/p&gt;
&lt;p&gt;So far we’ve only taken that approach with about a quarter of our app, but it’s all the latest pieces of our app, and it has been incredibly effective. Even once we’re able to take advantage of all those shiny new features, we’re going to keep leaning heavily on this approach, because it lets Ember do what Ember is best at, and keeps us from coupling our business logic to the application state management or view rendering details.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So that’s the state of things in Ember with TypeScript today. Your best bet for getting real mileage out of TypeScript today is to use the new class syntax support and decorators wherever you can within Ember-specific code, and then to write as much of your business logic outside the Ember system as possible. Gladly, all of that points you right at the future (in the case of syntax) and just good practice (in the case of separating out your business logic). So: not too shabby overall. It’s working well for us, and I hope it does for you as well!&lt;/p&gt;
&lt;p&gt;Next time: how we got here with the &lt;code&gt;ember-cli-typescript&lt;/code&gt; compiler, and where we hope to go from here!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note that here and throughout, I’m using the &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md#addendum-1---table-of-module-names-and-exports-by-global"&gt;RFC #176 Module API&lt;/a&gt;, which you can use today via &lt;a href="https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill"&gt;this polyfill&lt;/a&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 28 Jul 2017 12:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-28:/2017/typing-your-ember-part-3.html</guid><category>emberjs</category><category>typescript</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 2</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-2.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-1"&gt;first part&lt;/a&gt; of this series, I described how to set up a brand new Ember.js app to use TypeScript. In this part, I’m going to talk about starting to use TypeScript in the context of an existing Ember.js app.&lt;/p&gt;
&lt;p&gt;This is, in many ways, even simpler than setting up an app for the first time, because you already have almost everything you need. The steps here are exactly what you’re used to if you’re used to using the Ember CLI ecosystem:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Install &lt;code&gt;ember-cli-typescript&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Start using TypeScript wherever you want in your app.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It really is that simple, for the most part. There are a couple qualifications, and a couple tips, though.&lt;/p&gt;
&lt;p&gt;Let’s start with &lt;strong&gt;qualifications&lt;/strong&gt;. There are open, unresolved &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/"&gt;issues&lt;/a&gt; about using &lt;code&gt;ember-cli-typescript&lt;/code&gt; in your app in certain contexts. For example: &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/8"&gt;using it with &lt;code&gt;ember-browserify&lt;/code&gt;&lt;/a&gt;. While everything will &lt;em&gt;build&lt;/em&gt; correctly in that case (even if the TypeScript compiler complains about being unable to resolve some things, the Ember CLI build pipeline will still work as expected), your editor integration won’t. There are a bunch of corners like this we’re still hammering out; those are the main things we need to get resolved before we can call this a “1.0.” We have the &lt;em&gt;main&lt;/em&gt; stuff working, but, well… there’s more to do.&lt;/p&gt;
&lt;p&gt;Along those same lines, you should take a close look at the &lt;a href="https://github.com/emberwatch/ember-cli-typescript#not-yet-supported"&gt;&lt;strong&gt;Not yet supported&lt;/strong&gt;&lt;/a&gt; section of the README. There are parts of Ember’s programming model which TypeScript certainly &lt;em&gt;can&lt;/em&gt; support, but which we haven’t done the lifting to get the type declaration file to help with yet. (Looking for a place to pitch in and already comfortable doing some heavy lifting with some of TypeScript’s &lt;a href="http://www.typescriptlang.org/docs/handbook/mixins.html"&gt;most advanced type features&lt;/a&gt;? We could use the help.)&lt;/p&gt;
&lt;p&gt;One other thing to be aware of is that your &lt;code&gt;tsconfig.json&lt;/code&gt; settings will affect what kind of resolution your editor gives you. If you have &lt;code&gt;allowJs&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;, your editors will resolve JS modules. Otherwise, they’ll &lt;em&gt;only&lt;/em&gt; resolve TS modules. This can be incredibly annoying at times. However, this isn’t something we’ve nailed down in terms of what the default should be yet. (You can &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/"&gt;come tell us&lt;/a&gt; on GitHub if you have thoughts or insights there!) And the fact that Microsoft has left this configurable is suggestive: different projects may have different preferences here.&lt;/p&gt;
&lt;p&gt;Now, for the &lt;strong&gt;tips&lt;/strong&gt;. Note that these are just a couple quick pointers; I’ll come back and talk about structuring your project and more sophisticated uses of TypeScript in the future.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Don’t turn on &lt;code&gt;--strict&lt;/code&gt; or the corresponding individual flags on day 1. Unless you have an extremely unusual and disciplined Ember.js codebase, you’ll have an incredible set of errors to deal with.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t set the &lt;code&gt;noEmitOnError&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;, for much the same reason. Since the state of type declaration files for Ember is best described as &lt;em&gt;nascent&lt;/em&gt; at present, many of your files will have errors in them just from failed imports!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t try to convert everything at once. Just pick the next feature or bug you’re working on, and start with the files you’re touching for that bug. Rename it to &lt;code&gt;.ts&lt;/code&gt;, fix any major issues it flags up that you can—but stick as locally as possible. You’re apt to find a &lt;em&gt;lot&lt;/em&gt; of small bugs as you start migrating, and some of them are things which are apt to affect your whole system because they touch central data types. It’s okay. You can come back to those later. For today, you can just be explicit about the weirdnesses.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As part of that: get comfortable—really, really comfortable—with &lt;a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt;. They’ll make it much easier to express the kind of code you’ve &lt;em&gt;actually&lt;/em&gt; written.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t worry about adding explicit types to &lt;em&gt;everything.&lt;/em&gt; In fact, depending on how comfortable you are already with typed languages, you should probably take a pretty different tack with this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you’re just stepping into the world of typed programming languages, you might start adding types where they’re the &lt;em&gt;lowest risk&lt;/em&gt;: some place like your automated tests. That’ll help you start to see how to take advantage of them, while not impacting the way you write your app code until you have a better idea how best to employ the types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re already really comfortable with typed programming languages, you might employ types where they’re &lt;em&gt;most helpful:&lt;/em&gt; start with some types in the hairiest or trickiest spots of your app.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is plenty more I could say, but I think that’s a good start for now. I’ll have lots more to add in later posts about the details of how specifically to get the most mileage out of types within an Ember.js app today.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2017/typing-your-ember-part-1"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Part 1 – Set your Ember.js project up to use TypeScript.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Also, I &lt;em&gt;strongly&lt;/em&gt; encourage you to write types in terms of unions of types rather than in terms of &lt;a href="http://www.typescriptlang.org/docs/handbook/interfaces.html#optional-properties"&gt;optional properties on types&lt;/a&gt;. That might be surprising; I’ll explain it in more detail in a future post.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 07 May 2017 22:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-05-07:/2017/typing-your-ember-part-2.html</guid><category>typescript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 1</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-1.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In this first post in the series, we’re going to keep things simple and easy: we’re going to get an Ember.js app configured to use TypeScript. Later posts will cover some of the other details.&lt;/p&gt;
&lt;p&gt;Because of the lovely &lt;a href="https://ember-cli.com"&gt;Ember CLI&lt;/a&gt; ecosystem, this is a pretty straightforward process. I’m going to start from &lt;em&gt;zero&lt;/em&gt; so that even if you’ve never written an Ember app before, you can get this up and running by following these instructions. These instructions have also been tested and confirmed to work across platforms—you can do this equally on Windows, macOS, or Linux.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Make sure you have Ember’s prerequisites installed. Get &lt;a href="https://nodejs.org/en/"&gt;Node&lt;/a&gt; for your platform. Optionally (but highly recommended) install &lt;a href="https://yarnpkg.com"&gt;Yarn&lt;/a&gt; to manage your Node packages.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the Ember command lines tools globally:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;yarn global add ember-cli&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;npm install --global ember-cli&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create an Ember app.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember new my-ts-app --yarn&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Using the &lt;code&gt;--yarn&lt;/code&gt; flag will make it so your app uses &lt;a href="https://yarnpkg.com"&gt;&lt;code&gt;yarn&lt;/code&gt;&lt;/a&gt; and creates a &lt;code&gt;yarn.lock&lt;/code&gt; file instead of using &lt;code&gt;npm&lt;/code&gt; when it installs its dependencies.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now move to the root of the newly created app: this is where we’ll do everything else in the post.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;cd my-ts-app&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;a href="https://emberobserver.com/addons/ember-cli-typescript"&gt;&lt;em&gt;ember-cli-typescript&lt;/em&gt; add-on&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generate your first UI component.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember generate component some-input&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Rename the files it generated from &lt;code&gt;.js&lt;/code&gt; to &lt;code&gt;.ts&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;app/components/some-input.js&lt;/code&gt; → &lt;code&gt;app/components/some-input.ts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tests/integration/components/some-input-test.js&lt;/code&gt; → &lt;code&gt;tests/integration/components/some-input-test.ts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Eventually, we’ll make it so that you get TypeScript for all newly generated components when using &lt;em&gt;ember-cli-typescript&lt;/em&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add some content to the files:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;{{!-- some-input.hbs --}}
{{input value=theValue change=(mut theValue)}}
{{theValue}}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// some-input.ts
import Ember from &amp;#39;ember&amp;#39;;

export default Ember.Component.extend({
  theValue: &amp;#39;&amp;#39;,
});&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update your &lt;code&gt;application.hbs&lt;/code&gt; file to remove the default &lt;code&gt;{{welcome}}&lt;/code&gt; template and replace it with &lt;code&gt;{{some-input}}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Spin up the Ember application with Ember CLI’s development server:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember serve&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll likely note some warnings: the TypeScript compiler won’t be able to find some of the modules imported in your files. I’ll have more to say about this in a future post. For now, suffice it to say: don’t worry, Ember CLI is still resolving and compiling your modules just fine.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Load the application by going to &lt;code&gt;localhost:4200&lt;/code&gt; in your browser. You should see a blank white screen with an input in it. Type in it, and see the input rendered to the page. Simple enough, but it’s using a TypeScript file compiled along the way!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that’s it: we’re done setting up an Ember.js app to use TypeScript! In the next post, I’ll talk a bit about strategies for migrating an existing app to TypeScript—not just the mechanics of it, but also where and how to start actually integrating types into your code.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2017/typing-your-ember-part-2"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Part 2 – Adding TypeScript to an existing Ember.js project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I strongly prefer to use &lt;code&gt;yarn&lt;/code&gt; over &lt;code&gt;npm&lt;/code&gt; because &lt;code&gt;yarn&lt;/code&gt; installs are predictable and repeatable, and if there’s one thing I don’t need to spend time on when developing our Ember.js app at Olo, it’s chasing problems with transitive dependencies that are different in the build server than in my local development environment. Yarn’s lockfiles mean what ends up built on the server is &lt;em&gt;exactly&lt;/em&gt; what ended up built on my machine.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;But if you’re curious, here’s a preview: we really need more &lt;a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html"&gt;type definitions&lt;/a&gt; for the Ember ecosystem. I’ll be covering &lt;em&gt;how&lt;/em&gt; we build those in much more detail in a future installment.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 05 May 2017 00:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-05-05:/2017/typing-your-ember-part-1.html</guid><category>typescript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we’re both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I’ll be reusing some of this material as the basis of an internal tech talk I’m giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s not tied to JS directly, which means it’s free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That’s the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it’s… still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript’s is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; – not mostly sure, 100% sure – that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say “by design,” I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of “soundness holes” in the type system—there’s still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS… but not none. (That’s even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It’s just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean—&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that’s no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I’d summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item><item><title>TypeScript keyof Follow-Up</title><link>http://www.chriskrycho.com/2017/typescript-keyof-follow-up.html</link><description>&lt;p&gt;I recently wrote up some neat things you can do with &lt;a href="http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html"&gt;&lt;code&gt;keyof&lt;/code&gt; and mapped types&lt;/a&gt; in TypeScript 2.1. In playing further with those bits, I ran into some interesting variations on the approach I outlined there, so here we are.&lt;/p&gt;
&lt;p&gt;In the previous post, I concluded with an example that looked like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};

type State
  = &amp;#39;Pending&amp;#39;
  | &amp;#39;Started&amp;#39;
  | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That &lt;code&gt;UnionKeyToValue&amp;lt;State&amp;gt;&lt;/code&gt; type constraint requires us to fill out the &lt;code&gt;STATE&lt;/code&gt; object as expected. The whole point of this exercise was to give us the benefit of code completion with that STATE type so we could use it and not be worried about the kinds of typos that too-often bite us with stringly-typed arguments in JavaScript.&lt;/p&gt;
&lt;p&gt;It turns out we don’t &lt;em&gt;need&lt;/em&gt; that to get completion, though. All editors which use the TypeScript language service will give us the same degree of completion if we start typing a string and then trigger completion:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/more-ts.gif" title="screen capture of string completion in VS Code" alt="string completion with TypeScript 2.1" /&gt;&lt;figcaption&gt;string completion with TypeScript 2.1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Granted that you have to know this is a string (though the JetBrains &lt;abbr title="integrated development environment"&gt;IDE&lt;/abbr&gt;s will actually go a step further and suggest the right thing &lt;em&gt;without&lt;/em&gt; needing the string key). But that’s roughly equivalent to knowing you need to import the object literal constant to get the completion that way. Six one, half dozen the other, I think.&lt;/p&gt;
&lt;p&gt;This makes it something of a wash with the original approach, as long as you’re dealing in a pure-TypeScript environment. The big advantage that the original approach still has, of course, is that it also plays nicely with a mixed TypeScript and JavaScript environment. If you’re just progressively adding TypeScript to an existing JavaScript codebase, that’s possibly reason enough to stick with it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: an additional reason to prefer my original solution:&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="en"&gt;
&lt;p lang="en" dir="ltr"&gt;
&lt;a href="https://twitter.com/chriskrycho"&gt;@chriskrycho&lt;/a&gt; &lt;a href="https://twitter.com/typescriptlang"&gt;@typescriptlang&lt;/a&gt; I think a benefit of your previous solution is that you can rename keys and all their usages.
&lt;/p&gt;
— Timm (@timmpreetz) &lt;a href="https://twitter.com/timmpreetz/status/816672215924097024"&gt;January 4, 2017&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 03 Jan 2017 20:35:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-01-03:/2017/typescript-keyof-follow-up.html</guid><category>programming languages</category><category>software development</category><category>typescript</category><category>javascript</category></item><item><title>keyof and Mapped Types In TypeScript 2.1</title><link>http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html</link><description>&lt;p&gt;In the last few months, I’ve been playing with both &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt; and &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; as tools for increasing the quality and reliability of the JavaScript I write at Olo. Both of these are syntax that sits on top of normal JavaScript to add type analysis—basically, a form of &lt;a href="https://en.wikipedia.org/wiki/Gradual_typing"&gt;gradual typing&lt;/a&gt; for JS.&lt;/p&gt;
&lt;p&gt;Although TypeScript’s tooling has been better all along&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I initially preferred Flow’s type system quite a bit: it has historically been much more focused on &lt;a href="http://stackoverflow.com/questions/21437015/soundness-and-completeness-of-systems"&gt;soundness&lt;/a&gt;, especially around the &lt;em&gt;many&lt;/em&gt; problems caused by &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, than TypeScript. And it had earlier support for &lt;a href="https://flowtype.org/docs/disjoint-unions.html"&gt;tagged unions&lt;/a&gt;, a tool I’ve come to find invaluable since picking them up from my time with Rust.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But the 2.0 and 2.1 releases of TypeScript have changed the game substantially, and it’s now a &lt;em&gt;very&lt;/em&gt; compelling language in its own right—not to mention a great tool for writing better JavaScript. So I thought I’d highlight how you can get a lot of the benefits you would get from the type systems of languages like Elm with some of those new TypeScript features: the &lt;em&gt;&lt;code&gt;keyof&lt;/code&gt; operator&lt;/em&gt; and &lt;em&gt;mapped types&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i&gt;Some readers may note that what I’m doing here is a &lt;em&gt;lot&lt;/em&gt; of wrangling to cajole TypeScript into giving me the kinds of things you get for free in an ML-descended language. Yep. The point is that you &lt;em&gt;can&lt;/em&gt; wrangle it into doing this.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="plain-old-javascript" class="level3"&gt;
&lt;h3&gt;Plain old JavaScript&lt;/h3&gt;
&lt;p&gt;Let’s say we want to write a little state machine in terms of a function to go from one state to the next, like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case &amp;#39;Pending&amp;#39;: return &amp;#39;Started&amp;#39;;
    case &amp;#39;Started&amp;#39;: return &amp;#39;Completed&amp;#39;;
    case &amp;#39;Completed&amp;#39;: return &amp;#39;Completed&amp;#39;;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will work, and it’ll even throw an error if you hand it the wrong thing. But you’ll find out at runtime if you accidentally typed &lt;code&gt;nextState('Pednign')&lt;/code&gt; instead of &lt;code&gt;nextState('Pending')&lt;/code&gt;—something I’ve done more than once in the past. You’d have a similar problem if you’d accidentally written &lt;code&gt;case 'Strated'&lt;/code&gt; instead of &lt;code&gt;case 'Started'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many contexts like this one in JavaScript—perhaps the most obvious being &lt;a href="http://redux.js.org/docs/basics/Actions.html"&gt;Redux actions&lt;/a&gt;, but I get a lot of mileage out of the pattern in Ember, as well. In these contexts, I find it’s convenient to define types that are kind of like pseudo-enums or pseudo-simple-unions, like so:&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you’ve defined an object this way, instead of using strings directly in functions that take it as an argument, like &lt;code&gt;nextState('Started')&lt;/code&gt;, you can use the object property: &lt;code&gt;nextState(STATE.Started)&lt;/code&gt;. You can rewrite the function body to use the object definition instead as well:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case STATE.Pending: return STATE.Started;
    case STATE.Started: return STATE.Completed;
    case STATE.Completed: return STATE.Completed;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the object and its keys instead gets you something like a namespaced constant. As a result, you can get more help with things like code completion from your editor, along with warnings or errors from your linter if you make a typo. You’ll also get &lt;em&gt;slightly&lt;/em&gt; more meaningful error messages if you type the wrong thing. For example, if you type &lt;code&gt;STATE.Strated&lt;/code&gt; instead of &lt;code&gt;STATE.Started&lt;/code&gt;, any good editor will give you an error—especially if you’re using a linter. At Olo, we use &lt;a href="http://eslint.org"&gt;ESLint&lt;/a&gt;, and we have it &lt;a href="https://github.com/ember-cli/ember-cli-eslint/"&gt;set up&lt;/a&gt; so that this kind of typo/linter error fails our test suite (and we never merge changes that don’t pass our test suite!).&lt;/p&gt;
&lt;p&gt;This is about as good a setup as you can get in plain-old JavaScript. As long as you’re disciplined and always use the object, you get some real benefits from using this pattern. But you &lt;em&gt;always&lt;/em&gt; have to be disciplined. If someone who is unfamiliar with this pattern types &lt;code&gt;nextState('whifflebats')&lt;/code&gt; somewhere, well, we’re back to blowing up at runtime. Hopefully your test suite catches that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="typescript-to-the-rescue" class="level3"&gt;
&lt;h3&gt;TypeScript to the rescue&lt;/h3&gt;
&lt;p&gt;TypeScript gives us the ability to &lt;em&gt;guarantee&lt;/em&gt; that the contract is met (that we’re not passing the wrong value in). As of the latest release, it also lets us guarantee the &lt;code&gt;STATES&lt;/code&gt; object to be set up the way we expect. And last but not least, we get some actual productivity boosts when writing the code, not just when debugging it.&lt;/p&gt;
&lt;p&gt;Let’s say we decided to constrain our &lt;code&gt;nextState&lt;/code&gt; function so that it had to both take and return some kind of &lt;code&gt;State&lt;/code&gt;, representing one of the states we defined above. We’ll leave a &lt;code&gt;TODO&lt;/code&gt; here indicating that we need to figure out how to write the type of &lt;code&gt;State&lt;/code&gt;, but the function definition would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// TODO: figure out how to define `State`
function nextState(state: State): State {
  // the same body...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript has had &lt;a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt; since the &lt;a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html"&gt;1.4 release&lt;/a&gt; so they might seem like an obvious choice, and indeed we could write easily a type definition for the strings in &lt;code&gt;STATES&lt;/code&gt; as a union:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, you can’t write something like &lt;code&gt;State.Pending&lt;/code&gt; somewhere; you have to write the plain string &lt;code&gt;'Pending'&lt;/code&gt; instead. You still get some of the linting benefits you got with the approach outlined above via TypeScript’s actual type-checking, but you don’t get &lt;em&gt;any&lt;/em&gt; help with autocompletion. Can we get the benefits of both?&lt;/p&gt;
&lt;p&gt;Yes! (This would be a weird blog post if I just got this far and said, “Nope, sucks to be us; go use Elm instead.”)&lt;/p&gt;
&lt;p&gt;As of the 2.1 release, TypeScript lets you define types in terms of keys, so you can write a type like this:&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can use that type any place you need to constrain the type of a variable, or a return, or whatever:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const goodState: StateFromKeys = STATE.Pending;

// error: type &amp;#39;&amp;quot;Blah&amp;quot;&amp;#39; is not assignable to type &amp;#39;State&amp;#39;
const badState: StateFromKeys = &amp;#39;Blah&amp;#39;;

interface StateMachine {
  (state: StateFromKeys): StateFromKeys;
}

const nextState: StateMachine = (state) =&amp;gt; {
  // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The upside to this is that now you can guarantee that anywhere you’re supposed to be passing one of those strings, you &lt;em&gt;are&lt;/em&gt; passing one of those strings. If you pass in &lt;code&gt;'Compelte'&lt;/code&gt;, you’ll get an actual error—just like if we had used the union definition above. At a minimum, that will be helpful feedback in your editor. Maximally, depending on how you have your project configured, it may not even generate any JavaScript output.&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; So that’s a significant step forward beyond what we had even with the best linting rules in pure JavaScript.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="going-in-circles" class="level3"&gt;
&lt;h3&gt;Going in circles&lt;/h3&gt;
&lt;p&gt;But wait, we can do more! TypeScript 2.1 &lt;em&gt;also&lt;/em&gt; came with a neat ability to define “mapped types,” which map one object type to another. They have a few &lt;a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#mapped-types"&gt;interesting examples&lt;/a&gt; which are worth reading. What’s interesting to us here is that you can write a type like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in keyof typeof STATE]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course, you can simplify that using the type we defined above, since &lt;code&gt;StateFromKeys&lt;/code&gt; was just &lt;code&gt;keyof typeof STATE&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve now defined an object type whose &lt;em&gt;key&lt;/em&gt; has to be one of the items in the &lt;code&gt;State&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Now, by itself, this isn’t all that useful. Above, we defined that as the keys on the &lt;code&gt;STATE&lt;/code&gt; object, but if we tried to use that in conjunction with this new type definition, we’d just end up with a recursive type definition: &lt;code&gt;StateFromKeys&lt;/code&gt; defined as the keys of &lt;code&gt;STATE&lt;/code&gt;, &lt;code&gt;StateAsMap&lt;/code&gt; defined in terms of the elements of &lt;code&gt;StateFromKeys&lt;/code&gt;, and then &lt;code&gt;STATE&lt;/code&gt; defined as a &lt;code&gt;StateAsMap&lt;/code&gt;…&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: StateAsMap = {
  Pending: &amp;#39;Pending&amp;#39;,
  Active: &amp;#39;Active&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}

type StateFromKeys = keyof typeof STATE;

type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You end up with multiple compiler errors here, because of the circular references. This approach won’t work. If we take a step back, though, we can work through this (and actually end up someplace better).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="join-forces" class="level3"&gt;
&lt;h3&gt;Join forces!&lt;/h3&gt;
&lt;p&gt;First, let’s start by defining the mapping generically. After all, the idea here was to be able to use this concept all over the place—e.g. for &lt;em&gt;any&lt;/em&gt; Redux action, not just one specific one. We don’t need this particular &lt;code&gt;State&lt;/code&gt;; we just need a constrained set of strings (or numbers) to be used as the key of an object:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type MapKeyAsValue&amp;lt;Key extends string&amp;gt; = {
  [K in Key]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In principle, if we didn’t have to worry about the circular references, we could use that to constrain our definition of the original &lt;code&gt;STATE&lt;/code&gt; itself:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: MapKeyAsValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how to get around the problem of circular type definitions? Well, it turns out that the &lt;code&gt;K&lt;/code&gt; values in these &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; and &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; types are equivalent:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// Approach 1, using an object
const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;
type StateObjectKeyToValue = {
  [K in StateFromKeys]: K  // &amp;lt;- K is just the keys!
};

// Approach 2, using unions
type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;
type StateUnionKeyToValue = {
  [K in StateUnion]: K  // &amp;lt;- K is also just the keys!
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, unlike the &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; version, &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; doesn’t make any reference to the &lt;code&gt;STATE&lt;/code&gt; object. So we can use &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; to constrain &lt;code&gt;STATE&lt;/code&gt;, and then just use &lt;code&gt;StateUnion&lt;/code&gt; to constrain all the places we want to &lt;em&gt;use&lt;/em&gt; one of those states. Once we put it all together, that would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

type StateUnionKeyToValue = {
  [K in StateUnion]: K
};

const STATE: StateUnionKeyToValue = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By doing this, we get two benefits. First, &lt;code&gt;STATE&lt;/code&gt; now has to supply the key and value for &lt;em&gt;all&lt;/em&gt; the union’s variants. Second, we know that the key and value are the same, and that they map to the union’s variants. These two facts mean that we can be 100% sure that wherever we define something as requiring a &lt;code&gt;State&lt;/code&gt;, we can supply one of the items on &lt;code&gt;STATE&lt;/code&gt; and it will be guaranteed to be correct. If we change the &lt;code&gt;State&lt;/code&gt; union definition, everything else will need to be updated, too.&lt;/p&gt;
&lt;p&gt;Now we can make this generic, so it works for types besides just this one set of states—so that it’ll work for &lt;em&gt;any&lt;/em&gt; union type with string keys, in fact. (That string-key constraint is important because objects in TypeScript can currently only use strings or numbers as keys; whereas union types can be all sorts of things.) Apart from that constraint on the union, though, we can basically just substitute a generic type parameter &lt;code&gt;U&lt;/code&gt;, for “union,” where we had &lt;code&gt;StateUnion&lt;/code&gt; before.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then any object we say conforms to this type will take a union as its type parameter, and every key on the object must have exactly the same value as the key name:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If any of those don’t have &lt;em&gt;exactly&lt;/em&gt; the same value as the key name, you’ll get an error. So, each of the following value assignments would fail to compile, albeit for different reasons (top to bottom: capitalization, misspelling, and missing a letter).&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const BAD_STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;pending&amp;#39;,  // look ma, no capitals
  Started: &amp;#39;Strated&amp;#39;,  // St-rated = whuh?
  Completed: &amp;#39;Complete&amp;#39;,  // so tense
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll see a compiler error that looks something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="line-block"&gt;[ts]&lt;br /&gt;
Type ‘{ Pending: “pending”; Started: “Strated”; Completed: “Complete” }’ is not assignable to type ‘UnionKeyToValue&lt;State&gt;’.&lt;br /&gt;
  Types of property ‘Pending’ are incompatible.&lt;br /&gt;
    Type ‘“pending”’ is not assignable to type ‘“Pending”’.&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the key and the name don’t match, the compiler tells us we didn’t keep the constraint we defined on what these types should look like. Similarly, if you forget an item from the union, you’ll get an error. If you add an item that isn’t in the original union, you’ll get an error. Among other things, this means that you can be confident that if you add a value to the union, the rest of your code won’t compile until you include cases for it. You get all the power and utility of using union types, &lt;em&gt;and&lt;/em&gt; you get the utility of being able to use the object as a namespace of sorts.&lt;a href="#fn6" class="footnote-ref" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And the TypeScript language service—which you can use from a &lt;em&gt;lot&lt;/em&gt; of editors, including VS Code, Atom, Sublime Text, and the JetBrains IDEs—will actually give you the correct completion when you start definition a type. So imagine we were defining some other union type elsewhere in our program to handle events. Now we can use the same &lt;code&gt;UnionKeyToValue&lt;/code&gt; type to construct this type, with immediate, &lt;em&gt;correct&lt;/em&gt; feedback from the TypeScript language service:&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt;
&lt;source type='video/mp4' src='https://f001.backblazeb2.com/file/chriskrycho-com/images/completion.mp4'&gt;
&lt;/video&gt;
&lt;figcaption&gt;
TypeScript live code completion of the mapped type
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;By inverting our original approach of using &lt;code&gt;keyof&lt;/code&gt; (itself powerful and worth using in quite a few circumstances) and instead using the new mapped types, we get a &lt;em&gt;ton&lt;/em&gt; of mileage in terms of productivity when using these types—errors prevented, and speed of writing the code in the first place increased as well.&lt;/p&gt;
&lt;p&gt;Yes, it’s a little verbose and it does require duplicating the strings whenever you define one of these types.&lt;a href="#fn7" class="footnote-ref" id="fnref7"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; But, and this is what I find most important: there is only one &lt;em&gt;source&lt;/em&gt; for those string keys, the union type, and it is definitive. If you change that central union type, everything else that references it, including the namespace-like object, will fail to compile until you make the same change there.&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt;
&lt;source type='video/mp4' src='https://f001.backblazeb2.com/file/chriskrycho-com/images/change-union.mp4'&gt;
&lt;/video&gt;
&lt;figcaption&gt;
Updating a union
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;So it’s a lot more work than it would be in, say, Elm. But it’s also a lot more guarantees than I’d get in plain-old-JavaScript, or even TypeScript two months ago.&lt;/p&gt;
&lt;p&gt;I’ll call that a win.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;it’s no surprise that Microsoft’s developer tooling is stronger than Facebook’s&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;along with all the other ML-descended languages I’ve played with, including Haskell, F&lt;sup&gt;♯&lt;/sup&gt;, PureScript, and Elm.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Aside: to be extra safe and prevent any confusion or mucking around, you should probably call &lt;code&gt;Object.freeze()&lt;/code&gt; on the object literal, too:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = Object.freeze({
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both convention and linters make it unlikely you’ll modify something like this directly—but impossible is better than unlikely.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Flow has supported this feature for some time; you can write &lt;code&gt;$Keys&amp;lt;typeof STATE&amp;gt;&lt;/code&gt;—but the feature is entirely undocumented.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Set your &lt;code&gt;&amp;quot;compilerOptions&amp;quot;&lt;/code&gt; key in your &lt;code&gt;tsconfig.json&lt;/code&gt; to include &lt;code&gt;&amp;quot;noEmitOnError&amp;quot;: true,&lt;/code&gt;.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;For namespacing in a more general sense, you should use… &lt;a href="http://www.typescriptlang.org/docs/handbook/namespaces.html"&gt;namespaces&lt;/a&gt;.&lt;a href="#fnref6" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7"&gt;&lt;p&gt;It would be great if we could get these benefits without the duplication—maybe someday we’ll have better support in JS or TS natively.&lt;a href="#fnref7" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 17 Dec 2016 23:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-17:/2016/keyof-and-mapped-types-in-typescript-21.html</guid><category>javascript</category><category>typescript</category><category>software development</category><category>programming languages</category></item></channel></rss>