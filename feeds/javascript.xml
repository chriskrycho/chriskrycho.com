<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - javascript</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Mon, 26 Nov 2018 20:25:00 -0500</lastBuildDate><item><title>Internal and External Parameter Names in JavaScript and TypeScript</title><link>http://www.chriskrycho.com/2018/internal-and-external-parameter-names-in-javascript-and-typescript.html</link><description>&lt;p&gt;Earlier this month I was working on a fairly thorny problem for work—taking a total value and splitting it into numbers which summed up to it, possibly including with a rule about what the split-up values had to be a multiple of. E.g. you want to order 50 Buffalo wings, and you have to choose the flavors for the wings in increments of 5.&lt;/p&gt;
&lt;p&gt;I spent a lot of time thinking about the implementation of the algorithm for that, but I also spent a lot of time thinking about what its &lt;abbr&gt;API&lt;/abbr&gt; should look like. Here, it’s the latter I want to dive into (the former is a little tricky but not all that interesting).&lt;/p&gt;
&lt;p&gt;I started out with just simple parameters to the function:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function splitNicely(
  total: number, components: number, factor?: number
): number {
  // the implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is nice enough to use internally. But calling it is pretty confusing:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const result = splitNicely(50, 5, 2);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which number is what value here? Who knows!&lt;/p&gt;
&lt;p&gt;So then I just exposed &lt;em&gt;all&lt;/em&gt; of the items as an options hash:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;interface SplitArgs {
  total: number;
  components: number;
  factor?: number;
}

function splitNicely(
  { total, components, factor }: SplitArgs
): number {
  // the implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This was a lot nicer to call:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;const result =
    splitNicely({ total: 50, components: 5, factor: 2 });&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, it was a bit verbose, and I realized that it’s fairly obvious that the first argument should be the value we’re splitting up, so I simplified a bit:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;interface SplitArgs {
  components: number;
  factor?: number;
}

function splitNicely(
  total: number,
  { components, factor }: SplitArgs
): number {
  // the implementation
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now calling it read &lt;em&gt;relatively&lt;/em&gt; well:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;splitNicely(10, { components: 5, factor: 2 });&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the names were not my favorite for invoking the function. Really, what I wanted was for the function invocation to describe what I was doing, when reading it from the outside—while having these useful names for operating on the implementation internally.&lt;/p&gt;
&lt;p&gt;At this point, I remembered two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Swift and Objective-C have the nice notion of internal and external parameter names.&lt;/li&gt;
&lt;li&gt;JavaScript (and thus TypeScript) let you rename values in “destructuring assignment.”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second one lets us get the same basic effect in JavaScript or TypeScript as we get in Swift, if we’re using an options argument! Here’s how destructuring works in the function definition. Let’s see it first with just JavaScript. The object passed as a parameter has a key named &lt;code&gt;of&lt;/code&gt;, which has a string value—but &lt;code&gt;of&lt;/code&gt; is a bad name inside the function; there, we can just call it &lt;code&gt;s&lt;/code&gt; and it’s perfectly clear.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function length({ of: str }) {
  return str.length;
}

console.log(length({ of: &amp;quot;waffles&amp;quot; }));  // 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s the equivalent of a function that looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function length({ of }) {
  const str = of;
  return str.length
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the same code but in TypeScript:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;function length({ of: str }: { of: string }): number {
  return str.length;
}

console.log(length({ of: &amp;quot;waffles&amp;quot; }));  // 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a big more annoying to write out in TypeScript, because we need to supply the type of the whole object after the object we’ve destructured, but the effect is the same once we get past the declaration. It’s also pretty silly to do this kind of thing at all in this example—but it becomes much more useful in more complicated functions, like the one that motivated me to explore this in the first place.&lt;/p&gt;
&lt;p&gt;Recall that I &lt;em&gt;liked&lt;/em&gt; having &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;factor&lt;/code&gt; as the internal names. They weren’t great for &lt;em&gt;calling&lt;/em&gt; the function, though. After some consideration, I decided invoking the function should look like this:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;splitNicely(10, { into: 5, byMultiplesOf: 2 });&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By using the destructuring technique, we can get exactly this, while keeping &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;factor&lt;/code&gt; internally:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;interface SplitArgs = {
  into: number;
  byMultiplesOf?: number;
}

function splitNicely(
  total: number,
  { into: components, byMultiplesOf: factor }: SplitArgs
): number {
  // the implementation
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a great pattern to put in your toolbox. You can of course overdo it with this, as with any technique, but it’s a nice tool for these kinds of cases where you really want to make an expressive &lt;abbr&gt;API&lt;/abbr&gt; for both callers and the internal implementation of a function.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 26 Nov 2018 20:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-11-26:/2018/internal-and-external-parameter-names-in-javascript-and-typescript.html</guid><category>javascript</category><category>typescript</category><category>swift</category><category>software development</category></item><item><title>Why We Want Pattern-Matching in JavaScript</title><link>http://www.chriskrycho.com/2018/why-we-want-pattern-matching-in-javascript.html</link><description>&lt;p&gt;I’ve often noted how much I want the &lt;a href="https://github.com/tc39/proposal-pattern-matching"&gt;JavaScript pattern-matching proposal&lt;/a&gt; to land. I noted in conversation with some people recently, though, that it’s not always obvious &lt;em&gt;why&lt;/em&gt; it will be so helpful. Similarly, &lt;a href="https://twitter.com/littlecalculist"&gt;Dave Herman&lt;/a&gt; recently noted to me that &lt;a href="https://twitter.com/dhh"&gt;DHH&lt;/a&gt;’s mantra of “Show me the code” is a really helpful tool for thinking about language design. (I tend to agree!) So with that in mind, here’s a piece of example code from the Ember app I work on today, very slightly modified to get at the pure essentials of this particular example.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The context is a &lt;abbr&gt;UI&lt;/abbr&gt; component which shows the user their current discount, if any, and provides some nice interactivity if they try to switch to a different discount.&lt;/p&gt;
&lt;p&gt;First, some types that we’ll use in the example, which I use in the actual component to avoid the problems that inevitably come with using string values for these kinds of things. Linters like ESLint or type systems like TypeScript or Flow will catch typos this way, and you’ll also get better errors at runtime even if you’re not using a linter or a type system!&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const DiscountTypes = {
  Offer: &amp;#39;Offer&amp;#39;,
  Coupon: &amp;#39;Coupon&amp;#39;,
  None: &amp;#39;None&amp;#39;,
};

const Change = {
  OfferToOffer: &amp;#39;OfferToOffer&amp;#39;,
  OfferToCoupon: &amp;#39;OfferToCoupon&amp;#39;,
  CouponToCoupon: &amp;#39;CouponToCoupon&amp;#39;,
  CouponToOffer: &amp;#39;CouponToOffer&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we set up a component which has a little bit of internal state to track the desired change before we submit it, which we display differently based on what the value of the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get"&gt;&lt;abbr&gt;ES5&lt;/abbr&gt; getter&lt;/a&gt; for &lt;code&gt;change&lt;/code&gt; is here:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class DiscountComponent {
  constructor(currentDiscountType) {
    this.currentDiscountType = currentDiscountType;
    this.newDiscountType = null;
  }

  changeDiscount(newDiscountType) {
    this.newDiscountType = newDiscountType;
  }

  submitChange() {
    // logic for talking to the server
  }

  get change() {
    const { currentDiscountType, newDiscountType } = this;

    if (currentDiscountType === DiscountTypes.Offer) {
      if (newDiscountType === DiscountTypes.Offer) {
        return Change.OfferToOffer;
      } else if (newDiscountType === DiscountTypes.Coupon) {
        return Change.OfferToCoupon;
      } else if (newDiscountType === DiscountTypes.None) {
        return null;
      } else {
        assertInDev(
          `Missed a condition: ${currentDiscountType}, ${newDiscountType}`
        );
      }
    } else if (currentDiscountType === DiscountTypes.Coupon) {
      if (newDiscountType === DiscountTypes.Offer) {
        return Change.CouponToOffer;
      } else if (newDiscountType === DiscountTypes.Coupon) {
        return Change.CouponToCoupon;
      } else if (newDiscountType === DiscountTypes.None) {
        return null;
      } else {
        assertInDev(
          `Missed a condition: ${currentDiscountType}, ${newDiscountType}`
        );
      }
    } else if (currentDiscountType === DiscountTypes.None) {
      return null;
    } else {
      assertInDev(
        `Missed a condition: ${currentDiscountType}, ${newDiscountType}`
      );
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s the &lt;em&gt;exact&lt;/em&gt; same semantics for computing the &lt;code&gt;change&lt;/code&gt; value we’re interested, but with pattern matching:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class DiscountComponent {
  // ...snip

  get change() {
    case ([this.currentDiscountType, this.newDiscountType]) {
      when [DiscountTypes.Offer, DiscountTypes.Offer] -&amp;gt;
        return Change.OfferToOffer;
      when [DiscountTypes.Offer, DiscountTypes.Coupon] -&amp;gt;
        return Change.OfferToCoupon;
      when [DiscountTypes.Coupon, DiscountTypes.Offer] -&amp;gt;
        return Change.CouponToOffer;
      when [DiscountTypes.Coupon, DiscountTypes.Coupon] -&amp;gt;
        return Change.CouponToCoupon;
      when [DiscountTypes.None, ...] || [..., DiscountTypes.None] -&amp;gt;
        return null;
      when [...] -&amp;gt;
        assertInDev(
          `Missed a condition: ${currentDiscountType}, ${newDiscountType}`
        );
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The difference is stark. It’s not just that there are fewer lines of code, it’s that the actual intent of the code is dramatically clearer. (And while I’ve formatted it for nice display here, those are all one-liners in my normal 100-characters-per-line formatting.)&lt;/p&gt;
&lt;p&gt;My preference would be for pattern-matching to have expression semantics, so you wouldn’t need all the &lt;code&gt;return&lt;/code&gt; statements in the mix—and it’s &lt;em&gt;possible&lt;/em&gt;, depending on how a number of proposals in flight right now shake out, that it still will. Even if pattern matching doesn’t ultimately end up with an expression-based syntax, though, we can still get a lot of those niceties if the &lt;code&gt;do&lt;/code&gt;-expression proposal lands:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class DiscountComponent {
  // ...snip

  get change() {
    return do {
      case ([this.currentDiscountType, this.newDiscountType]) {
        when [DiscountTypes.Offer, DiscountTypes.Offer] -&amp;gt;
          Change.OfferToOffer;
        when [DiscountTypes.Offer, DiscountTypes.Coupon] -&amp;gt;
          Change.OfferToCoupon;
        when [DiscountTypes.Coupon, DiscountTypes.Offer] -&amp;gt;
          Change.CouponToOffer;
        when [DiscountTypes.Coupon, DiscountTypes.Coupon] -&amp;gt;
          Change.CouponToCoupon;
        when [DiscountTypes.None, ...] || [..., DiscountTypes.None] -&amp;gt;
          null;
        when [...] -&amp;gt;
          assertInDev(
            `Missed a condition: ${currentDiscountType}, ${newDiscountType}`
          );
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this is profoundly clearer about the intent of the code, and it’s far easier to be sure you haven’t missed a case.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; after some comments on Twitter, I thought I’d note how this is &lt;em&gt;even nicer&lt;/em&gt; in pure functions. If we assume that it gets expression semantics (which, again, I’m hoping for), a pure functional version of the sample above would look like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const change = (currentType, newType) =&amp;gt;
  case ([currentType, newType]) {
    when [DiscountTypes.Offer, DiscountTypes.Offer] -&amp;gt;
      Change.OfferToOffer;
    when [DiscountTypes.Offer, DiscountTypes.Coupon] -&amp;gt;
      Change.OfferToCoupon;
    when [DiscountTypes.Coupon, DiscountTypes.Offer] -&amp;gt;
      Change.CouponToOffer;
    when [DiscountTypes.Coupon, DiscountTypes.Coupon] -&amp;gt;
      Change.CouponToCoupon;
    when [DiscountTypes.None, ...] || [..., DiscountTypes.None] -&amp;gt;
      null;
    when [...] -&amp;gt;
      assertInDev(
        `Missed a condition: ${currentDiscountType}, ${newDiscountType}`
      );
  };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may not be &lt;em&gt;quite&lt;/em&gt; as clear as the same thing in F&lt;sup&gt;♯&lt;/sup&gt; or Elm or another language in that family… but it’s amazingly better than anything we’ve seen in JavaScript to date.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;&lt;code&gt;assertInDev&lt;/code&gt; looks a little different; we’re actually using the &lt;code&gt;Maybe&lt;/code&gt; type from my &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth&lt;/a&gt; library instead of returning &lt;code&gt;null&lt;/code&gt;; it’s an Ember app; as such it uses a &lt;code&gt;@computed&lt;/code&gt; decorator; and of course it’s all in TypeScript. I chose to write it with standard JavaScript to minimize the number of things you have to parse as a reader.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;In the actual TypeScript, these are defined with an &lt;a href="http://www.typescriptlang.org/docs/handbook/enums.html"&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt;.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Fun fact: the original code actually &lt;em&gt;had&lt;/em&gt; missed a number of cases, which I learned only because TypeScript’s &lt;code&gt;strictNullChecks&lt;/code&gt; setting informed me.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Sep 2018 13:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-09-23:/2018/why-we-want-pattern-matching-in-javascript.html</guid><category>javascript</category><category>programming languages</category></item><item><title>A Real Victory</title><link>http://www.chriskrycho.com/2018/a-real-victory.html</link><description>&lt;p&gt;On September 29, 2016, I started working on adding (&lt;a href="https://flow.org"&gt;Flow&lt;/a&gt;) types to the &lt;a href="https://emberjs.com"&gt;Ember&lt;/a&gt; app I had been working on since the start of the year. Throughout the rest of the year I worked on adding some basic Flow types to our app and for Ember. For my last commit in 2016, I switched us to TypeScript and began the rest of the long journey to fully type-checking our app. In early 2018, we made it to “the app type-checks”… in the loosest strictness settings.&lt;/p&gt;
&lt;p&gt;And as of 6pm today—September 5, 2018, almost two full years later, and 21 months after we switched from Flow to TypeScript (more on this below)—we have a fully type-checked TypeScript Ember application, with the strictness notches dialed as strict as they will go.&lt;/p&gt;
&lt;p&gt;It took almost two full years for us to get there, and I’m incredibly proud of that work.&lt;/p&gt;
&lt;p&gt;It took almost two full years because it was a lot of work, and slow work to do at that, and it was rare that I could block out any large chunks of time for that work—we had to sneak in improvements between features we were working urgently on for our clients and our own internally goals. More, it wasn’t just the work of adding types to our application. It was also the work of writing types for Ember itself, and for the surrounding ecosystem—which thankfully I did not finish alone, but which I did have to start alone. It was the work of integrating (and reintegrating) TypeScript into Ember’s build pipeline.&lt;/p&gt;
&lt;p&gt;Happily, I did &lt;em&gt;not&lt;/em&gt; do most of that work alone, and even on our app I’ve had a ton of help getting the types in place. But it has been a massive task, and finishing it today was a real victory. It’s not perfect. We have 200-or-so instances of &lt;code&gt;any&lt;/code&gt; in the application (most of them in semi-legitimate places, to be fair), and I wish it were more like 20. We have a number of places in the app with the &lt;code&gt;!&lt;/code&gt; “I promise this isn’t &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; here” operator on some nullable field, with long comments explaining &lt;em&gt;why&lt;/em&gt; it’s not possible for it to be null there.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But it type-checks today, and type errors fail the builds, and that &lt;em&gt;is&lt;/em&gt; a real victory.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;You can consider this “part 1” of my thoughts on what feels to me like a pretty significant achievement. I’ll hopefully follow this up with some backstory sometime in the next few weeks.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;See my &lt;a href="https://www.chriskrycho.com/2018/type-informed-design.html"&gt;recent post&lt;/a&gt; on thinking a lot about design decisions I would have made differently with TypeScript’s strict null checking available from day one!&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 05 Sep 2018 21:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-09-05:/2018/a-real-victory.html</guid><category>TypeScript</category><category>JavaScript</category><category>Flow</category><category>Ember.js</category><category>software development</category></item><item><title>Type-Informed Design</title><link>http://www.chriskrycho.com/2018/type-informed-design.html</link><description>&lt;p&gt;I’ve been working on getting the Ember app I work on fully type-checked in strict mode this week, and noticed something interesting along the way: there are a lot of design decisions—a few of them really core to the behavior of the app!—which we never, &lt;em&gt;ever&lt;/em&gt; would have made if we had been using Typescript in the first place.&lt;/p&gt;
&lt;p&gt;One of these is pervasive references to certain optional properties that appear in services throughout our app—the basket, for example. These can indeed be inset and at certain times they are. However, many of our components pull in this property from the service and simply assume it’s there to use. We’ve known for a while that this was a problem at times: &lt;a href="https://raygun.com/"&gt;Raygun&lt;/a&gt; has told us loud and clear. But it wasn’t obvious how pervasive this was—and how badly we were just assuming the presence of something that may well be absent &lt;em&gt;all over the app&lt;/em&gt;!—until I saw the type errors from it. Dozens of them.&lt;/p&gt;
&lt;p&gt;Some of them are places where we should have built the components differently: to take the item as an argument, for example, and to require it as an input, because the component just doesn’t make any sense without it, indeed lives in a part of the app such that it’s not even possible to render the component without it.&lt;/p&gt;
&lt;p&gt;And sure, we could document that invariant and use TypeScript’s override tools to carry on. (What do you think I’m doing this week?)&lt;/p&gt;
&lt;p&gt;But, and this is the thing that really caught my attention in thinking about all of this: it would be much better &lt;em&gt;not&lt;/em&gt; to have to do that. Had we had TypeScript in place when we started, we simply would have designed large swaths of the app differently because we’d have seen these kinds of things when we were building it in the first place!&lt;/p&gt;
&lt;p&gt;That’s a bit of wishing for the impossible in one sense: we literally couldn’t have done that when we started on the app, because TS didn’t have the necessary pieces to support typing the Ember libraries. My team helped &lt;em&gt;build&lt;/em&gt; the TS and Ember story over the last 18 months! But at a minimum I have a pretty good idea how the process will be different next time around, with this tool available and providing this kind of helpful design feedback from the outset!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 30 Aug 2018 19:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-08-30:/2018/type-informed-design.html</guid><category>TypeScript</category><category>JavaScript</category><category>functional programming</category><category>types</category><category>software development</category><category>Ember.js</category></item><item><title>Level up your `.filter` game</title><link>http://www.chriskrycho.com/2018/level-up-your-filter-game.html</link><description>&lt;p&gt;Adam Giese’s &lt;a href="https://css-tricks.com/level-up-your-filter-game/"&gt;“Level up your &lt;code&gt;.filter&lt;/code&gt; game”&lt;/a&gt; does something really interesting and helpful: it introduces a bunch of fairly sophisticated functional programming concepts without ever mentioning functional programming and without ever using any of the jargon associated with those terms.&lt;/p&gt;
&lt;p&gt;“Level up your &lt;code&gt;.filter&lt;/code&gt; game” gives you a reason to use some standard FP tools—currying, higher-order functions, composition—in your ordinary work. It’s pitched at working JS developers. It gives a real-world example of wanting to filter search results based on user input. It shows the utility of defining a bunch of small functions which can fit together like LEGO.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Filters are an essential part of JavaScript development. Whether you’re sorting out bad data from an API response or responding to user interactions, there are countless times when you would want a subset of an array’s values. I hope this overview helped with ways that you can manipulate predicates to write more readable and maintainable code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I commend the piece to you not so much for the explanation of how to use JavaScript’s &lt;code&gt;Array.prototype.filter&lt;/code&gt; effectively (though it has some good suggestions that way!) but &lt;em&gt;primarily&lt;/em&gt; as a great example of the kind of pedagogy we need a lot more of to demonstrate the value of functional programming in ordinary, day-to-day development work.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 18 Aug 2018 10:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-08-18:/2018/level-up-your-filter-game.html</guid><category>links</category><category>pedagogy</category><category>javascript</category><category>functional programming</category></item><item><title>Stable Libraries</title><link>http://www.chriskrycho.com/2018/stable-libraries.html</link><description>&lt;p&gt;&lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth&lt;/a&gt; has changed very little since I first released it, and although I have a few ideas for small additions I might make, I don’t really expect it to change much in the future. &lt;em&gt;That’s okay.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There’s a strange idea in some parts of the software development ecosystem—a way of think I also find myself falling into from time—which takes a lack of changes to a library as a sign that the library is &lt;em&gt;dead&lt;/em&gt; and shouldn’t be used. I call this idea “strange” because if you take a step back, it’s actually not necessarily very healthy for certain kinds of libraries to be changing all the time.&lt;/p&gt;
&lt;p&gt;But if you’re in an ecosystem where rapid change in libraries is normal, you end up assuming that something which &lt;em&gt;isn’t changing&lt;/em&gt; is &lt;em&gt;unmaintained&lt;/em&gt; or &lt;em&gt;not usable&lt;/em&gt; when in fact the opposite may be true. If someone opens a pull request or an issue for True Myth, I generally get to it in under a day, often under an hour if it’s in my normal working time. (That’s easy enough for me to do because it’s a small, simple library; I don’t have the scale problems that larger projects do.) The project isn’t &lt;em&gt;dead&lt;/em&gt;. It’s just mostly &lt;em&gt;done&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One of the things I’d like to see in the front-end/JavaScript community in particular is a growing embrace of the idea that some libraries can genuinely be finished. They might need a tweak here or there to work with a new packaging solution, or to fix some corner case bug that has been found. But the “churn” we all feel to varying degrees would be much diminished if maintainers didn’t feel a constant push to be changing for the sake of, well… change. The burden on maintainers would be lower, too. Maybe we’d all get to spend less time on small changes that just keep us “up to date” and more on solving bigger problems.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: sometimes changing perspective warrants a rewrite. But in libraries as in apps, just as often you’ll end up with a bad case of &lt;a href="https://en.m.wikipedia.org/wiki/Second-system_effect"&gt;second system syndrome&lt;/a&gt;; and rewrites are &lt;em&gt;rarely&lt;/em&gt;—not never, but rarely—clean wins.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 14 Aug 2018 19:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-08-14:/2018/stable-libraries.html</guid><category>software development</category><category>open source software</category><category>libraries</category><category>true myth</category><category>javascript</category></item><item><title>Client-Side Ideas for Server-Side Apps</title><link>http://www.chriskrycho.com/2018/client-side-ideas-for-server-side-apps.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;A quick note: I drafted this back in June, but forgot to actually publish it!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;I’ve been working on the design of a particular website I maintain (not this one; keep your eyes open), and besides the fact that I have learned a &lt;em&gt;lot&lt;/em&gt; about web design in general in the years since I originally built that site, I discovered that I desperately want to use a component-drive model for developing sites on the client.&lt;/p&gt;
&lt;p&gt;In my day job, I’m used to breaking down my application into discrete components with their own responsibilities. I’ve gotten spoiled by the component-driven model that dominates the front-end web development world now. (My tool of choice is usually Ember, but you’d get the same with React or Vue or whatever else.) And on the server development side, I’m desperately missing those.&lt;/p&gt;
&lt;p&gt;I’m using &lt;a href="https://getpelican.com"&gt;Pelican&lt;/a&gt; for this particular site because that’s what it’s been built on for the past few years and I have no desire to change it at the moment. And that means using &lt;a href="http://jinja.pocoo.org"&gt;Jinja2&lt;/a&gt; for templating. And Jinja2 has no notion of &lt;em&gt;components&lt;/em&gt;. Partials, yes—with all the implicit context you have to carry around in your head. It has a few different ways you can sort of hack your way to something sort of vaguely component-like using some of its &lt;a href="http://jinja.pocoo.org/docs/2.10/templates/#block-assignments"&gt;fancy features&lt;/a&gt;. But without any kind of “argument” or “return value”/yielding (&lt;em&gt;a la&lt;/em&gt; the ideas I discussed in &lt;a href="https://www.chriskrycho.com/2018/higher-order-components-in-emberjs.html" title="Higher-Order Components in Ember.js"&gt;this post&lt;/a&gt;). All of the solutions available in &lt;em&gt;any&lt;/em&gt; of these server-side frameworks for breaking up pages are &lt;em&gt;partial&lt;/em&gt;-style: which means they’re basically just dumb string includes!&lt;/p&gt;
&lt;p&gt;There’s nothing like the way I solve this problem in an Ember app every single day: &lt;em&gt;components&lt;/em&gt;. There’s no particular reason that the same component-based approach that has flourished on the client &lt;em&gt;can’t&lt;/em&gt; be done on the client side. It just… hasn’t, mostly. Which is kind of weird.&lt;/p&gt;
&lt;p&gt;Until this week, projects like &lt;a href="https://github.com/gatsbyjs/gatsby"&gt;Gatsby&lt;/a&gt; in the React world made no sense to me at all. It seemed like using a sledgehammer to kill a spider. But after this week, I’m suddenly &lt;em&gt;very&lt;/em&gt; interested in it—and I might in fact experiment with some server-side component-driven approaches to this at some point in the future—because a couple of days mucking with Jinja2 has me desperately wishing for a good old Ember or React component.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;As an aside: people talk about client-side development being overly complicated. I know some of what they mean, but the truth is that my experience hacking on this over the last week has actually served to remind me of just how &lt;em&gt;great&lt;/em&gt; the tooling is in this world.&lt;/p&gt;
&lt;p&gt;It’s true that there’s more complexity in many ways to building things with Ember or React or whatever other &lt;abbr&gt;JS&lt;/abbr&gt;-powered client-side framework than with plain-old &lt;abbr&gt;HTML&lt;/abbr&gt;. It’s more complex even than with something like Jinja2 or Liquid or whatever other server-side templating language you use. There’s good reason for that complexity, though: it comes with &lt;em&gt;more power&lt;/em&gt; and &lt;em&gt;more expressiveness&lt;/em&gt;. And the thing many critiquing the front-end seem to miss is that once you are used to having that power and expressiveness, it’s &lt;em&gt;really&lt;/em&gt; painful to go back to not having it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 07 Jun 2018 16:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-06-07:/2018/client-side-ideas-for-server-side-apps.html</guid><category>emberjs</category><category>javascript</category><category>web design</category></item><item><title>#EmberJS2018, Part 4</title><link>http://www.chriskrycho.com/2018/emberjs2018-part-4.html</link><description>&lt;p&gt;Following &lt;a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html"&gt;the example&lt;/a&gt; of the Rust community, the &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; team has &lt;a href="https://emberjs.com/blog/2018/05/02/ember-2018-roadmap-call-for-posts.html" title="Ember&amp;#39;s 2018 Roadmap: A Call for Blog Posts"&gt;called for blog posts&lt;/a&gt; as the first step in setting the 2018 roadmap (which will formally happen through the normal &lt;a href="https://github.com/emberjs/rfcs"&gt;&lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process&lt;/a&gt;). This is my contribution.&lt;/p&gt;
&lt;p&gt;There are three major themes I think should characterize the Ember.js community and project for the rest of 2018:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-1.html"&gt;&lt;strong&gt;Finishing What We’ve Started&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-2.html"&gt;&lt;strong&gt;Doubling Down on Documentation&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-3.html"&gt;&lt;strong&gt;Defaulting to Public for Discussions&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embracing the Ecosystem&lt;/strong&gt; (this post)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Over the last few weeks, I’ve talked about a few big ideas that I think the Ember.js community should go after in 2018 which will help the framework excel over the next few years. This last one (like Part 3 before it) is more a &lt;em&gt;culture shift&lt;/em&gt; than a matter of &lt;em&gt;things to build&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We need to shift from a posture of defensiveness about Ember.js to one of embracing the ecosystem, and embracing our role in the ecosystem.&lt;/p&gt;
&lt;p&gt;It’s easy to end up in an us-vs.-them mentality when looking at different libraries and frameworks. It’s doubly easy to go there when you often hear “Isn’t Ember dead?” or variations on that theme. We should avoid that way of thinking anyway. And there are three big pieces to this: &lt;em&gt;contributing outwards&lt;/em&gt;, &lt;em&gt;smoothing the paths into Ember&lt;/em&gt; from other ecosystems, and &lt;em&gt;embracing the rest of the ecosystem&lt;/em&gt;.&lt;/p&gt;
&lt;section id="contributing-outwards" class="level3"&gt;
&lt;h3&gt;Contributing outwards&lt;/h3&gt;
&lt;p&gt;There is genuinely great stuff happening all over the place in the front-end, and many of the things we love about working with Ember today have come directly out of e.g. React—hello, “data-down-actions-up”! The same is true in reverse: Ember has contributed many important ideas to the broader front-end ecosystem, from its early emphasis on rigorously linking URLs and application state to helping pioneer and popularize the use of good command line tooling, to more recent emphasis on &lt;em&gt;compilation&lt;/em&gt; as a way of solving certain classes of problems.&lt;/p&gt;
&lt;p&gt;So as we build all of these things, one of the best things to do—and, I believe, one of the ways we help Ember grow!—is think about how our work can benefit the larger ecosystem. When you build a library, you should consider whether there are parts of it that &lt;em&gt;don’t&lt;/em&gt; have to be Ember specific. For example, a colleague and I recently built out the foundation of a solution for well-rationalized form-handling.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; We build it in two pieces, though: a core library in TypeScript that will work as well in Vue or React as in Ember, and an Ember component library that consumes that core functionality.&lt;/p&gt;
&lt;p&gt;The more we can take that tack in &lt;em&gt;general&lt;/em&gt;, the better. It’s the first piece of making the gap between people’s experience in other parts of the front-end ecosystem and the Ember part smaller. Ember will seem much more interesting if people find themselves &lt;em&gt;often&lt;/em&gt; getting value out of things we’ve built.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="smoothing-the-paths-in" class="level3"&gt;
&lt;h3&gt;Smoothing the paths in&lt;/h3&gt;
&lt;p&gt;The flip side of this is figuring out ways to make it easier for people coming &lt;em&gt;into&lt;/em&gt; Ember.js to map patterns from their existing experience onto the framework’s tools and patterns. The simple reality is that there are far, far more developers familiar with React, Angular, and Vue than with modern Ember.js. Ember genuinely has a lot to offer there, but we need to make it easier for people to see that value and to recognize how it’s a lot like the good parts of what they already know!&lt;/p&gt;
&lt;p&gt;This is primarily a communications effort; it means changes to the docs and to the homepage, but also to what we do in blog posts and tutorials and talks as a community!&lt;/p&gt;
&lt;p&gt;At the highest level, I cannot recommend strongly enough the model suggested by Chris Garrett in &lt;a href="https://medium.com/@pzuraq/emberjs-2018-ember-as-a-component-service-framework-2e49492734f1"&gt;his #EmberJS2018 post&lt;/a&gt;: treat Ember.js (both in the docs and also in our presentations and communications about it) as a &lt;em&gt;component-service&lt;/em&gt; framework. This not only maps more easily to patterns people know from other communities, it has the really important effect of demystifying a lot of the “magic” that seems perplexing in the framework, especially around Ember Data—which is, after all, just a service you can inject!&lt;/p&gt;
&lt;p&gt;When we write blog posts, we can accomplish a lot of this simply by being aware of the rest of the ecosystem and making analogies there. You can see an example of how I’ve started trying to do this in my recent blog post on &lt;a href="http://www.chriskrycho.com/2018/higher-order-components-in-emberjs.html"&gt;higher-order components in Ember.js&lt;/a&gt;. It was just one little line:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In React, the [higher-order components] pattern as a whole is often known as the &lt;code&gt;renderProps&lt;/code&gt; pattern, for the way you most often accomplish it. It’s all the same idea, though!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That’s not a lot of extra work, but it means that if someone searches for “renderProps Ember.js” there now exists a blog post which will help someone map there existing knowledge over! I wasn’t writing a “how to do React renderProps in Ember” post—but I still smoothed the path in just a little bit. We should be doing that everywhere we can. It’s usually not a lot of effort to make those kinds of moves in talks or blog posts, but the yield is high: Ember stops being some super weird foreign entity and starts looking like a variation on a theme.&lt;/p&gt;
&lt;p&gt;There is also a much larger effort we &lt;em&gt;do&lt;/em&gt; need to undertake to make that story clearer on the home page and in the documentation—an effort that I know is already very much in consideration from chatting with the really amazing crew in &lt;code&gt;#-team-learning&lt;/code&gt; on Slack. In the &lt;strong&gt;how you can help&lt;/strong&gt; bucket: seriously please go into that channel and start chipping away at small tasks! There’s (&lt;a href="https://m.youtube.com/watch?v=Abu2BNixXak" title="“Becoming a Contributor”, my Rust Belt Rust 2017 talk"&gt;always!&lt;/a&gt;) way more work to be done than hands to do it.&lt;/p&gt;
&lt;p&gt;I think this also means prioritizing technical work that eases this. The sooner we can land the Glimmer component model, the better. The sooner we can hash out a more cogent story on routes and controllers and components, the better. The sooner we can make “npm-install-your-way-to-Ember” an actually viable strategy, the better. Because each of those things makes Ember dramatically more accessible to people working in other ecosystems today; each lowers the barrier to entry in some substantial way; and the combination of them all makes it far more viable for someone to &lt;em&gt;try&lt;/em&gt; Ember in an existing application.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="embracing-the-rest-of-the-ecosystem" class="level3"&gt;
&lt;h3&gt;Embracing the rest of the ecosystem&lt;/h3&gt;
&lt;p&gt;The final piece of this is actively embracing the best parts of the rest of the ecosystem.&lt;/p&gt;
&lt;p&gt;We as a community need to avoid defensiveness and recognize that there’s a &lt;em&gt;lot&lt;/em&gt; of good in the rest of the front-end space. I understand how it can be easy to feel defensive. Being dismissed, having people be surprised that the project even still exists, etc. gets really old after a while. But however reasonable that defensiveness is, it’s ultimately counterproductive. It makes us hold onto things we don’t need to hold onto, and it makes us ignore things that might benefit us, and as a result it can make us &lt;em&gt;needlessly weird&lt;/em&gt; technically.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Needless weirdness&lt;/em&gt; is an important idea I’d love for us to keep in mind. Any time you’re willing to move more slowly, to let the “new shiny” bake for a while to see whether it’s genuinely worth investing in, you’re going to seem weird. Likewise when you strongly embrace stability, in a broader ecosystem which hasn’t. Likewise when you value convention over configuration, in a broader ecosystem which hasn’t. But it’s important to be able to distinguish between &lt;em&gt;needful&lt;/em&gt; and &lt;em&gt;needless&lt;/em&gt; weirdness.&lt;/p&gt;
&lt;p&gt;We should have regular conversations as a community—through &lt;abbr title="request for comments"&gt;RFC&lt;/abbr&gt;s, through forum threads, through blog post arguments, etc.—about what’s &lt;em&gt;needful&lt;/em&gt; weirdness, and what has become &lt;em&gt;needless&lt;/em&gt; weirdness. (Because which weird things are needful change over time!) We should gleefully embrace the needful weirdness. But we should equally gleefully drop the needless weirdness.&lt;/p&gt;
&lt;p&gt;What makes Ember special is, by and large, &lt;em&gt;not&lt;/em&gt; the specific technical implementations we’ve landed on.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; What makes Ember valuable is having a coherent top-to-bottom story and a rich community with a commitment to aggressively seeking out shared solutions, and an even deeper commitment to providing good migration paths forward when we change things.&lt;/p&gt;
&lt;p&gt;But here’s the thing: those values are increasingly (if slowly) being embraced &lt;em&gt;outside&lt;/em&gt; the Ember ecosystem as well. Ember can contribute and even lead in many ways here—but only if we start actively embracing the good of other parts of the front-end ecosystem.&lt;/p&gt;
&lt;p&gt;For example: I’ve heard more times than I can count over the last few years that our use of Broccoli.js is really important for Ember, and the reality is… that isn’t true. We could have built on top of just about &lt;em&gt;any&lt;/em&gt; solution, and it would have been &lt;em&gt;fine&lt;/em&gt;. Broccoli &lt;em&gt;does&lt;/em&gt; have some advantages; it also has some real disadvantages (one of which is that we’re the only ones using it!), and we should forthrightly acknowledge those. By the same token, if Webpack is working well for many people, let’s neither trash it in discussion nor ignore it in implementation. Instead, let’s make it easy for people to integrate Webpack into the Ember world.&lt;/p&gt;
&lt;p&gt;That doesn’t oblige us to chuck out our existing build tooling! It just means making our own build pipelines robust enough to interoperate well with other packaging systems. And that’s precisely what the Ember &lt;abbr&gt;CLI&lt;/abbr&gt; team has been doing! This needs to be our pattern across the board going forward.&lt;/p&gt;
&lt;p&gt;It’s truly well and good to have made a call a few years ago, and to be going out of our way to mitigate the costs of churn. At the same time, we need to communicate—to a degree that probably feels like &lt;em&gt;over&lt;/em&gt;communicating to the people who already understand all these decisions!—so that both the original rationales and the current status are accessible to all the people who &lt;em&gt;weren’t&lt;/em&gt; there when the decisions were made.&lt;/p&gt;
&lt;p&gt;Insofar as it’s true that Broccoli and Webpack solve different problems, &lt;em&gt;explaining&lt;/em&gt; how Broccoli and Webpack actually solve meaningfully different problems —or at least, &lt;em&gt;excel&lt;/em&gt; at solving different problems—is one of the most important things we can do as well. Props to Chris Thoburn (&lt;a href="https://twitter.com/runspired"&gt;@runspired&lt;/a&gt;) for doing this in a few different contexts recently, but we need a lot more of it—because it’s one example I think most people both inside and outside the Ember community have just kind of scratched their heads at for a long time (me included).&lt;/p&gt;
&lt;p&gt;Again: I take the Broccoli/Webpack example simply because it’s an obvious one. The broader point is that we need to find ways to embrace the shared solutions which emerge not only in the Ember community but in the front-end ecosystem as a whole, even as we also do the hard work to make our own shared solutions useful to the rest of the front-end ecosystem. That two-way exchange will benefit us, and smooth the paths in for newcomers, and benefit the rest of the ecosystem, too—and that’s a huge win. Because in a very real sense, we front-end developers are all in this together.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Keep your eyes open; you’ll see a blog post announcing that along with a full set of documentation for it sometime in the next month or so!&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;To be clear: many, though certainly not all, of those specific implementations I like, but that’s beside the point.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 29 May 2018 07:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-29:/2018/emberjs2018-part-4.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category><category>emberjs2018</category></item><item><title>Higher-Order Components in Ember.js</title><link>http://www.chriskrycho.com/2018/higher-order-components-in-emberjs.html</link><description>&lt;p&gt;One of the most powerful patterns in programming is the idea of &lt;em&gt;higher-order functions&lt;/em&gt;: functions which can take other functions as arguments or return them as their return values. If you’ve spent much time at all working in JavaScript, you’ve certainly encountered these—whether you’re using &lt;code&gt;Array.map&lt;/code&gt; to transform the values in an array, or passing a function as an argument to an event handler.&lt;/p&gt;
&lt;p&gt;The same pattern is incredibly useful in building components, and most modern front-end frameworks support it—including Ember.js! (In React, the pattern as a whole is often known as the &lt;code&gt;renderProps&lt;/code&gt; pattern, for the way you most often accomplish it. It’s all the same idea, though!)&lt;/p&gt;
&lt;p&gt;In this little post, I’ll show you how to build a small “higher-order component” in Ember.js, hopefully demystifying that term a little bit a long the way. (If you just want to see how the pieces fit together, you can see the finished app &lt;a href="https://github.com/chriskrycho/ember-hoc-example"&gt;in this repo&lt;/a&gt;.)&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;I’m going to be using classes and decorators throughout. Both are very much ready-to-go in Ember, and I commend them to you! I’m also going to be using some of the new &lt;a href="https://emberjs.com/blog/2018/04/13/ember-3-1-released.html#toc_introducing-optional-features-3-of-4"&gt;optional features&lt;/a&gt; available in Ember 3.1+ to use template-only components!&lt;/p&gt;
&lt;p&gt;Note that one of the most important consequences of this is that arguments have to be referenced as &lt;code&gt;@theArgumentName&lt;/code&gt; rather than just &lt;code&gt;theArgumentName&lt;/code&gt; in templates. The reason is precisely that there is no backing JavaScript component. In old-school Ember.js components, &lt;code&gt;{{theArgumentName}}&lt;/code&gt; is implicitly turned into &lt;code&gt;{{this.argumentName}}&lt;/code&gt;, which does a lookup on the backing component. In Glimmer-style components—of which these are the first part—arguments live on a designated &lt;code&gt;args&lt;/code&gt; property and are accessible in templates via &lt;code&gt;@theArgumentName&lt;/code&gt; instead.&lt;/p&gt;
&lt;/aside&gt;
&lt;section id="higher-order-components-what-are-they" class="level2"&gt;
&lt;h2&gt;Higher-Order Components, What Are They&lt;/h2&gt;
&lt;p&gt;Just like with a “higher-order function,” all we mean when we talk about a “higher-order component” is a component which takes other components as arguments, returns other components itself (in Ember’s case via &lt;code&gt;yield&lt;/code&gt; in a template), or both.&lt;/p&gt;
&lt;p&gt;The thing we’re actually going to build here is a “modal” which accepts an optional button as an arguments, and which yields out a component for dividing the modal into sections visually so you can pass your own content in and have it look just right. This is closely based on a component my colleagues and I at Olo built recently, just with some of our specific details stripped away to get at the actually important bits. Here’s what it looks like in practice:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/hoc-rendered.png" alt="a modal with sectioned text and a close button" /&gt;&lt;figcaption&gt;a modal with sectioned text and a close button&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The goal for the button arguments is to let the modal be able to render the button the caller passes in, while not being concerned with the &lt;em&gt;functionality&lt;/em&gt; of the button. Otherwise, we’d have to tie the “API” of the modal to the details of button behavior, bind more actions into it, etc.&lt;/p&gt;
&lt;p&gt;The goal for the yielded sectioning component is for whatever is rendering the modal itself to be able to pass content in and get it chunked up however the modal decides is appropriate—the modal can display its own styles, etc.—without having to worry about the details of applying classes or sectioning up the content itself.&lt;/p&gt;
&lt;p&gt;In short, we want to &lt;em&gt;separate our concerns&lt;/em&gt;: the modal knows how to lay out its contents and where to put buttons, but it doesn’t want to have to know &lt;em&gt;anything&lt;/em&gt; about what the buttons do. The most complicated interaction in the world could be going on, and the modal won’t have to care. Likewise, things &lt;em&gt;using&lt;/em&gt; the modal can pass content and buttons into it, and let the modal manage its own layout and so on without having to be concerned with the details of that. So what does that look like in practice?&lt;/p&gt;
&lt;p&gt;The approach I use here builds on the “contextual components” pattern in Ember.js. The main new idea is that the &lt;em&gt;context&lt;/em&gt; includes components!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="implementing-it" class="level2"&gt;
&lt;h2&gt;Implementing It&lt;/h2&gt;
&lt;p&gt;We have three components here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a button&lt;/li&gt;
&lt;li&gt;a modal&lt;/li&gt;
&lt;li&gt;a modal section&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since Ember.js still (for now!) requires component names to be at least two words separated by a dash, we’ll just call these &lt;code&gt;x-button&lt;/code&gt;, &lt;code&gt;x-modal&lt;/code&gt;, and &lt;code&gt;x-modal-section&lt;/code&gt;.&lt;/p&gt;
&lt;section id="x-button" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;x-button&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The button component, we’ll keep pretty simple: it’s just a button element with a given label and an action bound to it:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;&amp;lt;button class={{@buttonClass}} type=&amp;#39;button&amp;#39; {{action @onClick}}&amp;gt;
  {{@label}}
&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="x-modal" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;x-modal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;x-modal&lt;/code&gt; has the meat of the implementation.&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;&amp;lt;div class=&amp;#39;modal-backdrop&amp;#39;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;#39;modal&amp;#39;&amp;gt;
  &amp;lt;div class=&amp;#39;modal-content&amp;#39;&amp;gt;
    {{yield (hash section=(component &amp;#39;x-modal-section&amp;#39;))}}
  &amp;lt;/div&amp;gt;

  {{#if @button}}
    {{component @button buttonClass=&amp;#39;modal-button&amp;#39;}}
  {{/if}}
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The two things two notice here are the &lt;code&gt;yield&lt;/code&gt; and the &lt;code&gt;component&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;yield&lt;/code&gt; statement yields a &lt;a href="https://www.emberjs.com/api/ember/3.1/classes/Ember.Templates.helpers"&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; with one property: &lt;code&gt;section&lt;/code&gt;. Yielding a hash is a convenient pattern in general. Here, we’re doing it to make the &lt;abbr&gt;API&lt;/abbr&gt; nicer for users of this component. It means that if we name the yielded value &lt;code&gt;|modal|&lt;/code&gt; when we invoke this, we’ll be able to write &lt;code&gt;modal.section&lt;/code&gt; to name this particular yielded item. (You’ll see exactly this below.)&lt;/p&gt;
&lt;p&gt;We use the &lt;code&gt;component&lt;/code&gt; helper twice: once as the value of the &lt;code&gt;section&lt;/code&gt; key in the yielded hash, and once for the &lt;code&gt;button&lt;/code&gt; below. In both cases, the helper does the same thing: invokes a component! While the most common way to render a component is with its name, inline—like &lt;code&gt;{{x-modal}}&lt;/code&gt;—you can always render it with the &lt;code&gt;component&lt;/code&gt; helper and the name as a string: &lt;code&gt;{{component 'x-modal'}}&lt;/code&gt;. This lets you render different components dynamically!&lt;/p&gt;
&lt;p&gt;Let’s remember our initial analogy: the same way you can pass different functions to a higher-order function like &lt;code&gt;Array.prototype.map&lt;/code&gt;, you can pass different components to a higher-order component like our &lt;code&gt;x-modal&lt;/code&gt; here. And just like you can &lt;em&gt;return&lt;/em&gt; a function from a higher-order function, we can &lt;em&gt;yield&lt;/em&gt; a component from a higher-order component. Just like higher-order functions, the function passed in or returned just has to have the right shape.&lt;/p&gt;
&lt;p&gt;For example, the argument to &lt;code&gt;Array.prototype.map&lt;/code&gt; needs to be a function which performs an operation on a single item in the array (and maybe also the index) and hands back the result of that operation. Similarly, the &lt;code&gt;button&lt;/code&gt; argument to our &lt;code&gt;x-modal&lt;/code&gt; needs to accept a &lt;code&gt;buttonClass&lt;/code&gt; component so that the modal can apply some styling to it. The same thing holds for the component being yielded back out: it has an &lt;abbr&gt;API&lt;/abbr&gt; you should use to invoke it, just like any other.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All of this gets at something really important: you can think of components as just being &lt;em&gt;pure functions&lt;/em&gt;: they take some input in the form of arguments, and give you the output of what they &lt;em&gt;render&lt;/em&gt; and what they &lt;em&gt;yield&lt;/em&gt;—and they always give you the same rendered &lt;abbr&gt;HTML&lt;/abbr&gt; and the same yielded values for the same inputs. They’re just functions!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="x-modal-section" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;x-modal-section&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;x-modal-section&lt;/code&gt; component is the simplest of all of these: it has no behavior, just some styling to actually chunk up the content:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;&amp;lt;div class=&amp;#39;modal-section&amp;#39;&amp;gt;
  {{yield}}
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="application-controller-and-template" class="level3"&gt;
&lt;h3&gt;Application controller and template&lt;/h3&gt;
&lt;p&gt;Now, let’s use in the context of the application template, where we can see how the pieces all fit together. First, let’s see the application controller backing it—nothing unusual here, just a simple toggle to show or hide the modal.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Controller from &amp;quot;@ember/controller&amp;quot;;
import { action } from &amp;quot;@ember-decorators/object&amp;quot;;

export default class Application extends Controller {
  constructor() {
    super(...arguments);
    this.showModal = false;
  }

  @action
  showIt() {
    this.set(&amp;quot;showModal&amp;quot;, true);
  }

  @action
  hideIt() {
    this.set(&amp;quot;showModal&amp;quot;, false);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now for the interesting bit—the template where we invoke &lt;code&gt;x-modal&lt;/code&gt; and use its higher-order-component functionality:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;{{#if showModal}}
  {{#x-modal
      button=(component &amp;#39;x-button&amp;#39;
        label=&amp;#39;Close modal!&amp;#39;
        onClick=(action &amp;#39;hideIt&amp;#39;)
      )
      as |modal|
  }}
    {{#modal.section}}
      Here is some content!
    {{/modal.section}}

    {{#modal.section}}
      Here is some other content.
    {{/modal.section}}

    {{#modal.section}}
      &amp;lt;p&amp;gt;The content can have its own sections, as you&amp;#39;d expect!&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;Nothing crazy going on here. Just a normal template!&amp;lt;/p&amp;gt;
    {{/modal.section}}
  {{/x-modal}}
{{/if}}

&amp;lt;button class=&amp;#39;button&amp;#39; {{action &amp;#39;showIt&amp;#39;}}&amp;gt;Show modal&amp;lt;/button&amp;gt;

&amp;lt;!-- some other content on the page --&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We invoke the block form of &lt;code&gt;x-modal&lt;/code&gt; just like we would any block component, and we get back the thing it yields with &lt;code&gt;as |modal|&lt;/code&gt;. However, one of the arguments we pass to it is a component. But &lt;code&gt;modal&lt;/code&gt; is a &lt;code&gt;hash&lt;/code&gt; (an object!) with a property named &lt;code&gt;section&lt;/code&gt;, which is the &lt;code&gt;x-modal-section&lt;/code&gt; component.&lt;/p&gt;
&lt;p&gt;Again, you can think of this like calling a function with one function as an argument and getting another function back as its return value—that returned function being something we could call over and over again once we had it.&lt;/p&gt;
&lt;p&gt;Here, we “call the function”—invoke the &lt;code&gt;x-modal&lt;/code&gt; component—with &lt;code&gt;component 'x-button'&lt;/code&gt; as its argument, and the returned &lt;code&gt;modal.section&lt;/code&gt; is a component we can invoke like a normal component.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; We could even pass it into some &lt;em&gt;other&lt;/em&gt; component itself if we so desired.&lt;/p&gt;
&lt;p&gt;And that’s really all there is to it!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;“Higher-order components” aren’t necessarily something you need all the time, but they’re really convenient and very powerful when you &lt;em&gt;do&lt;/em&gt; need them. They’re also a lot less complicated than the name might seem! Components are just things you can pass around in the context of a component template—they’re the &lt;em&gt;functions&lt;/em&gt; of Handlebars.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Splitting things into components like this does increase complexity, and in particular it can increase the mental overhead of keeping track of how the pieces fit together. However, they also let us cleanly separate different pieces of functionality from each other. Doing it this way means that our modal can be concerned about &lt;em&gt;positioning&lt;/em&gt; a button without needing to expose an &lt;abbr&gt;API&lt;/abbr&gt; for all of the button’s own mechanics for handling clicks and performing whatever actions necessary. That makes our modal &lt;em&gt;and&lt;/em&gt; our button way more reusable across our application. The button can be used &lt;em&gt;wherever&lt;/em&gt; a button is useful, and the modal doesn’t need to know or care anything about it. Likewise, the button has no need to know anything about the context where it’s being used; from the button component’s perspective, it just gets wired up to some actions as usual. The same thing goes for the modal sections: they let us abstract over how the DOM is laid out, what classes are applied to it, and so on—they chunk up the modal, but the modal itself maintains responsibility for how that chunking up happens. And the caller doesn’t even &lt;em&gt;have&lt;/em&gt; to use that; it’s just a tool that’s available for that purpose.&lt;/p&gt;
&lt;p&gt;To sum it all up, I’ll just reiterate my earlier description: components are just like pure functions: the same inputs give you the same outputs—and, just like functions, those inputs and outputs can be other functions, that is, other components.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you want a good way to document the things a component &lt;code&gt;yield&lt;/code&gt;s, check out &lt;a href="https://ember-learn.github.io/ember-cli-addon-docs/latest/docs/api/components/docs-demo"&gt;ember-cli-addon-docs&lt;/a&gt;, which can read an &lt;code&gt;@yield&lt;/code&gt; JSDoc annotation.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;And it could just as well be a component; the top-level controller template is just where we put our main app functionality.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;We could also simplify this since we’re only returning one component, and if we had the full Glimmer component story, this could look &lt;em&gt;very&lt;/em&gt; nice:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;&amp;lt;Modal @button={{component &amp;#39;Button&amp;#39;}} as |Section|&amp;gt;
  &amp;lt;Section&amp;gt;
    Some content!
  &amp;lt;/Section&amp;gt;
  &amp;lt;Section&amp;gt;
    Some more content!
  &amp;lt;/Section&amp;gt;

  &amp;lt;Section&amp;gt;
    &amp;lt;p&amp;gt;The content can have its own sections, as you&amp;#39;d expect!&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;Nothing crazy going on here. Just a normal template!&amp;lt;/p&amp;gt;
  &amp;lt;/Section&amp;gt;
&amp;lt;/Modal&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;If you’re inclined to “well actually” me about &lt;em&gt;helpers&lt;/em&gt; being the real functions of Handlebars templates: in the Glimmer &lt;abbr&gt;VM&lt;/abbr&gt; world, helpers are just a kind of component.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 26 May 2018 14:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-26:/2018/higher-order-components-in-emberjs.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category></item><item><title>#EmberJS2018, Part 3</title><link>http://www.chriskrycho.com/2018/emberjs2018-part-3.html</link><description>&lt;p&gt;Following &lt;a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html"&gt;the example&lt;/a&gt; of the Rust community, the &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; team has &lt;a href="https://emberjs.com/blog/2018/05/02/ember-2018-roadmap-call-for-posts.html" title="Ember&amp;#39;s 2018 Roadmap: A Call for Blog Posts"&gt;called for blog posts&lt;/a&gt; as the first step in setting the 2018 roadmap (which will formally happen through the normal &lt;a href="https://github.com/emberjs/rfcs"&gt;&lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process&lt;/a&gt;). This is my contribution.&lt;/p&gt;
&lt;p&gt;There are three major themes I think should characterize the Ember.js community and project for the rest of 2018:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-1.html"&gt;&lt;strong&gt;Finishing What We’ve Started&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-2.html"&gt;&lt;strong&gt;Doubling Down on Documentation&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Defaulting to Public for Discussions&lt;/strong&gt; (this post)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-4.html"&gt;&lt;strong&gt;Embracing the Ecosystem&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;One of the small changes I think would substantially improve the Ember.js ecosystem is: &lt;strong&gt;defaulting to public for discussions&lt;/strong&gt; among the core team. Indeed: for any open-source project with community involvement like Ember.js has, that should be the default. Not the &lt;em&gt;only&lt;/em&gt; option, just the default option.&lt;/p&gt;
&lt;p&gt;There is plenty of value in having private channels for discussion in contexts like this. Sometimes you have to deal with something awkward or socially difficult. Sometimes you have already taken the community’s input and just have to come to a decision about what to do on something. Private channels are useful.&lt;/p&gt;
&lt;p&gt;But: they shouldn’t be the default. They should be what you turn to when you’re in one of those particular kinds of situations which require it. The default should be public discussion and interaction.&lt;/p&gt;
&lt;p&gt;Over the last year, the maintainer-ship (and therefore decision-making) of ember-cli-typescript and the surrounding TypeScript ecosystem has grown from being pretty much just me to being a small group of four of us: Derek Wickern, Dan Freeman, James Davis, and me. We have the “final say,” so to speak, on the things we’re doing with the addon and the typings and so on. (What that actually means in practice is mostly just we all try to shoulder the burden of staying on top of pull requests.) And we have a private channel for discussions as a “core team” for projects in the &lt;a href="https://github.com/typed-ember"&gt;typed-ember&lt;/a&gt; organization.&lt;/p&gt;
&lt;p&gt;But: it’s not the default. It’s what we turn to when we’re in one of those particular kinds of situations which require it. The default is public discussion and interaction.&lt;/p&gt;
&lt;p&gt;And this isn’t just an unspoken norm or something. As a team, we all explicitly agreed that we default to public. Pretty much the only times we chat in our private channel is if we’re figuring out how to diffuse an awkward situation kindly, or if we’re adding someone else to the team. Otherwise, we try to have all our discussions in the GitHub issues for the projects or the &lt;code&gt;#topic-typescript&lt;/code&gt; room in the Ember Community Slack.&lt;/p&gt;
&lt;p&gt;This has a few major effects, as I see it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;No one should feel left out or in the dark about what we’re up to. Even if we’re hashing out crazy-seeming ideas for how to move stuff forward, it’s all there for everyone to see. This includes neat things like Dan Freeman’s proof-of-concept on &lt;a href="https://twitter.com/__dfreeman/status/994410180661170177"&gt;type-checked templates&lt;/a&gt;, or our mad sprint (as a team!) to get some core improvements landed before I gave a workshop at EmberConf, or anything else we’re going after.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We’re obviously available for input on things as people have questions, because we’re interacting with &lt;em&gt;each other&lt;/em&gt; in those public forums. And if we’d like to start moving some of the oft-repeated questions over to the &lt;a href="https://discuss.emberjs.com"&gt;Ember Discourse&lt;/a&gt; or to &lt;a href="https://stackoverflow.com/questions/tagged/ember.js"&gt;Stack Overflow&lt;/a&gt;, it’s still really helpful for people who &lt;em&gt;are&lt;/em&gt; on the Slack to see that we’re there and available for help.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We get to see the regular pain points others run into. That often turns into issues, priorities, etc. for us as a group. The slowly growing issue &lt;a href="https://github.com/typed-ember/ember-cli-typescript/issues/170"&gt;tracking things we need to document&lt;/a&gt; is essentially a direct product of that constant cycle of interaction.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We get the benefit of input from others! If we’ve missed something, or simply failed to think of something, others in the community often haven’t. One prime example of this: the “registry” strategy we use for making things like Ember Data store, adapter, etc. lookups work came out of conversations with a community member (&lt;a href="https://github.com/maerten"&gt;Maarten Veenstra&lt;/a&gt;) which happened many months before we were in a spot where we could land that kind of thing—and initially I was pretty skeptical of it, but they were totally right, and it’s now core to how Ember’s typings work!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I recommend—very strongly—that the Ember.js core team adopt the same strategy. Teams &lt;em&gt;do&lt;/em&gt; need private channels sometimes. But they shouldn’t be the default. They should be for those particular circumstances which &lt;em&gt;require&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;The biggest things I think could come out of this are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A greater confidence from within the Ember.js community about what the core team is up to and where we’re going. Technical leadership seems to me to be about 10% technical brilliance and 90% clear communication. We have loads of technical brilliance; we need more communication!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;More confidence in the trajectory of Ember.js from &lt;em&gt;outside&lt;/em&gt; its existing community. Seeing that there is active leadership is essential for people to have confidence that choosing Ember.js is a good choice both today and for the medium-to-long-term.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And we need both of those—a lot—for Ember.js to continue to grow and thrive in the years ahead!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 23 May 2018 07:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-23:/2018/emberjs2018-part-3.html</guid><category>emberjs</category><category>emberjs2018</category><category>javascript</category><category>leadership</category></item><item><title>#EmberJS2018, Part 2</title><link>http://www.chriskrycho.com/2018/emberjs2018-part-2.html</link><description>&lt;p&gt;Following &lt;a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html"&gt;the example&lt;/a&gt; of the Rust community, the &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; team has &lt;a href="https://emberjs.com/blog/2018/05/02/ember-2018-roadmap-call-for-posts.html" title="Ember&amp;#39;s 2018 Roadmap: A Call for Blog Posts"&gt;called for blog posts&lt;/a&gt; as the first step in setting the 2018 roadmap (which will formally happen through the normal &lt;a href="https://github.com/emberjs/rfcs"&gt;&lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process&lt;/a&gt;). This is my contribution.&lt;/p&gt;
&lt;p&gt;There are three major themes I think should characterize the Ember.js community and project for the rest of 2018:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-1.html"&gt;&lt;strong&gt;Finishing What We’ve Started&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doubling Down on Documentation&lt;/strong&gt; (this post)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-3.html"&gt;&lt;strong&gt;Defaulting to Public for Discussions&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-4.html"&gt;&lt;strong&gt;Embracing the Ecosystem&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;section id="part-2-double-down-on-docs" class="level2"&gt;
&lt;h2&gt;Part 2: Double down on docs&lt;/h2&gt;
&lt;p&gt;The best project in the world is useless without documentation. As such, my &lt;em&gt;second&lt;/em&gt; major goal for Ember.js this year is to see our documentation story improve dramatically across a number of fronts. This is not just the kind of thing that’s important in principle or because we care about doing the right thing, though those alone &lt;em&gt;are&lt;/em&gt; sufficient motivation. It’s &lt;em&gt;also&lt;/em&gt; absolutely necessary for Ember to grow and thrive in the ways it deserves to in the years ahead.&lt;/p&gt;
&lt;p&gt;To be clear: Ember’s story around documentation is &lt;em&gt;pretty good&lt;/em&gt; and it continues to improve all the time. A few years ago, the base documentation was a mess and even figuring out where to start was hard. Today, Ember.js itself has great guides along with versioned-and-searchable &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; documentation. The gaps now are in the &lt;em&gt;surrounding ecosystem&lt;/em&gt; and in the &lt;em&gt;framework internals&lt;/em&gt;. That’s huge progress! But if we want Ember to excel, we need to go after both of these with gusto.&lt;/p&gt;
&lt;section id="the-surrounding-ecosystem" class="level3"&gt;
&lt;h3&gt;The surrounding ecosystem&lt;/h3&gt;
&lt;p&gt;Ember Data, Ember Engines, and perhaps most important Ember &lt;abbr title="command line interface"&gt;CLI&lt;/abbr&gt; and its core dependency Broccoli all &lt;em&gt;desperately&lt;/em&gt; need documentation work just at the “how do you even use these things level.”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Broccoli.js&lt;/strong&gt; in particular is core to pretty much everything in Ember’s ecosystem, and its docs today are in roughly the state Webpack’s were back in its sad 1.0 days. We should take a page out of our own history (and Webpack’s for that matter!) and make it easy for people to use Broccoli in whatever ways their apps need, and that mostly means documenting it!&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Oli Griffith’s recent &lt;a href="http://www.oligriffiths.com/broccolijs/"&gt;blog post series&lt;/a&gt; is an incredibly valuable first step in that direction. But we need really solid documentation for &lt;a href="http://broccolijs.com"&gt;Broccoli itself&lt;/a&gt;, and also for the equally important &lt;a href="https://www.npmjs.com/search?q=keywords:broccoli-plugin"&gt;plugin ecosystem&lt;/a&gt; which is the primary way people interact with it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;The docs for &lt;strong&gt;Ember &lt;abbr&gt;CLI&lt;/abbr&gt;&lt;/strong&gt; itself are &lt;em&gt;decent&lt;/em&gt;, but they’re quite out of date and are about to be a lot more so because of the previously-mentioned packager bits. We need accurate and up-to-date guides and &lt;abbr&gt;API&lt;/abbr&gt; docs for the &lt;abbr&gt;CLI&lt;/abbr&gt;, and we also need clarity about the seams between Ember &lt;abbr&gt;CLI&lt;/abbr&gt; and Broccoli—something I’ve only begun to become clear on after a year of hacking on &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;! This includes a number of kinds of documentation:
&lt;ul&gt;
&lt;li&gt;up-to-date guides&lt;/li&gt;
&lt;li&gt;complete &lt;abbr&gt;API&lt;/abbr&gt; documentation&lt;/li&gt;
&lt;li&gt;a “cookbook” of common patterns to use&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;strong&gt;Ember Data&lt;/strong&gt; docs need to be split into two parts: one for &lt;em&gt;users&lt;/em&gt; of Ember Data, and one for people building Ember Data integrations and addons. Right now, all the docs are targeted squarely at implementors of Ember Data addons. This means that one of the pieces of the Ember ecosystem that’s in widest use (and is &lt;em&gt;most&lt;/em&gt; distinct from the rest of the JS ecosystem!) is really, really hard to learn. This is the part of the framework I still struggle the most with, despite having worked full time on an Ember app for over two years now.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ember Engines&lt;/strong&gt; are really need for manually breaking up your app into discrete sections which can be worked on independently and even loaded dynamically as you need them, and they provide a different level of abstraction than route-splitting and other similar approaches. (Not necessarily better or worse, but different.) Unfortunately, most of the documentation hasn’t been touched in over a year. That means if you &lt;em&gt;want&lt;/em&gt; to use Ember Engines, almost all of the information is in an example here and a Slack conversation there. We need to turn that sort of “tribal knowledge” into actual docs!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To be clear, the Ember docs team is doing great work and is already going after a lot of these areas; but there’s an enormous amount of ground to cover. They could use your help! Because if Ember is going to flourish in the year(s) ahead, we need good docs. And users are the people best-placed in all the world to help write docs.&lt;/p&gt;
&lt;p&gt;So &lt;strong&gt;how you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Open issues about things you don’t understand.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you see an error in the documentation, open a pull request to fix it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Volunteer to proofread or edit as new materials are produced. Yes, seriously: proofreading is &lt;em&gt;incredibly&lt;/em&gt; valuable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Volunteer to write documentation of things you &lt;em&gt;do&lt;/em&gt; understand where you see gaps.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="framework-internals" class="level3"&gt;
&lt;h3&gt;Framework internals&lt;/h3&gt;
&lt;p&gt;Every time I have started poking into Ember’s own codebase—to ship a fix for some small bug, or simply to understand the behavior of my own application—I have found myself stymied by a really serious issue. &lt;em&gt;Almost nothing is documented.&lt;/em&gt; This is true of Ember proper, of Ember Data, of Ember &lt;abbr&gt;CLI&lt;/abbr&gt;, of Broccoli’s internals… Everything I named above as being in need of &lt;em&gt;user&lt;/em&gt;-facing documentation also desperately needs &lt;em&gt;developer&lt;/em&gt;-facing documentation.&lt;/p&gt;
&lt;p&gt;A lot of this happens naturally in projects developed organically by small teams. I’ve seen it in my own current job: the &lt;em&gt;vast&lt;/em&gt; majority of our codebase is without any formal documentation, because it didn’t &lt;em&gt;require&lt;/em&gt; it when we were a much smaller organization working on a much smaller codebase. But no project—whether private or open-source—can grow or thrive unless it becomes possible for new contributors to come in, understand the system as it exists, and start making changes effectively. “Tribal knowledge” is &lt;em&gt;not&lt;/em&gt; a bad thing in some contexts, but it does not scale.&lt;/p&gt;
&lt;p&gt;The Ember.js ecosystem needs developer documentation of several sorts, then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Architecture documents:&lt;/strong&gt; what are the pieces of the framework or library in question, and how do they fit together? This is often the hardest piece to maintain, simply because it changes organically over time, and unlike the next couple examples it doesn’t have an inherent attachment to the code. However, it’s also the piece that’s absolutely the most important, because it’s what gives anyone trying to dive in and contribute the orientation they need to be effective.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;“Why” comments:&lt;/strong&gt; The internals of the core libraries very often have good reasons for doing things even in apparently odd ways. However, the reasons for those are &lt;em&gt;very&lt;/em&gt; rarely written down anywhere. This is &lt;em&gt;precisely&lt;/em&gt; what comments are for! If some implementation actually &lt;em&gt;can’t&lt;/em&gt; be simplified in the way it looks like it can, write it down right there in a comment! This will save both you and other developers lots of wasted time with false starts and useless pull requests and so on.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Documentation of private &lt;abbr&gt;API&lt;/abbr&gt;:&lt;/strong&gt; Much of the public-facing &lt;abbr&gt;API&lt;/abbr&gt; for Ember is fairly clear (modulo caveats around completeness and accuracy). However, most internal &lt;abbr&gt;API&lt;/abbr&gt; is essentially entirely undocumented. This makes it &lt;em&gt;extremely&lt;/em&gt; difficult for someone to know how to use the internal &lt;abbr&gt;API&lt;/abbr&gt;s when working on internal code!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these things came home to me pretty sharply as I started poking at the Glimmer VM project to see where and how I can pull together my knowledge of both TypeScript and Rust to drive some of those efforts forward. The core team folks I’ve interacted with have all been &lt;em&gt;extremely&lt;/em&gt; helpful—and that’s always been true all along the way!—but they’re also busy, and taking the time to write down something &lt;em&gt;once&lt;/em&gt; ends up being a major “force multiplier”. You can explain the same thing to multiple different people via multiple different conversations, or you can write it down &lt;em&gt;once&lt;/em&gt; and make it a resource that anyone can use to start working effectively in the system!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you’re a current Ember developer in any part of the ecosystem: &lt;em&gt;start writing down what you know.&lt;/em&gt; If a question comes up more than once, put it in a document somewhere. If nothing else, then you can link to it instead of typing it up one more time in Slack!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re just getting started on developing core Ember functionality: &lt;em&gt;write down what you learn.&lt;/em&gt; If you’re working through some section of the codebase, don’t understand it, and then come to understand it by way of asking questions, add documentation for that! You’ll help the next person coming along behind you!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;In short: please write more things down! We need user-facing and developer-facing documentation; they need to be different and distinct from each other; and we need the whole range in both. That’s an &lt;em&gt;enormous&lt;/em&gt; amount of work, and it’s very different from programming (and therefore harder for many of us).&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But it’s also work that will pay equally enormous dividends in enabling the Ember community to grow in both the &lt;em&gt;number&lt;/em&gt; and the &lt;em&gt;effectiveness&lt;/em&gt; of its contributors—and that’s something we very much need!&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Most of Webpack’s bad reputation is long-since undeserved: it &lt;em&gt;was&lt;/em&gt; poorly documented… a few years ago. So was Ember!&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;I’ll let you draw your own conclusions about my own relationship to writing given the absurd number of words I put out on this site.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 18 May 2018 22:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-18:/2018/emberjs2018-part-2.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category><category>emberjs2018</category></item><item><title>#EmberJS2018, Part 1</title><link>http://www.chriskrycho.com/2018/emberjs2018-part-1.html</link><description>&lt;p&gt;Following &lt;a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html"&gt;the example&lt;/a&gt; of the Rust community, the &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; team has &lt;a href="https://emberjs.com/blog/2018/05/02/ember-2018-roadmap-call-for-posts.html" title="Ember&amp;#39;s 2018 Roadmap: A Call for Blog Posts"&gt;called for blog posts&lt;/a&gt; as the first step in setting the 2018 roadmap (which will formally happen through the normal &lt;a href="https://github.com/emberjs/rfcs"&gt;&lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process&lt;/a&gt;). This is my contribution.&lt;/p&gt;
&lt;p&gt;There are three major themes I think should characterize the Ember.js community and project for the rest of 2018:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;strong&gt;Finishing What We’ve Started&lt;/strong&gt; (this post)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-2.html"&gt;&lt;strong&gt;Doubling Down on Docs&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/emberjs2018-part-3.html"&gt;&lt;strong&gt;Defaulting to Public for Discussions&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2018/emberjs2018-part-4.html"&gt;&lt;strong&gt;Embracing the Ecosystem&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;section id="finishing-what-weve-started" class="level2"&gt;
&lt;h2&gt;Finishing What We’ve Started&lt;/h2&gt;
&lt;p&gt;What I want, more than any new feature anyone could come up with, is for this to be the year Ember.js commits to &lt;em&gt;finishing what we have started&lt;/em&gt;. The last few years have seen the Ember team do a lot of really important exploratory work, including projects like &lt;a href="https://glimmerjs.com"&gt;Glimmer.js&lt;/a&gt;; and we have landed some of the initiatives we have started. But I think it’s fair to say that focus has not been our strong suit. It’s time for a year of &lt;em&gt;shipping&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We need to land all the things we have in flight, and as much as possible avoid the temptation (much though I feel it myself!) to go haring off after interesting new ideas. As such, literally everything I list below is an effort &lt;em&gt;already in progress&lt;/em&gt;. It’s just a matter of making concerted efforts as a community to land them.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And that way of putting it is important: we have to make concerted efforts &lt;em&gt;as a community&lt;/em&gt; to land these things. Very, very few people are paid to work on Ember.js full time—far too few to accomplish all of this! If these things matter to you and your company, find a way to carve out time for it. Even if it’s just a few hours a week, even if it’s “just” (and there’s no “just” about these!) helping out with triage of open issues or answering questions in Slack or Discourse or Stack Overflow, even if it doesn’t &lt;em&gt;feel&lt;/em&gt; like a lot… it adds up.&lt;/p&gt;
&lt;p&gt;To be very clear, before I go any further: none of this is a knock on everything that the Ember core team and community have done in the last couple years. A lot of things that have landed along the way—dropping in the Glimmer rendering engine midway through the 2.x series, landing ES5 getters just weeks ago in Ember 3.1, and so on—are genuinely great! &lt;em&gt;All&lt;/em&gt; that I mean is, a year where we land and polish everything would make everything that much more awesome (and make Ember that much more competitive a choice in the client-side framework world).&lt;/p&gt;
&lt;p&gt;So: what do we need to ship this year?&lt;/p&gt;
&lt;section id="land-glimmer-components-in-ember.js-proper" class="level3"&gt;
&lt;h3&gt;Land Glimmer &lt;code&gt;&amp;lt;Component&amp;gt;&lt;/code&gt;s in Ember.js proper&lt;/h3&gt;
&lt;p&gt;We’ve taken the first steps toward this already via a number of &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt;s that were written late last year and merged since. We need to finish the implementation for these. That means getting the &lt;a href="https://github.com/emberjs/ember.js/issues/16301"&gt;Glimmer Components in Ember&lt;/a&gt; quest across the finish line.&lt;/p&gt;
&lt;p&gt;The whole story here will make Ember &lt;em&gt;feel&lt;/em&gt; much more modern in a variety of ways, as well as enabling some great performance and programming model wins: Immutable component arguments! Auto-tracked class properties! &lt;code&gt;&amp;lt;AngleBracketComponent&amp;gt;&lt;/code&gt; invocation! Clear semantic distinctions between arguments and local context! So many good things. We just need to land it! &lt;a href="https://github.com/emberjs/ember.js/issues/16301"&gt;The quest&lt;/a&gt; needs to be moving forward, not stagnant.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Show up and volunteer to go after pieces of the quest. There are people willing to mentor you through the work that needs to be done!&lt;/li&gt;
&lt;li&gt;Test it as it lands! You don’t have to commit to &lt;em&gt;shipping&lt;/em&gt; things in your app to &lt;em&gt;test&lt;/em&gt; them in your app.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="land-a-lot-of-ember-cli-efforts" class="level3"&gt;
&lt;h3&gt;Land a &lt;em&gt;lot&lt;/em&gt; of Ember CLI efforts&lt;/h3&gt;
&lt;p&gt;There are a great many Ember CLI efforts in flight. Every last one of them should be on stable and in use before the end of the year.&lt;/p&gt;
&lt;section id="module-unification" class="level4"&gt;
&lt;h4&gt;Module Unification&lt;/h4&gt;
&lt;p&gt;The &lt;a href="https://github.com/dgeb/rfcs/blob/module-unification/text/0000-module-unification.md"&gt;Module Unification &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt;&lt;/a&gt; was opened in May 2016 and merged October 2016. There has been a lot of progress made, but we need to &lt;em&gt;ship it&lt;/em&gt;—from where I stand, it’d be nice if it landed less than 2 years after we approved it! And we’re &lt;a href="https://github.com/emberjs/ember.js/issues/16373"&gt;getting pretty close&lt;/a&gt;; you can actually use the Module Unification blueprint in an Ember application today. Some stuff doesn’t work &lt;em&gt;quite&lt;/em&gt; right yet, but it’s getting close.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; try it out! Spin up new apps with the module unification blueprint flag, and try running the migrator codemod, and report back on what breaks.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="broccoli-1.0" class="level4"&gt;
&lt;h4&gt;Broccoli 1.0&lt;/h4&gt;
&lt;p&gt;We’re &lt;em&gt;super&lt;/em&gt; close on this one—Oli Griffiths has done some heroic work on this since EmberConf—but we need to finish it. Ember CLI, for historical reasons, has been using a fork of Broccoli.js for quite some time. This divergence has caused all manner of trouble, including compatibility issues between Broccoli plugins and an inability to take advantage of the best things that have landed in Broccoli since the fork happened.&lt;/p&gt;
&lt;p&gt;Perhaps the single most important example of that is that Broccoli 1.0 supports the use of the system &lt;code&gt;tmp&lt;/code&gt; directory. That single change will improve the performance of Ember CLI &lt;em&gt;dramatically&lt;/em&gt;, especially on Windows. It will also flat-out eliminate a number of bugs and odd behaviors that appear when trying to integrate Ember CLI with other file watching tools (e.g. TypeScript’s &lt;code&gt;--watch&lt;/code&gt; invocation).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; once the Ember CLI team says it’s ready for testing, test your app and addons with it! Make sure that everything works as it should—specifically, that you’re not making any assumptions that depend on either the forked &lt;abbr&gt;API&lt;/abbr&gt; or the location of the &lt;code&gt;tmp&lt;/code&gt; directory used for intermediate build steps.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-new-packager-setup-with-tree-shaking-and-app-splitting" class="level4"&gt;
&lt;h4&gt;The new &lt;code&gt;Packager&lt;/code&gt; setup, with tree-shaking and app-splitting&lt;/h4&gt;
&lt;p&gt;One of the current major pain points with Ember’s build pipeline is that it’s hard to extend, and not really documented at all. (I’ll have a &lt;em&gt;lot&lt;/em&gt; more to say on the question of documentation in the next post!) However, work is in progress to change that, too!&lt;/p&gt;
&lt;p&gt;The accepted-and-actively-being-worked-on &lt;a href="https://github.com/ember-cli/rfcs/blob/master/active/0051-packaging.md"&gt;Packaging Ember CLI &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt;&lt;/a&gt; aims to fix both of these. Quoting from it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The current application build process merges and concatenates input broccoli trees. This behaviour is not well documented and is a tribal knowledge. While the simplicity of this approach is nice, it doesn’t allow for extension. We can refactor our build process and provide more flexibility when desired.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A few of the things we can expect to be possible once that effort lands:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tree-shaking – we can lean on Rollup.js to get &lt;em&gt;only&lt;/em&gt; the code we actually need, cutting shipped file size dramatically&lt;/li&gt;
&lt;li&gt;app-splitting – lots of different strategies to explore, including route-based or “section”-based, etc.&lt;/li&gt;
&lt;li&gt;static-build-asset-splitting – no reason to cache-bust your &lt;em&gt;dependencies&lt;/em&gt; every time the app releases!&lt;/li&gt;
&lt;li&gt;distinct app builds – you could ship one build of your app for browsers which support ES Modules and one for browsers which don’t (heeeeey, IE11) – letting you minimize the payload size for the ones that do&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you know Ember CLI internals: pop into #-dev-ember-cli and ask how you can help land the features&lt;/li&gt;
&lt;li&gt;If you don’t know Ember CLI internals: also pop into #-dev-ember-cli, but ask instead how you can &lt;em&gt;test&lt;/em&gt; the changes&lt;/li&gt;
&lt;li&gt;Help document those internals (see the next post in this series)&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="install-your-way-to-ember" class="level3"&gt;
&lt;h3&gt;Install-your-way-to-Ember&lt;/h3&gt;
&lt;p&gt;We need to finish splitting apart the Ember source from its current state of still being fairly monolith and get it turned into a true set of packages. The new Modules API which landed last year was a huge step toward this and made the experience on the developer side &lt;em&gt;look&lt;/em&gt; like this should be possible—but that’s still a shim around the actual non-modularized Ember core code. The process of splitting it apart &lt;em&gt;is happening&lt;/em&gt;, but we need to finish it.&lt;/p&gt;
&lt;p&gt;The promise here is huge: Ember will be able to be the kind of thing you can progressively add to your existing applications and slowly convert them, rather than something that comes along all as a large bundle. It’s technically possible to do this today, but you cannot drop in &lt;em&gt;just the view layer&lt;/em&gt;, for example, and that’s a huge value for people who want to try out the programming model or add it for just one feature in an existing application.&lt;/p&gt;
&lt;p&gt;Making it possible for people to install Glimmer components, then the service layer, then the router, and so on as they need it will make adoption easier for people who are curious about the framework. But it will also be a huge boon to those of us already using Ember and wanting to migrate existing applications (often a tangled mix of server-side rendering and massive jQuery spaghetti files!) to Ember progressively. I’ve had multiple scenarios come up at my own job in just the last month where this would have been hugely useful.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; make it known that you’re willing to help work on breaking apart Ember into its constituent pieces, and as that effort lands (hopefully over the rest of this year!) test it in your own apps and addons, and find the pain points in the install-your-way-to-the-framework process.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="make-typescript-great-everywhere" class="level3"&gt;
&lt;h3&gt;Make TypeScript &lt;em&gt;great&lt;/em&gt; everywhere&lt;/h3&gt;
&lt;p&gt;This one is near and dear to my heart… and it also really falls in no small part to me and the rest of the group working on ember-cli-typescript and type definitions for the Ember ecosystem!&lt;/p&gt;
&lt;p&gt;There are two big wins we can land this year:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Built-in support in Ember.js itself.&lt;/li&gt;
&lt;li&gt;Solid type definitions for the rest of the Ember.js ecosystem&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you don’t like TypeScript, don’t panic! The upshot here will actually be a better experience for &lt;em&gt;all&lt;/em&gt; users of Ember.js.&lt;/p&gt;
&lt;section id="built-in-support-in-ember.js-itself" class="level4"&gt;
&lt;h4&gt;1. Built-in support in Ember.js itself&lt;/h4&gt;
&lt;p&gt;One of my goals for this summer&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; is to finish an &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; making TypeScript a first-class citizen of the Ember.js ecosystem. To clarify what this will and won’t entail (assuming it’s accepted, assuming I ever manage to finish writing it!):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ember will &lt;em&gt;always&lt;/em&gt; be JS-first, and it will &lt;em&gt;never&lt;/em&gt; require type metadata reflected to runtime, unlike e.g. Angular. No one will ever have a &lt;em&gt;worse&lt;/em&gt; experience because they prefer JS to TS. The idea will be to make TypeScript an &lt;em&gt;equally&lt;/em&gt; good experience, and to include it for consideration when thinking about design choices for new features.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember users, both JS and TS, will get the &lt;em&gt;benefits&lt;/em&gt; of having good types available right out of the box: many editors and IDEs can use TypeScript type definitions to enable better docs, autocompletion, etc.—and we may even be able to leverage it for &lt;a href="https://twitter.com/__dfreeman/status/994410180661170177"&gt;better validation of Handlebars templates&lt;/a&gt;!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We’ll have (because we’ll have to have!) a story on what we support in terms of backwards compatibility and SemVer for TypeScript and Ember and the type definitions. Necessarily, it has been the Wild West for the first year of concentrated effort here, trying to get our type definitions from “barely exist and not useful” to “full coverage and 99% right.” But as TypeScript becomes more widely used, we have to have a stability story, and we very soon will.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There’s also ongoing work to convert Ember’s own internals to TypeScript, and landing that will help guarantee that the type definitions for Ember are actually &lt;em&gt;correct&lt;/em&gt;, which in turn will make the experience for everyone better. (Bad type definitions are worse than &lt;em&gt;no&lt;/em&gt; type definitions!)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; engage in the &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process once we get it started, and if you are up for it show up to help convert the Ember internals to TypeScript as well.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="solid-type-definitions-for-the-rest-of-the-ember.js-ecosystem" class="level4"&gt;
&lt;h4&gt;2. Solid type definitions for the rest of the Ember.js ecosystem&lt;/h4&gt;
&lt;p&gt;Closely related to making TypeScript a first-class citizen for Ember.js itself is getting the pieces in place for the rest of the ecosystem as well. That means we need type definitions for addons—a &lt;em&gt;lot&lt;/em&gt; of them! The ember-cli-typescript team will (hopefully late this month or in early June) be launching a quest issue to get type definitions for the whole Ember ecosystem in place—by helping convert addons to TS if their authors desire it, or by adding type definitions to the addons if they’re up for it, or by getting them up on DefinitelyTyped if they’re totally disinterested. (And, as I’ll note again in that quest issue, it’s totally fine for people &lt;em&gt;not&lt;/em&gt; to be interested: there &lt;em&gt;is&lt;/em&gt; a maintenance burden there!) The goal, again, is that when you’re using &lt;em&gt;any&lt;/em&gt; part of the Ember ecosystem it’ll be easy to get all the benefits of TypeScript—and indeed that in many cases you’ll get a fair number of those benefits as a JS user.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How you can help:&lt;/strong&gt; participate in the quest issue once it’s live! We’ll help mentor you through the process of converting addons to TypeScript, writing type definitions and getting them well-validated, and so on!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;That’s a lot to do. More than enough all by itself, and a lot of moving parts. As such, I’ll reiterate what I said at the start: we don’t need new features this year. &lt;strong&gt;It’s time for a year of &lt;em&gt;shipping&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;To put it in the terms the Rust community used for their similar push at the end of 2017, and which we have often used to describe the ongoing efforts in Rust to land the “Rust 2018 edition”: this is an “impl period”—a play on the Rust &lt;code&gt;impl&lt;/code&gt; keyword, used to describe the &lt;em&gt;implementation&lt;/em&gt; of the behavior associated with a given data type. You can think of this as the same: it’s the implementation of the good ideas we have.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Confession: it was a goal for the spring but I found myself utterly exhausted after EmberConf… and had a full month with &lt;em&gt;another&lt;/em&gt; major talk given for internal purposes afterwards. I’m worn out.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 11 May 2018 09:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-11:/2018/emberjs2018-part-1.html</guid><category>emberjs</category><category>javascript</category><category>typescript</category><category>emberjs2018</category></item><item><title>Announcing ember-cli-typescript 1.1.0</title><link>http://www.chriskrycho.com/2018/announcing-ember-cli-typescript-110.html</link><description>&lt;p&gt;I’m delighted to announce the release of &lt;a href="https://github.com/typed-ember/ember-cli-typescript/releases/tag/v1.1.0"&gt;ember-cli-typescript 1.1.0&lt;/a&gt;. This first minor release since 1.0 includes the following shiny and awesome new features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#generators"&gt;Generators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#developing-addons"&gt;Support for developing addons in TypeScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#incremental-compilation"&gt;Incremental compilation (a.k.a. fast rebuilds in &lt;code&gt;ember serve&lt;/code&gt; mode)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="generators" class="level2"&gt;
&lt;h2&gt;Generators&lt;/h2&gt;
&lt;p&gt;We’ve now added support for generating &lt;em&gt;all&lt;/em&gt; standard Ember items as TypeScript files instead of JavaScript files. So now when you run &lt;code&gt;ember generate component user-profile&lt;/code&gt; for example, you’ll get &lt;code&gt;user-profile.ts&lt;/code&gt;, &lt;code&gt;user-profile-test.ts&lt;/code&gt;, and &lt;code&gt;user-profile.hbs&lt;/code&gt;. For most files, this is just a nicety—just two files you don’t have to rename!—but in the case of services, controllers, and Ember Data models, adapters, and serializers it will actually make a really big difference in your experience of using TypeScript in your app or addon.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Those generators are &lt;em&gt;mostly&lt;/em&gt; identical with ones in Ember and Ember Data, just with &lt;code&gt;.ts&lt;/code&gt; instead of &lt;code&gt;.js&lt;/code&gt; for the extension. The only changes we have made are: (a) we’ve tweaked them to use classes where possible, and (b) we have customized the controller, service, and Ember Data model, adapter, and serializer generators so you get the most mileage out of TypeScript for the least effort we can manage today. So when you do &lt;code&gt;ember generate service session&lt;/code&gt;, this is what you’ll see:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Service from &amp;quot;@ember/service&amp;quot;;

export default class Session extends Service.extend({
  // anything which *must* be merged on the prototype
}) {
  // normal class definition
}

// DO NOT DELETE: this is how TypeScript knows how to look up your services.
declare module &amp;quot;ember&amp;quot; {
  interface ServiceRegistry {
    session: Session;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Courtesy of these generators, you can now write &lt;em&gt;almost&lt;/em&gt; exactly what you’d write in vanilla Ember and get full support for autocompletion of properties and methods on the &lt;code&gt;Session&lt;/code&gt; service, as well as type-checking for how you use those. Service and controller injections just require you to explicitly name the service or controller being injected:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Component from &amp;quot;@ember/component&amp;quot;;
import { inject as service } from &amp;quot;@ember/service&amp;quot;;

export default class UserProfile extends Component {
  session = service(&amp;quot;session&amp;quot;);
  // note the string ^ naming the service explicitly
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, for example, if your &lt;code&gt;session&lt;/code&gt; service had a &lt;code&gt;login&lt;/code&gt; method on it:&lt;/p&gt;
&lt;pre class="ts"&gt;&lt;code&gt;import Service from &amp;quot;@ember/service&amp;quot;;
import RSVP from &amp;quot;rsvp&amp;quot;;

export default class Session extends Service {
  login(email: string, password: string): RSVP.Promise&amp;lt;string&amp;gt; {
    // some API call to log in
  }
}

// DO NOT DELETE: this is how TypeScript knows how to look up your services.
declare module &amp;quot;ember&amp;quot; {
  interface ServiceRegistry {
    session: Session;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then anywhere you injected and used it, you’ll get auto-complete suggestions and type checking:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/ts-autocomplete.png" alt="autocompletion" /&gt;&lt;figcaption&gt;autocompletion&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/ts-type-checking.png" alt="type-checking" /&gt;&lt;figcaption&gt;type-checking&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;(You’ll see the same kinds of things in other editors, from Vim to IntelliJ IDEA. Visual Studio Code is just my current editor of choice.)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="addon-development" class="level2"&gt;
&lt;h2&gt;Addon development&lt;/h2&gt;
&lt;p&gt;As &lt;a href="http://www.chriskrycho.com/2017/announcing-ember-cli-typescript-100.html#the-roadmap"&gt;promised with the 1.0 release&lt;/a&gt;, 1.1 (though arriving much later than I hoped it would) includes support for developing addons with TypeScript.&lt;/p&gt;
&lt;p&gt;Strictly speaking, of course, you could &lt;em&gt;always&lt;/em&gt; develop addons using TypeScript, but there were two problems with it: (1) dependency management and (2) manual work required to deal with the dependency management problems.&lt;/p&gt;
&lt;section id="dependency-management" class="level3"&gt;
&lt;h3&gt;1. Dependency management&lt;/h3&gt;
&lt;p&gt;In the normal Ember CLI workflow, TypeScript had to be a &lt;code&gt;dependency&lt;/code&gt;—not a &lt;code&gt;devDependency&lt;/code&gt;—of the addon, because the normal pattern with Ember CLI is to ship the uncompiled files and have the consumer compile them all together at build time.&lt;/p&gt;
&lt;p&gt;This makes a certain amount of sense for Babel given the Ember community’s shared reliance on Babel: it’s just assumed to be part of every app build. In that case, it gives consumers control over their compilation target. If an app only needs to target evergreen browsers, it can do that and ship a smaller payload, because an addon won’t have pre-compiled in things like generator support, etc.&lt;/p&gt;
&lt;p&gt;In the case of TypeScript, however, this makes a lot less sense: many (probably &lt;em&gt;most&lt;/em&gt;) consumers of addons written in TypeScript will still be normal JavaScript consumers. We did not want to burden normal consumers with a TypeScript compile step. We &lt;em&gt;also&lt;/em&gt; didn’t want to burden any consumers with the reality that TypeScript is a &lt;em&gt;large&lt;/em&gt; install. TypeScript 2.6.2 is 32MB on disk for me. Even with some degree of deduplication by npm or yarn, if addons used a variety of versions of TypeScript for development—as they surely would!—the install cost for consumers would quickly spiral into a nasty spot. And again: that’s bad enough for someone who &lt;em&gt;wants&lt;/em&gt; to use TypeScript in their app; it’s far worse for someone who just wants to consume the compiled JavaScript.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="manual-workarounds" class="level3"&gt;
&lt;h3&gt;2. Manual workarounds&lt;/h3&gt;
&lt;p&gt;You could work around all of that by building the JavaScript (and TypeScript definitions) yourself. But as part of that, you had to do all the work of making sure both the JavaScript files and the type definitions you generated ended up in the right place for distribution and consumption. That was always possible, but it was also always going to be a lot of work. In practice, as far as I know, &lt;em&gt;no one has done this&lt;/em&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="solution" class="level3"&gt;
&lt;h3&gt;Solution&lt;/h3&gt;
&lt;p&gt;We now support TypeScript as a &lt;code&gt;devDependency&lt;/code&gt; and also manage the work of generating JavaScript and type definitions for you. All you have to do is install ember-cli-typescript into an addon, and then when you do your build step, we’ll automatically do the work (on prepublish) of generating TypeScript &lt;code&gt;.d.ts&lt;/code&gt; files and JavaScript source for you.&lt;/p&gt;
&lt;p&gt;Consumers of your addon, therefore, will (a) not know or care that the addon is written in TypeScript if they just want to consume it as normal JavaScript&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; or (b) will get the benefits of your having written the library in TypeScript without paying the penalty of having to have multiple versions of the TypeScript compiler downloaded to their own app.&lt;/p&gt;
&lt;p&gt;One important caveat: we do &lt;em&gt;not&lt;/em&gt; support TypeScript in an addon’s &lt;code&gt;app&lt;/code&gt; directory. However, for most addons, we don’t think this should be a problem. It’s rare for addons to put actual implementation in the &lt;code&gt;app&lt;/code&gt; directory; instead it has simply become conventional for the &lt;code&gt;app&lt;/code&gt; directory simply to have re-exports for convenient access to the functionality supplied by the addon.&lt;/p&gt;
&lt;p&gt;Also note that you can supply type definitions for your addon &lt;em&gt;without&lt;/em&gt; developing the addon itself in TypeScript.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; You do &lt;em&gt;not&lt;/em&gt; need ember-cli-typescript installed for that. You only need the addon if you actually want to take advantage of the opportunities TypeScript affords for developing your own addon.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="incremental-compilation" class="level2"&gt;
&lt;h2&gt;Incremental compilation&lt;/h2&gt;
&lt;p&gt;Last but not least, we’ve managed—mostly through the hard work of both Dan Freeman (&lt;a href="https://github.com/dfreeman"&gt;@dfreeman&lt;/a&gt;) and Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;—to get support for TypeScript’s &lt;code&gt;--watch&lt;/code&gt; mode integrated.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; What this means in practice is: &lt;em&gt;way&lt;/em&gt; faster iteration as you work.&lt;/p&gt;
&lt;p&gt;Previously, every time you triggered &lt;em&gt;any&lt;/em&gt; change in your app (even if it didn’t involve any TypeScript files at all), the TypeScript compiler would recompile &lt;em&gt;all&lt;/em&gt; the TypeScript files in your application. We didn’t initially have a good way to make TypeScript and Broccoli (and therefore Ember CLI) communicate clearly about what had changed. Now, courtesy of Dan and Derek’s hard work (and my cheerleading, testing, and fixing a few corner pieces along the way), we do! So when you change a &lt;code&gt;.hbs&lt;/code&gt; file or a &lt;code&gt;.js&lt;/code&gt; file… the TypeScript compiler won’t do anything. And when you change a TypeScript file, the TypeScript compiler will &lt;em&gt;only&lt;/em&gt; recompile that file.&lt;/p&gt;
&lt;p&gt;On my own app (~35,000 lines of TypeScript across ~700 files), that’s the difference between rebuilds involving TypeScript taking 15–20 seconds and their taking 1–2 seconds. Literally an order of magnitude faster! Over the course of a day of development, that saves a &lt;em&gt;huge&lt;/em&gt; amount of time.&lt;/p&gt;
&lt;p&gt;The way we did it also solved an incredibly annoying problem we had in the previous pass: &lt;em&gt;any&lt;/em&gt; change to your app was triggering &lt;code&gt;tsc&lt;/code&gt; to rebuild the entire TypeScript tree of your app, even if you didn’t so much as look at &lt;code&gt;.ts&lt;/code&gt; file. This was particularly annoying when combined with the long rebuild times: change a CSS file and wait for your TypeScript files to rebuild? Ugh. But not anymore!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="credit-and-thanks" class="level2"&gt;
&lt;h2&gt;Credit and Thanks&lt;/h2&gt;
&lt;p&gt;Massive credit goes to Dan Freeman (&lt;a href="https://github.com/dfreeman"&gt;@dfreeman&lt;/a&gt;) and Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;), who did most of the heavy lifting on the internals for this release, and together unlocked both incremental compilation and addon support. Derek also did the lion’s share of the work on writing the types for Ember and Ember Data.&lt;/p&gt;
&lt;p&gt;Thanks to Maarten Veenstra (&lt;a href="https://github.com/maerten"&gt;@maerten&lt;/a&gt;) for the original inspiration (and a spike last summer) for using a type registry, and to Mike North (&lt;a href="https://github.com/maerten"&gt;@mike-north&lt;/a&gt;) for some discussion and planning around the idea late in 2017. I may have implemented them, but the ideas came from the community!&lt;/p&gt;
&lt;p&gt;Thanks to Frank Tan (&lt;a href="https://github.com/tansongyang"&gt;@tansongyang&lt;/a&gt;) for doing a lot of the work on porting the generators from the Ember and Ember Data repositories to ember-cli-typescript, as well as converting them to TypeScript and to use the new formats. He also contributed the type definitions for the new (&lt;a href="https://github.com/emberjs/rfcs/pull/232/"&gt;RFC #232&lt;/a&gt;) QUnit testing API.&lt;/p&gt;
&lt;p&gt;Thanks to everyone who contributed to ember-cli-typescript or the Ember typings in any way since we released 1.0.0:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ember-cli-typescript contributors (note that I intentionally include here everyone who opened issues on the repository: that is &lt;em&gt;not&lt;/em&gt; a small thing and has helped us immensely):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bryan Crotaz (&lt;a href="https://github.com/BryanCrotaz"&gt;@BryanCrotaz&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Daniel Gratzl (&lt;a href="https://github.com/danielgratzl"&gt;@danielgratzl&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Guangda Zhang (&lt;a href="https://github.com/inkless"&gt;@inkless&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/guangda-prosperworks"&gt;@guangda-prosperworks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Krati Ahuja (&lt;a href="https://github.com/kratiahuja"&gt;@kratiahuja&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Martin Feckie (&lt;a href="https://github.com/mfeckie"&gt;@mfeckie&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Nikos Katsikanis (&lt;a href="https://github.com/QuantumInformation"&gt;@QuantumInformation&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Per Lundberg (&lt;a href="https://github.com/perlun"&gt;@perlun&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Prabhakar Poudel (&lt;a href="https://github.com/prabhakar-poudel"&gt;@Prabhakar-Poudel&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Ryan LaBouve (&lt;a href="https://github.com/ryanlabouve"&gt;@ryanlabouve&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Simon Ihmig (&lt;a href="https://github.com/simonihmig"&gt;@simonihmig&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Theron Cross (&lt;a href="https://github.com/theroncross"&gt;@theroncross&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Thomas Gossman (&lt;a href="https://github.com/gossi"&gt;@gossi&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Vince Cipriani (&lt;a href="https://github.com/vcipriani"&gt;@vcipriani&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember typings contributors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adnan Chowdhury (&lt;a href="https://github.com/bttf"&gt;@bttf&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Frank Tan (&lt;a href="https://github.com/tansongyang"&gt;@tansongyang&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Guangda Zhang (&lt;a href="https://github.com/inkless"&gt;@inkless&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Ignacio Bona Piedrabuena (&lt;a href="https://github.com/igbopie"&gt;@igbopie&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Leonard Thieu &lt;a href="https://github.com/leonard-thieu"&gt;@leonard-thieu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Logan Tegman &lt;a href="https://github.com/ltegman"&gt;@ltegman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Martin Feckie (&lt;a href="https://github.com/mfeckie"&gt;@mfeckie&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Mike North (&lt;a href="https://github.com/maerten"&gt;@mike-north&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Nathan Jacobson (&lt;a href="https://github.com/natecj"&gt;@natecj&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Per Lundberg (&lt;a href="https://github.com/perlun"&gt;@perlun&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Robin Ward (&lt;a href="https://github.com/eviltrout"&gt;@eviltrout&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks to Rob Jackson (&lt;a href="https://github.com/rwjblue"&gt;@rwjblue&lt;/a&gt;) and Tobias Bieniek (&lt;a href="https://github.com/Turbo87"&gt;@Turbo87&lt;/a&gt; on GitHub, @tbieniek in the Ember Slack) for answering tons of questions and putting up with regular pestering about Ember CLI.&lt;/p&gt;
&lt;p&gt;And last but not least, thanks to everyone who’s popped into #topic-typescript on the Ember Community Slack with questions, comments, problem reports, and the occasional word of encouragement. It really does help.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;For details on how this all works, see &lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-4.html"&gt;TypeScript and Ember.js Update: Part 4&lt;/a&gt;, where I discuss these changes in detail.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;although they may actually get some benefits in a number of modern editors, since e.g. VS Code and the JetBrains IDEs will leverage types if they exist!&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;More on that in a post to be released in the next couple weeks—one I promised &lt;em&gt;long&lt;/em&gt; ago, but which we’re now in a place to actually do: a plan and a roadmap for typing the whole Ember ecosystem!&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;And of course, right as we finally landed our support for it, by hacking around the &lt;code&gt;--watch&lt;/code&gt; invocation in a lot of really weird ways, Microsoft shipped API-level support for it. We hope to switch to using that under the hood, but that shouldn’t make any difference at all to you as a consumer of the addon, except that if/when we land it at some point, you’ll just have a nicer experience.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 12 Feb 2018 07:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-02-12:/2018/announcing-ember-cli-typescript-110.html</guid><category>emberjs</category><category>typescript</category><category>javascript</category><category>typing-your-ember</category></item><item><title>I Want JSON Decoders</title><link>http://www.chriskrycho.com/2017/i-want-json-decoders.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;This post was originally published at &lt;a href="https://www.dailydrip.com/blog/i-want-json-decoders.html"&gt;DailyDrip.com&lt;/a&gt;. They’re doing really great work over there, so I encourage you to check out their content and consider subscribing!&lt;/i&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;The other day, I got a report about the Ember.js app I’m working on: when a customer applied a coupon in the basket, they’d see an indication that the coupon was applied, but the basket total would still display as if it hadn’t been updated. Orders were &lt;em&gt;placed&lt;/em&gt; correctly, but they wouldn’t render right. I dug around for a bit, and then discovered that it was one of the (many) places where &lt;code&gt;undefined&lt;/code&gt; was biting us.&lt;/p&gt;
&lt;p&gt;How did this happen? It turned out it was a perfect storm: a confusingly-designed &lt;abbr&gt;API&lt;/abbr&gt; combined with a reasonable (but in this case, very unhelpful) assumption in our data layer. When the total on a given basket dropped to zero, our &lt;abbr&gt;API&lt;/abbr&gt; simply didn’t send back a value on the payload at all. Instead of &lt;code&gt;{ total: 0, ... }&lt;/code&gt;, there was just, well, &lt;code&gt;{ ... }&lt;/code&gt; – no &lt;code&gt;total&lt;/code&gt; field at all. Meanwhile, our data layer was designed to let a server send back only the fields which &lt;em&gt;required&lt;/em&gt; updating. That way, you can send back partial records to indicate only what has changed, instead of having to send back the whole of what might be a very large record, or a very large collection of records.&lt;/p&gt;
&lt;p&gt;The combination was terrible, though: because the server didn’t send back the &lt;code&gt;total&lt;/code&gt; field at all when it dropped to &lt;code&gt;0&lt;/code&gt;, the client never updated the total it displayed to the user: as far as it was concerned, the server was saying “no change here!”&lt;/p&gt;
&lt;p&gt;The first and most obvious solution here, of course, is the one we implemented: we had the &lt;abbr&gt;API&lt;/abbr&gt; always send back a value, even if that value was &lt;code&gt;0&lt;/code&gt;. But it seems like there should be a better way.&lt;/p&gt;
&lt;p&gt;Lots of languages have fairly nice facilities for parsing JavaScript. Several languages even have tools for automatically constructing local, strongly-typed data structures from the structure of a &lt;abbr&gt;JSON&lt;/abbr&gt; response on an &lt;abbr&gt;API&lt;/abbr&gt;. F♯’s &lt;a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/"&gt;type providers&lt;/a&gt; are like this and &lt;em&gt;really fancy&lt;/em&gt; in the way they’ll automatically derive the type for you so you don’t even have to write it out as you would in everything from Haskell to C#. But for the most part in JavaScript, you have at most a way to map data to a local record in your data store – certainly none of those type safe guarantees. In TypeScript, you can write the types you receive out carefully – though, as I discovered in this case, probably not carefully &lt;em&gt;enough&lt;/em&gt; unless you model &lt;em&gt;everything&lt;/em&gt; as an optional field, and then you’re back to checking for &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; everywhere, and &lt;em&gt;why isn’t this already a solved problem?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;And it turns out, it &lt;em&gt;is&lt;/em&gt; a solved problem – or at least, it is in Elm, &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;via&lt;/a&gt; those &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;&lt;abbr&gt;JSON&lt;/abbr&gt; Decoders&lt;/a&gt;. I don’t get to write Elm at work right now (or any time in the foreseeable future) – but if I can’t write Elm, I can at least try to steal a bunch of its great ideas and push them back into my TypeScript.&lt;/p&gt;
&lt;p&gt;So… what exactly are &lt;abbr&gt;JSON&lt;/abbr&gt; Decoders and how would they have solved this problem? (And why, if you’re already familiar a little with Elm and possibly feeling frustrated with decoding, are they actually worth it?)&lt;/p&gt;
&lt;p&gt;A &lt;abbr&gt;JSON&lt;/abbr&gt; Decoder is just a way of guaranteeing that once you’re inside the boundary of your program, you &lt;em&gt;always&lt;/em&gt; have a valid instance of the data type you’ve decoded it into, &lt;em&gt;or&lt;/em&gt; an error which tells you why you &lt;em&gt;don’t&lt;/em&gt; have a valid instance of the data. They’re composable, so you can stack them together and take smaller decoders to build bigger ones, so if you have a complex &lt;abbr&gt;JSON&lt;/abbr&gt; structure, you can define repeated substructures in it, or decoders for dissimilar sibling items in it, and use them to put together a grand decoder for your whole final structure. The decoders use the &lt;a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result"&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, and they hand back either &lt;code&gt;Ok&lt;/code&gt; with the decoded value or &lt;code&gt;Err&lt;/code&gt; with the reason for the failure – and if &lt;em&gt;any&lt;/em&gt; piece of a decoded type doesn’t match with what you’ve specified, you’ll end up with an &lt;code&gt;Err&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, initially that might sound like a recipe for disaster – &lt;abbr&gt;JSON&lt;/abbr&gt; payloads can be formed in weird ways all the time! – but in fact it encourages you to think through the various ways your payloads can be formed and to account for them. &lt;em&gt;Sometimes&lt;/em&gt;, if the payload doesn’t have what you expect, that really does mean something is wrong either in your request or in the server-side implementation. In that case, getting an &lt;code&gt;Err&lt;/code&gt; is &lt;em&gt;exactly&lt;/em&gt; what you want. Other times, the server might be perfectly legitimate in sending back a variety of shapes in its response, and your responsibility is to decide how to decode it to make sense in your app. Remember, the problem I had was that I received a payload which didn’t have the data. With Elm’s decoders, I would have had three choices:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;I could have treated this as an error, and passed that along to be dealt with in some way.&lt;/li&gt;
&lt;li&gt;I could have normalized it as a 0-value payload.&lt;/li&gt;
&lt;li&gt;I could have treated it &lt;em&gt;explicitly&lt;/em&gt; as a no-op, maintaining whatever previous state I had in the data store, i.e. the implicit behavior of my actual data store.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What I &lt;em&gt;couldn’t&lt;/em&gt; do, though, is do any one of those &lt;em&gt;accidentally&lt;/em&gt;. I could still support incomplete payloads (via option 3), but I’d be explicitly opting into that, and there would be an obvious place where that was the case. This would be particularly helpful in a scenario where I wasn’t also in charge of the &lt;abbr&gt;API&lt;/abbr&gt;: if I couldn’t just go change it so the &lt;abbr&gt;API&lt;/abbr&gt; itself had a more sensible behavior, I could enforce whichever desired behavior on my own end. More than that, with something modeled on the Elm &lt;abbr&gt;JSON&lt;/abbr&gt; Decoders, I would &lt;em&gt;have&lt;/em&gt; to: there would be no implicit consumption of raw &lt;abbr&gt;JSON&lt;/abbr&gt;.&lt;/p&gt;
&lt;p&gt;The first time I played with the Elm &lt;abbr&gt;JSON&lt;/abbr&gt; Decoder approach, I thought it was a lot of work. I was used to just doing &lt;code&gt;JSON.parse()&lt;/code&gt; in JS or &lt;code&gt;json.loads()&lt;/code&gt; in Python. Now I needed to define a whole series of decode steps explicitly for every field in a response? Good grief! But it grew on me. More than that, I now actively miss it in my apps; I’d have been really happy not to have to spend a morning hunting down this particular bug.&lt;/p&gt;
&lt;p&gt;Sometimes that explicitness can seem like quite a lot of boilerplate, and indeed it is: there’s a reason the Elm &lt;a href="https://github.com/NoRedInk/elm-decode-pipeline"&gt;elm-decode-pipeline&lt;/a&gt; project exists. But even given the &lt;em&gt;initial&lt;/em&gt; nicety of something like F♯ type providers, I think the Elm approach has a slight edge in the long-term for &lt;em&gt;maintainability&lt;/em&gt; specifically. It’s one thing to be able to just get to work right away and have a type definition you know to conform to a given &lt;abbr&gt;API&lt;/abbr&gt; response. It’s something else entirely to be able to &lt;em&gt;know&lt;/em&gt; that you’ve accounted for all the varieties of responses you might get (and without throwing an exception for failed &lt;abbr&gt;JSON&lt;/abbr&gt; decoding at that!).&lt;/p&gt;
&lt;p&gt;Given all of this, I’ve started mentally teasing out what such a &lt;abbr&gt;JSON&lt;/abbr&gt; decoding library for Ember.js might look like in TypeScript. It’s a long way off, but it’s the kind of thing that I &lt;em&gt;really&lt;/em&gt; want to experiment with, and that I think would make for a big win for the maintainability of our apps. Keep your eyes peeled, because I suspect this is another thing JS will steal from Elm, and that’s &lt;em&gt;great&lt;/em&gt; in my book.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 25 Dec 2017 19:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-25:/2017/i-want-json-decoders.html</guid><category>JavaScript</category><category>Elm</category><category>TypeScript</category><category>web development</category><category>software development</category></item><item><title>“Collection-Last Auto-Curried Functions”</title><link>http://www.chriskrycho.com/2017/collection-last-auto-curried-functions.html</link><description>&lt;p&gt;I’ve been using &lt;a href="https://lodash.com"&gt;lodash&lt;/a&gt; for a while at work, and I love having it in our toolbox. But, as I increasingly embrace &lt;em&gt;composition of smaller functions&lt;/em&gt; as a helpful approach to building up the final version of an overall transformation of some piece of data, I’ve increasingly wanted to be using &lt;a href="https://github.com/lodash/lodash/wiki/FP-Guide"&gt;lodash-fp&lt;/a&gt; instead—those “auto-curried… data-last methods” are &lt;em&gt;nice&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I could belabor the difference with words, but a code sample will do better. Here’s how I would write the same basic transformation in both Lodash and lodash-fp.&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// Lodash
const breakfasts = [&amp;#39;pancakes&amp;#39;, &amp;#39;waffles&amp;#39;, &amp;#39;french toast&amp;#39;]

const uniqueLetters = _.flow([
  bs =&amp;gt; _.map(bs, words),
  _.flatten,
  bs =&amp;gt; _.map(bs, b =&amp;gt; split(b, &amp;#39;&amp;#39;)),
  _.flatten,
  _.uniq,
  ls =&amp;gt; _.sortBy(ls, id),
])

console.log(uniqueLetters(breakfasts))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That gets the job done, but wouldn’t it be nice if we didn’t have to have all those anonymous functions (lambdas) throughout?&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// lodash-fp
const uniqueLettersFp = _.flow([
  _.map(words),
  _.flatten,
  _.map(split(&amp;#39;&amp;#39;)),
  _.flatten,
  _.uniq,
  _.sortBy(id),
])

const breakfasts = [&amp;#39;pancakes&amp;#39;, &amp;#39;waffles&amp;#39;, &amp;#39;french toast&amp;#39;]

console.log(uniqueLettersFp(breakfasts))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Suddenly the intent is much clearer with the noise introduced by the lambdas gone. You get this because the lodash-fp functions are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;auto-curried:&lt;/strong&gt; that is, even though &lt;code&gt;_.split&lt;/code&gt; takes the splitter and then a string, you can just write &lt;code&gt;_.split('')&lt;/code&gt; and get back a function which takes a string as an argument.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data-last:&lt;/strong&gt; because &lt;code&gt;_.split&lt;/code&gt; takes the string to split &lt;em&gt;last&lt;/em&gt;, it can be passed into an auto-curried function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You need &lt;em&gt;both&lt;/em&gt; to get that nice clean call to &lt;code&gt;_.flow&lt;/code&gt;. But once you have both, it’s really, really hard ever to go back, because it’s so much nicer for building pipelines of functions.&lt;/p&gt;
&lt;p&gt;…I need to see if I can help &lt;a href="https://github.com/mike-north/ember-lodash/issues/21"&gt;do the work&lt;/a&gt; to make lodash-fp available in Ember.js.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 24 Jun 2017 17:35:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-06-24:/2017/collection-last-auto-curried-functions.html</guid><category>javascript</category><category>functional programming</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we’re both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I’ll be reusing some of this material as the basis of an internal tech talk I’m giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s not tied to JS directly, which means it’s free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That’s the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it’s… still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript’s is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; – not mostly sure, 100% sure – that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say “by design,” I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of “soundness holes” in the type system—there’s still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS… but not none. (That’s even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It’s just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean—&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that’s no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I’d summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item><item><title>Functions, Objects, and Destructuring in JavaScript</title><link>http://www.chriskrycho.com/2017/functions-objects-and-destructuring-in-javascript.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;A colleague just getting his feet wet with JavaScript, and coming from a background with much more C# than JavaScript, sent me a question on Slack the other day, and I realized the answer I’d written up was more generally helpful, so here you go!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;I’m including the context of original question because I want to call out something really important: there are no dumb questions. When you’re just coming up to speed on &lt;em&gt;any&lt;/em&gt; technology, stuff is going to be confusing. That goes double when making the jump as far as between something like C# and something like modern JS.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hey this may be a really dumb question&lt;/p&gt;
&lt;p&gt;but I’m a JavaScript n00b, and I have no idea what’s going on here&lt;/p&gt;
&lt;p&gt;I’m not used to this syntax&lt;/p&gt;
&lt;p&gt;I have this program:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function ab() {
   function fa() { console.log(&amp;quot;A&amp;quot;); };
   function fb() { console.log(&amp;quot;B&amp;quot;); };
   return {fa, fb};
};

let {fa, fb} = ab();

fa();
fb();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and it outputs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A
B&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(as expected)&lt;/p&gt;
&lt;p&gt;What I don’t understand is the syntax for the &lt;code&gt;let&lt;/code&gt; part (or maybe even the return from &lt;code&gt;ab()&lt;/code&gt;)&lt;/p&gt;
&lt;ol type="A"&gt;
&lt;li&gt;&lt;p&gt;What is &lt;code&gt;ab()&lt;/code&gt; actually returning? An object with 2 function pointers?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What can’t I do a &lt;code&gt;let {a, b} = ab()&lt;/code&gt; and then call &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt;? I get syntax errors that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; aren’t defined&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;edit to show code that doesn’t work (definition of ab() remains the same):&lt;/em&gt;&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let {a, b} = ab();

a(); // will throw an error here
b();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I don’t understand why the names for &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt; have to be the same across all scopes/closures (? am I using those terms correctly? JavaScript is an odd dance partner at times)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;First, your (A) is &lt;em&gt;basically&lt;/em&gt; correct, but the phrase “function pointers” is one you should banish from your mind entirely in this context. In JavaScript, functions are just items like any other. From the language’s perspective, there’s no difference between these things other than what you can do with them:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let foo = &amp;quot;a string&amp;quot;;
function quux(blah) { console.log(&amp;quot;blah is &amp;quot; + blah); }
let bar = quux;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are just variables. (&lt;code&gt;quux&lt;/code&gt; is a variable, too, but it behaves a little differently; I’ll cover that in a minute.) They have different types, and therefore different things you can do on them. &lt;code&gt;foo&lt;/code&gt; has the &lt;code&gt;length&lt;/code&gt; property and a bunch of string-specific methods attached. &lt;code&gt;bar&lt;/code&gt; is callable. But both of them are just &lt;em&gt;things&lt;/em&gt; in the same way, and at the same level in the program.&lt;/p&gt;
&lt;p&gt;So in your original &lt;code&gt;function ab() { ... }&lt;/code&gt;, what you’re doing is declaring two functions, &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt;, and returning them attached to an object.&lt;/p&gt;
&lt;p&gt;For various reasons which aren’t especially interesting, functions can have &lt;em&gt;names&lt;/em&gt;…&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function fa() { ... }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…and can be &lt;em&gt;assigned to other variables&lt;/em&gt;…&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let trulyISayToYou = function waffles() { console.log(&amp;quot;are so tasty&amp;quot;); };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…and in fact you can define the functions &lt;em&gt;themselves&lt;/em&gt; anonymously, that is, without any name attached to the function declaration itself: combine those:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let lookMa = function() { console.log(&amp;quot;no function name!&amp;quot;); };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Doing &lt;code&gt;function ab() { ... }&lt;/code&gt; simultaneously &lt;em&gt;declares&lt;/em&gt; the function and &lt;em&gt;hoists&lt;/em&gt; it, that is, it makes it available in that entire scope, regardless of where it is defined. So you can do this, even though it’s kind of insane most of the time and you shouldn’t:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;quux();
function quux() { console.log(&amp;#39;SRSLY?&amp;#39;); }&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;Now, about returning &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt; from the function.&lt;/p&gt;
&lt;p&gt;First, note that you normally define objects in a long form, like so:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let someObject = {
  a: true,
  b: &amp;#39;some string&amp;#39;
};

console.log(someObject.a);  // prints true
console.log(someObject.b);  // prints &amp;quot;some string&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, very, &lt;em&gt;very&lt;/em&gt; often, you find yourself doing something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// do some work to define what `a` and `b` should be, then...
let someObject = {
  a: a,
  b: b
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because this is such a common pattern, the 2015 version of JS introduced a “shorthand,” which lets you just write that last assignment like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let someObject = {
  a,
  b
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course, for convenience we often write that on one line:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let someObject = { a, b };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can combine that with the fact that you declared two items (functions, but again: that &lt;em&gt;really&lt;/em&gt; doesn’t matter, they could be anything) with the names &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt;, and what you’re doing is returning an object containing those two items in it: &lt;code&gt;return {fa, fb}&lt;/code&gt; is equivalent to this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let theFunctions = {
  fa: fa,
  fb: fb, 
};
return theFunctions;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;What about the &lt;code&gt;let&lt;/code&gt; assignment?&lt;/p&gt;
&lt;p&gt;JS has three kinds of name bindings: &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, and &lt;code&gt;const&lt;/code&gt;. &lt;code&gt;var&lt;/code&gt; bindings act like &lt;code&gt;function&lt;/code&gt;: the names you use get “hoisted”. So:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;console.log(neverDefined);  // throws an error
console.log(definedLater);  // prints undefined
var definedLater = &amp;quot;what&amp;quot;;
console.log(definedLater);  // prints &amp;quot;what&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; behave much more like you’d expect: they’re only valid &lt;em&gt;after&lt;/em&gt; they’re defined, and they’re scoped to the blocks they appear in. (&lt;code&gt;var&lt;/code&gt; will escape things like &lt;code&gt;if&lt;/code&gt; blocks, too. It’s crazy-pants.) The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is that they create &lt;em&gt;mutable&lt;/em&gt; or &lt;em&gt;immutable&lt;/em&gt; &lt;em&gt;bindings&lt;/em&gt; to a name.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;let a = true;&lt;/code&gt; is just creating a name, &lt;code&gt;a&lt;/code&gt;, and binding the value &lt;code&gt;true&lt;/code&gt; to it. Likewise, with &lt;code&gt;const b = false;&lt;/code&gt; it’s creating a name, &lt;code&gt;b&lt;/code&gt;, and binding the value &lt;code&gt;false&lt;/code&gt; to it. And those &lt;em&gt;won’t&lt;/em&gt; be hosted. Now, having done &lt;code&gt;let a = true;&lt;/code&gt; we could on the next line write &lt;code&gt;a = false;&lt;/code&gt; and that’s fine: &lt;code&gt;let&lt;/code&gt; bindings are mutable; they can change. We’ll get an error if we try to do &lt;code&gt;b = true;&lt;/code&gt; though, because &lt;code&gt;const&lt;/code&gt; bindings are &lt;em&gt;not&lt;/em&gt; mutable.&lt;/p&gt;
&lt;p&gt;One thing to beware of with that: things like objects and arrays, being reference types, are not themselves created as immutable when you use &lt;code&gt;const&lt;/code&gt;. Rather, the specific &lt;em&gt;instance&lt;/em&gt; is immutably bound to the name. So:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const foo = { a: true };
foo.b = &amp;#39;I can add properties!&amp;#39;;  // okay
delete foo.a;  // okay
foo = { c: &amp;quot;assign a new object&amp;quot; };  // will error&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can change the internals of the item bound to the name, but not assign a new item to the name. For value types (numbers, booleans, etc.), that makes them behave like &lt;em&gt;constants&lt;/em&gt; in other languages. You have to use something like &lt;code&gt;Object.freeze&lt;/code&gt; to get actually constant object types.&lt;/p&gt;
&lt;p&gt;That was a long digression to explain what you’re seeing in a general sense with &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Finally, let’s come back around and talk about that assignment and why you need the names &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As noted, &lt;code&gt;ab()&lt;/code&gt; returns an object with two items attached, &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt;. (And again: functions are &lt;em&gt;just&lt;/em&gt; items in JS.) So you could also write that like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let theFunctions = ab();  // theFunctions is now the object returned
theFunctions.fa();  // and it has the `fa` item on it
theFunctions.fb();  // and the `fb` item, too&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, if your original &lt;code&gt;ab()&lt;/code&gt; function had returned other properties, they’d be accessible there, too, in just the same way (though they wouldn’t be callable if they weren’t functions).&lt;/p&gt;
&lt;p&gt;Again, this is a super common pattern: you want to immediately do something with the values returned on an object by some function, and you don’t necessarily want to type out the name of the object every time. So ES2015 introduced &lt;em&gt;destructuring&lt;/em&gt; to help with this problem. I’ll do it without the function in the way to show how it works at the simplest level first.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let someObject = {
  foo: &amp;#39;what is a foo anyway&amp;#39;,
  bar: &amp;#39;hey, a place to drink *or* a thing to hit people with&amp;#39;,
  quux: &amp;#39;is this like a duck&amp;#39;
};

console.log(someObject.foo);  // etc.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if we wanted to get at &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;quux&lt;/code&gt;, we could always do that with &lt;code&gt;someObject.quux&lt;/code&gt; and so on. But, especially if we have some large object floating around, we often just want a couple properties from it—say, in this case, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;quux&lt;/code&gt;. We could do that like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let foo = someObject.foo;
let quux = someObject.quux;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course those new names &lt;em&gt;don’t&lt;/em&gt; have to match:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let whatever = someObject.foo;
let weLike = someObject.quux;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, because wanting to snag just a couple items off of objects like this is so common, the shorthand is available. In the case of the shorthand for &lt;em&gt;destructuring&lt;/em&gt;, just like the case of the shorthand for object creation, the names have to match: otherwise, it wouldn’t know what to match them with.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let { foo, quux } = someObject;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, going back to your original example: &lt;code&gt;ab()&lt;/code&gt; returns an object which has the items &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt; on it. You’re using the destructuring assignment there to get just &lt;code&gt;fa&lt;/code&gt; and &lt;code&gt;fb&lt;/code&gt;. There’s no reason they &lt;em&gt;have&lt;/em&gt; to be those names in the outer scope, other than that you’re using the destructuring assignment. You could also do this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let theFunctions = ab();
let oneOfThem = theFunctions.fa;
let theOtherOne = theFunctions.fb;
oneOfThem();  // does what fa() does
theOtherOne();  // does what fb() does&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;I &lt;em&gt;think&lt;/em&gt; that covers everything your questions brought up; but please feel free to ask more!&lt;/p&gt;
&lt;p&gt;The most important thing to take away is that even though yes, those are pointers to functions under the hood, in JS that’s &lt;em&gt;absolutely&lt;/em&gt; no different than the fact that there are pointers to objects and arrays under the hood. Functions are just more items you can do things with. You can put them on objects, you can return them directly, you can take them as arguments, etc.&lt;/p&gt;
&lt;p&gt;Hopefully that’s helpful!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Bonus content: in ES2015 and later, you can also define anonymous functions like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;let someFunction = (someArg) =&amp;gt; { console.log(someArg); };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This has some interesting side effects about the value of &lt;code&gt;this&lt;/code&gt; in the body of the function you declare… but that’s for another time.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 27 Mar 2017 18:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-03-27:/2017/functions-objects-and-destructuring-in-javascript.html</guid><category>javascript</category></item><item><title>TypeScript keyof Follow-Up</title><link>http://www.chriskrycho.com/2017/typescript-keyof-follow-up.html</link><description>&lt;p&gt;I recently wrote up some neat things you can do with &lt;a href="http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html"&gt;&lt;code&gt;keyof&lt;/code&gt; and mapped types&lt;/a&gt; in TypeScript 2.1. In playing further with those bits, I ran into some interesting variations on the approach I outlined there, so here we are.&lt;/p&gt;
&lt;p&gt;In the previous post, I concluded with an example that looked like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};

type State
  = &amp;#39;Pending&amp;#39;
  | &amp;#39;Started&amp;#39;
  | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That &lt;code&gt;UnionKeyToValue&amp;lt;State&amp;gt;&lt;/code&gt; type constraint requires us to fill out the &lt;code&gt;STATE&lt;/code&gt; object as expected. The whole point of this exercise was to give us the benefit of code completion with that STATE type so we could use it and not be worried about the kinds of typos that too-often bite us with stringly-typed arguments in JavaScript.&lt;/p&gt;
&lt;p&gt;It turns out we don’t &lt;em&gt;need&lt;/em&gt; that to get completion, though. All editors which use the TypeScript language service will give us the same degree of completion if we start typing a string and then trigger completion:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="https://f001.backblazeb2.com/file/chriskrycho-com/images/more-ts.gif" title="screen capture of string completion in VS Code" alt="string completion with TypeScript 2.1" /&gt;&lt;figcaption&gt;string completion with TypeScript 2.1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Granted that you have to know this is a string (though the JetBrains &lt;abbr title="integrated development environment"&gt;IDE&lt;/abbr&gt;s will actually go a step further and suggest the right thing &lt;em&gt;without&lt;/em&gt; needing the string key). But that’s roughly equivalent to knowing you need to import the object literal constant to get the completion that way. Six one, half dozen the other, I think.&lt;/p&gt;
&lt;p&gt;This makes it something of a wash with the original approach, as long as you’re dealing in a pure-TypeScript environment. The big advantage that the original approach still has, of course, is that it also plays nicely with a mixed TypeScript and JavaScript environment. If you’re just progressively adding TypeScript to an existing JavaScript codebase, that’s possibly reason enough to stick with it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: an additional reason to prefer my original solution:&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="en"&gt;
&lt;p lang="en" dir="ltr"&gt;
&lt;a href="https://twitter.com/chriskrycho"&gt;@chriskrycho&lt;/a&gt; &lt;a href="https://twitter.com/typescriptlang"&gt;@typescriptlang&lt;/a&gt; I think a benefit of your previous solution is that you can rename keys and all their usages.
&lt;/p&gt;
— Timm (@timmpreetz) &lt;a href="https://twitter.com/timmpreetz/status/816672215924097024"&gt;January 4, 2017&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 03 Jan 2017 20:35:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-01-03:/2017/typescript-keyof-follow-up.html</guid><category>programming languages</category><category>software development</category><category>typescript</category><category>javascript</category></item><item><title>The Itch</title><link>http://www.chriskrycho.com/2016/the-itch.html</link><description>&lt;p&gt;It took me until just a few weeks ago to put my finger on why typed functional programming, as a style and approach, has appealed to me so much as I started picking it up over the last year. For all its novelty, typed FP feels—over and over again—&lt;em&gt;familiar&lt;/em&gt;. Strange to say, but it’s true.&lt;/p&gt;
&lt;p&gt;This came home to me again when reading a &lt;a href="https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6#.e887yz63p"&gt;short post on functors&lt;/a&gt;—i.e., &lt;em&gt;mappable&lt;/em&gt; types. I’ve written a lot of JavaScript in the last few years, and it has been a source of constant frustration to me that &lt;code&gt;Array&lt;/code&gt; implements the &lt;code&gt;map&lt;/code&gt; method, but &lt;code&gt;Object&lt;/code&gt; does not. Countless times, I have wanted to take an object shaped like &lt;code&gt;{ count: &amp;lt;number&amp;gt; }&lt;/code&gt; and transform that &lt;code&gt;count&lt;/code&gt;. I’m not alone in that. There’s a reason that libraries like &lt;a href="http://underscorejs.org"&gt;Underscore&lt;/a&gt;, &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;, and &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; all supply utilities to allow you to map over objects. There are also good reasons why it &lt;em&gt;isn’t&lt;/em&gt; implemented for on &lt;code&gt;Object.prototype&lt;/code&gt;: the reality is that coming up with a predictable &lt;em&gt;and&lt;/em&gt; useful API for &lt;em&gt;all&lt;/em&gt; &lt;code&gt;Object&lt;/code&gt; instances is difficult at best: Objects are used for everything from dictionaries to records and strange combinations of the two. But still: there’s something there.&lt;/p&gt;
&lt;p&gt;And reading this post on functors, it struck me what that “something” is: object types are, in principle, functors. Maybe it doesn’t make sense to have a single &lt;code&gt;map&lt;/code&gt; implementation for every &lt;code&gt;Object&lt;/code&gt; instance out there. But they’re perfectly mappable. I didn’t have a word for this before tonight, but now I do. Over and over again, this is my experience with functional programming.&lt;/p&gt;
&lt;p&gt;There’s this familiar feeling of frustration I’m slowly coming to recognize—a mental sensation which is a little like the intellectual equivalent of an itch in a spot you can’t quite reach. You’re reaching for an abstraction to express an idea, but you don’t even know that there &lt;em&gt;is&lt;/em&gt; an abstraction for it. You want to map over objects, and you don’t know why that seems so reasonable, but it does. And then someone explains functors to you. It scratches the itch.&lt;/p&gt;
&lt;p&gt;Another example. Since I started programming eight and a half years ago, I’ve worked seriously with Fortran, C, C++ PHP, Python, and JavaScript. In each of those languages (and especially in the C-descended languages), I have found myself reaching for enums or things like them as a way of trying to represent types and states in my system in a more comprehensive way. I figured out that you should &lt;a href="http://wiki.c2.com/?UseEnumsNotBooleans"&gt;use enums not booleans&lt;/a&gt; a long time before I found the advice on the internet. I was encoding error types as enum values instead of just using &lt;code&gt;int&lt;/code&gt;s almost as soon as I started, because it was obvious to me that &lt;code&gt;ErrorCode someFunction() { ... }&lt;/code&gt; was far more meaningful than &lt;code&gt;int someFunction() { ... }&lt;/code&gt; (even if the context of C meant that the latter often implied the former, and even if it was trivial to coerce one to the other).&lt;/p&gt;
&lt;p&gt;Then I read &lt;a href="https://gumroad.com/l/maybe-haskell/"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt;, a book I’ve mentioned often on this blog because it was so revelatory for me. This is what I had been reaching for all those years—and then some. Handing data around with the constraints? Yes, please! I had played with unions, enums, structs with enums inside them, anything to try to get some type-level clarity and guarantees about what my code was doing. Haskell showed me the way; and since then Rust and Elm and F# have reinforced it many times over. &lt;a href="https://guide.elm-lang.org/types/union_types.html"&gt;Tagged unions&lt;/a&gt; are a joy. They let me say what I mean—finally.&lt;/p&gt;
&lt;p&gt;I can still feel that itch. It’s shifted a little, but it’s still there: reaching for higher abstractions to let me tell the machine more clearly what I intend. Half a dozen times this year, I’ve realized: &lt;em&gt;Here&lt;/em&gt; is where dependent types would be useful. They’re far beyond me, but close enough now I can see. I’m sure a year from now, I’ll have find some tools to scratch &lt;em&gt;these&lt;/em&gt; itches, only to discover a few more.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 19 Dec 2016 21:45:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-19:/2016/the-itch.html</guid><category>software development</category><category>functional programming</category><category>Rust</category><category>JavaScript</category></item><item><title>keyof and Mapped Types In TypeScript 2.1</title><link>http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html</link><description>&lt;p&gt;In the last few months, I’ve been playing with both &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt; and &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; as tools for increasing the quality and reliability of the JavaScript I write at Olo. Both of these are syntax that sits on top of normal JavaScript to add type analysis—basically, a form of &lt;a href="https://en.wikipedia.org/wiki/Gradual_typing"&gt;gradual typing&lt;/a&gt; for JS.&lt;/p&gt;
&lt;p&gt;Although TypeScript’s tooling has been better all along&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I initially preferred Flow’s type system quite a bit: it has historically been much more focused on &lt;a href="http://stackoverflow.com/questions/21437015/soundness-and-completeness-of-systems"&gt;soundness&lt;/a&gt;, especially around the &lt;em&gt;many&lt;/em&gt; problems caused by &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, than TypeScript. And it had earlier support for &lt;a href="https://flowtype.org/docs/disjoint-unions.html"&gt;tagged unions&lt;/a&gt;, a tool I’ve come to find invaluable since picking them up from my time with Rust.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But the 2.0 and 2.1 releases of TypeScript have changed the game substantially, and it’s now a &lt;em&gt;very&lt;/em&gt; compelling language in its own right—not to mention a great tool for writing better JavaScript. So I thought I’d highlight how you can get a lot of the benefits you would get from the type systems of languages like Elm with some of those new TypeScript features: the &lt;em&gt;&lt;code&gt;keyof&lt;/code&gt; operator&lt;/em&gt; and &lt;em&gt;mapped types&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i&gt;Some readers may note that what I’m doing here is a &lt;em&gt;lot&lt;/em&gt; of wrangling to cajole TypeScript into giving me the kinds of things you get for free in an ML-descended language. Yep. The point is that you &lt;em&gt;can&lt;/em&gt; wrangle it into doing this.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="plain-old-javascript" class="level3"&gt;
&lt;h3&gt;Plain old JavaScript&lt;/h3&gt;
&lt;p&gt;Let’s say we want to write a little state machine in terms of a function to go from one state to the next, like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case &amp;#39;Pending&amp;#39;: return &amp;#39;Started&amp;#39;;
    case &amp;#39;Started&amp;#39;: return &amp;#39;Completed&amp;#39;;
    case &amp;#39;Completed&amp;#39;: return &amp;#39;Completed&amp;#39;;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will work, and it’ll even throw an error if you hand it the wrong thing. But you’ll find out at runtime if you accidentally typed &lt;code&gt;nextState('Pednign')&lt;/code&gt; instead of &lt;code&gt;nextState('Pending')&lt;/code&gt;—something I’ve done more than once in the past. You’d have a similar problem if you’d accidentally written &lt;code&gt;case 'Strated'&lt;/code&gt; instead of &lt;code&gt;case 'Started'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many contexts like this one in JavaScript—perhaps the most obvious being &lt;a href="http://redux.js.org/docs/basics/Actions.html"&gt;Redux actions&lt;/a&gt;, but I get a lot of mileage out of the pattern in Ember, as well. In these contexts, I find it’s convenient to define types that are kind of like pseudo-enums or pseudo-simple-unions, like so:&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you’ve defined an object this way, instead of using strings directly in functions that take it as an argument, like &lt;code&gt;nextState('Started')&lt;/code&gt;, you can use the object property: &lt;code&gt;nextState(STATE.Started)&lt;/code&gt;. You can rewrite the function body to use the object definition instead as well:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case STATE.Pending: return STATE.Started;
    case STATE.Started: return STATE.Completed;
    case STATE.Completed: return STATE.Completed;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the object and its keys instead gets you something like a namespaced constant. As a result, you can get more help with things like code completion from your editor, along with warnings or errors from your linter if you make a typo. You’ll also get &lt;em&gt;slightly&lt;/em&gt; more meaningful error messages if you type the wrong thing. For example, if you type &lt;code&gt;STATE.Strated&lt;/code&gt; instead of &lt;code&gt;STATE.Started&lt;/code&gt;, any good editor will give you an error—especially if you’re using a linter. At Olo, we use &lt;a href="http://eslint.org"&gt;ESLint&lt;/a&gt;, and we have it &lt;a href="https://github.com/ember-cli/ember-cli-eslint/"&gt;set up&lt;/a&gt; so that this kind of typo/linter error fails our test suite (and we never merge changes that don’t pass our test suite!).&lt;/p&gt;
&lt;p&gt;This is about as good a setup as you can get in plain-old JavaScript. As long as you’re disciplined and always use the object, you get some real benefits from using this pattern. But you &lt;em&gt;always&lt;/em&gt; have to be disciplined. If someone who is unfamiliar with this pattern types &lt;code&gt;nextState('whifflebats')&lt;/code&gt; somewhere, well, we’re back to blowing up at runtime. Hopefully your test suite catches that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="typescript-to-the-rescue" class="level3"&gt;
&lt;h3&gt;TypeScript to the rescue&lt;/h3&gt;
&lt;p&gt;TypeScript gives us the ability to &lt;em&gt;guarantee&lt;/em&gt; that the contract is met (that we’re not passing the wrong value in). As of the latest release, it also lets us guarantee the &lt;code&gt;STATES&lt;/code&gt; object to be set up the way we expect. And last but not least, we get some actual productivity boosts when writing the code, not just when debugging it.&lt;/p&gt;
&lt;p&gt;Let’s say we decided to constrain our &lt;code&gt;nextState&lt;/code&gt; function so that it had to both take and return some kind of &lt;code&gt;State&lt;/code&gt;, representing one of the states we defined above. We’ll leave a &lt;code&gt;TODO&lt;/code&gt; here indicating that we need to figure out how to write the type of &lt;code&gt;State&lt;/code&gt;, but the function definition would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// TODO: figure out how to define `State`
function nextState(state: State): State {
  // the same body...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript has had &lt;a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt; since the &lt;a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html"&gt;1.4 release&lt;/a&gt; so they might seem like an obvious choice, and indeed we could write easily a type definition for the strings in &lt;code&gt;STATES&lt;/code&gt; as a union:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, you can’t write something like &lt;code&gt;State.Pending&lt;/code&gt; somewhere; you have to write the plain string &lt;code&gt;'Pending'&lt;/code&gt; instead. You still get some of the linting benefits you got with the approach outlined above via TypeScript’s actual type-checking, but you don’t get &lt;em&gt;any&lt;/em&gt; help with autocompletion. Can we get the benefits of both?&lt;/p&gt;
&lt;p&gt;Yes! (This would be a weird blog post if I just got this far and said, “Nope, sucks to be us; go use Elm instead.”)&lt;/p&gt;
&lt;p&gt;As of the 2.1 release, TypeScript lets you define types in terms of keys, so you can write a type like this:&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can use that type any place you need to constrain the type of a variable, or a return, or whatever:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const goodState: StateFromKeys = STATE.Pending;

// error: type &amp;#39;&amp;quot;Blah&amp;quot;&amp;#39; is not assignable to type &amp;#39;State&amp;#39;
const badState: StateFromKeys = &amp;#39;Blah&amp;#39;;

interface StateMachine {
  (state: StateFromKeys): StateFromKeys;
}

const nextState: StateMachine = (state) =&amp;gt; {
  // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The upside to this is that now you can guarantee that anywhere you’re supposed to be passing one of those strings, you &lt;em&gt;are&lt;/em&gt; passing one of those strings. If you pass in &lt;code&gt;'Compelte'&lt;/code&gt;, you’ll get an actual error—just like if we had used the union definition above. At a minimum, that will be helpful feedback in your editor. Maximally, depending on how you have your project configured, it may not even generate any JavaScript output.&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; So that’s a significant step forward beyond what we had even with the best linting rules in pure JavaScript.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="going-in-circles" class="level3"&gt;
&lt;h3&gt;Going in circles&lt;/h3&gt;
&lt;p&gt;But wait, we can do more! TypeScript 2.1 &lt;em&gt;also&lt;/em&gt; came with a neat ability to define “mapped types,” which map one object type to another. They have a few &lt;a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#mapped-types"&gt;interesting examples&lt;/a&gt; which are worth reading. What’s interesting to us here is that you can write a type like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in keyof typeof STATE]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course, you can simplify that using the type we defined above, since &lt;code&gt;StateFromKeys&lt;/code&gt; was just &lt;code&gt;keyof typeof STATE&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve now defined an object type whose &lt;em&gt;key&lt;/em&gt; has to be one of the items in the &lt;code&gt;State&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Now, by itself, this isn’t all that useful. Above, we defined that as the keys on the &lt;code&gt;STATE&lt;/code&gt; object, but if we tried to use that in conjunction with this new type definition, we’d just end up with a recursive type definition: &lt;code&gt;StateFromKeys&lt;/code&gt; defined as the keys of &lt;code&gt;STATE&lt;/code&gt;, &lt;code&gt;StateAsMap&lt;/code&gt; defined in terms of the elements of &lt;code&gt;StateFromKeys&lt;/code&gt;, and then &lt;code&gt;STATE&lt;/code&gt; defined as a &lt;code&gt;StateAsMap&lt;/code&gt;…&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: StateAsMap = {
  Pending: &amp;#39;Pending&amp;#39;,
  Active: &amp;#39;Active&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}

type StateFromKeys = keyof typeof STATE;

type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You end up with multiple compiler errors here, because of the circular references. This approach won’t work. If we take a step back, though, we can work through this (and actually end up someplace better).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="join-forces" class="level3"&gt;
&lt;h3&gt;Join forces!&lt;/h3&gt;
&lt;p&gt;First, let’s start by defining the mapping generically. After all, the idea here was to be able to use this concept all over the place—e.g. for &lt;em&gt;any&lt;/em&gt; Redux action, not just one specific one. We don’t need this particular &lt;code&gt;State&lt;/code&gt;; we just need a constrained set of strings (or numbers) to be used as the key of an object:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type MapKeyAsValue&amp;lt;Key extends string&amp;gt; = {
  [K in Key]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In principle, if we didn’t have to worry about the circular references, we could use that to constrain our definition of the original &lt;code&gt;STATE&lt;/code&gt; itself:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: MapKeyAsValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how to get around the problem of circular type definitions? Well, it turns out that the &lt;code&gt;K&lt;/code&gt; values in these &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; and &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; types are equivalent:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// Approach 1, using an object
const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;
type StateObjectKeyToValue = {
  [K in StateFromKeys]: K  // &amp;lt;- K is just the keys!
};

// Approach 2, using unions
type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;
type StateUnionKeyToValue = {
  [K in StateUnion]: K  // &amp;lt;- K is also just the keys!
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, unlike the &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; version, &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; doesn’t make any reference to the &lt;code&gt;STATE&lt;/code&gt; object. So we can use &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; to constrain &lt;code&gt;STATE&lt;/code&gt;, and then just use &lt;code&gt;StateUnion&lt;/code&gt; to constrain all the places we want to &lt;em&gt;use&lt;/em&gt; one of those states. Once we put it all together, that would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

type StateUnionKeyToValue = {
  [K in StateUnion]: K
};

const STATE: StateUnionKeyToValue = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By doing this, we get two benefits. First, &lt;code&gt;STATE&lt;/code&gt; now has to supply the key and value for &lt;em&gt;all&lt;/em&gt; the union’s variants. Second, we know that the key and value are the same, and that they map to the union’s variants. These two facts mean that we can be 100% sure that wherever we define something as requiring a &lt;code&gt;State&lt;/code&gt;, we can supply one of the items on &lt;code&gt;STATE&lt;/code&gt; and it will be guaranteed to be correct. If we change the &lt;code&gt;State&lt;/code&gt; union definition, everything else will need to be updated, too.&lt;/p&gt;
&lt;p&gt;Now we can make this generic, so it works for types besides just this one set of states—so that it’ll work for &lt;em&gt;any&lt;/em&gt; union type with string keys, in fact. (That string-key constraint is important because objects in TypeScript can currently only use strings or numbers as keys; whereas union types can be all sorts of things.) Apart from that constraint on the union, though, we can basically just substitute a generic type parameter &lt;code&gt;U&lt;/code&gt;, for “union,” where we had &lt;code&gt;StateUnion&lt;/code&gt; before.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then any object we say conforms to this type will take a union as its type parameter, and every key on the object must have exactly the same value as the key name:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If any of those don’t have &lt;em&gt;exactly&lt;/em&gt; the same value as the key name, you’ll get an error. So, each of the following value assignments would fail to compile, albeit for different reasons (top to bottom: capitalization, misspelling, and missing a letter).&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const BAD_STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;pending&amp;#39;,  // look ma, no capitals
  Started: &amp;#39;Strated&amp;#39;,  // St-rated = whuh?
  Completed: &amp;#39;Complete&amp;#39;,  // so tense
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll see a compiler error that looks something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="line-block"&gt;[ts]&lt;br /&gt;
Type ‘{ Pending: “pending”; Started: “Strated”; Completed: “Complete” }’ is not assignable to type ‘UnionKeyToValue&lt;State&gt;’.&lt;br /&gt;
  Types of property ‘Pending’ are incompatible.&lt;br /&gt;
    Type ‘“pending”’ is not assignable to type ‘“Pending”’.&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the key and the name don’t match, the compiler tells us we didn’t keep the constraint we defined on what these types should look like. Similarly, if you forget an item from the union, you’ll get an error. If you add an item that isn’t in the original union, you’ll get an error. Among other things, this means that you can be confident that if you add a value to the union, the rest of your code won’t compile until you include cases for it. You get all the power and utility of using union types, &lt;em&gt;and&lt;/em&gt; you get the utility of being able to use the object as a namespace of sorts.&lt;a href="#fn6" class="footnote-ref" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And the TypeScript language service—which you can use from a &lt;em&gt;lot&lt;/em&gt; of editors, including VS Code, Atom, Sublime Text, and the JetBrains IDEs—will actually give you the correct completion when you start definition a type. So imagine we were defining some other union type elsewhere in our program to handle events. Now we can use the same &lt;code&gt;UnionKeyToValue&lt;/code&gt; type to construct this type, with immediate, &lt;em&gt;correct&lt;/em&gt; feedback from the TypeScript language service:&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt;
&lt;source type='video/mp4' src='https://f001.backblazeb2.com/file/chriskrycho-com/images/completion.mp4'&gt;
&lt;/video&gt;
&lt;figcaption&gt;
TypeScript live code completion of the mapped type
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;By inverting our original approach of using &lt;code&gt;keyof&lt;/code&gt; (itself powerful and worth using in quite a few circumstances) and instead using the new mapped types, we get a &lt;em&gt;ton&lt;/em&gt; of mileage in terms of productivity when using these types—errors prevented, and speed of writing the code in the first place increased as well.&lt;/p&gt;
&lt;p&gt;Yes, it’s a little verbose and it does require duplicating the strings whenever you define one of these types.&lt;a href="#fn7" class="footnote-ref" id="fnref7"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; But, and this is what I find most important: there is only one &lt;em&gt;source&lt;/em&gt; for those string keys, the union type, and it is definitive. If you change that central union type, everything else that references it, including the namespace-like object, will fail to compile until you make the same change there.&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt;
&lt;source type='video/mp4' src='https://f001.backblazeb2.com/file/chriskrycho-com/images/change-union.mp4'&gt;
&lt;/video&gt;
&lt;figcaption&gt;
Updating a union
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;So it’s a lot more work than it would be in, say, Elm. But it’s also a lot more guarantees than I’d get in plain-old-JavaScript, or even TypeScript two months ago.&lt;/p&gt;
&lt;p&gt;I’ll call that a win.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;it’s no surprise that Microsoft’s developer tooling is stronger than Facebook’s&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;along with all the other ML-descended languages I’ve played with, including Haskell, F&lt;sup&gt;♯&lt;/sup&gt;, PureScript, and Elm.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Aside: to be extra safe and prevent any confusion or mucking around, you should probably call &lt;code&gt;Object.freeze()&lt;/code&gt; on the object literal, too:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = Object.freeze({
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both convention and linters make it unlikely you’ll modify something like this directly—but impossible is better than unlikely.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Flow has supported this feature for some time; you can write &lt;code&gt;$Keys&amp;lt;typeof STATE&amp;gt;&lt;/code&gt;—but the feature is entirely undocumented.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Set your &lt;code&gt;&amp;quot;compilerOptions&amp;quot;&lt;/code&gt; key in your &lt;code&gt;tsconfig.json&lt;/code&gt; to include &lt;code&gt;&amp;quot;noEmitOnError&amp;quot;: true,&lt;/code&gt;.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;For namespacing in a more general sense, you should use… &lt;a href="http://www.typescriptlang.org/docs/handbook/namespaces.html"&gt;namespaces&lt;/a&gt;.&lt;a href="#fnref6" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7"&gt;&lt;p&gt;It would be great if we could get these benefits without the duplication—maybe someday we’ll have better support in JS or TS natively.&lt;a href="#fnref7" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 17 Dec 2016 23:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-17:/2016/keyof-and-mapped-types-in-typescript-21.html</guid><category>javascript</category><category>typescript</category><category>software development</category><category>programming languages</category></item><item><title>What is Functional Programming?</title><link>http://www.chriskrycho.com/2016/what-is-functional-programming.html</link><description>&lt;p&gt;&lt;i class='editorial'&gt;The following is a script I wrote for a tech talk I gave on functional programming. The recording isn’t (and won’t be) publicly available; but a script is often easier to reference anyway!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; updated with corrected performance characterstics.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Hello, everyone. Today, we are going to talk about functional programming—asking what it is, and why we should care.&lt;/p&gt;
&lt;section id="clearing-the-table-functional-programmings-reputation" class="level2"&gt;
&lt;h2&gt;Clearing the Table: Functional Programming’s Reputation&lt;/h2&gt;
&lt;p&gt;Functional programming has something of a reputation: on the one hand, as incredible difficult, dense, full of mathematical jargon, applicable only to certain fields like machine learning or massive data analysis; on the other hand, as a kind of panacea that solves all of your problems. The reality, I think, is a little bit of both.&lt;/p&gt;
&lt;p&gt;The world of functional programming &lt;em&gt;does&lt;/em&gt; include a lot of jargon from the math world, and there are good reasons for that, but there is also a lot we could do to make it more approachable to people who don’t have a background in, say category. Category theory is useful, of course, and I think there are times when we might want to be able to draw on it. But gladly, functional programming doesn’t require you to know what an &lt;em&gt;applicative functor&lt;/em&gt; is to be able to use it. (And, gladly, there’s a lot of increasingly-solid teaching material out there about functional programming which &lt;em&gt;doesn’t&lt;/em&gt; lean on math concepts.)&lt;/p&gt;
&lt;p&gt;On the other side, functional programming does give us some real and serious benefits, and that’s what I’m going to spend the first third or so of this talk looking at. But of course, it’s still just a tool, and even though it is a very helpful and very powerful tool, it can’t keep us from writing bugs. Still, every tool we can add to our belt for writing correct software is a win.&lt;/p&gt;
&lt;p&gt;One more prefatory note before we get into the meat of this talk: unfamiliar terminology is not specific to functional programming. So, yes, when you see this list, it might seem a little out there:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functor&lt;/li&gt;
&lt;li&gt;Applicative&lt;/li&gt;
&lt;li&gt;Monoid&lt;/li&gt;
&lt;li&gt;Monad&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And in truth, a number of those could have better names. &lt;em&gt;But&lt;/em&gt; we have plenty of terminology we throw around in the world of imperative, object-oriented programming. To pick just one, obvious and easy example—what are the &lt;abbr&gt;SOLID&lt;/abbr&gt; principles?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single reponsibility&lt;/li&gt;
&lt;li&gt;Open/closed&lt;/li&gt;
&lt;li&gt;Liskov substitution&lt;/li&gt;
&lt;li&gt;Interface segregation&lt;/li&gt;
&lt;li&gt;Dependency inversion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may not remember what it felt like the first time you encountered &lt;abbr&gt;SOLID&lt;/abbr&gt;, but suffice it to say: “Liskov substitution principle” isn’t any more intuitive or obvious than “Monad”. You’re just familiar with one of them. The same is true of “applicative” and “Visitor pattern”. And so on. Granted, again: it would be nice for some of these things to have easier names, a &lt;em&gt;big&lt;/em&gt; part of the pain here is just unfamiliarity.&lt;/p&gt;
&lt;p&gt;So, with that out of the way, what &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming" class="level2"&gt;
&lt;h2&gt;What is functional programming?&lt;/h2&gt;
&lt;p&gt;Functional programming is a style of programming that uses &lt;em&gt;pure functions&lt;/em&gt; and &lt;em&gt;immutable data&lt;/em&gt; for as many things as possible, and builds programs primarily out of &lt;em&gt;functions&lt;/em&gt; rather than other abstractions. I’ll define all of those terms in a moment, but first…&lt;/p&gt;
&lt;section id="why-do-we-care" class="level3"&gt;
&lt;h3&gt;Why do we care?&lt;/h3&gt;
&lt;p&gt;We care, frankly, because &lt;em&gt;we’re not that smart&lt;/em&gt;. Let’s think about some of the kinds of things we’re doing with, say, restaurant software: clients, with locations, building baskets, composed of products with options and modifiers, which have a set of rules for what combinations are allowed both of products and of their elements as making up a basket, which turn into orders, which have associated payment schemes (sometimes a lot of them), which generate data to send to a point-of-sale as well as summaries for the customer who ordered it, and so on. There are a &lt;em&gt;lot&lt;/em&gt; of moving pieces there. I’m sure a missed some non-trivial pieces, too. And if all of that is &lt;em&gt;stateful&lt;/em&gt;, that’s a lot of state to hold in your head.&lt;/p&gt;
&lt;p&gt;Let me be a bit provocative for a moment. Imagine you were reading a JavaScript module and it looked like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;var foo = 12;
var bar = &amp;#39;blah&amp;#39;;
var quux = { waffles: &amp;#39;always&amp;#39; };

export function doSomething() {
  foo = 42;
}

export function getSomething() {
  bar = quux;
  quux.waffles = &amp;#39;never&amp;#39;;
  return bar;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everyone watching would presumably say, “No that’s bad, don’t do that!” Why? Because there is &lt;em&gt;global state&lt;/em&gt; being changed by those functions, and there’s nothing about the functions which tells you what’s going on. Global variables are bad. Bad bad bad. We all know this. Why is it bad? Because you have no idea when you call &lt;code&gt;doSomething()&lt;/code&gt; or &lt;code&gt;getSomething()&lt;/code&gt; what kinds of side effects it might have. And if &lt;code&gt;doSomething()&lt;/code&gt; and &lt;code&gt;getSomething()&lt;/code&gt; affect the same data, then the order you call them in matters.&lt;/p&gt;
&lt;p&gt;In a previous job, I spent literally months chasing a bunch of bugs in a C codebase where all of the state was global. &lt;em&gt;We don’t do this anymore.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;But really, what’s different about this?&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class AThing {
  constructor() {
    this.foo = 12;
    this.bar = &amp;#39;blah&amp;#39;;
    this.quux = { waffles: &amp;#39;always&amp;#39; };
  }

  doSomething() {
    this.foo = 42;
  }

  getSomething() {
    this.bar = this.quux;
    this.quux.waffles = &amp;#39;never&amp;#39;;
    return this.bar;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have some “internal” data, just like we had in the module up above. And we have some public methods which change that state. In terms of these internals, it’s the same. There are differences in terms of having &lt;em&gt;instances&lt;/em&gt; and things like that, but in terms of understanding the behavior of the system—understanding the state involved—it’s the same. It’s global, mutable state. Now it’s not global like attaching something to the &lt;code&gt;window&lt;/code&gt; object in JavaScript, and that’s good, but still: at the module or class level, it’s just global mutable state, with no guarantees about how anything works. And this is normal—endemic, even—in object-oriented code. We encapsulate our state, but we have &lt;em&gt;tons&lt;/em&gt; of state, it’s all mutable, and as far as any given class method call is concerned, it’s all global to that class.&lt;/p&gt;
&lt;p&gt;You have no idea, when you call a given object method, what it might do. The fact that you call it with an &lt;code&gt;Int&lt;/code&gt; and get out a &lt;code&gt;String&lt;/code&gt; tells you almost nothing. For all you know, it’s triggering a &lt;abbr&gt;JSON-RPC&lt;/abbr&gt; call using the int as the &lt;abbr&gt;ID&lt;/abbr&gt; for the endpoint, which in turn triggers an operation, responds with another &lt;abbr&gt;ID&lt;/abbr&gt;, which you then use to query a database, and load a string from there, which you then set on some other member of the object instance, and then return. Should you write a method that does that? Probably not. But you can; nothing stops you.&lt;/p&gt;
&lt;p&gt;When you call a method, you have no idea what it will do. JavaScript, TypeScript, C&lt;sup&gt;♯&lt;/sup&gt;, it doesn’t matter. You have literally no idea. And that makes things &lt;em&gt;hard&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It often makes fixing bugs hard, because it means you have to figure out which particular &lt;em&gt;state&lt;/em&gt; caused the issue, and find a way to reproduce that state. Which usually means calling methods in a particular order.&lt;/li&gt;
&lt;li&gt;It makes testing hard. Again, it often entails calling methods in a particular order. It also means you often need mocks for all those outside-world things you’re trying to do.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Functional programming is an out. An escape hatch. An acknowledgement, a recognition, that holding all of this in our heads is too much for us. No one is that smart. And our software, even at its best, is hard to hold in our heads, hard to make sure that our changes don’t break something seemingly unrelated, hard to see how the pieces fit together—hard, in a phrase you’ll often hear from functional programming fans, hard to reason about.&lt;/p&gt;
&lt;p&gt;So, how do we solve these problems? With functional programming!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="what-is-functional-programming-1" class="level3"&gt;
&lt;h3&gt;What &lt;em&gt;is&lt;/em&gt; functional programming?&lt;/h3&gt;
&lt;p&gt;Functional programming is basically combining four bigs ideas:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;First class functions&lt;/li&gt;
&lt;li&gt;Higher-order functions&lt;/li&gt;
&lt;li&gt;Pure functions&lt;/li&gt;
&lt;li&gt;Immutable data&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The combination of these things leads us to a &lt;em&gt;very&lt;/em&gt; different style of programming than traditional &lt;abbr&gt;OOP&lt;/abbr&gt;. Let’s define them.&lt;/p&gt;
&lt;section id="first-class-functions-and-higher-order-functions" class="level4"&gt;
&lt;h4&gt;First class functions and higher-order functions&lt;/h4&gt;
&lt;p&gt;We’ll start by looking at the things that are probably most familiar to you if you’re a JavaScript developer (even if you haven’t necessarily heard the names): first-class functions and higher-order functions.&lt;/p&gt;
&lt;p&gt;When we talk about &lt;em&gt;first class functions,&lt;/em&gt; we mean that functions are just data—they’re first-class items in the language just like any other type. As such, a function is just another thing you can hand around as an argument to other functions. There’s no distinction between a function and a number or a string or some complex data structure. This is essential because, when you combine it with higher-order functions, it allows for incredible &lt;em&gt;simplicity&lt;/em&gt; and incredible &lt;em&gt;reusability&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Higher-order functions, in turn, are functions which take other functions as parameters or return them as their values. We’ll see this in detail in a worked example in a few, but for right now, let’s just use a really simple example that will be familiar to anyone who’s done much JavaScript: using &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we have a collection like an array and we want to transform every piece of data in it, we could of course do it with a for loop, and with iterable types we could use &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"&gt;&lt;code&gt;for ... of&lt;/code&gt;&lt;/a&gt;. But with &lt;code&gt;map&lt;/code&gt;, we can just leave the implementation details of &lt;em&gt;how&lt;/em&gt; the items in the array are iterated through, and instead worry about what we want to change. We can do that because &lt;code&gt;map&lt;/code&gt; takes functions as arguments.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(value =&amp;gt; value * 2);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We did it there with a function explicitly, but we could just as easily extract the function like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const double = value =&amp;gt; value * 2;
const initialValues = [1, 2, 3];
const doubledValues = initialValues.map(double);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is possible because &lt;em&gt;functions are just data&lt;/em&gt;—they’re first-class members of the language—and therefore &lt;em&gt;functions can be arguments or return values&lt;/em&gt;—the language supports higher-order functions.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="pure-functions" class="level4"&gt;
&lt;h4&gt;Pure functions&lt;/h4&gt;
&lt;p&gt;What about &lt;em&gt;pure functions&lt;/em&gt;? Pure functions are functions with &lt;em&gt;no effects&lt;/em&gt;. The input directly translates to the output, every time. The examples we looked at just a moment ago with &lt;code&gt;map&lt;/code&gt; are all pure functions (and it’s a really weird antipattern to use effectful functions with &lt;code&gt;map&lt;/code&gt;! Don’t do that! Use &lt;code&gt;forEach&lt;/code&gt; if you must have an effect). Here are a few more super simple examples:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const toString = (number) =&amp;gt; `The value is ${number}`;
const toLength = (list) =&amp;gt; list.length;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are some examples of straightforward functions which are &lt;em&gt;not&lt;/em&gt; pure:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const logDataFromEndpoint = (endpoint) =&amp;gt; {
  fetch(endpoint).then(response =&amp;gt; {
    console.log(response);
  });
};

let foo = 42;
const setFoo = (newValue) =&amp;gt; {
  foo = newValue;
};

const getFoo = () =&amp;gt; foo;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So a pure function is one whose output is &lt;em&gt;solely&lt;/em&gt; determined by its input That means no talking to a database, no making &lt;abbr&gt;API&lt;/abbr&gt; calls, no reading from or writing to disk.&lt;/p&gt;
&lt;p&gt;And of course, you can’t do anything meaningful with &lt;em&gt;just&lt;/em&gt; pure functions. We need user input, and we need to put the results of our computation somewhere. So the goal isn’t to write &lt;em&gt;only&lt;/em&gt; pure functions. It’s to write &lt;em&gt;mostly&lt;/em&gt; pure functions and to &lt;em&gt;isolate&lt;/em&gt; all impure functions.&lt;/p&gt;
&lt;p&gt;What this gets us is two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;A much smaller list of things to worry about when we’re looking at a given function.&lt;/li&gt;
&lt;li&gt;The ability to &lt;em&gt;compose&lt;/em&gt; functions together more easily.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have fewer things to keep in our heads when we look at any given pure function, because we don’t have to worry at all about whether something it touches has been changed by another function or not. We have inputs. We transform them into outputs. That’s it. Compare these two things in practice.&lt;/p&gt;
&lt;p&gt;Here’s a traditional &lt;abbr&gt;OOP&lt;/abbr&gt; approach:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;class Order {
  constructor() {
    this.subTotal = 0.0;
    this.taxRate = 0.01;
  }

  getTotal() {
    return this.subTotal * (1 + this.taxRate);
  }
}

const order = new Order();
order.subTotal = 42.00;

const total = order.getTotal();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the total is always dependent on what has happened in the object. If we write &lt;code&gt;order.subTotal = 43&lt;/code&gt;, &lt;code&gt;order.total&lt;/code&gt; will change. So if we want to test how &lt;code&gt;total&lt;/code&gt; behaves, or if there’s a bug in it, we need to make sure we’ve made all the appropriate transformations to the object ahead of time. That’s no big deal here; the &lt;code&gt;total&lt;/code&gt; getter is incredibly simple (and in fact, we’d normally just write it with a property getter). But still, we have to construct an order and make sure all the relevant properties are set to get the right value out of &lt;code&gt;getTotal()&lt;/code&gt;. Things outside the method call itself affect what we get back. We have no way to test &lt;code&gt;getTotal()&lt;/code&gt; by itself, and no way to debug it if there’s a bug without first doing some object setup.&lt;/p&gt;
&lt;p&gt;Now, here’s a functional approach.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const order = {
  subTotal: 42.0,
  taxRate: 0.01
}

const getTotal = (subTotal, taxRate) =&amp;gt; subTotal * (1 + taxRate);
const total = getTotal(order.subTotal, order.taxRate);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the object is &lt;em&gt;just data&lt;/em&gt;. It’s a &lt;em&gt;record&lt;/em&gt;. And the function just takes a couple of arguments. If there needed to be a more complicated transformation internally, we could do that just as easily. Note that it also decouples the structure of the data from the actual computation (though we could pass in a record as well if we had a good reason to).&lt;/p&gt;
&lt;p&gt;This makes it easily testable, for free. Want to make sure different tax rates get the correct output? Just… pass in a different tax rate. You don’t have to do any complicated work setting up an object instance first (which is especially important for more complex data types). It also makes it easier to chase down any bugs: the only thing you have to care about is that simple function body. There’s no other state to think about, because there’s no state at all here from the perspective of the function: just inputs and outputs.&lt;/p&gt;
&lt;p&gt;This has one other &lt;em&gt;really&lt;/em&gt; important consequence, which goes by the name &lt;strong&gt;referential transparency&lt;/strong&gt;. All that means is that anywhere you see a pure function, you can always substitute the value it produces, or vice versa. This is quite unlike the &lt;code&gt;Order::getTotal()&lt;/code&gt; method, where (a) it’s attached to an object instance and (b) it’s dependent on other things about that object. You can’t just substitute it in, or freely move it around, when you’re doing a refactor. &lt;em&gt;Maybe&lt;/em&gt; you can, but you’d better hope that all the other state is shuffled around with it correctly. Whereas, with the standalone &lt;code&gt;getTotal()&lt;/code&gt; function, all you need is its arguments, and you’ll always get the same thing back.&lt;/p&gt;
&lt;p&gt;This is just like math: if you say, &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt; = 5&lt;/span&gt; when solving an algebraic equation, you can put &lt;span class="math inline"&gt;5&lt;/span&gt; &lt;em&gt;anywhere you see &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt;&lt;/em&gt;; or, if it’s useful for factoring the equation or something, you can just as easily put &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; anywhere you see &lt;span class="math inline"&gt;5&lt;/span&gt;. And in math, that’s true for &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt; as well. When we use pure functions, it’s true for programming, too! That makes refactoring much easier.&lt;/p&gt;
&lt;p&gt;As we’ll see in the example I walk through in a minute, it also lets us &lt;em&gt;compose&lt;/em&gt; functions together far more easily. If all we have are inputs and outputs, then I can take the output from one function and use it as the input to the next.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="immutable-data" class="level4"&gt;
&lt;h4&gt;Immutable data&lt;/h4&gt;
&lt;p&gt;Complementing the use of mostly pure functions is to use &lt;em&gt;immutable data&lt;/em&gt;. Instead of having objects which we mutate, we create copies of the data as we transform it.&lt;/p&gt;
&lt;p&gt;You’re probably wondering how in the world this can work (and also how you avoid it being incredibly computationally expensive). For the most part, we can rely on two things: smart compilers and runtimes, and the fact that we often don’t need to reuse the &lt;em&gt;exact&lt;/em&gt; same data because we’re transforming it. However, as we’ll see below, in languages which don’t have native support for immutability, it can impose a performance penalty. Gladly, there are ways to work around this!&lt;/p&gt;
&lt;hr /&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="a-worked-example" class="level2"&gt;
&lt;h2&gt;A Worked Example&lt;/h2&gt;
&lt;p&gt;Let’s get down to a real example of these ideas. This is a ‘code kata’ I do every so often. In this particular kata, you get a list of burger orders which looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;[
  { condiments: [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;, &amp;#39;pickles&amp;#39;] },
  { condiments: [&amp;#39;tomatoes&amp;#39;] },
  { condiments: [&amp;#39;mustard&amp;#39;, &amp;#39;ketchup&amp;#39;] },
  // etc...
]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’re supposed to take this list (of 10,000-some-odd burger variations!) and determine what the top ten most common orders (not just condiments, but orders) are. (The truth is, the list actually mostly looks like &lt;code&gt;condiments: ['ketchup']&lt;/code&gt; over and over again.) So as a preliminary, you can assume that the data is being loaded like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getBurgers = () =&amp;gt;
  fetch(&amp;#39;http://files.example.com/burgers.json&amp;#39;)
    .then(request =&amp;gt; request.json());&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we’ll print our results (which will always end up in the same format) like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const descAndCountToOutput = descAndCount =&amp;gt; `${descAndCount[0]}: ${descAndCount[1]}`;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is actually a perfect case to demonstrate how functional programming ideas can help us solve a problem.&lt;/p&gt;
&lt;section id="imperative" class="level3"&gt;
&lt;h3&gt;Imperative&lt;/h3&gt;
&lt;p&gt;First, let’s look at what I think is a &lt;em&gt;relatively&lt;/em&gt; reasonable imperative approach. Our basic strategy will be:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  let totals = {};

  // 2. Build up a mapping from description to count.
  for (let burger of burgers) {
    // 1. Convert condiments to descriptions.
    // 1.1. Convert the objects to just their lists of condiments.
    const condiments = burger.condiments;
    // 1.2. Sort those strings.
    condiments.sort();
    // 1.3. Turn them into descriptions by joining them with a comma.
    const description = condiments.join(&amp;#39;, &amp;#39;);

    // 2. Build up a mapping from description to count.
    const previousCount = totals[description];
    totals[description] = previousCount ? previousCount + 1 : 1;
  }

  // 3. Sort that by count.
  const sortableCondiments = Object.entries(totals);
  sortableCondiments.sort((a, b) =&amp;gt; b[1] - a[1]);
  // 4. Get the top 10.
  const topTen = sortableCondiments.slice(0, 10);
  // 5. Print out the results.
  for (let descAndCount of topTen) {
    console.log(descAndCountToOutput(descAndCount));
  }
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s pretty well-factored. But it’s pretty wrapped up on the specific details of this problem, and there’s basically nothing here I could reuse. It’s also relatively hard to test. There aren’t really a lot of pieces there we could break up into smaller functions if we wanted to figure out why something was broken. The way you’d end up fixing a bug here is probably by dropping &lt;code&gt;debugger&lt;/code&gt; or &lt;code&gt;console.log()&lt;/code&gt; statements in there to see what the values are at any given spot.&lt;/p&gt;
&lt;p&gt;And this is where functional programming really does give us a better way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="functional" class="level3"&gt;
&lt;h3&gt;Functional&lt;/h3&gt;
&lt;p&gt;Instead of thinking about the specific details of &lt;em&gt;how&lt;/em&gt; to get from A to B, let’s think about what we start with and what we finish with, and see if we can build up a pipeline of transformations that will get us there.&lt;/p&gt;
&lt;p&gt;We start with a &lt;em&gt;list&lt;/em&gt; of &lt;em&gt;objects&lt;/em&gt; containing &lt;em&gt;arrays&lt;/em&gt; of &lt;em&gt;strings&lt;/em&gt;. We want to end up with a &lt;em&gt;list&lt;/em&gt; of the &lt;em&gt;distinct combinations&lt;/em&gt; and their &lt;em&gt;frequency&lt;/em&gt;. How can we do this? Well, the basic idea is the same as what we did above:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Convert condiments to descriptions.
&lt;ol type="1"&gt;
&lt;li&gt;Convert the objects to just their lists of condiments.&lt;/li&gt;
&lt;li&gt;Sort those strings.&lt;/li&gt;
&lt;li&gt;Turn them into descriptions by joining them with a comma.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Build up a mapping from description to count.&lt;/li&gt;
&lt;li&gt;Sort that by count.&lt;/li&gt;
&lt;li&gt;Get the top 10.&lt;/li&gt;
&lt;li&gt;Print out the results.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To someone acquainted with functional programming, that looks like a bunch of &lt;code&gt;map&lt;/code&gt;s, a &lt;code&gt;reduce&lt;/code&gt;, and some &lt;code&gt;sort&lt;/code&gt;s. And each of those using just simple, pure functions. Let’s see what that might look like. First, what are our transformations?&lt;/p&gt;
&lt;p&gt;The step 1 transformations are all quite straightforward:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
// 1.1. Convert the objects to just their lists of condiments.
const toCondiments = burger =&amp;gt; burger.condiments ? burger.condiments : [];
// 1.2. Sort those strings.
const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();
// 1.3. Turn them into descriptions by joining them with a comma.
const toDescriptions = condiments =&amp;gt; condiments.join(&amp;#39;, &amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 2 is a little more involved: it involves building up a new data structure (&lt;code&gt;totals&lt;/code&gt;) from an old one. This function is a &lt;em&gt;reducer&lt;/em&gt;: it will build up &lt;code&gt;totals&lt;/code&gt; by updating &lt;code&gt;totals&lt;/code&gt; with each &lt;code&gt;description&lt;/code&gt; from an array of them.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 2. Build up a mapping from description to count.
const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  totals[description] = count;
  return totals;
};

// 3. Sort that by count.
const byCount = (a, b) =&amp;gt; b[1] - a[1];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll see how to get just 10 in a moment; for now, let’s also wrap up the output:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 5. Print it out
const output = value =&amp;gt; { console.log(value); };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are our base building blocks, and we’ll re-use them in each of the approaches I cover below. Note that we’ve now taken those same basic steps from our imperative approach and turned them into standalone, testable functions. They’re small and single-purpose, which always helps. But more importantly, (with two exceptions we’ll talk about in a minute) all of those transformations are &lt;em&gt;pure functions&lt;/em&gt;, we know that we’ll get the same results every time we use them. If I want to make sure that burger condiments are converted correctly, I can test &lt;em&gt;just that function&lt;/em&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;describe(&amp;#39;toCondiments&amp;#39;, () =&amp;gt; {
  it(&amp;#39;returns an empty list when there is no `condiments`&amp;#39;, () =&amp;gt; {
    toCondiments({}).should.deepEqual([]);
  });

  it(&amp;#39;returns the list of condiments when it is passed&amp;#39;, () =&amp;gt; {
    const condiments = [&amp;#39;ketchup&amp;#39;, &amp;#39;mustard&amp;#39;];
    toCondiments({ condiments }).should.deepEqual(condiments);
  });
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a trivial example, of course, but it gets the point across: all we have to do to test this is pass in an object. It doesn’t depend on anything else. It doesn’t have &lt;em&gt;any knowledge&lt;/em&gt; of how we’re going to use it. It doesn’t know that it’s going to be used with data coming from an array. All it knows is that if you give it an object with a &lt;code&gt;condiments&lt;/code&gt; property, it’ll hand you back the array attached to that property.&lt;/p&gt;
&lt;p&gt;The result is that, with all of these functions, we don’t have to deal with mocks or stubs or anything like that to be testable. Input produces output. Pure functions are great for this. Now, some of you may be thinking, “That’s great, but what about &lt;abbr&gt;I/O&lt;/abbr&gt;, or databases, or any other time we actually interact with the world? What about talking to a point-of-sale?” I actually have some tentative thoughts about a future tech talk to look at how to do that in some detail, but for today, just remember that the goal is to write as many pure functions as possible, and to isolate the rest of your code from knowing about that. And of course, that’s best practice anyway! We’re just codifying it. We’ll see what that looks like in practice in just a minute.&lt;/p&gt;
&lt;p&gt;Now, while we’re on the topic of pure functions, some of you with quick eyes may have noticed that two of these little functions we laid out are actually &lt;em&gt;not&lt;/em&gt; pure: JavaScript’s &lt;code&gt;Array.sort&lt;/code&gt; method operates in-place, for performance reasons, and so does our &lt;code&gt;toTotals&lt;/code&gt; function. So a truly pure version of the sorting function looks like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toSortedCondiments = condiments =&amp;gt; condiments.concat().sort();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, we &lt;em&gt;could&lt;/em&gt; define the &lt;code&gt;toTotals&lt;/code&gt; to return a new object every time, like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const toTotals = (totals, description) =&amp;gt; {
  const previousCount = totals[description];
  const count = previousCount ? previousCount + 1 : 1;
  const update = { [description]: count };
  return Object.assign({}, totals, update);
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, given the amount of data we’re dealing with, that’s prohibitively expensive. We end up spending a &lt;em&gt;lot&lt;/em&gt; of time allocating objects and garbage-collecting them. As a result, it’s tens of thousands of times slower. Running it on my 4GHz iMac, the in-place version takes less than 40ms. Doing it the strictly pure way—returning copies every time—takes ~53s. And if you profile it, almost all of that time is spent in &lt;code&gt;assign&lt;/code&gt; (52.95s).&lt;/p&gt;
&lt;p&gt;This takes us to an important point, though: it’s actually not a particularly big deal to have this particular data changed in place, because we’re not going to do anything &lt;em&gt;else&lt;/em&gt; with it. And in fact, under the hood, this is exactly what pure functional languages do with these kinds of transformations—precisely because it’s perfectly safe to do so, because we’re the only ones who have access to this data. We’re generating a &lt;em&gt;new&lt;/em&gt; data structure from the data that we were originally handed, and the next function will make its own new data structure (whether a copy or something else).&lt;/p&gt;
&lt;p&gt;In other words, when we’re talking about a &lt;em&gt;pure function&lt;/em&gt;, we don’t really care about internal mutability (though of course, that can bite us if we’re not careful). We’re really concerned about &lt;em&gt;external&lt;/em&gt; mutability. As long as the same inputs get the same outputs every time, the rest of the world doesn’t have to care how we got that result.&lt;/p&gt;
&lt;p&gt;Now let’s see how we use these functions.&lt;/p&gt;
&lt;section id="pure-javascript" class="level4"&gt;
&lt;h4&gt;Pure JavaScript&lt;/h4&gt;
&lt;p&gt;First, here’s a pure-JavaScript approach, but a more functional one instead of an imperative one:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const descriptionToCount = burgers
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(toDescriptions)
    .reduce(toTotals, {})

  const entries = Object.entries(descriptionToCount);

  [...entries]
    .sort(byCount)
    .slice(0, 10)  // 4. Get the top 10.
    .map(descAndCountToOutput)
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, the good: our transformation is no longer all jumbled together. In fact, our code reads a lot like our original description did. Also, notice that we just have a bunch of functions operating on data: none of the functions used here have any knowledge about where the data comes from that they operate on.&lt;/p&gt;
&lt;p&gt;But then we also have a couple things that are a &lt;em&gt;little&lt;/em&gt; bit clunky. The main thing that sticks out is that sudden stop in the chain in the middle.&lt;/p&gt;
&lt;p&gt;When we’re dealing with the &lt;code&gt;Array&lt;/code&gt; type, everything is fine, but when we convert our data into a &lt;code&gt;Map&lt;/code&gt;, we no longer have that option, so we have to jump through some hoops to do the transformation back into the data type we need. We’re stuck if the object type doesn’t have the method we need. We’re kind of trying to mash together the imperative and functional styles, and it’s leaving us in a little bit of a weird spot.&lt;/p&gt;
&lt;p&gt;There’s another issue here, though, and it’s the way that using the method-style calling convention obscures something important. When we call &lt;em&gt;most&lt;/em&gt; of those methods, we’re doing something quite different from what most &lt;em&gt;methods&lt;/em&gt; do. A method normally is an operation on an object. These methods—most of them—are operations that return &lt;em&gt;new&lt;/em&gt; objects. So it’s nice from a syntax perspective, but if we’re not &lt;em&gt;already&lt;/em&gt; familiar with the behavior of a given method, it won’t be clear at all that we’re actually generating a bunch of totally new data by calling those methods.&lt;/p&gt;
&lt;p&gt;And… two of these methods (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt;) &lt;em&gt;are&lt;/em&gt; not doing that, but are modifying an array in place instead.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="lodash" class="level4"&gt;
&lt;h4&gt;Lodash&lt;/h4&gt;
&lt;p&gt;The first step away from this problem is to use a tool like &lt;a href="https://lodash.com"&gt;Lodash&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// More functional, with _:
// We tweak how a few of these work slightly to play nicely.
const _toDescriptions = condiments =&amp;gt; _.join(condiments, &amp;#39;, &amp;#39;);
const _byCount = _.property(1);

getBurgers().then(burgers =&amp;gt; {
  const condiments = _.map(burgers, toCondiments);
  const sortedCondiments = _.map(condiments, toSortedCondiments);
  const descriptions = _.map(sortedCondiments, _toDescriptions);
  const totals = _.reduce(descriptions, toTotals, {});
  const totalPairs = _.toPairs(totals);
  const sortedPairs = _.sortBy(totalPairs, _byCount);
  const sortedPairsDescending = _.reverse(sortedPairs);
  const topTen = _.take(sortedPairsDescending, 10);
  const forOutput = _.map(topTen, descAndCountToOutput)
  _.forEach(forOutput, output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But it seems like we lost something when we moved away from the object-oriented approach. Being able to chain things, so that each item worked with the previous item, was actually pretty nice. And needing all these intermediate variables is &lt;em&gt;not&lt;/em&gt; so nice.&lt;/p&gt;
&lt;p&gt;One way around this is to use Lodash’s &lt;code&gt;_.chain&lt;/code&gt; method. That would have let us write it like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;getBurgers().then(burgers =&amp;gt; {
  const foo = _.chain(burgers)
    .map(toCondiments)
    .map(toSortedCondiments)
    .map(_toDescriptions)
    .reduce(toTotals, {})
    .toPairs()
    .sortBy(_byCount)
    .reverse()
    .take(10)
    .map(descAndCountToOutput)
    .value()
    .forEach(output);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that &lt;em&gt;is&lt;/em&gt; a win. But it only works because JavaScript is &lt;em&gt;incredibly&lt;/em&gt; dynamic and lets us change the behavior of the underlying &lt;code&gt;Array&lt;/code&gt; type. (You’d have a much harder time doing that in Java or C&lt;sup&gt;♯&lt;/sup&gt;!)&lt;/p&gt;
&lt;p&gt;Perhaps just as importantly, it requires us to make sure that we do that &lt;code&gt;_.chain()&lt;/code&gt; call on on anything we want to tackle this way. So, can we get the benefits of this some &lt;em&gt;other&lt;/em&gt; way? Well, obviously the answer is &lt;em&gt;yes&lt;/em&gt; because I wouldn’t be asking otherwise.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="with-ramda." class="level4"&gt;
&lt;h4&gt;With Ramda.&lt;/h4&gt;
&lt;p&gt;But we can actually go a bit further, and end up in a spot where we don’t need to modify the object prototype at all. We can just do this with a series of standalone functions which don’t depend on being attached to &lt;em&gt;any&lt;/em&gt; object. If we use the &lt;a href="http://ramdajs.com"&gt;Ramda&lt;/a&gt; library,&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; we can tackle this with nothing but functions.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
  R.reduce(toTotals, {}),
  R.toPairs,
  R.sortBy(R.prop(1)),  // will give us least to greatest
  R.reverse,
  R.take(10),
  R.map(descAndCountToOutput)
);

return getBurgers()
  .then(getTop10Burgers)
  .then(R.forEach(output));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice the difference between here and even where we started with Lodash: we’re no longer dependent on a specific piece of data being present. Instead, we’ve created a standalone function which can operate on that data, simply by “piping” together—that is, &lt;em&gt;composing&lt;/em&gt;—a bunch of other, smaller functions. The output from each one is used as the input for the next.&lt;/p&gt;
&lt;p&gt;One of the many small niceties that falls out of this is that we can refactor this just by pulling it apart into smaller acts of compositions.&lt;/p&gt;
&lt;p&gt;Here’s an example of how we might use that. We defined those simple transformations for the condiments as a set of three functions, which converted them from objects with &lt;code&gt;condiments&lt;/code&gt; elements, sorted them, and joined them into a string. Now, let’s build those into meaningful functions for each step:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// 1. Convert condiments to descriptions.
const burgerRecordsToDescriptions = R.pipe(
  R.map(R.prop(&amp;#39;condiments&amp;#39;)),
  R.map(R.sortBy(R.toString)),
  R.map(R.join(&amp;#39;, &amp;#39;)),
);

// 2. Build up a mapping from description to count.
const descriptionsToUniqueCounts = R.pipe(
  R.reduce(toTotals, {}),
  R.toPairs,
);

// 3. Sort that by count.
const uniqueCountsToSortedPairs = R.pipe(
  R.sortBy(R.prop(1)),
  R.reverse,
);

// For (4), to get the top 10, we&amp;#39;ll just use `R.take(10)`.
// We could also alias that, but it doesn&amp;#39;t gain us much.

// 5. Print it out
const sortedPairsToConsole = R.pipe(
  R.map(descAndCountToOutput),
  R.forEach(output)
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can put those together into another, top-level function to do &lt;em&gt;exactly&lt;/em&gt; our steps.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const getTop10Burgers = R.pipe(
  burgerRecordsToDescriptions,  // (1)
  descriptionsToUniqueCounts,   // (2)
  uniqueCountsToSortedPairs,    // (3)
  R.take(10)                    // (4)
);

getBurgers()
  .then(getTop10Burgers)
  .then(sortedPairsToConsole);  // (5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, because each step is just composing together functions, “refactoring” is easy. And, to be sure, you have to be mindful about what comes in and out of each function. But that’s true in the imperative approach, too: you always have to keep track of the state of the object you’re building up, but there you’re doing it in the middle of a loop, so you’re keeping track of a lot &lt;em&gt;more&lt;/em&gt; state at any given time. Functions with simple inputs and outputs give us a more explicit way of specifying the structure and state of the data at any given time. That’s true even in JavaScript, but it goes double if we’re in a typed language like F&lt;sup&gt;♯&lt;/sup&gt;, Elm, etc., where we can specify those types for the function as a way of designing the flow of the program. (That’s such a helpful way of solving problems, in fact, that I may also do a talk on type-driven design in the future!)&lt;/p&gt;
&lt;p&gt;Note, as well, that we’ve now completely isolated our input and output from everything else. The middle there is a chain of pure functions, built out of other pure functions, which neither know nor care that the data came in from an &lt;abbr&gt;API&lt;/abbr&gt; call, or that we’re going to print it to the console when we finish.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;So this takes us back around to that first question: why do we care? At the end of the day, is this really a win over the imperative style? Is the final version, using Ramda, really better than the pure-JavaScript mostly-functional version we used at first?&lt;/p&gt;
&lt;p&gt;Obviously, I think the answers there are yes. The Ramda version there at the end is &lt;em&gt;way&lt;/em&gt; better than the imperative version, and substantially better than even the first “functional” JavaScript versions we wrote.&lt;/p&gt;
&lt;p&gt;For me, at least, the big takeaway here is this: we just built a small but reasonable transformation of data out of a bunch of really small pieces. That has two big consequences—consequences we’ve talked about all along the way, but which you’ve now seen in practice:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Those pieces are easy to test. If something isn’t working, I can easily take those pieces apart and test them individually, or test the result of any combination of them. As a result, I can test any part of that pipe chain, and I can &lt;em&gt;fix&lt;/em&gt; pieces independent of each other. No part depends on being in the middle of a looper where transformations are done to other parts.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because they’re small and do one simple things, I can recombine those pieces any way I like. And you see that in the Ramda examples in particular: most of what we’re doing in those examples is not even something we wrote ourselves. They’re also &lt;em&gt;really&lt;/em&gt; basic building blocks, available in basically every standard library.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One last thing: if you’re curious about performance… you should know that it does matter for data at scale. In my tests (which are admittedly extremely unscientific; unfortunately, I couldn’t get JSPerf running nicely with this particular set of variations), I found that the time it took to run these varied depending on the approach &lt;em&gt;and&lt;/em&gt; the library. With a ~10k-record data set:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The imperative version, unsurprisingly, was the fastest, taking ~16–17ms.&lt;/li&gt;
&lt;li&gt;After that, the chained lodash version and the pure-&lt;abbr&gt;JS&lt;/abbr&gt; version were comparable, at ~32–36ms, or around twice as long to finish as the imperative version.&lt;/li&gt;
&lt;li&gt;The plain lodash version was consistently a &lt;em&gt;little&lt;/em&gt; slower yet, at ~38–43ms.&lt;/li&gt;
&lt;li&gt;Ramda is &lt;em&gt;slow&lt;/em&gt;: both variations consistently took over 90ms to finish.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those differences added up on larger data sets: dealing with ~10,000,000 records, the times ranged from ~12s for the imperative version, to ~15s for the lodash and pure-&lt;abbr&gt;JS&lt;/abbr&gt; variants, to ~50s for the Ramda version.&lt;/p&gt;
&lt;p&gt;They were all pretty darn quick. Compilers, including JavaScript &lt;abbr&gt;JIT&lt;/abbr&gt;s, are incredibly smart. Mostly you can just trust them; come back and profile before you even &lt;em&gt;think&lt;/em&gt; about optimizing things. But you &lt;em&gt;should&lt;/em&gt; know the performance characteristics of different libraries and consider the implications of what the language does well and what it doesn’t. Ramda is likely slower because of the way it curries every function—something that works well in languages with native support for it, e.g. F&lt;sup&gt;♯&lt;/sup&gt; or Elm or Haskell, but imposes a penalty in languages which don’t… like JavaScript. That said, if you’re not in the habit of processing tens of thousands of records, you’re probably okay using any of them.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;or &lt;a href="https://github.com/lodash/lodash/wiki/FP-Guide"&gt;lodash-fp&lt;/a&gt;, but Ramda is a bit better documented and I just like it a little better&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 11 Nov 2016 22:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-11:/2016/what-is-functional-programming.html</guid><category>software development</category><category>functional programming</category><category>javascript</category></item><item><title>Rust vs. React Native—What?</title><link>http://www.chriskrycho.com/2016/rust-vs-react-native-what.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I was recently discussing some thoughts I’ve had on building a top-notch application experience in a Slack team I belong to, and noted that I believe that a Rust core with native UIs is a &lt;em&gt;massively&lt;/em&gt; winning strategy. A friend in the group responded that he thinks “React + JS is eating the world right now” and that “Rust as awesome for if you want to write a JS vm, or something like that… or a compiler… anything involving lots of speed and stability.” What follows is my response, lightly edited to remove details specific to that friend and to add a few further thoughts.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Here’s the thing: I don’t &lt;em&gt;care&lt;/em&gt; what’s eating the world today, for three reasons:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;I just want to build the best stuff I can build, and native UIs are still massively better than React and even React Native&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; in innumerable ways. There are clear advantages to React Native + JavaScript, and times when you absolutely should take that approach. But there are also a lot of times and reasons why you shouldn’t. Heck, even if you just want killer performance &lt;em&gt;in browsers&lt;/em&gt;, our future includes things like Rust-to-WebAssembly, and that’s a good thing.&lt;/li&gt;
&lt;li&gt;What was eating the world five years ago? Ten? Is it still eating the world today? I don’t feel obliged to follow those trends (not least because, not being a consultancy, following those trends doesn’t buy me anything for the things I want to do; your tradeoffs and mine look way different).&lt;/li&gt;
&lt;li&gt;I’m actually getting really tired of just treating as acceptable or normative the performance characteristics of browsers. Browsers are awesome. But we can (and should) do a &lt;em&gt;lot&lt;/em&gt; better in terms of user experience, and I don’t see browsers catching up to what you can do with e.g. Cocoa (Touch). Sure, that doesn’t matter that much for building yet-another-storefront. (Again, there are different tradeoffs for every single app!) But why in the world are we in a spot now where one of the most popular text editors in the world is &lt;em&gt;slower&lt;/em&gt; than any text editor of five years ago? That’s not a &lt;em&gt;necessary&lt;/em&gt; decision, and you can (and should) go after the same degree of ease-of-extensibility that Atom has had—perhaps even using things like HTML and CSS for skinning!—while not tying yourself to the browser and its upsides and downsides for &lt;em&gt;everything&lt;/em&gt;. We have &lt;em&gt;incredibly&lt;/em&gt; powerful machines, and the user experience is often getting &lt;em&gt;slower&lt;/em&gt;. I’m looking for ways to change that.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again, JS+React&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; may be &lt;em&gt;exactly&lt;/em&gt; the right tradeoff for a lot of apps, and given what consultancies (like my friends’s!) are doing, I think doing that with ReactNative for apps is a &lt;em&gt;very&lt;/em&gt; good move. It makes good sense business-wise, and it makes good sense in terms of the apps you’re likely to be delivering. Don’t hear me for a second saying Rust is the best for &lt;em&gt;everything&lt;/em&gt;. I think it, or something like it, is a very good choice for &lt;em&gt;many&lt;/em&gt; things, though, and it shouldn’t be dismissed simply because it’s a very different world from doing Ruby or Elixir or JavaScript.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;So much for my initial response. On reflection, I wanted to expand it a bit. So here’s another few hundred words!&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Beyond this, I think there’s a bit of a false dichotomy here: the idea that “lots of speed and stability” &lt;em&gt;aren’t&lt;/em&gt; values we should be seeking more aggressively for &lt;em&gt;all&lt;/em&gt; our apps. Fully granted that not every app needs the same &lt;em&gt;degree&lt;/em&gt; of each of those, and moreover that there are a lot of ways to get to those goals. Still: speed and stability are &lt;em&gt;core&lt;/em&gt; user experience values. I don’t really care how you get at those goals, whether it’s with Rust, or Elixir or Clojure, or, yes, React with TypeScript or &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt;. I &lt;em&gt;do&lt;/em&gt; think that Rust is, for the moment at least, uniquely positioned to add real value in this space because it gives screaming performance but with so many niceties we’re used to when writing languages like Python or Ruby and so much of the power you get in languages like OCaml or F♯.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; But at the end of the day, I think &lt;em&gt;all&lt;/em&gt; apps should focus much more on speed and stability than they do today. We have supercomputers in our pockets, and we’re often shipping apps that are slower and more finicky.&lt;/p&gt;
&lt;p&gt;But I have this dream of a world where apps aren’t needlessly power-hungry or memory-intensive, where every swipe and or click or scroll results in buttery-smooth responses. We won’t get there by saying, “You know, Facebook is doing &lt;em&gt;x&lt;/em&gt; so that’s good enough for me.”&lt;/p&gt;
&lt;p&gt;Of course every developer, and any given product shop or consultancy, is going to have to make decisions about which stacks it invests in. If you’re primarily shipping web applications, investing in Elixir and React with React Native for your apps is a very sensible move. Most of your clients’ native apps may not &lt;em&gt;need&lt;/em&gt; the degree of polished performance you might get from writing their iOS app in Swift and their Android app in Kotlin and the core in Rust (or even C++). That tradeoff is a &lt;em&gt;tradeoff&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But let’s remember that there is real value there, and that some apps &lt;em&gt;do&lt;/em&gt; deserve that investment. We should evaluate the tradeoffs at every turn, and our core considerations should enduringly include &lt;em&gt;speed and stability&lt;/em&gt;. Don’t dismiss Rust (or Swift, or F♯) out of hand.&lt;/p&gt;
&lt;p&gt;Equally importantly, we need to stop assuming that just because something is eating the world today means it’s also the future. Betting big on Flash in the mid-2000s wasn’t a &lt;em&gt;bad&lt;/em&gt; move by a long shot. But its massive popularity then wasn’t a good predictor for its future. That goes double, frankly, for projects coming out of Facebook or Google or similar: big companies like that have the resources to drop everything and use a new language, or a new tool, as it suits them. If you don’t believe me, look at the actual open-source records of both of those companies! What’s hot today is far more relevant to a consultancy than to a product shop. And in both cases, choosing tech suitable for the job at hand is more important yet.&lt;/p&gt;
&lt;p&gt;My friend gets that, for what it’s worth. He’s making the right moves for his business as the owner of a consultancy. I just want him—and lots of other people—to see where languages like Rust and Swift and F♯ might be worth considering. And speed and stability matter in a lot of places besides just compilers and VMs.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I’m aware that React-Native ultimately binds down to native widgets. It’s still not quite the same.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;or, frankly, Ember or whatever else; React is great, but it is also overhyped.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Swift too, and honestly for a lot of things Swift is an easier experience for not &lt;em&gt;that&lt;/em&gt; much less performance than Rust. But as of today you &lt;em&gt;can’t&lt;/em&gt; ship core functionality in Swift for Android or Windows.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Oct 2016 08:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-10-07:/2016/rust-vs-react-native-what.html</guid><category>JavaScript</category><category>Rust</category><category>Swift</category><category>F Sharp</category><category>software development</category></item><item><title>Y Combinators, how do they even work?</title><link>http://www.chriskrycho.com/2016/y-combinators-how-do-they-even-work.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I was reading &lt;a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/"&gt;a post&lt;/a&gt; by &lt;a href="http://matt.might.net"&gt;Matt Might&lt;/a&gt;, a computer science professor at the University of Utah, about Y Combinators, and I was having a hard time tracking with some of it just by reading. The way I normally solve this problem is to write it out—and, optimally, to write it out in something roughly like &lt;a href="https://wiki.haskell.org/Literate_programming"&gt;Literate Haskell&lt;/a&gt; or &lt;a href="http://coffeescript.org/#literate"&gt;Literate CoffeeScript&lt;/a&gt;. That’s exactly what you’ll find below; this is basically &lt;em&gt;commentary&lt;/em&gt; on Might’s original post.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;A few other prefatory notes:&lt;/i&gt;&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;i class=editorial&gt;Since this is commentary, I’m not focusing on explaining combinators in general. For a very helpful explanation, though, both of what combinators are and why you’d ever want to use them, &lt;a href="http://programmers.stackexchange.com/a/117575"&gt;read this&lt;/a&gt;.&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=editorial&gt;The Y Combinator itself isn’t all that useful for ordinary programming. It &lt;em&gt;is&lt;/em&gt; really useful as a way of thinking about how programming &lt;em&gt;works&lt;/em&gt;, and that’s why I was reading about it and trying to figure out what was going on in Might’s original post.&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=editorial&gt;This didn’t actually all make sense to me until I also read Might’s post, &lt;a href="http://matt.might.net/articles/python-church-y-combinator/"&gt;“Equational derivations of the Y combinator and Church encodings in Python”&lt;/a&gt;. Which is a crazy post. But kind of fun. &lt;/i&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Note for background (this was new to me today): &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;v&lt;/em&gt;.&lt;em&gt;e&lt;/em&gt;&lt;/span&gt; is the function which maps v to e. In ECMAScript 2015 or later (hereafter just JS):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const λv_e = v =&amp;gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Y Combinator is a higher-order functional: it is a function which takes a functional/higher-order function. Quoting from Might:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Y combinator takes a functional as input, and it returns the (unique) fixed point of that functional as its output. A functional is a function that takes a function for its input. Therefore, the fixed point of a functional is going to be a function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And a “fixed point” is an input to a function equal to the &lt;em&gt;output&lt;/em&gt; of the function. (Not all functions have such.) A fixed point is where &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;) = &lt;em&gt;x&lt;/em&gt;&lt;/span&gt;. He uses the example &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; − 1&lt;/span&gt;, which has two solutions, two &lt;em&gt;fixed points&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;He starts out with the total recursion form—also known as the “crash all the things!” form—of the Y-combinator. (I’m using letters to denote the version of the combinator; this is Y-naive.)&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Yn = (F) =&amp;gt; F(Yn(F))  // all the recursing!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“Crash all the things”… because of one pesky little detail: it calls itself immediately, and so recurses infinitely. Which is actually kind of a problem.&lt;/p&gt;
&lt;p&gt;Might then asks: What if we transformed this a bit? He notes that we can &lt;em&gt;transform&lt;/em&gt; with lambda calculus to expand what we’re doing, so:&lt;/p&gt;
&lt;figure&gt;
&lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;) = &lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.(&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;))&lt;/span&gt;
&lt;/figure&gt;
&lt;p&gt;(I haven’t done this kind of thing since undergraduate math work I did for physics, but as I was thinking about it, it made sense. I’m used to trying to &lt;em&gt;remove&lt;/em&gt; extraneous variables when dealing with software, but in this case we’re using it as a tool for transforming the equation into a form that is &lt;em&gt;equivalent&lt;/em&gt; but &lt;em&gt;expressed differently&lt;/em&gt;.)&lt;/p&gt;
&lt;p&gt;And &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.(&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt; is equivalent to the fixed point. It’s the function which takes &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; as an argument and results in &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt;; but &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)&lt;/span&gt; is just another argument, so this looks just like our original &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;) = &lt;em&gt;x&lt;/em&gt;&lt;/span&gt;, but with &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)&lt;/span&gt; substituted for &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;&lt;/span&gt;. Can we write this in JS?&lt;/p&gt;
&lt;p&gt;Here’s my implementation, using modern JS; note that it still recurses. (I’m calling this updated Y-transformed, so &lt;code&gt;Yt&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Yt = (F) =&amp;gt; F((x) =&amp;gt; Yt(F)(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His version:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function Y(F) { return F(function(x) { return Y(F)(x); }); }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mine and his are equivalent; here’s his version transformed to modern JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; F((x) =&amp;gt; Y(F)(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Might then says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using another construct called the U combinator, we can eliminate the recursive call inside the Y combinator, which, with a couple more transformations gets us to:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I hated it when profs (or books!) did this when I was in college, and it frustrates me here, too. I want to &lt;em&gt;see&lt;/em&gt; the transformation. I really wish Might didn’t skip how the U combinator works or what transformations he applies, because then he jumps to this form:&lt;/p&gt;
&lt;figure&gt;
&lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt; = (&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)))(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)))&lt;/span&gt;
&lt;/figure&gt;
&lt;p&gt;Writing this out in JS is going to be a real bear. More to the point, I don’t know how he got to it; now I need to go look up the U Combinator it seems.&lt;/p&gt;
&lt;p&gt;…which I’ve &lt;a href="http://www.ucombinator.org"&gt;now done&lt;/a&gt;. So:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the theory of programming languages, the U combinator, &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;&lt;/span&gt;, is the mathematical function that applies its argument to its argument; that is &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;) = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;, or equivalently, &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt; = &lt;em&gt;λ&lt;/em&gt;&lt;em&gt;f&lt;/em&gt;.&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;That is, the U Combinator is the case where you apply a function to itself: &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;) = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;—you can see that in the result there, where the first expression is the same as the argument handed to it (and both are functions). It’s also there in the &lt;span class="math inline"&gt;&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;)&lt;/span&gt; calls.&lt;/li&gt;
&lt;li&gt;The transformations are just transforming from a function-argument for to a lambda form, I think. The kind of thing where you go from &lt;code&gt;function a(b) { return c }&lt;/code&gt; to &lt;code&gt;var a = function(b) { return c }&lt;/code&gt; in JS. (Better, in &lt;em&gt;modern&lt;/em&gt; JS, to &lt;code&gt;const a = (b) =&amp;gt; c&lt;/code&gt;.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I’ll return to that in a moment. First, writing up the JS. The innermost term is (repeated) &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt;, so we’ll start by writing this out.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const λ_inner = (x) =&amp;gt; (h(h)(F))(x)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need the definition of &lt;span class="math inline"&gt;&lt;em&gt;h&lt;/em&gt;&lt;/span&gt; next; this comes from further out, the transformation &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;em&gt;n&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;)&lt;/span&gt; (where we’re substituting the &lt;code&gt;λ_inner&lt;/code&gt; we just wrote to make this a bit easier to get our heads around).&lt;/p&gt;
&lt;p&gt;Remembering that each “.” in the equation represents a mapping, i.e. a JS function call, we have this (writing it with function definitions starting new lines to clarify):&lt;/p&gt;
&lt;p&gt;Here’s what I came up with as a fairly direct translation into JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (
  (h) =&amp;gt;
    (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))  // substituting λ_inner from above
) (
  (h) =&amp;gt;
    (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))  // substituting λ_inner from above
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His (note that things are aligned as they are so that it’s clear which functions match up):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;var Y = function (F) {
 return (function (x) {
  return F(function (y) { return (x(x))(y);});
  })
        (function (x) {
  return F(function (y) { return (x(x))(y);});
  }) ;
} ;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His transformed to modern JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; (
  (x) =&amp;gt; F((y) =&amp;gt; x(x)(y))
) (
  (x) =&amp;gt; F((y) =&amp;gt; x(x)(y))
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His and mine are not &lt;em&gt;quite&lt;/em&gt; the same (though I know they’re equivalent because they both work). I really wish he’d explained how he got &lt;em&gt;this&lt;/em&gt; substitution as well! More importantly, I wish he’d been consistent in his notation; changing variable names is… frustrating when you’re trying to follow someone’s work.&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;When I get stuck on something like &lt;em&gt;this&lt;/em&gt;, the way I figure it out is by writing out how the substitutions would work at each step. See below.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;In any case, now that we have the Y combinator, we can use it with &lt;code&gt;FactGen&lt;/code&gt;, a functional which, if you pass it the factorial function, passes back the factorial function. &lt;code&gt;FactGen&lt;/code&gt; itself isn’t recursive. But with the Y Combinator, it builds a function which is &lt;em&gt;not&lt;/em&gt; recursive; it doesn’t reference itself anywhere. It just needs the right kind of “factory”: a function which returns &lt;em&gt;another&lt;/em&gt; funtion which itself &lt;em&gt;is&lt;/em&gt; recursive. Here’s a standard recursive factorial implementation (identical to the one Might supplies, though modernized):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const FactGen =
  (fact) =&amp;gt;
    (n) =&amp;gt; n === 0 ? 1 : n * fact(n - 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You call that like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;Y(FactGen)(5)  // 120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Y(FactGen)&lt;/code&gt; call gets back a function which then runs on whatever input you hand it (a fairly standard pattern with curried arguments), so you could also write it like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const factorial = Y(FactGen)
factorial(5)  // 120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I’m still not sure how his and mine are equivalent.&lt;/p&gt;
&lt;p&gt;A note: wrapping things in &lt;code&gt;(...)&lt;/code&gt; in JS defines that wrapped content as a distinct &lt;em&gt;expression&lt;/em&gt;. As long as the type of a given expression is a function, it can be called with an argument. So &lt;code&gt;(function() {})()&lt;/code&gt; or &lt;code&gt;(() =&amp;gt; {})()&lt;/code&gt; takes a no-operation function and immediately executes it.&lt;/p&gt;
&lt;p&gt;So in his Y combinator, the substitution goes like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; (  // F is FactGen
  // x is the identical function passed as argument below
  (x) =&amp;gt;
    // Run FactGen by taking the function below as its `fact`
    // argument.
    F(
      // `y` is the argument passed to the result of Y, e.g.
      // `fact(5)`. Recall that `x` is the function below; we
      // call it with itself. Calling x(x) will get the actual
      // factorial function returned by `FactGen`.
      (y) =&amp;gt; x(x)(y)
    )
// We close the *expression* which defines the outer function,
// and call it with this next expression as an argument.
) (
  // and x here is the same function, passed as argument
  (x) =&amp;gt;
    // Again, run `FactGen` with this function as its argument.
    F(
      // `y`, again, will be the integer. `x(x)` again will be
      // the actual factorial function.
      (y) =&amp;gt; x(x)(y)
    )
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is pretty funky! But it works; the two anonymous functions call &lt;em&gt;each other&lt;/em&gt; rather than recursing directly.&lt;/p&gt;
&lt;p&gt;In mine, it goes like this, instead:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Ymine = (
  // Where in Might&amp;#39;s example, the `x` function was where the
  // U Combinator was applied, here (because I followed the
  // original notation he gave) it&amp;#39;s `h`. So it&amp;#39;s `h` which is
  // the same function handed back and forth as argument
  // to itself.
  (h) =&amp;gt;
    // `h` takes a functional, which takes `FactGen` as its
    // parameter. This is similar to the outermost function in
    // Might&amp;#39;s version.
    (F) =&amp;gt;
      // As in Might&amp;#39;s version, we call `FactGen` here.
      F(
        // The form is *similar* but not identical to his,
        // because of the extra call structure. `h(h)(F)` is the
        // factorial function.
        //
        // Note that then he has `y` where I have `x`; my `x`
        // and his `y` are just the result of the computation
        // (in this case, the integer factorial).
        (x) =&amp;gt; (h(h)(F))(x))
) (
  // This is identical to the above; it&amp;#39;s using the U Combinator.
  (h) =&amp;gt; (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is how his simplification worked: instead of generating the factorial function each time, it generated it just the once and then &lt;em&gt;used&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;I still couldn’t &lt;em&gt;do&lt;/em&gt; the simplification he did myself. It’ll take more practice using and thinking about combinators and combinatorial logic before I get there, but that’s okay. That’s how learning works.&lt;/p&gt;
&lt;p&gt;And that’s enough playing with combinatorials for now. (Except that I’m kind of tempted to see if I can go implement the U or Y combinators—or both—in Rust.)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;If you’re curious how I worked this out… I expanded the JS representations of the final forms (&lt;a href="//www.chriskrycho.com/extra/ycombinator.js"&gt;here’s the code&lt;/a&gt;) and then stepped through the result in my JavaScript dev tools, watching how the function calls worked and what the values of each intermediate value were. It’s fascinating, and well worth your time.&lt;/i&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 19 Jun 2016 09:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-19:/2016/y-combinators-how-do-they-even-work.html</guid><category>javascript</category><category>software development</category><category>programming languages</category></item><item><title>Testing Ember.js Mixins (and Helpers) With a Container</title><link>http://www.chriskrycho.com/2016/testing-emberjs-mixins-with-a-container.html</link><description>&lt;p&gt;&lt;i&gt;Updated to note that the same concerns apply to helpers. You can always see the full revision history of this item &lt;a href="https://github.com/chriskrycho/chriskrycho.com/commits/master/content/tech/ember-js-mixins-container.md"&gt;here&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Today I was working on an Ember.js &lt;a href="http://emberjs.com/api/classes/Ember.Mixin.html#content"&gt;mixin&lt;/a&gt; for the new mobile web application we’re shipping at Olo, and I ran into an interesting problem when trying to test it.&lt;/p&gt;
&lt;p&gt;When you’re testing mixins (or helpers), you’re generally not working with the normal Ember container.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; In fact, the default test setup for mixins doesn’t have &lt;em&gt;any&lt;/em&gt; container in play. It just looks like this (assuming you ran &lt;code&gt;ember generate mixin bar&lt;/code&gt; in an app named &lt;code&gt;foo&lt;/code&gt;):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;import Ember from &amp;#39;ember&amp;#39;;
import BarMixin from &amp;#39;foo/mixins/bar&amp;#39;;
import { module, test } from &amp;#39;qunit&amp;#39;;

module(&amp;#39;Unit | Mixin | bar&amp;#39;);

// Replace this with your real tests.
test(&amp;#39;it works&amp;#39;, function(assert) {
  let BarObject = Ember.Object.extend(BarMixin);
  let subject = BarObject.create();
  assert.ok(subject);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note two things:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It uses the basic Qunit &lt;code&gt;module&lt;/code&gt; setup, not the ember-qunit &lt;code&gt;moduleFor&lt;/code&gt; setup.&lt;/li&gt;
&lt;li&gt;It assumes you’re generating a new object instance for every single test.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both of those assumptions are fine, &lt;em&gt;if you don’t need to interact with the container&lt;/em&gt;. In many cases, that’s perfectly reasonable—I’d go so far as to say that most mixins and helpers probably &lt;em&gt;shouldn’t&lt;/em&gt; have any dependency on the container.&lt;/p&gt;
&lt;p&gt;In the specific case I was working on, however, the point of the mixin was to abstract some common behavior which included all the interactions with a &lt;a href="https://guides.emberjs.com/v2.6.0/applications/services/"&gt;service&lt;/a&gt;. This meant making sure the dependency injection worked in the unit test. This in turn meant dealing with the container. So let’s see what was involved in that. (You can generalize this approach to any place in the Ember ecosystem where you need to test something which doesn’t normally have the container set up.)&lt;/p&gt;
&lt;p&gt;We start by switching from the basic &lt;code&gt;qunit&lt;/code&gt; helpers to using the &lt;code&gt;ember-qunit&lt;/code&gt; helpers.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// Replace this...
import { module, test } from &amp;#39;qunit&amp;#39;;
module(&amp;#39;Unit | Mixin | bar&amp;#39;);

// with this:
import { moduleFor, test } from &amp;#39;ember-qunit&amp;#39;;
moduleFor(&amp;#39;mixin:bar&amp;#39;, &amp;#39;Unit | Mixin | Bar&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;moduleFor()&lt;/code&gt; helper has two things going for it—one of which we &lt;em&gt;need&lt;/em&gt;, and one of which isn’t strictly &lt;em&gt;necessary&lt;/em&gt;, but has some nice functionality. In any case, this will help when registering a container. Those two features:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;It does support the use of the container. In fact, it’s declaring how this mixin relates to the container in the first argument to the helper function: &lt;code&gt;'mixin:foo'&lt;/code&gt; is the definition of the mixin for injection into the container.&lt;/li&gt;
&lt;li&gt;Any functions we define on the options argument we can pass to the &lt;code&gt;moduleFor()&lt;/code&gt; helper are available on the &lt;code&gt;this&lt;/code&gt; of the test.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, in the first version of this, I had set up a common &lt;code&gt;Ember.Object&lt;/code&gt; which had mixed in the &lt;code&gt;BarMixin&lt;/code&gt;, so:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const BarObject = Ember.Object.extend(BarMixin);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, in each test, I created instances of this to use:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;test(&amp;#39;test some feature or another&amp;#39;, function(assert) {
  const subject = BarObject.create();
  // ...do stuff and test it with `assert.ok()`, etc.
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem was that any of those tests which required a container injection always failed. Assume we have a service named &lt;code&gt;quux&lt;/code&gt;, and that it’s injected into the mixin like this in &lt;code&gt;foo/app/mixins/bar.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;import Ember from &amp;#39;ember&amp;#39;;

export default Ember.Mixin.create({
  quux: Ember.inject.service()
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Any test which actually tried to &lt;em&gt;use&lt;/em&gt; &lt;code&gt;quux&lt;/code&gt; would simply fail because of the missing container (even if you specified in the test setup that you needed the service):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test(&amp;#39;it uses quux somehow&amp;#39;, function(assert) {
  const subject = BarObject.create();
  const quux = subject.get(&amp;#39;quux&amp;#39;);  // throws Error
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Specifically, you will see &lt;code&gt;Attempting to lookup an injected property on an object without a container&lt;/code&gt; if you look in your console.&lt;/p&gt;
&lt;p&gt;Taking advantage of the two &lt;code&gt;ember-qunit&lt;/code&gt; features, though, we can handle all of this.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;import Ember from &amp;#39;ember&amp;#39;;
import { moduleFor, test } from &amp;#39;ember-qunit&amp;#39;;

const { getOwner } = Ember;

moduleFor(&amp;#39;mixin:bar&amp;#39;, &amp;#39;Unit | Mixin | bar&amp;#39;, {
  // The `needs` property in the options argument tells the test
  // framework that it needs to go find and instantiate the `quux`
  // service. (Note that if `quux` depends on other injected
  // services, you have to specify that here as well.)
  needs: [&amp;#39;service:quux&amp;#39;],

  // Again: any object we create in this options object will be
  // available on the `this` of every `test` function below. Here,
  // we want to get a &amp;quot;test subject&amp;quot; which is attached to the
  // Ember container, so that the container is available to the
  // test subject itself for retrieving the dependencies injected
  // into it (and defined above in `needs`).
  subject() {
    BarObject = Ember.Object.extend(BarMixin);

    // This whole thing works because, since we&amp;#39;re in a
    // `moduleFor()`, `this` has the relevant method we need to
    // attach items to the container: `register()`.
    this.register(&amp;#39;test-container:bar-object&amp;#39;, BarObject);

    // `Ember.getOwner` is the public API for getting the
    // container to do this kind of lookup. You can use it in lots
    // of places, including but not limited to tests. Note that
    // that because of how the dependency injection works, what we
    // get back from the lookup is not `BarObject`, but an
    // instance of `BarObject`. That means that we don&amp;#39;t need to
    // do `BarObject.create()` when we use this below; Ember
    // already did that for us.
    return getOwner(this).lookup(&amp;#39;test-container:bar-object&amp;#39;);
  }
});

test(&amp;#39;the mixin+service does what it should&amp;#39;, function(assert) {
  // We start by running the subject function defined above. We
  // now have an instance of an `Ember.Object` which has
  // `BarMixin` applied.
  const subject = this.subject();

  // Now, because we used a test helper that made the container
  // available, declared the dependencies of the mixin in `needs`,
  // and registered the object we&amp;#39;re dealing with here, we don&amp;#39;t
  // get an error anymore.
  const quux = subject.get(&amp;#39;quux&amp;#39;);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, in summary:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Use the &lt;code&gt;ember-qunit&lt;/code&gt; helpers if you need the container.&lt;/li&gt;
&lt;li&gt;Define whatever dependencies you have in &lt;code&gt;needs&lt;/code&gt;, just as you would in any other test.&lt;/li&gt;
&lt;li&gt;Register the mixin-derived object (whether &lt;code&gt;Ember.Object&lt;/code&gt;, &lt;code&gt;Ember.Route&lt;/code&gt;, &lt;code&gt;Ember.Component&lt;/code&gt;, or whatever else) in a method on the options argument for &lt;code&gt;moduleFor()&lt;/code&gt;. Use that to get an instance of the object and you’re off to the races!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One final consideration: while in this case it made good sense to use this approach and make the service injection available for the test, there’s a reason that the tests generated by Ember CLI don’t use &lt;code&gt;moduleFor()&lt;/code&gt; by default. It’s a quiet but clear signal that you should reevaluate whether this &lt;em&gt;is&lt;/em&gt; in fact the correct approach.&lt;/p&gt;
&lt;p&gt;In general, mixins are best used for self-contained units of functionality. If you &lt;em&gt;need&lt;/em&gt; dependency injection for them, it may mean that you should think about structuring things in a different way. Can all the functionality live on the service itself? Can all of it live in the mixin instead of requiring a service? Can the service calls be delegated to whatever type is using the mixin?&lt;/p&gt;
&lt;p&gt;But if not, and you &lt;em&gt;do&lt;/em&gt; need a mixin which injects a service, now you know how to do it!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Side note:&lt;/strong&gt; The documentation around testing mixins is relatively weak, and in general the testing docs are the weak bits in the Ember guides right now.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; After a conversation with &lt;a href="https://github.com/rwjblue"&gt;@rwjblue&lt;/a&gt; on the &lt;a href="https://ember-community-slackin.herokuapp.com"&gt;Ember Community Slack&lt;/a&gt;, though, I was able to get a handle on the issue, and here we are. Since it stumped me, I’m guessing I’m not the only one.&lt;/p&gt;
&lt;p&gt;When this happens, &lt;em&gt;write it up&lt;/em&gt;. I’ve been guilty of this too often in the past few months: learning something new that I couldn’t find anywhere online, and then leaving it stored in my own head. It doesn’t take a particularly long time to write a blog post like this, and if you’re stuck, chances are &lt;em&gt;very&lt;/em&gt; good someone else is too.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re not familiar with the “container”, this is where all the various dependencies are registered, and where Ember looks them up to inject them when you use methods like &lt;code&gt;Ember.inject.service()&lt;/code&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Something I intend to help address in the next week or two via a pull request, so if you’re my Ember.js documentation team friend and you’re reading this… it’s coming. 😉&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 09 Jun 2016 20:35:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-09:/2016/testing-emberjs-mixins-with-a-container.html</guid><category>emberjs</category><category>javascript</category><category>software development</category></item><item><title>The Future of JavaScript</title><link>http://www.chriskrycho.com/2016/the-future-of-javascript.html</link><description>&lt;p&gt;I gave a short tech talk at my new employer &lt;a href="http://www.olo.com"&gt;Olo&lt;/a&gt; today, covering a number of the changes current and forthcoming in ECMAScript 2015 and later. Alas, I ran out of time in preparation and didn’t get to cover everything I wanted—I would have liked very much to cover modules, and to cover fat-arrow-functions in more depth than I did. I’ll look forward to hopefully giving further tech talks at Olo in the future, and perhaps giving this one, expanded and finished out a bit, elsewhere. (If you’d like me to give a talk, including this one, just let me know!) In the meantime, you can take a look at the &lt;a href="//www.chriskrycho.com/talks/es-future-olo"&gt;slides&lt;/a&gt;, which I think will be helpful and interesting!&lt;/p&gt;
&lt;p&gt;And yes, there &lt;em&gt;were&lt;/em&gt; a lot of really delightful &lt;em&gt;Doctor Who&lt;/em&gt; references in this talk. Because &lt;em&gt;of course&lt;/em&gt; there were!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 02 Mar 2016 12:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-02:/2016/the-future-of-javascript.html</guid><category>talks</category><category>software development</category><category>programming languages</category><category>javascript</category></item><item><title>HTML5 Location, &lt;base&gt;, and SVG</title><link>http://www.chriskrycho.com/2015/html5-location-base-and-svg.html</link><description>&lt;p&gt;For quite some time, I have been frustrated by a bug in HolyBible.com: Firefox would not render SVGs using the &lt;code&gt;&amp;lt;use xlink:xhref=&amp;quot;#some-SVG-ID&amp;quot;&amp;gt;&amp;lt;/use&amp;gt;&lt;/code&gt; pattern. Today, I set aside my ongoing work on new user-facing functionality and dedicated what working time I had to hunting down the cause of this and fixing it at last.&lt;/p&gt;
&lt;p&gt;I was surprised to find the culprit: the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag. If you don’t know what the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag is, you’re not alone. It is &lt;em&gt;not&lt;/em&gt; used all that much in general, and I had never actually seen it on a site before starting on this project last year.&lt;/p&gt;
&lt;p&gt;So what went wrong? How do these two things play together?&lt;/p&gt;
&lt;p&gt;I am using (and reusing) SVG items throughout the HolyBible.com interface, taking advantage of the ability to define symbols and reference them with the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag, like so:&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;svg version=&amp;quot;1.1&amp;quot; xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot; xmlns:xlink=&amp;quot;http://www.w3.org/1999/xlink&amp;quot; xmlns:ev=&amp;quot;http://www.w3.org/2001/xml-events&amp;quot; style=&amp;quot;display: none&amp;quot;&amp;gt;
  &amp;lt;symbol id=&amp;quot;logo-shape&amp;quot; viewBox=&amp;quot;0 0 256 256&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Logo&amp;lt;/title&amp;gt;
    &amp;lt;desc&amp;gt;The HolyBible.com logo: sunrise breaking over an open book (the Bible).&amp;lt;/desc&amp;gt;
    &amp;lt;path id=&amp;quot;logo-light&amp;quot; d=&amp;quot;M172.1 116.3l5.1-4.1-12.5-.5 32-26.3-41.4 18.4 11-20.1L148 96l12.2-37.5L138.8 91l.1-36.2-10.3 34.4L114 36.1l4.3 54.9-22.2-34.9 13 39.9-18.3-12.4 11 20.1-42.5-19.2 32.8 26.9-10.4.8 4.4 3.9c13.1-1.6 27.4-2.7 42.4-2.7 15.4 0 30.1 1.2 43.6 2.9z&amp;quot;/&amp;gt;
    &amp;lt;path id=&amp;quot;logo-book&amp;quot; d=&amp;quot;M199.9 219.9c-47.4-9.8-96.4-9.8-143.8 0-6-28.9-12-57.7-17.9-86.6 59.3-12.3 120.4-12.3 179.7 0-6 28.9-12 57.8-18 86.6z&amp;quot;/&amp;gt;
  &amp;lt;/symbol&amp;gt;
&amp;lt;/svg&amp;gt;

&amp;lt;!-- somewhere else on the page --&amp;gt;
&amp;lt;svg&amp;gt;
  &amp;lt;use xlink:href=&amp;quot;#logo-shape&amp;quot;&amp;gt;&amp;lt;/use&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Throughout all my early prototyping, this worked perfectly across all modern browsers. (For more, see &lt;a href="https://css-tricks.com/svg-sprites-use-better-icon-fonts/"&gt;CSS Tricks&lt;/a&gt;.) Now, when I started moving from the prototype phase into actually building the application in Angular last fall, I learned that you have to set the base URL for the application using the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag to use the HTML5 Location API with Angular 1.x. If you want URL-based, rather than &lt;code&gt;#&lt;/code&gt;-based navigation in an Angular app, you need this. Following the recommendation of whatever documentation and tutorials I found, I set it so:&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;base href=&amp;quot;/&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this was the recommendation I saw in every bit of documentation and every tutorial, so I assumed it would have no problems. As it turns it, that’s not the case. (This is a &lt;a href="http://www.chriskrycho.com/2015/how-to-build-a-single-page-app-api-right.html"&gt;recurring theme&lt;/a&gt; in my experience with Angular.) In Chrome, Safari, and IE9+, this works exactly as expected. In Firefox, however, it does &lt;em&gt;not&lt;/em&gt;. The use of the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag changes the behavior of &lt;code&gt;#&lt;/code&gt;-based URLs on a page. Specifically, it makes it so that if you’re at a URL that &lt;em&gt;isn’t&lt;/em&gt; the base route, anchor links don’t behave as expected. In order to make the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag as expected, we would have to use the same URL as the base tag. Among other things, this would require making sure that any place we used the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag, we would have to set that—not exactly a good idea, given that it would entail an awful lot of changes if the base URL were ever changed.&lt;/p&gt;
&lt;p&gt;What if, instead, we did this?&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;script&amp;gt;document.write(&amp;#39;&amp;lt;base href=&amp;quot;&amp;#39; + document.location.origin + &amp;#39;&amp;quot; /&amp;gt;&amp;#39;);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This way, when the page renders, it writes the document location based on the &lt;em&gt;current&lt;/em&gt; location. The URL history still behaves as expected with Angular, but the relative URLs for IDs behave as expected in Firefox again, while not breaking the behavior in any other browsers.&lt;/p&gt;
&lt;p&gt;But… then you’ll navigate to another page, and Firefox will be back to not working.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/angular/angular.js/issues/8934#issuecomment-56568466"&gt;solution&lt;/a&gt;, it turns out, only came into being after I’d done the initial implementation, and I have no idea how much later it found its way into the Angular docs. However, even though it now &lt;em&gt;exists&lt;/em&gt; in the docs, it’s by no means obvious why you should do it this way, and certainly no mention of SVG! This might not seem odd to you… but it should, given that the only reason that Angular introduced this API change was to account for &lt;em&gt;exactly this issue&lt;/em&gt;.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As the Angular docs note, leaving out the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag means all your URLs have to be absolute if you want to use HTML5 location and the &lt;code&gt;$locationProvider&lt;/code&gt;. If you want to use SVGs with &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; and Firefox, though, that’s what you have to do (and therefore that’s what I’m doing).&lt;/p&gt;
&lt;p&gt;Fun times, right?&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;The closest it gets is this reference:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Links that only contain a hash fragment (e.g. &lt;code&gt;&amp;lt;a href=&amp;quot;#target&amp;quot;&amp;gt;&lt;/code&gt;) will only change &lt;code&gt;$location.hash()&lt;/code&gt; and not modify the url otherwise. This is useful for scrolling to anchors on the same page without needing to know on which page the user currently is.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Even this, however, only &lt;em&gt;hints&lt;/em&gt; at the root of the SVG issue.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 20 Jun 2015 10:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-06-20:/2015/html5-location-base-and-svg.html</guid><category>software development</category><category>angularjs</category><category>javascript</category></item><item><title>How to Build a Single-Page App API Right</title><link>http://www.chriskrycho.com/2015/how-to-build-a-single-page-app-api-right.html</link><description>&lt;p&gt;When I was first working on HolyBible.com, I struggled for quite a while to wrap my head around the right way to structure its API—and in truth, I actually didn’t come up with what I would call the &lt;em&gt;right&lt;/em&gt; solution. I came up with a &lt;em&gt;working&lt;/em&gt; solution, and the site performs all right, most of the time. However, our goal as developers shouldn’t be “all right, most of the time.” It should be “really well, all the time.” A big part of what I did wrong came from the bad advice I found in reading up on the issue along the way. This is my shot at helping you, dear reader, avoid making the same mistake.&lt;/p&gt;
&lt;section id="the-challenge" class="level2"&gt;
&lt;h2&gt;The challenge&lt;/h2&gt;
&lt;p&gt;When building a client-side application, we need to get the data for each view so that we can render it. In the case of HolyBible.com, that means everything from actual Bible text to study Bible notes, about pages, etc. The question is &lt;em&gt;how&lt;/em&gt; to do this: we need to be able to load an actual page from our server, and we need a way to request data (rather than whole pages) from the server.&lt;/p&gt;
&lt;p&gt;(More experienced developers already know where this is going: that last sentence there has the key to this whole thing. I know. But the internet &lt;em&gt;doesn’t.&lt;/em&gt; I learned this the hard way.)&lt;/p&gt;
&lt;section id="the-mistake" class="level3"&gt;
&lt;h3&gt;The mistake&lt;/h3&gt;
&lt;p&gt;Here’s the mistake I made: I built the Bible data API as (essentially) a &lt;em&gt;single&lt;/em&gt; endpoint. When I went looking for advice on how to build this in Angular and Node/Express, every single tutorial or blog post I found outlined the same basic solution: routes for your data endpoints, and catch-all route that returns the basic frame page for everything else. So, for HolyBible.com, that would come out with route matchers for e.g. &lt;code&gt;/data/gen.1.1&lt;/code&gt;, and for any other specific routes needed (for other views, static resources, etc.), with a default behavior of just dropping a static, basically empty template at the catchall &lt;code&gt;*&lt;/code&gt; route. Then, once the application has loaded, it can inspect the URL and load the relevant data.&lt;/p&gt;
&lt;p&gt;This works. It’s exactly what I did on HolyBible.com, in fact. But it’s &lt;em&gt;slow&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: the time until the initial page load is actually relatively quick (though I plan to improve it substantially over the next couple months). The real problem is that the initial page load &lt;em&gt;doesn’t include any content&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I &lt;em&gt;hate&lt;/em&gt; this. That’s why people are on the site: not to see my neat skills with JavaScript, just to read the Bible. And they have to wait, because once the page &lt;em&gt;does&lt;/em&gt; load, Angular has to spin up the full application, see what content &lt;em&gt;should&lt;/em&gt; have been loaded, and request it.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-solution" class="level3"&gt;
&lt;h3&gt;The solution&lt;/h3&gt;
&lt;p&gt;Don’t write &lt;em&gt;one&lt;/em&gt; API. Write &lt;em&gt;two&lt;/em&gt;. They should be structured nearly identically, but one of them will be a &lt;em&gt;page&lt;/em&gt; API endpoint, and one will be a &lt;em&gt;data&lt;/em&gt; API endpoint. In the context of HolyBible.com, here’s how that would play out.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; One endpoint would be based purely on the standard URL, something like &lt;code&gt;holybible.com/jhn.3.16&lt;/code&gt;. The other would be to retrieve a set of &lt;em&gt;data&lt;/em&gt; associated with a given address, like &lt;code&gt;holybible.com/data/jhn.3.16&lt;/code&gt;. This is only a little different from the approach suggested above, but that small difference matters—in fact, it matters a &lt;em&gt;lot&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Instead of having the &lt;code&gt;/jhn.3.16&lt;/code&gt; route get handled by a catchall &lt;code&gt;*&lt;/code&gt; route on the back end, it gets its own API endpoint, which looks for URLS of this shape and hands back a full page. That API endpoint is responsible to actually render the content of the page appropriately—in this case, with something like the whole chapter of John 3.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;em&gt;That&lt;/em&gt; gets handed back to the browser, so the very first thing the user sees is not a blank page while the JavaScript framework spins up and requests data, but rather &lt;em&gt;the Bible text they asked for in the first place&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Meanwhile, the JavaScript framework &lt;em&gt;can&lt;/em&gt; spin up, and load any required session data, etc. and start managing the UI like normal. Once we get to this point, the framework can go ahead and request a data payload from the &lt;code&gt;/data/&amp;lt;reference&amp;gt;&lt;/code&gt; endpoint. So, for example, if there is a navigation control on the page (as on HolyBible.com and indeed most sites), clicking to navigate to Job 14 could, instead of requesting &lt;code&gt;/job.14.4&lt;/code&gt;, fetch the data from the other endpoint by running an AJAX request to &lt;code&gt;/data/job.14.4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The backend thus supplies &lt;em&gt;both&lt;/em&gt; a &lt;code&gt;/&amp;lt;resource&amp;gt;&lt;/code&gt; and a &lt;code&gt;/data/&amp;lt;resource&amp;gt;&lt;/code&gt; route. This might seem redundant, but we’ve just seen why it isn’t, Moreover, if you have any logic that needs to be in place—in our example here, a Bible reference parser, for example, to decide what content should be supplied—you can easily reuse it between the two routes. The differences is simply in the form of the data returned: is it a fully-rendered template, or just the data?&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="so-what" class="level2"&gt;
&lt;h2&gt;So what?&lt;/h2&gt;
&lt;p&gt;This approach has two big advantages over the catch-all approach that was frequently recommended in e.g. Angular SPA tutorials I read.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s &lt;em&gt;progressive enhancement&lt;/em&gt;. If the JavaScript fails, or the user has it disabled, or it fails to load because it’s loaded asynchronously, the user still gets the page they asked for. Moreover, as long as the page content is build carefully (links built appropriately for other content, and so on), the entire application could continue to work even if the JavaScript &lt;em&gt;never&lt;/em&gt; becomes available.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It’s &lt;em&gt;performant&lt;/em&gt;. Loading the content this way will be &lt;em&gt;much&lt;/em&gt; faster than the standard approach recommended for single-page apps. As noted above, it gets the content to the user immediately, then lets the JavaScript UI bits come into play. Since future page loads can take advantage of both caching and smaller data payloads, the whole thing can actually be faster than either a pure client-side &lt;em&gt;or&lt;/em&gt; a pure server-side approach. That is, once the client-side application is running, it can just update its views with data delivered via AJAX, rather than reloading the whole page. But &lt;em&gt;before&lt;/em&gt; that, the user doesn’t have to wait to see something useful until the JavaScript framework spins up.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It’s not often an approach gives you progressive enhancement and actually increases the performance of an application, but this one does. Better yet, you can apply this in just about any framework: it’s equally applicable to AngularJS with ExpressJS, Backbone with Rails, Ember with Django, Aurelia with Phoenix, or any other combination you come up with.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note: this is &lt;em&gt;not&lt;/em&gt; the actual API structure of HolyBible.com, or even particularly close to it. Remember, I learned everything I’m writing here by doing it &lt;em&gt;wrong&lt;/em&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Or possibly a section which constitutes a semantic block of data. I have some thoughts on chunking Bible data semantically rather than by chapter and verse for this kind of thing. That’s another post for another day, though.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 09 Jun 2015 22:16:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-06-09:/2015/how-to-build-a-single-page-app-api-right.html</guid><category>software development</category><category>javascript</category></item><item><title>Lessons Learned</title><link>http://www.chriskrycho.com/2015/lessons-learned.html</link><description>&lt;p&gt;Since mid July 2014, I have been working on a complete redesign and re-build of &lt;a href="//holybible.com"&gt;HolyBible.com&lt;/a&gt;. The good folks at &lt;a href="//prts.edu"&gt;Puritan Reformed Theological Seminary&lt;/a&gt; who own the site wanted to replace its previous content with a Bible reading tool. While there’s still a lot to wrap up, the project is &lt;em&gt;nearing&lt;/em&gt; its conclusion, and I thought I’d note a few things I’ve learned (in some cases, learned &lt;em&gt;again&lt;/em&gt;) along the way. I want to say up front, lest these be taken the wrong way: I’m extremely proud of the work I’ve done, and the application I’ve delivered &lt;em&gt;does&lt;/em&gt; work to the specifications I was hired to meet. More than that, it does it well. But, of course, it could do it &lt;em&gt;better&lt;/em&gt;. The following thoughts are therefore not, “How I failed” but rather “How I will do this &lt;em&gt;even better&lt;/em&gt; next time around.”&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Single page apps are great, but not always the right choice.&lt;/em&gt; I made the decision, based on my expectations and understandings of what I would need, to develop the site as a single-page web application. This was a mistake. Not the worst mistake ever: it has its upsides, including performance &lt;em&gt;once the app spins up&lt;/em&gt;, but for the kind of content I have here, I would take a different tack today. Better in this case to deliver static content and &lt;em&gt;update&lt;/em&gt; it dynamically as appropriate than to try to load all the content dynamically every time.&lt;/p&gt;
&lt;p&gt;At a technical level, that would probably mean supplementing standard HTML with &lt;a href="//backbonejs.org"&gt;Backbone&lt;/a&gt; instead of developing it as a single-page app in &lt;a href="//angularjs.org"&gt;Angular&lt;/a&gt;. For the backend, while I did it in Node.js and that would work fine, I’d probably do a straight Django app (especially with a few of the goals I learned about &lt;em&gt;after&lt;/em&gt; the project was well along in development).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Progressive enhancement or graceful degradation are hard in web applications, but they still matter.&lt;/em&gt; In the past, I’ve always taken a hard line on making sure things either degrade gracefully or are simply enhanced by JavaScript content. In the architecture decisions I made for this app, I failed to take that into account (largely because I thought it would just &lt;em&gt;need&lt;/em&gt; to work as a web app, but see above). I regret that enormously at this point; it would be much better in this particular case to have content available even if the additional functionality doesn’t work. Even if you &lt;em&gt;are&lt;/em&gt; doing something where you are building an &lt;em&gt;app&lt;/em&gt;, finding ways to make it work on poor connections, older browsers, etc. matters. I’m still thinking a &lt;em&gt;lot&lt;/em&gt; about the best way to do this in the future.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;More popular doesn’t mean better.&lt;/em&gt; Angular has a ton of traction and uptake, and that was deceptive early on. I won’t so easily be fooled in the future. Angular is so very popular in part because Google can put serious money behind its development—and its marketing. But it’s &lt;em&gt;not&lt;/em&gt; the best for many applications; if you’re not in the business of developing your own custom framework, it’s not even &lt;em&gt;close&lt;/em&gt; to the best. Use Ember or Knockout or any number of other full-stack frameworks rather than a meta-framework.&lt;/p&gt;
&lt;p&gt;How to avoid making that mistake? Well, for my part since then, I’ve learned to look not just as the &lt;em&gt;quantity&lt;/em&gt; of material in a given community, but its &lt;em&gt;quality&lt;/em&gt;. For example, &lt;a href="//emberjs.com"&gt;Ember&lt;/a&gt; has &lt;em&gt;incredible&lt;/em&gt; documentation (far better than Angular’s), and they also have a much clearer vision and a more dependable approach to development (strict semantic versioning, etc.). Had I taken the time to read &lt;em&gt;both&lt;/em&gt; sets of docs more carefully and think through the consequences of their designs more thoroughly, I could have recognized this before starting. Next time, I will do just that.&lt;/p&gt;
&lt;p&gt;I will also look at the way the community behaves. The Ember community is &lt;em&gt;far&lt;/em&gt; friendlier for newcomers from what I’ve seen than the Angular community—no slam meant on the Angular crowd, but the Ember folks are just doing that really well. That matters, too. (I can’t speak for other communities, of course; these are just the groups I’ve watched the most.)&lt;/p&gt;
&lt;p&gt;All in all, Ember would have been the better fit between these two (even though, as noted above, it also wouldn’t have been the &lt;em&gt;best&lt;/em&gt; fit).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Unit tests really are the best.&lt;/em&gt; I did a vast majority of this project with unit tests—the first time I’ve ever been able to do that for a whole project. In other projects, I’ve been able to do it for parts, but never this much. It saved my bacon a &lt;em&gt;lot&lt;/em&gt;. Where I got in a hurry and felt like I didn’t have time to write the tests, I (inevitably and predictably!) ended up spending a lot of time chasing down hard-to-isolate bugs—time I could have avoided by writing well-tested (and therefore better-factored) code in the first place. Lesson learned &lt;em&gt;very&lt;/em&gt; thoroughly. Server- and client-side unit tests are &lt;em&gt;really&lt;/em&gt; good. They’re also sometimes &lt;em&gt;hard&lt;/em&gt;; getting mocks set up correctly for dealing with databases, etc. can take a while. That difficulty pays for itself, though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Unit tests &lt;strong&gt;really&lt;/strong&gt; don’t replace API documentation.&lt;/em&gt; I have seen people advocate test-driven-development as a way of obviating the need to do major documentation of an API. This is, in a word, ridiculous. Having to read unit tests if you want to remember how you structured an API call is a pain in the neck. Don’t believe it. Design your API and document it, &lt;em&gt;then&lt;/em&gt; do test-driven development against that contract.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Sometimes ‘good enough’ is enough.&lt;/em&gt; There is always more to be done, and inevitably you can see a thousand things that could be improved. But ‘good’ shipping code is far more valuable than ‘perfect’ code that never ships. You should never ship &lt;em&gt;bad&lt;/em&gt; code, but sometimes you do have to recognize ‘good enough’ and push it out the door.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Full-stack development is fun, but it’s also really hard.&lt;/em&gt; I wrote every scrap of code in HolyBible.com proper (though of course it relies on a lot of third-party code). It was very, very difficult to manage that all by myself; it’s a lot to hold in one’s head. (One of the reasons I chose Node was because keeping my implementation and testing all in one language helped reduce that load somewhat.) Would I do it again? Sure. But very much chastened about the difficulties involved. It has been enormously rewarding, and I &lt;em&gt;like&lt;/em&gt; being a full-stack developer. But it’s a lot of work, and now I know more clearly just how much.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I could say a great deal more about the technical side of things especially, but my biggest takeaway here is that a lot of the hardest and most important work in developing software has nothing to do with the code itself. Architecture and approach shape &lt;em&gt;far&lt;/em&gt; more than the implementation details (even if those details still matter an awful lot). And popularity is not at all the same as either &lt;em&gt;quality&lt;/em&gt; or (especially) &lt;em&gt;suitability for a given task&lt;/em&gt;. In the future, I will be better equipped for the necessary kinds of evaluation, and will hopefully make still better decisions accordingly.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 12 Apr 2015 13:49:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-04-12:/2015/lessons-learned.html</guid><category>software development</category><category>javascript</category><category>angularjs</category></item><item><title>Unsurprisingly, In Flux</title><link>http://www.chriskrycho.com/2015/unsurprisingly-in-flux.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;This started as a &lt;a href="https://alpha.app.net/chriskrycho/post/57102562"&gt;series of posts&lt;/a&gt; on App.net. I &lt;a href="http://www.chriskrycho.com/2014/a-few-theses-on-blogging.html"&gt;resolved&lt;/a&gt; a while ago that if I was tempted to do that, I should just write a blog post instead. I failed at that resolution, but at a friend’s &lt;a href="https://alpha.app.net/jws/post/57108281"&gt;suggestion&lt;/a&gt;, am adapting it into a blog post anyway. You can see the posts that prompted it &lt;a href="https://alpha.app.net/keita/post/57096585"&gt;here&lt;/a&gt; and &lt;a href="https://alpha.app.net/jws/post/57096838"&gt;here&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The state of JavaScript frameworks today is a scale, really, from not-at-all-monolithic to totally-monolithic, in roughly this order: Backbone – React &amp;amp; Angular – Ember – Meteor.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Backbone and related library Underscore are really collections of common JS tools and patterns you can use to write apps, but they’re not &lt;em&gt;frameworks&lt;/em&gt;, per se. You’ll write all your own boilerplate there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React and Angular supply much &lt;em&gt;more&lt;/em&gt; of the functionality, but Angular is a “meta-framework” that aims to do &lt;em&gt;some&lt;/em&gt; boilerplate but let you construct your own custom app framework.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Angular is very powerful, but it’s kind of like Git: wires are exposed; you have to understand a &lt;em&gt;lot&lt;/em&gt; about the internals to get it to do what you want. Its routing functionality is pretty limited out of the box, too—so much so that there’s a near-standard third-party router.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React, as I understand it, supplies a paradigm and associated tools oriented primarily at view state management, though with capabilities via extensions for routing, etc. These tools are &lt;em&gt;extremely&lt;/em&gt; powerful for performance in particular. It’s not a full framework, and the docs expressly note that you can &lt;em&gt;just&lt;/em&gt; use React for the view layer with other tools if you want.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In any case, Angular and React do &lt;em&gt;different&lt;/em&gt; things from each other, but both do substantially more than Backbone.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember is a full framework, strongly emphasizing shared conventions (with a lot of common developers from Rails). It’s perhaps less adaptable than React or Angular, but is much more full-featured; you have very little boilerplate to do.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Meteor is like Ember, but does server-side Node as well as client-side stuff, with the goal being to minimize code duplication, sharing assets as much as possible.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Of all of those, Ember has easily (easily!) the best-explained roadmap, most articulate leadership, and best development path. They are also aggressively adopting the best features of other frameworks wherever it makes sense.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Angular is currently in flux, as Google has announced Angular 2.0 will be basically a completely different framework; there will be &lt;em&gt;no&lt;/em&gt; direct migration path for Angular 1.x apps to Angular 2.0+. Total rewrite required.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember uses a steady 6-week release schedule with very careful regression testing and semantic versioning, with clear deprecation notices and upgrade paths, and is therefore both rapidly iterating &lt;em&gt;and&lt;/em&gt; relatively stable for use.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you just need a set of tools for enhance functionality on otherwise relatively static pages, Backbone+Underscore is a great combo. If you already have a bunch of things in place but want a dedicated view layer, React is good.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re writing a new, full-on web &lt;em&gt;application&lt;/em&gt; (SPA, or organized in whatever other way), I think Ember is the very clear winner at this point. I have good confidence in their leadership and they’re firing on all cylinders.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regarding Angular, &lt;a href="https://alpha.app.net/mikehoss"&gt;@mikehoss&lt;/a&gt; &lt;a href="https://alpha.app.net/mikehoss/post/57105656"&gt;posted&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For the record they are doing that to make it more mobile-friendly. The Ang1 has abysmal performance on mobile. Besides a time machine, this maybe the best option. And Miško is a bit of a jerk.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I can’t speak to his comment about Miško (Miško Hevery, one of the leads on AngularJS), but I agree about Angular itself: the rewrite needs to happen. Angular 1.x is a mess—as are its docs. It’s just not a good time to be using 1.x for any new projects.&lt;/p&gt;
&lt;p&gt;I’ll add to these points that I’ve used Angular for the last 9 months on HolyBible.com development. As I noted: the documentation is pretty rough, and in a lot of cases you really do have to understand what the framework is doing and how before you can get it to do the things you want. This is, in one sense, exactly the &lt;em&gt;opposite&lt;/em&gt; of what I’m looking for in a framework—but it makes sense given Angular’s goal of being a meta-framework.&lt;/p&gt;
&lt;p&gt;Rather like Git, though, which was originally going to be infrastructure for version control systems which would have their own interface, but eventually just had a “good enough” interface that we’re all now stuck with, Angular is being used &lt;em&gt;as&lt;/em&gt; a framework, not just as a &lt;em&gt;meta-framework&lt;/em&gt;, and it’s unsurprisingly not great for that.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class="editorial"&gt;Take this for what it’s worth: not the final word (by a long stretch) on JavaScript frameworks, but rather the perspective of one guy who notably &lt;em&gt;hasn’t used all of the frameworks&lt;/em&gt;, but has spent some time looking at them. Moreover, I haven’t particularly edited this; it’s more a summary in the kind of short-form posts that I originally created than a detailed analysis. The only things I’ve done are expand some of the notes on Angular and React, and add the footnote on React.&lt;/i&gt;&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I &lt;em&gt;really&lt;/em&gt; don’t know a ton about React, but I do think a lot of what I do know about it is cool from a programming perspective. From a designer perspective, however, it’s a bit of a pain: React’s “JSX” domain-specific language is &lt;em&gt;much&lt;/em&gt; less friendly to developers than standard HTML, and therefore than either Ember or Angular, both of which implement their templating via HTML templating languages. There’s a substantil tradeoff there: React’s model is interesting not only academically but in practice because of the performance results it produces. It’s worth note, though, that others have recognized this and are adopting it to varying degrees; notably, Ember is incorporating the idea of minimizing changes to the DOM by keeping track of state and updating only differences, rather than refreshing the whole tree, in the new rendering engine (HTMLBars) they’re rolling out over the past several and future several releases.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 08 Apr 2015 16:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-04-08:/2015/unsurprisingly-in-flux.html</guid><category>software development</category><category>javascript</category><category>angularjs</category><category>emberjs</category><category>react</category></item></channel></rss>