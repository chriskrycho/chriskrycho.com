<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - fsharp</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Sun, 14 Jan 2018 09:00:00 -0500</lastBuildDate><item><title>Exploring 4 Languages: Starting to Model the Domain</title><link>http://www.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html</link><description>&lt;p&gt;In the first three chapters of &lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;, Wlaschin walks through the creation of a “domain model” for an order-taking system. (It’s well worth reading the book just for a bunch of the lessons in that section—I found them quite helpful!) Then, after spending a chapter introducing F&lt;sup&gt;♯&lt;/sup&gt;’s type system, he introduces the ways you can &lt;em&gt;use&lt;/em&gt; those type mechanics to express the domain. In today’s post, I’ll show the idiomatic implementations of these types in each of Rust, Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and ReasonML.&lt;/p&gt;
&lt;section id="simple-values" class="level2"&gt;
&lt;h2&gt;Simple values&lt;/h2&gt;
&lt;p&gt;Simple wrapper types let you take simple types like strings, numbers, etc. and use types to represent part of the business domain you’re dealing with—the basic idea being that a Customer ID may be a number, but it’s not interchangeable with &lt;em&gt;other&lt;/em&gt; numbers such as Order IDs.&lt;/p&gt;
&lt;p&gt;Here’s the most ergonomic and effective (and automatically-formatted in line with the language standards, where applicable!) way to do that in each of the languages:&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct CustomerId(i32);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type CustomerId
    = CustomerId Int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML:&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type customerId =
  | CustomerId(int);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how similar these all are! The Rust implementation is the &lt;em&gt;most&lt;/em&gt; distinctive, though you can do it with the same kind of union type as the others. Here’s how that would look:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum CustomerId {
  CustomerId(i32),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For performance reasons, you might also choose to implement the F&lt;sup&gt;♯&lt;/sup&gt; type as a struct:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;&amp;lt;Struct&amp;gt;
type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="complex-data" class="level2"&gt;
&lt;h2&gt;Complex data&lt;/h2&gt;
&lt;p&gt;Wlaschin then moves on to showing how to model more complex data structures: types that “and” or “or” together other data. We “and” data together using record or struct types, and “or” data together using “union” or “enum” types. (Assume we’ve defined &lt;code&gt;CustomerInfo&lt;/code&gt;, &lt;code&gt;ShippingAddress&lt;/code&gt;, etc. types for all of these.)&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
struct Order {
    customer_info: CustomerInfo,
    shipping_address: ShippingAddress,
    billing_address: BillingAddress,
    order_lines: Vec&amp;lt;OrderLine&amp;gt;,
    billing_amount: BillingAmount,
}

// &amp;quot;or&amp;quot;
enum ProductCode {
    Widget(WidgetCode),
    Gizmo(GizmoCode),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- &amp;quot;and&amp;quot;
type alias Order =
    { customerInfo : CustomerInfo
    , shippingAddress : ShippingAddress
    , billingAddress : BillingAddress
    , orderLines : List OrderLine
    , billingAmount : BillingAmount
    }

-- &amp;quot;or&amp;quot;
type ProductCode
    = Widget WidgetCode
    | Gizmo GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
type Order = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine list
    AmountToBill: BillingAmount
}

// &amp;quot;or&amp;quot;
type ProductCode =
    | Widget of WidgetCode
    | Gizmo of GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML—note that since we’re assuming we’ve already defined the other types here, you can write this without duplicating the name and type declaration, just like you can with JavaScript object properties.&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* &amp;quot;and&amp;quot; */
type order = {
  customerInfo,
  shippingAddress,
  billingAddress,
  orderLine,
  billingAmount
};

/* &amp;quot;or&amp;quot; */
type productCode =
  | Widget(widgetCode)
  | Gizmo(gizmoCode);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An interesting aside: unless you planned to reuse these types, you wouldn’t usually write these as standalone types with this many wrapper types in it in Rust in particular (even if the compiler would often recognize that it could squash them down for you).&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Instead, you’d normally write &lt;em&gt;only&lt;/em&gt; the base enum type to start, and refactor out the &lt;code&gt;struct&lt;/code&gt; wrapper later only if you found you needed it elsewhere:&lt;/p&gt;
&lt;pre class="diff"&gt;&lt;code&gt;enum ProductCode {
-    Widget(WidgetCode),
+    Widget(String),
-    Gizmo(GizmoCode),
+    Gizmo(String),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That said: given how the book is tackling things, and the fact that you might want to &lt;em&gt;validate&lt;/em&gt; these types… having them as these low-cost wrappers is probably worth it. (In fact, having read a bit further than I’ve managed to write out yet, I can guarantee it.)&lt;/p&gt;
&lt;p&gt;We work through the rest of the basic types this way. But what about the types where we don’t yet have a good idea how we want to handle them?&lt;/p&gt;
&lt;p&gt;Each of these languages gives us an out (or more than one) for how to say “I don’t know what to put here yet.”&lt;/p&gt;
&lt;p&gt;Rust (which does not have a built-in &lt;code&gt;Never&lt;/code&gt; type… yet; see below):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// Make an empty enum (which you by definition cannot construct)
enum Never {}

// Use it throughout where we don&amp;#39;t know the type yet. It will fail to compile
// anywhere we try to *use* this, because you can&amp;#39;t construct it.
type OrderId = Never;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (which has a built-in &lt;code&gt;Never&lt;/code&gt; type):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- It will fail to compile anywhere we try to *use* this, because you cannot
-- construct `Never`.
type alias OrderId =
    Never&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (which &lt;em&gt;sort&lt;/em&gt; of does):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// Make a convenience type for the `exn`/`System.Exception` type
type Undefined = exn

type OrderId = Undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (which also &lt;em&gt;sort&lt;/em&gt; of does—identically with F&lt;sup&gt;♯&lt;/sup&gt;):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* Make a convenience type for the `exn`/`System.Exception` type */
type undefined = exn;

/*
  Use it throughout where we don&amp;#39;t know the type yet. It will compile, but fail
  to run anywhere we try to *use* this.
 */
type orderId = undefined;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For both F&lt;sup&gt;♯&lt;/sup&gt; and Reason, that’s following Wlaschin’s example. The main reason to do that is to make explicit that we’re not actually wanting an &lt;em&gt;exception&lt;/em&gt; type in our domain model, but just something we haven’t &lt;em&gt;yet&lt;/em&gt; defined. Anywhere we attempted to use it, we’d have to handle it like, well… an exception, instead of an actual type.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type OrderId = !;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="workflows-and-functions" class="level2"&gt;
&lt;h2&gt;Workflows and functions&lt;/h2&gt;
&lt;p&gt;Once we have the basic types themselves in place, we need to write down the ways we transform between them. In a functional style, we’re not going to implement instance methods—though as we’ll see in the next post, what we do in Rust will have &lt;em&gt;some&lt;/em&gt; similarities to class methods—we’re going to implement standalone functions which take types and return other types.&lt;/p&gt;
&lt;p&gt;Again, you’ll note that despite the common lineage, there is a fair amount of variation here. (Note that we’d also have defined the &lt;code&gt;UnvalidatedOrder&lt;/code&gt;, &lt;code&gt;ValidationError&lt;/code&gt;, and &lt;code&gt;ValidatedOrder&lt;/code&gt; types for all of this; I’m mostly interested in showing &lt;em&gt;new&lt;/em&gt; differences here.)&lt;/p&gt;
&lt;p&gt;Rust (using the &lt;a href="https://github.com/alexcrichton/futures-rs"&gt;Futures&lt;/a&gt; library to represent eventual computation):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidationResponse&amp;lt;T&amp;gt; = Future&amp;lt;Item = T, Error = ValidationError&amp;gt;;

fn validate_order(unvalidated: UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt; {
    unimplemented!()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (using the built-in &lt;code&gt;Task&lt;/code&gt; type for eventual computation; &lt;code&gt;Task&lt;/code&gt;s encapsulate both eventuality and the possibility of failure):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type ValidationResponse a
    = Task (List ValidationError) a

type alias ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse ValidatedOrder&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (using the built-in &lt;code&gt;Async&lt;/code&gt; type for eventual computation):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type ValidationResponse&amp;lt;&amp;#39;a&amp;gt; = Async&amp;lt;Result&amp;lt;&amp;#39;a,ValidationError list&amp;gt;&amp;gt;

type ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (using the built-in JavaScript-specific &lt;code&gt;Js.Promise&lt;/code&gt; type—which is exactly what it sounds like—for eventual computation):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type validationResponse(&amp;#39;a) = Js.Promise.t(Js.Result.t(&amp;#39;a, list(validationError)));

type validateOrder = unvalidatedOrder =&amp;gt; validationResponse(validatedOrder);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again Rust is much &lt;em&gt;more&lt;/em&gt; different here from the others than they are from each other. The biggest difference between Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason is how they handle generics and type parameters.&lt;/p&gt;
&lt;p&gt;You’ll note that in Elm, they just follow the name of the wrapping type. This is a kind of syntactic symmetry: the way you &lt;em&gt;name&lt;/em&gt; a generic type like this is the same basic way you &lt;em&gt;construct&lt;/em&gt; it. It’s quite elegant. And as it turns out, the same is true of Reason; it’s just that its authors have chosen to follow OCaml and use parentheses for them instead of following Haskell with spaces—a reasonable choice, given Reason is surface syntax for OCaml and not Haskell.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; uses angle brackets, I strongly suspect, because that’s what C&lt;sup&gt;#&lt;/sup&gt; uses for generics, and keeping them syntactically aligned in things like this is very helpful. Rust similarly uses angle brackets for similarity with other languages which have similar surface syntax—especially C++ (with its templates).&lt;/p&gt;
&lt;p&gt;The way you &lt;em&gt;name&lt;/em&gt; generic parameters differs between the languages as well. Elm, following Haskell, uses lowercase letters to name its generics (usually called &lt;em&gt;type parameters&lt;/em&gt; in Elm). F&lt;sup&gt;#&lt;/sup&gt; and Reason both (unsurprisingly) follow OCaml in using lowercase letters preceded by an apostrophe to name generics—in F&lt;sup&gt;#&lt;/sup&gt;, &lt;code&gt;TypeGenericOver&amp;lt;'a&amp;gt;&lt;/code&gt;; in Reason, &lt;code&gt;typeGenericOver('a)&lt;/code&gt;. Rust follows the convention from languages like C++, Java, and C&lt;sup&gt;#&lt;/sup&gt; and uses capital letters, &lt;code&gt;TypeGenericOver&amp;lt;T&amp;gt;&lt;/code&gt;. The use of specific letters is conventional, not mandated by the language (unlike the casing). The ML family usually starts with &lt;code&gt;a&lt;/code&gt; and moves through the alphabet; Rust and the languages it follows usually start with &lt;code&gt;T&lt;/code&gt; (for &lt;em&gt;type&lt;/em&gt;) and moves forward through the alphabet. (Sometimes you’ll also see different letters where it’s obviously a better fit for what’s contained.)&lt;/p&gt;
&lt;p&gt;These languages also vary in the syntax for constructing a &lt;em&gt;list&lt;/em&gt; of things. In F&lt;sup&gt;#&lt;/sup&gt; has convenience syntax for a few built-ins (the most common being the &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Option&lt;/code&gt; types), allowing you to write them &lt;em&gt;either&lt;/em&gt; as e.g. &lt;code&gt;List&amp;lt;ConcreteType&amp;gt;&lt;/code&gt; or &lt;code&gt;ConcreteType list&lt;/code&gt; (as here in the example). Elm, Reason, and Rust all just use the standard syntax for generic types—&lt;code&gt;List a&lt;/code&gt;, &lt;code&gt;list('a)&lt;/code&gt;, and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Finally, you’ll also note that we haven’t written out a &lt;em&gt;type&lt;/em&gt; declaration here for Rust; we’ve actually written out a stub of a function, with the &lt;a href="https://doc.rust-lang.org/std/macro.unimplemented.html"&gt;&lt;code&gt;unimplemented!()&lt;/code&gt;&lt;/a&gt; &lt;a href="https://doc.rust-lang.org/1.17.0/reference/macros-by-example.html"&gt;macro&lt;/a&gt;. If you invoke this function, you’ll get a clear crash with an explanation of which function isn’t implemented.&lt;/p&gt;
&lt;p&gt;Now, Rust also &lt;em&gt;does&lt;/em&gt; let us write out the type of these functions as type aliases if we want:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidateOrder =
    Fn(UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You just don’t use these very often in idiomatic Rust; it’s much more conventional to simply write out what I did above. However, the one time you &lt;em&gt;might&lt;/em&gt; use a type alias like this is when you’re defining the type of a closure and you don’t want to write it inline. This is a pretty sharp difference between Rust and the other languages on display here, and it goes to the difference in their approaches.&lt;/p&gt;
&lt;p&gt;Rust is &lt;em&gt;not&lt;/em&gt; a functional-first language in the way that each of the others are, though it certainly draws heavily on ideas from functional programming throughout and makes quite a few affordances for a functional style. Instead, it’s a programming language first and foremost interested in combining the most screaming performance possible with true safety, and leaning on ideas from the ML family (among others!) as part of achieving that.&lt;/p&gt;
&lt;p&gt;Among other things, this is why you don’t have currying or partial application in Rust: those essentially &lt;em&gt;require&lt;/em&gt; you to have invisible heap-allocation to be ergonomic. We &lt;em&gt;don’t&lt;/em&gt; have that in Rust, as we do in Elm, Reason, and F&lt;sup&gt;♯&lt;/sup&gt;. If we want to pass around a function, we have to explicitly wrap it in a pointer to hand it around if we construct it in another function. (I won’t go into more of the details of this here; I’ve covered it some &lt;a href="http://www.newrustacean.com/show_notes/e004/index.html"&gt;on New Rustacean&lt;/a&gt; and some &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;in my Rust and Swift comparison&lt;/a&gt; a couple years ago.)&lt;/p&gt;
&lt;p&gt;That same underlying focus on performance and explicitness is the reason we have &lt;code&gt;Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;&lt;/code&gt; in the Rust case: we’re explicitly returning a &lt;em&gt;pointer&lt;/em&gt; to the type here. In Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason, that’s &lt;em&gt;always&lt;/em&gt; the case. But in Rust, you can and often do return stack-allocated data and rely on “move” semantics to copy or alias it properly under the hood.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;So: lots of similarities here at first blush. The biggest differences that show up at this point are purely syntactical, other than some mildly sharper differences with Rust because of its focus on performance. The fact that these languages share a common lineage means it’s not hard to read any of them if you’re familiar with the others, and it’s actually quite easy to switch between them at the levels of both syntax and semantics.&lt;/p&gt;
&lt;p&gt;As usual, when dealing with languages in a relatively similar family, it’s &lt;em&gt;most&lt;/em&gt; difficult to learn the &lt;em&gt;library&lt;/em&gt; differences. The most obvious example of that here is Reason’s &lt;code&gt;Js.Promise&lt;/code&gt;, Elm’s &lt;code&gt;Task&lt;/code&gt;, F&lt;sup&gt;♯&lt;/sup&gt;’s &lt;code&gt;Async&lt;/code&gt;, and Rust’s &lt;code&gt;Future&lt;/code&gt; types: each of those has their own quirks, their own associated helper functions or methods, and their own ways of handling the same basic patterns.&lt;/p&gt;
&lt;p&gt;Still, if you have played with any one of these, you could pretty easily pick up one of the others. It’s sort of like switching between Python and Ruby: there are some real differences there, but the similarities are greater than the differences. Indeed, if anything, these languages are &lt;em&gt;more&lt;/em&gt; similar than those.&lt;/p&gt;
&lt;p&gt;Next time I’ll dig into Wlaschin’s chapter on &lt;em&gt;validating&lt;/em&gt; the domain model, and here some of the not-just-syntax-level differences in the languages will start to become more apparent.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I can’t speak to what’s idiomatic this way in any of the non-Rust languages, because I just haven’t used them enough yet.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 14 Jan 2018 09:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-14:/2018/exploring-4-languages-starting-to-model-the-domain.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages: Project Setup</title><link>http://www.chriskrycho.com/2018/exploring-4-languages-project-setup.html</link><description>&lt;p&gt;In this post, I’m just going to briefly talk through the steps I needed to do to set up each of the languages and my editor setup for them. Gladly, it was pretty simple. At the end, I’ll offer a note on my thoughts on the setup processes. (Note that this isn’t “How to do this for anyone ever”—it’s “how I did it, with some notes where it might be relevant to you.”)&lt;/p&gt;
&lt;p&gt;For context, I’m running macOS and using &lt;a href="https://code.visualstudio.com"&gt;VS Code&lt;/a&gt; as my editor. Whenever I say “Install the VS Code extension,” you can do it either by opening the extension side panel and searching for &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;, or by typing &lt;code&gt;ext install &amp;lt;extension label&amp;gt;&lt;/code&gt;—I’ll write it like &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;extension label&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The source code as of what I’m describing in this post is &lt;a href="https://github.com/chriskrycho/dmmf/tree/project-setup"&gt;at the &lt;code&gt;project-setup&lt;/code&gt; tag&lt;/a&gt; in &lt;a href="https://github.com/chriskrycho/dmmf/"&gt;the repo&lt;/a&gt;.&lt;/p&gt;
&lt;section id="rust" class="level2"&gt;
&lt;h2&gt;Rust&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation:&lt;/strong&gt; Install &lt;a href="https://rustup.rs"&gt;&lt;em&gt;rustup&lt;/em&gt;&lt;/a&gt;: &lt;code&gt;curl https://sh.rustup.rs -sSf | sh&lt;/code&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code extension: &lt;code&gt;Rust (rls)&lt;/code&gt;/&lt;code&gt;rust&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of &lt;a href="https://github.com/chriskrycho/dmmf"&gt;my repo&lt;/a&gt;, I ran &lt;code&gt;cargo new rust&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="elm" class="level2"&gt;
&lt;h2&gt;Elm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: There are installers, but I just did &lt;code&gt;npm i -g elm&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code Elm extension: &lt;code&gt;Elm&lt;/code&gt;/&lt;code&gt;elm&lt;/code&gt;.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Install the &lt;code&gt;create-elm-app&lt;/code&gt; tool: &lt;code&gt;npm i -g create-elm-app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the root of the project, I ran &lt;code&gt;create-elm-app elm&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="f" class="level2"&gt;
&lt;h2&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Install &lt;a href="http://www.mono-project.com"&gt;mono&lt;/a&gt;: &lt;code&gt;brew install mono&lt;/code&gt; (note installation instructions &lt;a href="option-5-install-f-with-mono-via-homebrew-64-bit"&gt;here&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Install the VS Code Ionide extension: &lt;code&gt;Ionide-fsharp&lt;/code&gt;/&lt;code&gt;ionide-fsharp&lt;/code&gt;. It’ll automatically install the associated Paket and FAKE extensions from the Ionide project as well, and those will install Paket and FAKE during installation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;In the root of the repo, I created the &lt;code&gt;fsharp&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;Then I opened a VS Code instance to to that directory, opened the command palette, and ran &lt;code&gt;F#: New Project&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;I chose &lt;code&gt;console&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;I left the directory blank&lt;/li&gt;
&lt;li&gt;I named the project &lt;code&gt;dmmf&lt;/code&gt; (for &lt;em&gt;D&lt;/em&gt;omain &lt;em&gt;M&lt;/em&gt;odeling &lt;em&gt;M&lt;/em&gt;ade &lt;em&gt;F&lt;/em&gt;unctional).&lt;/li&gt;
&lt;li&gt;Since F&lt;sup&gt;♯&lt;/sup&gt; (like C&lt;sup&gt;♯&lt;/sup&gt;) prefers PascalCase names, I renamed the generated module &lt;code&gt;DMMF&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="reasonml" class="level2"&gt;
&lt;h2&gt;ReasonML&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Following the setup instructions &lt;a href="https://reasonml.github.io/guide/javascript/quickstart"&gt;here&lt;/a&gt;, I ran &lt;code&gt;npm install -g bs-platform&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; following &lt;a href="https://reasonml.github.io/guide/editor-tools/global-installation"&gt;the official instructions&lt;/a&gt;—
&lt;ul&gt;
&lt;li&gt;I ran &lt;code&gt;npm install -g https://github.com/reasonml/reason-cli/archive/3.0.4-bin-darwin.tar.gz&lt;/code&gt; to install the dependencies for the editor configuration.&lt;/li&gt;
&lt;li&gt;I installed the VS Code extension: &lt;code&gt;Reason&lt;/code&gt;/&lt;code&gt;reasonml&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of the repo, I ran &lt;code&gt;bsb -init reason -theme basic-reason&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="comments-on-the-setup-processes" class="level2"&gt;
&lt;h2&gt;Comments on the setup processes&lt;/h2&gt;
&lt;p&gt;Most of the languages have &lt;em&gt;fairly&lt;/em&gt; straightforward processes to get up and running with a good-to-excellent tooling experience.&lt;/p&gt;
&lt;p&gt;The best of them is Rust, which is &lt;em&gt;extremely&lt;/em&gt; easy to get up and running with.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; Elm is roughly in the middle—it’s less straightforward than Rust in that &lt;code&gt;create-elm-app&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; an officially supported approach, unlike &lt;code&gt;rustup&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;, so you’re going to have a much less awesome experience if you don’t know about it.&lt;/p&gt;
&lt;p&gt;Reason and F&lt;sup&gt;♯&lt;/sup&gt; both have slightly larger negatives.&lt;/p&gt;
&lt;p&gt;Reason requires you to &lt;code&gt;npm install&lt;/code&gt; a large, gzipped file with multiple dependencies all bundled, instead of having a dedicated installer &lt;em&gt;a la&lt;/em&gt; &lt;code&gt;rustup&lt;/code&gt;. It also has the possibility for a not-so-great first-run experience in the editor, which &lt;a href="https://github.com/facebook/reason/issues/1729"&gt;I discovered&lt;/a&gt; all too quickly.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; essentially requires you to use an editor extension to get the language setup with &lt;a href="https://fsprojects.github.io/Paket/"&gt;Paket&lt;/a&gt;, which is a &lt;em&gt;much&lt;/em&gt; better choice of package manager than the default .NET package manager NuGet. Command line tools exist and are improving rapidly, and you &lt;em&gt;can&lt;/em&gt; &lt;a href="https://fsprojects.github.io/Paket/paket-and-dotnet-cli.html"&gt;get them working&lt;/a&gt;… but it’s harder than it needs to be. And that project setup wizard is &lt;em&gt;fine&lt;/em&gt;, but it’s a lot noisier than just doing &lt;code&gt;create-elm-app&lt;/code&gt; or especially &lt;code&gt;cargo new&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In any case, though, I have them all up and running now! More soon!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re uncomfortable with running that script, there are &lt;a href="https://www.rust-lang.org/en-US/other-installers.html"&gt;other options&lt;/a&gt; as well.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Note that the VS Code extension is &lt;em&gt;not&lt;/em&gt; the best experience out there for Elm: the Atom extensions (&lt;a href="https://atom.io/packages/language-elm"&gt;language-elm&lt;/a&gt; and &lt;a href="https://atom.io/packages/elmjutsu"&gt;elmjutsu&lt;/a&gt;) are. I stuck with VS Code because it’s &lt;em&gt;good enough&lt;/em&gt; and, more importantly, the Code extensions are arguably best in class for the &lt;em&gt;other&lt;/em&gt; languages… and it’s what I use every day.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;I’m not just saying that because I’m a Rust fanboy, either! If Rust were hard to use, I’d be complaining &lt;em&gt;louder&lt;/em&gt; because of my enthusiasm for the language.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 01 Jan 2018 13:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-01:/2018/exploring-4-languages-project-setup.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages</title><link>http://www.chriskrycho.com/2017/exploring-4-languages.html</link><description>&lt;p&gt;Today, as I hit the first of the implementation chapters in &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt;, I started thinking about how I wanted to implement it. As I’ve noted &lt;a href="https://twitter.com/chriskrycho/status/934170826718429184"&gt;elsewhere&lt;/a&gt; in the past, very little of the book is &lt;em&gt;truly&lt;/em&gt; specific to F&lt;sup&gt;♯&lt;/sup&gt;, though that’s the language Wlaschin uses in the book—and Wlaschin himself &lt;a href="https://twitter.com/ScottWlaschin/status/934177554331848705"&gt;agrees&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks! Yes, it’s true that you could easily use #ElmLang, #RustLang, #Scala, or especially #OCaml to work through the book. I use hardly any F# specific features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So… I decided to try something a little bit bonkers. I’m going to implement these exercises in &lt;em&gt;four different languages&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fsharp.org"&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reasonml.github.io"&gt;ReasonML&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are all related: they’re descended from &lt;a href="http://smlnj.org/sml.html"&gt;Standard ML&lt;/a&gt;. ReasonML and F&lt;sup&gt;♯&lt;/sup&gt; are like siblings: Reason is merely a custom syntax for OCaml; F&lt;sup&gt;♯&lt;/sup&gt; is (originally) an implementation of OCaml on .NET (though the two languages have diverged since F&lt;sup&gt;♯&lt;/sup&gt; came into existence). Elm and Rust are cousins of each other and of Reason and F&lt;sup&gt;♯&lt;/sup&gt;, though they’re both drawing on other languages besides OCaml as well. I also have some familiarity with Rust, Elm, and F&lt;sup&gt;♯&lt;/sup&gt; already, and have read the docs for Reason a couple times. So this is a &lt;em&gt;bit&lt;/em&gt; less crazy than it might otherwise be.&lt;/p&gt;
&lt;p&gt;Why, though? Mostly because I think it’ll be interesting to compare the implementations of the domain model from the book side by side. It’ll look just a bit different in each language, and I expect to learn a bit more of the &lt;em&gt;feel&lt;/em&gt; of each language by doing this. (That side by side comparison is something I’ve &lt;a href="http://www.chriskrycho.com/rust-and-swift.html" title="Series: Rust and Swift"&gt;done before&lt;/a&gt; and &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html" title="Part V: The value (and challenge) of learning languages in parallel."&gt;found very profitable&lt;/a&gt;.) I’ll also turn it into blog posts, which hopefully will be interesting to others!&lt;/p&gt;
&lt;p&gt;More to come, and soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 31 Dec 2017 20:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-31:/2017/exploring-4-languages.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>The Book of F♯</title><link>http://www.chriskrycho.com/2017/the-book-of-f.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I keep my book review ratings simple—they’re either &lt;em&gt;required&lt;/em&gt;, &lt;em&gt;recommended&lt;/em&gt;, &lt;em&gt;recommended with qualifications&lt;/em&gt;, or &lt;em&gt;not recommended&lt;/em&gt;. If you want the TL;DR, this is it:&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Recommended With Qualifications:&lt;/strong&gt; This book is just okay, and at this point it’s a bit outdated—but if you’re in its fairly narrow target audience, it’s a decent way to get up to speed on F#.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;The Book of F♯: Breaking Free With Managed Functional Programming&lt;/em&gt; is a No Starch Press publication by Dave Fancher, published in 2014. I read it over the course of the last four or so months, just plugging away in my spare cycles. A couple qualifications on the short list of observations that follow:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;I don’t have any experience whatsoever writing production F♯ (though I have &lt;em&gt;read&lt;/em&gt; a fair bit of it). I am interested because it’s a functional programming language on the .NET stack—which isn’t my own personal favorite stack, but &lt;em&gt;is&lt;/em&gt; the stack at Olo. If we’re going to ship functional code on the server, it’ll be in F♯.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I am also not a C♯ developer. As such, I’m &lt;em&gt;explicitly&lt;/em&gt; not the audience of this book. As Fancher put it in the intro:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I wrote this book for people like me: experienced .NET developers looking to break into functional programming while retaining the safety net of the tools and libraries they’re already using.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The net of that is that a lot of what frustrated me about the book is just a result of my not being the target audience.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Those qualifications aside, some assorted thoughts on the book:&lt;/p&gt;
&lt;p&gt;First, as the intro and my above qualification suggest: this is &lt;em&gt;really&lt;/em&gt; not interesting or useful as a general introduction to F♯. Throughout, it assumes a very high baseline of C♯ knowledge. In fact, the majority of the discussion of F♯, even in the section of the book which turns away from object oriented programming toward functional programming, focuses on comparing F♯ to C♯. This makes sense for the target audience, but this is &lt;em&gt;not&lt;/em&gt; the book for you if you’re not a C♯ developer.&lt;/p&gt;
&lt;p&gt;That said, if you &lt;em&gt;are&lt;/em&gt; a C♯ developer, this could be a useful resource as you’re spinning up. It also might be a useful book to work through with a group of C♯ developers who want to learn F♯. The comparisons &lt;em&gt;do&lt;/em&gt; generally work in F♯’s favor, even when doing exactly what you would be doing in the C♯, which makes it an easier “sell” in that regard.&lt;/p&gt;
&lt;p&gt;Along the same lines, the book is structured as a &lt;em&gt;very gradual&lt;/em&gt; introduction to functional programming ideas. Roughly the first half of the book emphasizes F♯’s object-oriented programming abilities, and only in the second half does Fancher turn to a functional style. Again, this is probably the right move given the audience, but it means the book spends a &lt;em&gt;lot&lt;/em&gt; of time on kinds of F♯ you won’t actually be writing very often once you’re going. Idiomatic F♯ isn’t object-oriented. But as a way of helping someone make the transition, it’s not a bad plan: object-oriented F♯ is briefer and nicer in many ways than the exact same code in C♯. It meant that the first half of the book was completely uninteresting to &lt;em&gt;me&lt;/em&gt;, though: I don’t want to write a line of object-oriented F♯.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All of this had a pretty serious downside even for existing C♯ developers, though: the book often ends up seeming like it’s sort of apologizing for or defending F♯ against an expected audience of people asking “What’s wrong with C♯?” And even though there’s a real sense in which that’s true—that &lt;em&gt;is&lt;/em&gt; what a lot of the audience is asking, no doubt—it became quite annoying rhetorically.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; It’s also unnecessary: if someone is picking up a book on F♯, you can assume that they’re alredy at least a little interested in the language and what it might offer! Along those lines, I much prefer the tack taken in what I’ve seen of Scott Wlaschin’s upcoming &lt;em&gt;Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F♯&lt;/em&gt; (The Pragmatic Bookshelf, expected in fall 2017)—which shows not how to do the same things as in C♯, just more briefly; but how to solve the same problems much more effectively.&lt;/p&gt;
&lt;p&gt;Those problems aside, the book was… &lt;em&gt;fine&lt;/em&gt;. I wouldn’t call it scintillating reading, but this kind of technical writing, especially at this length, is really hard work. Credit to Fancher for managing an introduction to an entire programming language in a relatively approachable way, and credit to him and his editors for making sure it remains lucid throughout. Still: I’d love to see the bar for programming books be higher. We need more books which are genuinely engaging in the world of programming language texts. These things are &lt;em&gt;interesting&lt;/em&gt;; we don’t have to make them dry and dull! (And if you want a pretty good example of that: everything I’ve read of Edwin Brady’s &lt;em&gt;Type-Driven Development with Idris&lt;/em&gt; hits the mark.)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A few other observations about the language itself from reading the book.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First,&lt;/strong&gt; reading this highlighted a lot of strange things about F♯, all of which ultimately come down to the ways F♯’s development has been driven by concerns for interoperability with C♯. Worse, there are a lot of places where the influence of C♯ casts this shadow &lt;em&gt;entirely unnecessarily&lt;/em&gt;. One particular expression of this which drove me crazy: F♯ far too often uses exceptions instead of &lt;code&gt;Option&lt;/code&gt;s. It’s &lt;a href="http://www.chriskrycho.com/2017/better-off-using-exceptions.html"&gt;one thing&lt;/a&gt; to make sure the language gracefully handle exceptions: you &lt;em&gt;will&lt;/em&gt; have them coming from outside contexts. It is another entirely to design core parts of the language to throw exceptions where it doesn’t have to.&lt;/p&gt;
&lt;p&gt;Perhaps the most prominent example is the &lt;code&gt;List.head&lt;/code&gt; function. Its type signature is &lt;code&gt;'T list -&amp;gt; 'T&lt;/code&gt;, where I would expect it to be &lt;code&gt;'T list -&amp;gt; 'T option&lt;/code&gt;. If you call &lt;code&gt;List.head&lt;/code&gt; on an empty list, you get an exception. It would make far more sense for it to return an &lt;code&gt;Option&lt;/code&gt; and just give you &lt;code&gt;None&lt;/code&gt; if there’s no item. Then you’re not worried about &lt;code&gt;try&lt;/code&gt; expressions and the type system will actually help you! This is one of the most valuable parts of having a type system like F♯’s! I really don’t understand a lot of these decisions, not least since this isn’t for interop with C♯ collections—these are for native F♯ collections.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second,&lt;/strong&gt; the use of things like computation expressions instead of type machinery has an interesting effect: it makes it simpler to read when you first encounter it, but harder to compose, build, etc.—and it’s more syntax to remember. Computation expressions just end up being a way to do “monadic” transformations, from what I can tell. But as I noted often in my discussion of &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;Rust and Swift&lt;/a&gt;, I profoundly prefer approaches that build on the same existing machinery—even in the surface syntax of the language—rather than constantly building new machinery. It makes it easier to deeply internalize new concepts and to &lt;em&gt;understand&lt;/em&gt; the language (rather than just being able to &lt;em&gt;use&lt;/em&gt;) the language. It also seems (from my admittedly limited vantage point) that computation expressions are as a result much less &lt;em&gt;composable&lt;/em&gt; than actual type machinery of the sort available in other languages (Haskell, Idris, etc.).&lt;/p&gt;
&lt;p&gt;Now, the tradeoff there is that adding those adds a lot of complexity both to the compiler and to the libraries people are apt to write; there’s a reason Elm has totally eschewed that kind of type machinery to date. But Elm has also refused to just add syntax around ideas like this the way F♯ has here, and it makes for a much cleaner and frankly &lt;em&gt;nicer&lt;/em&gt; language.&lt;/p&gt;
&lt;p&gt;And that brings me to my &lt;strong&gt;third and final&lt;/strong&gt; point: I’m really glad F♯ exists, and that it’s providing a pretty good experience of functional programming on the &lt;abbr title='Common Language Runtime'&gt;CLR&lt;/abbr&gt;. But—and I fully grant that a fair bit of this kind of thing is almost entirely subjective—it doesn’t &lt;em&gt;feel&lt;/em&gt; good in the same way that Elm or Rust do. There is something very difficult to nail down here, but I get a vsiceral experience of joy when writing some languages and not others. Again: that will vary person to person, but I think there are things that make it more or less likely. Things that make it more likely, at least for me, include everything from self-consistency and predictability at the semantic level to the way the code lays out and flows at the visual/syntactical level.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; Sadly, F♯ just doesn’t hit the right notes&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; for me. I’ll be much, much happier to write it than C♯ at work… but I really just want Elm and Rust and Idris to come save the day.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I am of course writing a &lt;em&gt;lot&lt;/em&gt; of functional code in our JavaScript; JavaScript is a surprisingly good language for it.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;It’s not that OOP is &lt;em&gt;bad&lt;/em&gt;, exactly; it’s just that what passes for OOP in languages like C♯, Java, and yes, F♯, is relatively low utility to me—and I think OOP ideas are much more interesting and useful when applied at a systems level, e.g. in an Actor system, than at the level of individual “actors” within the system. Compare Erlang/Elixir: functional components, organized in what is arguably an &lt;em&gt;incredibly&lt;/em&gt; object-oriented way.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;The temptation extends beyond this book; O’Reilly’s &lt;em&gt;Programming Rust&lt;/em&gt; (Jim Blandy and Jason Orendorff) reads as the same kind of defensive introduction to Rust for C++ developers.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;And yes, nerds, syntax &lt;em&gt;does&lt;/em&gt; matter. Try reading this sentence, nicely punctuated, and with spaces and capitalization. Now: tryreadingthissentencewithoutpunctuationorspacesorcapitalization. There may be a point after which it becomes less important, and a range of things which are equally good in an absolute sense, but it matters.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Pun not intended, but inevitable given the language names here.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 21 Jul 2017 19:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-21:/2017/the-book-of-f.html</guid><category>book-reviews</category><category>programming languages</category><category>fsharp</category><category>writing</category><category>pedagogy</category></item><item><title>Better Off Using Exceptions?</title><link>http://www.chriskrycho.com/2017/better-off-using-exceptions.html</link><description>&lt;p&gt;I saw this post on error-handling in F&lt;sup&gt;♯&lt;/sup&gt;, &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You’re better off using Exceptions"&gt;“You’re better off using Exceptions”&lt;/a&gt; making the rounds on Twitter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Exception handling is an error management paradigm that has often been met with criticism. Such criticisms typically revolve around scoping considerations, exceptions-as-control-flow abuse or even the assertion that exceptions are really just a type safe version of goto. To an extent, these seem like valid concerns but it is not within the scope of this article to address those per se.&lt;/p&gt;
&lt;p&gt;Such concerns resonate particularly well within FP communities, often taken to the extreme: we should reject exceptions Show more…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And I get the argument, and in the specific context of F&lt;sup&gt;♯&lt;/sup&gt;—especially given how much C&lt;sup&gt;♯&lt;/sup&gt;-interoperating and therefore exception-throwing-code-interoperating there is there—it’s reasonable.&lt;/p&gt;
&lt;p&gt;But it still makes me sad. (To be clear: exceptions were and are a big win over what you get in languages like C. I’ll take them any day over &lt;code&gt;goto&lt;/code&gt; or &lt;code&gt;segfault&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;You need to embrace exceptions in F&lt;sup&gt;♯&lt;/sup&gt; &lt;em&gt;because F&lt;sup&gt;♯&lt;/sup&gt; has exceptions&lt;/em&gt; and because &lt;em&gt;many of its libraries rely on exceptions&lt;/em&gt;. But my experience with Rust and other non-exception-using languages is that you &lt;em&gt;don’t&lt;/em&gt; need exceptions in the general case.&lt;/p&gt;
&lt;p&gt;The questions are: whether your language has good support for things like flat-mapping, and whether you’re willing to commit to letting the compiler help you with these problems.&lt;/p&gt;
&lt;p&gt;To be sure: there’s more work involved up front to deal with that. But that’s a tradeoff I’m &lt;em&gt;always&lt;/em&gt; willing to make. I’d rather have the compiler tell me if I’m failing to account for something than learn because I saw a runtime error report come up in &lt;a href="https://raygun.com"&gt;Raygun&lt;/a&gt;, especially because that tends to mean an error that affects the user in some way.&lt;/p&gt;
&lt;p&gt;Rust’s model gives you something like exceptions for truly unrecoverable errors, “panics.” A panic gives you all the context you’d get from an exception (one of the virtues of exceptions highlighted in that post), but you can only “catch” it at thread boundaries, and it otherwise just kills the program. Because it’s catastrophic, you only use it where you don’t have any way to recover in your immediate context. But where you can recover in your immediate context… using something like a highly descriptive enum (just as suggested at the end of &lt;a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/" title="You’re better off using Exceptions"&gt;that original post&lt;/a&gt;!) is a better option.&lt;/p&gt;
&lt;p&gt;It’s well-understood in my circles that you shouldn’t use exceptions for things you can recover from; you should use them for things you &lt;em&gt;can’t&lt;/em&gt; recover from. But in most languages which lean heavily on exceptions, you inevitably start using them for control flow. I say: if you can recover from an error… just recover from it! Account for recoverable errors as possible conditions in your program and carry on! If you can’t recover… don’t. Die and let some other part of your system kick things back off.&lt;/p&gt;
&lt;p&gt;In summary: yes, if you’re in F&lt;sup&gt;♯&lt;/sup&gt;, use exceptions. It &lt;em&gt;is&lt;/em&gt; the right thing to do in many cases (and you don’t have a choice in many others). But I’m hopeful for a future where we handle recoverable errors locally, and &lt;a href="http://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html"&gt;act like Erlang or Elixir otherwise&lt;/a&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 20 Feb 2017 12:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-02-20:/2017/better-off-using-exceptions.html</guid><category>fsharp</category><category>software development</category><category>rust</category><category>functional programming</category></item></channel></rss>