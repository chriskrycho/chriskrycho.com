<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - UI</title><link>http://v4.chriskrycho.com/</link><description></description><lastBuildDate>Thu, 12 Sep 2019 09:00:00 -0400</lastBuildDate><item><title>User Interfaces are API Boundaries</title><link>http://v4.chriskrycho.com/2019/user-interfaces-are-api-boundaries.html</link><description>&lt;p&gt;&lt;i&gt;&lt;b&gt;&lt;a href="https://v4.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience&lt;/a&gt;:&lt;/b&gt; software developers, especially those who work on user interfaces.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fsharpforfunandprofit.com/ddd/"&gt;Domain-driven design&lt;/a&gt;, and its near neighbor the &lt;a href="https://web.archive.org/web/20060711221010/http://alistair.cockburn.us:80/index.php/Hexagonal_architecture"&gt;ports and adapters (hexagonal) architecture&lt;/a&gt; all emphasize the importance of distinguishing between your internal “business logic” and your interactions with the rest of the world. Much of the time, the “ports” that get discussed are &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; calls (e.g. over &lt;abbr title="hyper-text transfer protocol"&gt;HTTP&lt;/abbr&gt;) or interacting with a database.&lt;/p&gt;
&lt;p&gt;Yesterday, in the midst of a rollicking conversation about building forms in web apps,&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I realized:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;User interfaces are &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; boundaries, too!&lt;/em&gt;&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;I claim no novelty here; I’m sure that if I went through the literature on domain-driven design and the adjacent architectural ideas, I’d find this same point made by others. It’s just a fruitful&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; wording I have not heard before—a concise way of expressing an idea that has been rather floating around in my head in much vaguer terms for the last couple years.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;One of the key insights of DDD and the ports-and-adapters model is that every interaction with the world outside your program is a place of uncertainty. The &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; might have changed and you might be getting back different responses than you expect. The database might have been corrupted. The network might be down—or worse, degraded so that you get &lt;em&gt;partial&lt;/em&gt; messages through, and have to deal with incomplete or nonsensical data. Your software design has to account for this. If you isolate the complexity of dealing with that to well-defined, well-constrained boundaries for your application, everything in between can be &lt;em&gt;much&lt;/em&gt; simpler.&lt;/p&gt;
&lt;p&gt;And the most reliably unpredictable source of data we have for &lt;em&gt;any&lt;/em&gt; application… is users! People are complicated and distracted, and our interfaces are always imperfect, often misleading or confusing in various ways (our best intentions notwithstanding). So we get “bad” data from our users. I scare-quote “bad” here because the data is not (necessarily) &lt;em&gt;morally&lt;/em&gt; bad (though: see Twitter!) and it is (usually) a &lt;em&gt;mistake&lt;/em&gt; rather than &lt;em&gt;malice&lt;/em&gt; at root (though: see all sorts of hacking). But from the perspective of our app’s internals, the data has to be validated and transformed to our model of the world, just as data returned from an &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; or a database does.&lt;/p&gt;
&lt;p&gt;If you’re familiar with how these architectures suggest handling sources of data external to your program, the implication for user interaction is obvious: you need to treat it like you would an &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt;. You should have a clean separation between the data model of a form and the data model used within your application. Put in common &lt;abbr title="object oriented"&gt;OO&lt;/abbr&gt; parlance: your form model is a kind of &lt;a href="https://martinfowler.com/eaaCatalog/dataTransferObject.html"&gt;data transfer object&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Notice that this holds whether you’re using a traditional web form which submits a &lt;code&gt;POST&lt;/code&gt; request via &lt;abbr title="hyper-text transfer protocol"&gt;HTTP&lt;/abbr&gt;, or building a rich &lt;abbr title="single page application"&gt;SPA&lt;/abbr&gt;-style JavaScript app which will use the form data without ever sending it anywhere. You have to first validate the data to make sure it is complete and correct—presumably with a mechanism for letting the user know if it isn’t. You also normally need to &lt;em&gt;transform&lt;/em&gt; the basically flat data you get back from your form into in a data structure which is appropriately rich for the domain you’re working with.&lt;/p&gt;
&lt;p&gt;Again: all of this is bog standard for DDD and ports-and-adapters thinking. The point is that you should treat forms specifically and user interaction in general in much the same way as any other external data: because &lt;em&gt;user interfaces are &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; boundaries&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In a future post, hopefully some time in the next week or two, I’ll trace out one of the implications of this for how I think about building forms in much more concrete terms!&lt;/p&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;about which conversation more another day!&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;I found it &lt;i&gt;fruitful&lt;/i&gt; in two senses: it was generative for me as I reflected on it, and it produced some forward motion in a conversation about real-world software development.&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 12 Sep 2019 09:00:00 -0400</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2019-09-12:/2019/user-interfaces-are-api-boundaries.html</guid><category>software development</category><category>domain-driven design</category><category>UI</category><category>software architecture</category></item><item><title>From My Sent Folder: On Mozilla and IRC</title><link>http://v4.chriskrycho.com/2019/from-my-sent-folder-on-mozilla-and-irc.html</link><description>&lt;p&gt;&lt;i&gt;&lt;b&gt;&lt;a href="https://v4.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience&lt;/a&gt;:&lt;/b&gt; anyone who cares about the success of free and open-source software.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i&gt;A New Rustacean listener sent me a note lamenting the way &lt;a href="https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html"&gt;Mozilla’s transition from IRC to Discord&lt;/a&gt;—i.e., from an open protocol to a proprietary service. For many advocates of free software, this is a deeply unsettling move. The kind listener who sent me an email pointed to &lt;a href="https://matrix.org/blog/index"&gt;Matrix&lt;/a&gt;, an open-protocol service, and noted: “perhaps the default web interface is slightly less slick, but there’s not much in it, and it’s open source.” I sympathize with them, but also had a few &lt;em&gt;other&lt;/em&gt; thoughts. My reply is reproduced below.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Yeah, it’s complicated for sure. The last time I looked, Matrix’s mobile clients were so bad as to be effectively unusable; I know that was one of the considerations for the Rust move to Discord.&lt;/p&gt;
&lt;p&gt;It seems to me that a lot of folks committed to free and open-source have ended up wanting free-as-in-beer as well as free-as-in-speech, and the combo of that with the existing market dynamics means that good is rarely open/free-as-in-speech, and vice versa. It’s a Gordian knot I don’t see an easy way through.&lt;/p&gt;
&lt;p&gt;The specific dynamic you highlight with docs is a prime example of the other cultural challenges I see, too: devs don’t like writing docs, they like writing code… but it turns out that docs and other “soft” things—including, yes, &lt;abbr&gt;UI&lt;/abbr&gt; polish!—are actually as or more important for adoption as things like protocols.&lt;/p&gt;
&lt;p&gt;We’ll see this same cycle repeat until free and open source software advocates learn to prioritize the things users actually value as well as the things they (we!) believe they should value.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 30 Apr 2019 08:25:00 -0400</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2019-04-30:/2019/from-my-sent-folder-on-mozilla-and-irc.html</guid><category>open-source software</category><category>free software</category><category>from my sent folder</category><category>UI</category></item></channel></rss>