<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - C</title><link>http://v4.chriskrycho.com/</link><description></description><lastBuildDate>Thu, 20 Dec 2018 18:45:00 -0500</lastBuildDate><item><title>JavaScript is C</title><link>http://v4.chriskrycho.com/2018/javascript-is-c.html</link><description>&lt;p&gt;&lt;i&gt;&lt;b&gt;&lt;a href="https://v4.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience:&lt;/a&gt;&lt;/b&gt; software developers, especially those interested in modern, typed programming languages.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Earlier this week, I was working on a problem in the Ember app where I spend most of my day job, and realized: &lt;i&gt;JavaScript is the same as C.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;That probably doesn’t make any sense, so let’s back up. The scenario I was dealing with was one where there was a bit of invariant around a piece of data that I &lt;em&gt;had&lt;/em&gt; to maintain for the application not to blow up in horrible ways, but had no good way to enforce with the language’s tools. &lt;em&gt;This&lt;/em&gt; action on &lt;em&gt;that&lt;/em&gt; piece of data was only valid if &lt;em&gt;this&lt;/em&gt; condition held true… but even with the fully-type-checked TypeScript application we now have, the action (because of the entire application’s architecture and indeed the entire way that Ember apps are wired together!) could not be statically verified to be safe.&lt;/p&gt;
&lt;p&gt;As I considered the best way to handle this—I ended up having the function involved in the action just throw an error if the invariant wasn’t properly maintained—I was reminded of the years I spent writing C. In C, it’s quite &lt;em&gt;possible&lt;/em&gt; to write safe code around memory management. I managed it fine in the applications I worked on, by carefully documenting the invariants a given function required to be safe. &lt;em&gt;This&lt;/em&gt; piece of data is allocated by &lt;em&gt;that&lt;/em&gt; function and then released to &lt;em&gt;the caller&lt;/em&gt; to manage. Even with every bit of static analysis I threw at those kinds of things, it was possible to get it wrong.&lt;/p&gt;
&lt;p&gt;The exact same kinds of problems I had in C, I have in JavaScript or even TypeScript today. Experientially, JavaScript&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; &lt;em&gt;is&lt;/em&gt; C, as far as having to deal with these kinds of invariants goes.&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enter &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;: the kinds of management of memory that I was always having to keep track of in my head (or, better, with detailed documentation comments along the way—but with the same problem that it was easy to get wrong), I could now have statically guaranteed by a compiler. Given that I spent the first six years of my career managing and carefully tracking all of that by hand, it’s no wonder I &lt;a href="https://newrustacean.com"&gt;fell in love&lt;/a&gt; with Rust. I could have the &lt;em&gt;compiler&lt;/em&gt; guarantee the invariants I needed around memory management.&lt;/p&gt;
&lt;p&gt;And it turns out, this same dynamic exists in the world of front-end web development. People sometimes wonder why (and colleagues are often bemused that) I get so excited by &lt;a href="https://elm-lang.org"&gt;Elm&lt;/a&gt;. But the step from JavaScript (or even TypeScript) to Elm is just like the step from C to Rust. It’s a real and profound shift in what kinds of things you can &lt;em&gt;know for certain&lt;/em&gt; about your program.&lt;/p&gt;
&lt;p&gt;In a C application, try as hard as I may, at the end of the day I am always on my own, making sure the invariants I need for memory safety hold. In Rust, I can be 100% confident that I will not have memory-unsafe code. Not 98%-and-I’d-better-check-those-last-2%-really-closely. One hundred percent. That’s a game-changer.&lt;/p&gt;
&lt;p&gt;In a JavaScript or TypeScript application, try as hard as I may, at the end of the day I am always on my own, making sure the invariants I need for state management hold. In Elm, I can be 100% confident that I will not have code which needs a given invariant about a piece of state to hold break the way it could in this TypeScript application. Because I can’t even apply the relevant transformations in question if it isn’t! That’s a game-changer.&lt;/p&gt;
&lt;p&gt;Neither of those is a guarantee I won’t have bugs. (A compiler that could guarantee that would have to be sentient and far smarter than any human!) Neither of them means I can’t intentionally do stupid things that violate invariants in ways that get the program into broken states from the user’s point of view. But both of them give me the tools and the confidence that I can absolutely guarantee that certain, very important kinds of invariants hold. We’re not looking for an absence of all bugs or a system which can prevent us from making any kind of mistake. We’re looking to be able to spend our times on the things that matter, &lt;em&gt;not&lt;/em&gt; on minutiae the computer can check for us.&lt;/p&gt;
&lt;p&gt;So: I’m not going back to C, and I’m ready to move past JavaScript and TypeScript.&lt;/p&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;This goes for plenty of languages that aren’t JavaScript, too. It’s equally true of c&lt;sup&gt;♯&lt;/sup&gt; or Python.&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;Obviously there are some kinds of things you don’t have to worry about in JS that you do in C: memory management, for one. The point is that the manual-verification-of-every-invariant-you-care-about is the same.&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 20 Dec 2018 18:45:00 -0500</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2018-12-20:/2018/javascript-is-c.html</guid><category>JavaScript</category><category>TypeScript</category><category>Elm</category><category>Rust</category><category>C</category><category>software development</category></item><item><title>High- and Low-Level Programming Languages</title><link>http://v4.chriskrycho.com/2015/high-and-low-level-programming-languages.html</link><description>&lt;p&gt;It occurred to me while listening to &lt;a href="https://edwinb.wordpress.com"&gt;Edwin Brady&lt;/a&gt; talk about &lt;a href="http://www.idris-lang.org"&gt;Idris&lt;/a&gt; on the &lt;a href="http://typetheorypodcast.com"&gt;Type Theory Podcast&lt;/a&gt;,&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; having just spent a few weeks starting to learn &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;: “low-level” has at least two meanings in software. One is whether something has manual memory management or is garbage collected, reference counted, or otherwise manages memory itself. This is what people often mean when they talk about C, C++, etc. as being “low-level” and languages like Python or Ruby or C♯ being high-level.&lt;/p&gt;
&lt;p&gt;But then you toss in a language like &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;, and things start to get a little more complicated. Rust can do the same kind of direct memory management that makes C or C++ a good language for things like writing operating system kernels. [&lt;a href="https://github.com/torvalds/linux"&gt;1&lt;/a&gt;,&lt;a href="https://en.wikipedia.org/wiki/Architecture_of_Windows_NT"&gt;2&lt;/a&gt;,&lt;a href="http://www.opensource.apple.com/source/xnu/xnu-2782.10.72/"&gt;3&lt;/a&gt;] But it is also memory-safe, at least in ordinary usage. Like C♯, you have to be explicit about any unsafe code, with the &lt;code&gt;unsafe&lt;/code&gt; keyword on any blocks that do memory management that isn’t safe. And the vast majority of Rust code &lt;em&gt;is&lt;/em&gt; safe.&lt;/p&gt;
&lt;p&gt;More than that, though, Rust &lt;em&gt;feels&lt;/em&gt; like a high-level language. It gives you higher-kinded functions, generics, traits-based composition of types, hygienic macros, and the implementation of many important parts the essentials of the language in the library. If you need to patch something, or extend something, you can do that in a straightforward way. In short, it gives you lots of good abstractions like you would expect in a high-level language.&lt;/p&gt;
&lt;p&gt;Rust is low-level in that you can write (and people are writing) systems-level programs in it. It is high-level in that it lets you express things in ways normally associated with languages like Haskell or OCaml or Python or Ruby. To put it simply: it’s &lt;em&gt;low-level&lt;/em&gt; in its ability to address the computer, and &lt;em&gt;high-level&lt;/em&gt; in the abstractions it hands to a programmer. That’s a powerful combination, and I hope more languages embrace it in the years to come.&lt;/p&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;Yes, I know that’s insanely nerdy. What did you expect?&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Aug 2015 20:00:00 -0400</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2015-08-07:/2015/high-and-low-level-programming-languages.html</guid><category>programming languages</category><category>rust</category><category>python</category><category>ruby</category><category>c</category><category>cplusplus</category></item></channel></rss>