<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - web development</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Mon, 25 Dec 2017 19:20:00 -0500</lastBuildDate><item><title>I Want JSON Decoders</title><link>http://www.chriskrycho.com/2017/i-want-json-decoders.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;This post was originally published at &lt;a href="https://www.dailydrip.com/blog/i-want-json-decoders.html"&gt;DailyDrip.com&lt;/a&gt;. They’re doing really great work over there, so I encourage you to check out their content and consider subscribing!&lt;/i&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;The other day, I got a report about the Ember.js app I’m working on: when a customer applied a coupon in the basket, they’d see an indication that the coupon was applied, but the basket total would still display as if it hadn’t been updated. Orders were &lt;em&gt;placed&lt;/em&gt; correctly, but they wouldn’t render right. I dug around for a bit, and then discovered that it was one of the (many) places where &lt;code&gt;undefined&lt;/code&gt; was biting us.&lt;/p&gt;
&lt;p&gt;How did this happen? It turned out it was a perfect storm: a confusingly-designed API combined with a reasonable (but in this case, very unhelpful) assumption in our data layer. When the total on a given basket dropped to zero, our API simply didn’t send back a value on the payload at all. Instead of &lt;code&gt;{ total: 0, ... }&lt;/code&gt;, there was just, well, &lt;code&gt;{ ... }&lt;/code&gt; – no &lt;code&gt;total&lt;/code&gt; field at all. Meanwhile, our data layer was designed to let a server send back only the fields which &lt;em&gt;required&lt;/em&gt; updating. That way, you can send back partial records to indicate only what has changed, instead of having to send back the whole of what might be a very large record, or a very large collection of records.&lt;/p&gt;
&lt;p&gt;The combination was terrible, though: because the server didn’t send back the &lt;code&gt;total&lt;/code&gt; field at all when it dropped to &lt;code&gt;0&lt;/code&gt;, the client never updated the total it displayed to the user: as far as it was concerned, the server was saying “no change here!”&lt;/p&gt;
&lt;p&gt;The first and most obvious solution here, of course, is the one we implemented: we had the API always send back a value, even if that value was &lt;code&gt;0&lt;/code&gt;. But it seems like there should be a better way.&lt;/p&gt;
&lt;p&gt;Lots of languages have fairly nice facilities for parsing JavaScript. Several languages even have tools for automatically constructing local, strongly-typed data structures from the structure of a JSON response on an API. F♯’s &lt;a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/"&gt;type providers&lt;/a&gt; are like this and &lt;em&gt;really fancy&lt;/em&gt; in the way they’ll automatically derive the type for you so you don’t even have to write it out as you would in everything from Haskell to C#. But for the most part in JavaScript, you have at most a way to map data to a local record in your data store – certainly none of those type safe guarantees. In TypeScript, you can write the types you receive out carefully – though, as I discovered in this case, probably not carefully &lt;em&gt;enough&lt;/em&gt; unless you model &lt;em&gt;everything&lt;/em&gt; as an optional field, and then you’re back to checking for &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; everywhere, and &lt;em&gt;why isn’t this already a solved problem?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;And it turns out, it &lt;em&gt;is&lt;/em&gt; a solved problem – or at least, it is in Elm, &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;via&lt;/a&gt; those &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;JSON Decoders&lt;/a&gt;. I don’t get to write Elm at work right now (or any time in the foreseeable future) – but if I can’t write Elm, I can at least try to steal a bunch of its great ideas and push them back into my TypeScript.&lt;/p&gt;
&lt;p&gt;So… what exactly are JSON Decoders and how would they have solved this problem? (And why, if you’re already familiar a little with Elm and possibly feeling frustrated with decoding, are they actually worth it?)&lt;/p&gt;
&lt;p&gt;A JSON Decoder is just a way of guaranteeing that once you’re inside the boundary of your program, you &lt;em&gt;always&lt;/em&gt; have a valid instance of the data type you’ve decoded it into, &lt;em&gt;or&lt;/em&gt; an error which tells you why you &lt;em&gt;don’t&lt;/em&gt; have a valid instance of the data. They’re composable, so you can stack them together and take smaller decoders to build bigger ones, so if you have a complex JSON structure, you can define repeated substructures in it, or decoders for dissimilar sibling items in it, and use them to put together a grand decoder for your whole final structure. The decoders use the &lt;a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result"&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, and they hand back either &lt;code&gt;Ok&lt;/code&gt; with the decoded value or &lt;code&gt;Err&lt;/code&gt; with the reason for the failure – and if &lt;em&gt;any&lt;/em&gt; piece of a decoded type doesn’t match with what you’ve specified, you’ll end up with an &lt;code&gt;Err&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, initially that might sound like a recipe for disaster – JSON payloads can be formed in weird ways all the time! – but in fact it encourages you to think through the various ways your payloads can be formed and to account for them. &lt;em&gt;Sometimes&lt;/em&gt;, if the payload doesn’t have what you expect, that really does mean something is wrong either in your request or in the server-side implementation. In that case, getting an &lt;code&gt;Err&lt;/code&gt; is &lt;em&gt;exactly&lt;/em&gt; what you want. Other times, the server might be perfectly legitimate in sending back a variety of shapes in its response, and your responsibility is to decide how to decode it to make sense in your app. Remember, the problem I had was that I received a payload which didn’t have the data. With Elm’s decoders, I would have had three choices:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;I could have treated this as an error, and passed that along to be dealt with in some way.&lt;/li&gt;
&lt;li&gt;I could have normalized it as a 0-value payload.&lt;/li&gt;
&lt;li&gt;I could have treated it &lt;em&gt;explicitly&lt;/em&gt; as a no-op, maintaining whatever previous state I had in the data store, i.e. the implicit behavior of my actual data store.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What I &lt;em&gt;couldn’t&lt;/em&gt; do, though, is do any one of those &lt;em&gt;accidentally&lt;/em&gt;. I could still support incomplete payloads (via option 3), but I’d be explicitly opting into that, and there would be an obvious place where that was the case. This would be particularly helpful in a scenario where I wasn’t also in charge of the API: if I couldn’t just go change it so the API itself had a more sensible behavior, I could enforce whichever desired behavior on my own end. More than that, with something modeled on the Elm JSON Decoders, I would &lt;em&gt;have&lt;/em&gt; to: there would be no implicit consumption of raw JSON.&lt;/p&gt;
&lt;p&gt;The first time I played with the Elm JSON Decoder approach, I thought it was a lot of work. I was used to just doing &lt;code&gt;JSON.parse()&lt;/code&gt; in JS or &lt;code&gt;json.loads()&lt;/code&gt; in Python. Now I needed to define a whole series of decode steps explicitly for every field in a response? Good grief! But it grew on me. More than that, I now actively miss it in my apps; I’d have been really happy not to have to spend a morning hunting down this particular bug.&lt;/p&gt;
&lt;p&gt;Sometimes that explicitness can seem like quite a lot of boilerplate, and indeed it is: there’s a reason the Elm &lt;a href="https://github.com/NoRedInk/elm-decode-pipeline"&gt;elm-decode-pipeline&lt;/a&gt; project exists. But even given the &lt;em&gt;initial&lt;/em&gt; nicety of something like F♯ type providers, I think the Elm approach has a slight edge in the long-term for &lt;em&gt;maintainability&lt;/em&gt; specifically. It’s one thing to be able to just get to work right away and have a type definition you know to conform to a given API response. It’s something else entirely to be able to &lt;em&gt;know&lt;/em&gt; that you’ve accounted for all the varieties of responses you might get (and without throwing an exception for failed JSON decoding at that!).&lt;/p&gt;
&lt;p&gt;Given all of this, I’ve started mentally teasing out what such a JSON decoding library for Ember.js might look like in TypeScript. It’s a long way off, but it’s the kind of thing that I &lt;em&gt;really&lt;/em&gt; want to experiment with, and that I think would make for a big win for the maintainability of our apps. Keep your eyes peeled, because I suspect this is another thing JS will steal from Elm, and that’s &lt;em&gt;great&lt;/em&gt; in my book.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 25 Dec 2017 19:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-25:/2017/i-want-json-decoders.html</guid><category>JavaScript</category><category>Elm</category><category>TypeScript</category><category>web development</category><category>software development</category></item><item><title>Chrome is Not the Standard</title><link>http://www.chriskrycho.com/2017/chrome-is-not-the-standard.html</link><description>&lt;p&gt;Over the past few years, I’ve increasingly seen articles with headlines that run something like, “New Feature Coming To the Web”—followed by content which described how Chrome had implemented an experimental new feature. “You’ll be able to use this soon!” has been the promise.&lt;/p&gt;
&lt;p&gt;The reality is a bit more complicated. Sometimes, ideas the Chrome team pioneers make their way out to the rest of the browsers and become tools we can all use. Sometimes… they get shelved because none of the other browsers decide to implement them.&lt;/p&gt;
&lt;p&gt;Many times, when this latter tack happens, developers grouse about the other browser makers who are “holding the web back.” But there is a fundamental problem in this way of looking at things: &lt;em&gt;Chrome isn’t the standard.&lt;/em&gt; The fact that Chrome proposes something, and even the fact that a bunch of developers like it, does not a standard make. Nor does it impose an obligation to other browsers to prioritize it, or even to ship it.&lt;/p&gt;
&lt;p&gt;As web developers, it can be easy to become focused on interesting new features for the platform we work on. That’s no different than the excitement Android and iOS developers have when Google and Apple release new SDKs for developing on their platforms. It’s healthy to be excited about possible new features, things that might make our jobs easier or enable us to do things we couldn’t do before.&lt;/p&gt;
&lt;p&gt;But there &lt;em&gt;is&lt;/em&gt; an important difference between those platforms and the web. Those platforms are the domain of a single vendor. The web is a shared platform. This is its unique benefit, and its unique cost. It uniquely allows us to write software that can actually run, and run reasonably well, &lt;em&gt;everywhere&lt;/em&gt;. But it also means that a minimum of four companies—the major browser vendors—get a say in whether a feature is a &lt;em&gt;feature&lt;/em&gt; or whether it’s just an interesting idea one of the teams had.&lt;/p&gt;
&lt;p&gt;Let’s get concrete about an example that’s been extremely high-profile for the last couple years—and, to be clear, one I think is a &lt;em&gt;good&lt;/em&gt; idea from Google: &lt;a href="https://developers.google.com/web/progressive-web-apps/" title="Google’s PWA page"&gt;progressive web apps&lt;/a&gt; (hereafter &lt;abbr title='Progressive Web App'&gt;PWA&lt;/abbr&gt;). They have been pitched by Google and other supporters as an unambiguous win for the user experience of complex web applications. And, as a web developer myself, I’m actually inclined to agree with that assessment! However, I have fairly regularly seen people getting angry at especially Apple for not prioritizing support for &lt;abbr title='Progressive Web App'&gt;PWA&lt;/abbr&gt;s in (especially iOS) Safari—Apple is, in this view, “holding back the future of the web.”&lt;/p&gt;
&lt;p&gt;Well… no. For any given idea Google pitches, Apple may or may not be sold on Google’s vision of the web, or they may even think it’s a good idea but not &lt;em&gt;more&lt;/em&gt; important than other things they’re working on.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And this is what it &lt;em&gt;means&lt;/em&gt; to be part of the web platform. No single company gets to dominate the others in terms of setting the agenda for the web. Not Firefox, with its development and advocacy of &lt;a href="http://webassembly.org/"&gt;WebAssembly&lt;/a&gt;, dear to my heart though that is. Not Microsoft and the IE/Edge team, with its proposal of the CSS grid spec in &lt;em&gt;2011&lt;/em&gt;, sad though I am that it languished for as long as it did. Not Apple, with its pitch for &lt;a href="https://webkit.org/blog/7846/concurrent-javascript-it-can-work/" title="“Concurrent JavaScript: it can work!”"&gt;concurrent JavaScript&lt;/a&gt;. And not—however good its developer relations team is—Chrome, with any of the many ideas it’s constantly trying out, including &lt;abbr title='Progressive Web App'&gt;PWA&lt;/abbr&gt;s.&lt;/p&gt;
&lt;p&gt;It’s also worth recognizing how these decisions aren’t, in almost any case, unalloyed pushes for “the future of the web.” They reflect &lt;em&gt;business&lt;/em&gt; priorities, just like any other technical prioritization. Google cares about &lt;abbr title='Progressive Web App'&gt;PWA&lt;/abbr&gt;s because Google makes its money from the web and wants people to spend more of their time on the web. Apple cares about things like the battery life implications and the sheer speed of its iOS JavaScript engine because it makes money from hardware and it wants people to be happy with their iPhones and iPads.&lt;/p&gt;
&lt;p&gt;Does any one of those browser’s commitments map cleanly to &lt;em&gt;all&lt;/em&gt; users’ (or even all &lt;em&gt;developers’&lt;/em&gt;) priorities? Of course not! This is and always has been the beauty of a competitive browser landscape. I’m a web developer who wants &lt;abbr title='Progressive Web App'&gt;PWA&lt;/abbr&gt; support everywhere—so I want Apple supporting it. But I’m also a smartphone user who wants those applications to &lt;em&gt;scream&lt;/em&gt; on my device—not to crawl, like they do on Chrome on Android, which is still years behind iOS in performance. As an end user, not just a developer, it matters to me that running Safari on my laptop instead of Chrome can dramatically increase my battery life.&lt;/p&gt;
&lt;p&gt;These are tradeoffs, plain and simple. Chrome ships new features fast, but they’re not always stable and they often have performance costs. Safari ships new features on a much slower cadence, but they’re usually solid and always perform incredibly well. These are both engineering and business tradeoffs, and the companies behind the browsers are making because of their own business and engineering priorities. Don’t valorize any of the browser vendors, and don’t act as if &lt;em&gt;any&lt;/em&gt; of them is the standard, or a reliable predictor of the future. Instead, value what each brings to the table, but also value the interplay &lt;em&gt;at&lt;/em&gt; the table, and the ways each of these vendors pushes the others and challenges the others’ assumptions of what is most important. That’s what makes the web so great, even when it makes things move more slowly. Sometimes—often, even!—moving more slowly not in the &lt;em&gt;experimental&lt;/em&gt; phase but in the &lt;em&gt;finalizing&lt;/em&gt; phase makes for a much better outcome overall.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;In this case, it seems to have been the latter, since yesterday’s release of Safari Tech Preview enabled Service Workers, one of the major pieces of the &lt;abbr title='Progressive Web App'&gt;PWA&lt;/abbr&gt; push.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 21 Dec 2017 07:10:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-21:/2017/chrome-is-not-the-standard.html</guid><category>web development</category></item></channel></rss>