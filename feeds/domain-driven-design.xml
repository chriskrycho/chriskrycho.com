<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - domain-driven design</title><link>http://v4.chriskrycho.com/</link><description></description><lastBuildDate>Thu, 12 Sep 2019 09:00:00 -0400</lastBuildDate><item><title>User Interfaces are API Boundaries</title><link>http://v4.chriskrycho.com/2019/user-interfaces-are-api-boundaries.html</link><description>&lt;p&gt;&lt;i&gt;&lt;b&gt;&lt;a href="https://v4.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience&lt;/a&gt;:&lt;/b&gt; software developers, especially those who work on user interfaces.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fsharpforfunandprofit.com/ddd/"&gt;Domain-driven design&lt;/a&gt;, and its near neighbor the &lt;a href="https://web.archive.org/web/20060711221010/http://alistair.cockburn.us:80/index.php/Hexagonal_architecture"&gt;ports and adapters (hexagonal) architecture&lt;/a&gt; all emphasize the importance of distinguishing between your internal “business logic” and your interactions with the rest of the world. Much of the time, the “ports” that get discussed are &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; calls (e.g. over &lt;abbr title="hyper-text transfer protocol"&gt;HTTP&lt;/abbr&gt;) or interacting with a database.&lt;/p&gt;
&lt;p&gt;Yesterday, in the midst of a rollicking conversation about building forms in web apps,&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I realized:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;User interfaces are &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; boundaries, too!&lt;/em&gt;&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;I claim no novelty here; I’m sure that if I went through the literature on domain-driven design and the adjacent architectural ideas, I’d find this same point made by others. It’s just a fruitful&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; wording I have not heard before—a concise way of expressing an idea that has been rather floating around in my head in much vaguer terms for the last couple years.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;One of the key insights of DDD and the ports-and-adapters model is that every interaction with the world outside your program is a place of uncertainty. The &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; might have changed and you might be getting back different responses than you expect. The database might have been corrupted. The network might be down—or worse, degraded so that you get &lt;em&gt;partial&lt;/em&gt; messages through, and have to deal with incomplete or nonsensical data. Your software design has to account for this. If you isolate the complexity of dealing with that to well-defined, well-constrained boundaries for your application, everything in between can be &lt;em&gt;much&lt;/em&gt; simpler.&lt;/p&gt;
&lt;p&gt;And the most reliably unpredictable source of data we have for &lt;em&gt;any&lt;/em&gt; application… is users! People are complicated and distracted, and our interfaces are always imperfect, often misleading or confusing in various ways (our best intentions notwithstanding). So we get “bad” data from our users. I scare-quote “bad” here because the data is not (necessarily) &lt;em&gt;morally&lt;/em&gt; bad (though: see Twitter!) and it is (usually) a &lt;em&gt;mistake&lt;/em&gt; rather than &lt;em&gt;malice&lt;/em&gt; at root (though: see all sorts of hacking). But from the perspective of our app’s internals, the data has to be validated and transformed to our model of the world, just as data returned from an &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; or a database does.&lt;/p&gt;
&lt;p&gt;If you’re familiar with how these architectures suggest handling sources of data external to your program, the implication for user interaction is obvious: you need to treat it like you would an &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt;. You should have a clean separation between the data model of a form and the data model used within your application. Put in common &lt;abbr title="object oriented"&gt;OO&lt;/abbr&gt; parlance: your form model is a kind of &lt;a href="https://martinfowler.com/eaaCatalog/dataTransferObject.html"&gt;data transfer object&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Notice that this holds whether you’re using a traditional web form which submits a &lt;code&gt;POST&lt;/code&gt; request via &lt;abbr title="hyper-text transfer protocol"&gt;HTTP&lt;/abbr&gt;, or building a rich &lt;abbr title="single page application"&gt;SPA&lt;/abbr&gt;-style JavaScript app which will use the form data without ever sending it anywhere. You have to first validate the data to make sure it is complete and correct—presumably with a mechanism for letting the user know if it isn’t. You also normally need to &lt;em&gt;transform&lt;/em&gt; the basically flat data you get back from your form into in a data structure which is appropriately rich for the domain you’re working with.&lt;/p&gt;
&lt;p&gt;Again: all of this is bog standard for DDD and ports-and-adapters thinking. The point is that you should treat forms specifically and user interaction in general in much the same way as any other external data: because &lt;em&gt;user interfaces are &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; boundaries&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In a future post, hopefully some time in the next week or two, I’ll trace out one of the implications of this for how I think about building forms in much more concrete terms!&lt;/p&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;about which conversation more another day!&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;I found it &lt;i&gt;fruitful&lt;/i&gt; in two senses: it was generative for me as I reflected on it, and it produced some forward motion in a conversation about real-world software development.&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 12 Sep 2019 09:00:00 -0400</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2019-09-12:/2019/user-interfaces-are-api-boundaries.html</guid><category>software development</category><category>domain-driven design</category><category>UI</category><category>software architecture</category></item><item><title>Exploring 4 Languages: Integrity and Consistency</title><link>http://v4.chriskrycho.com/2018/exploring-4-languages-integrity-and-consistency.html</link><description>&lt;p&gt;In chapter 6, Wlaschin turns to one of the most important aspects of “domain modeling”: keeping it consistent. It’s all well and good to set up a domain model, but if you don’t have a way to make sure that model is reliable everywhere you use it, well… you’ve done a lot of extra work and you’re not going to see a lot of results for all that effort! But as Wlaschin points out, we can actually use the type systems, and the types we wrote up in the previous chapter, to help us enforce the business &lt;em&gt;rules&lt;/em&gt; for our domain (as well as the business &lt;em&gt;shapes&lt;/em&gt; in the domain).&lt;/p&gt;
&lt;p&gt;An important note: you can see the latest version of this code (along with history indicating some of my travails in getting there!) in &lt;a href="https://github.com/chriskrycho/dmmf"&gt;this public repository on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;section id="a-simple-example-widgetcode" class="level2"&gt;
&lt;h2&gt;A simple example: &lt;code&gt;WidgetCode&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;We’ll start with one of the simpler examples: validating that a &lt;code&gt;WidgetCode&lt;/code&gt; is legitimate. A &lt;code&gt;WidgetCode&lt;/code&gt;, in this domain, is valid if, and &lt;em&gt;only&lt;/em&gt; if, it has a &lt;code&gt;W&lt;/code&gt; followed by four digits.&lt;/p&gt;
&lt;p&gt;The basic tack we’ll take, in all four languages, is to leverage the way the types work to make it so we have to use a function to create a valid instance of a &lt;code&gt;WidgetCode&lt;/code&gt;. That’s a bit of extra work (though especially in the functional-first languages, it ends up not being a &lt;em&gt;lot&lt;/em&gt; of extra work) but it lets us use &lt;code&gt;Result&lt;/code&gt; types to handle invalid data up front.&lt;/p&gt;
&lt;p&gt;The downside is that we can’t just get directly at the value inside our wrapper types using basic pattern matching. Instead, we need to be provide a function for “unwrapping” it. Tradeoffs!&lt;/p&gt;
&lt;p&gt;We’ll go at this using the most appropriate tool from each language, but in every case we’ll end up with a &lt;code&gt;create&lt;/code&gt; function that takes a string and returns a &lt;code&gt;Result&lt;/code&gt; with the successful option being a &lt;code&gt;WidgetCode&lt;/code&gt; and the error option being a string describing the error; and a &lt;code&gt;value&lt;/code&gt; function to unwrap a valid code. Throughout, I also assume an essentially-identical implementation of a related &lt;code&gt;GizmoCode&lt;/code&gt; type; I pull both in to show how they end up being used side by side.&lt;/p&gt;
&lt;section id="rust" class="level3"&gt;
&lt;h3&gt;Rust&lt;/h3&gt;
&lt;p&gt;We are using a tuple struct to wrap the string value here. Since there is no &lt;code&gt;pub&lt;/code&gt; modifier in the wrapped &lt;code&gt;String&lt;/code&gt;, it’s opaque from the perspective of the caller—and this is exactly what we want. We’ll pull in &lt;a href="https://docs.rs/regex/0.2.10/regex/"&gt;the &lt;code&gt;Regex&lt;/code&gt; crate&lt;/a&gt; and validate the code passed to us on creation.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use regex::Regex;

pub struct WidgetCode(String);

impl WidgetCode {
    pub fn create(code: &amp;amp;str) -&amp;gt; Result&amp;lt;WidgetCode, String&amp;gt; {
        let re = Regex::new(r&amp;quot;W\d{4}&amp;quot;).expect(r&amp;quot;W\d{4} is a valid regex&amp;quot;);
        if re.is_match(code) {
            Ok(WidgetCode(String::from(code)))
        } else {
            Err(String::from(
                &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;,
            ))
        }
    }

    pub fn value(&amp;amp;self) -&amp;gt; &amp;amp;str {
        &amp;amp;self.0
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fairly idiomatic Rust: we’re &lt;em&gt;borrowing&lt;/em&gt; a &lt;em&gt;reference&lt;/em&gt; to the code as a “string slice”, and creating a new, wrapped &lt;code&gt;String&lt;/code&gt; instance to wrap up the code &lt;em&gt;or&lt;/em&gt; return a new &lt;code&gt;String&lt;/code&gt; as an error. When we get the value out, we return a reference to the string,&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; with &lt;code&gt;&amp;amp;self.0&lt;/code&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; to indicate a reference, &lt;code&gt;.0&lt;/code&gt; to indicate the first item of a tuple. Note as well that the final &lt;code&gt;if&lt;/code&gt; block here is an expression. There’s no semicolon terminating it, and this whole &lt;code&gt;if&lt;/code&gt; block ends up being the resulting value of the function.&lt;/p&gt;
&lt;p&gt;One other point of interest here is that the creation of the regex &lt;em&gt;itself&lt;/em&gt; is checked by the compiler for us! If we pass an invalid regular expression, this simply won’t compile.&lt;/p&gt;
&lt;p&gt;This could also live in its own module, &lt;code&gt;ordering/widget_code.rs&lt;/code&gt;, and in fact that’s how I would normally do this (and have in the repository where I’m working): every one of these small types would get its own module file within the containing &lt;code&gt;Ordering&lt;/code&gt; module. It’s not &lt;em&gt;necessary&lt;/em&gt;, but as the domain model grows, it becomes increasingly &lt;em&gt;convenient&lt;/em&gt; in that you always know where to find things.&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Then we can import it and use it like this in &lt;code&gt;ordering/mod.rs&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;mod widget_code;
mod gizmo_code;

use widget_code::WidgetCode;
use gizmo_code::GizmoCode;

pub enum ProductCode {
    Widget(WidgetCode),
    Gizmo(GizmoCode),
}

fn demo_it() {
    let valid = WidgetCode::create(&amp;quot;W1234&amp;quot;);
    let invalid = WidgetCode::create(&amp;quot;wat&amp;quot;);

    let unwrapped = match valid {
        Ok(ref code) =&amp;gt; code.value(),
        Err(_) =&amp;gt; &amp;quot;&amp;quot;,
    };
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that in Rust, the &lt;code&gt;mod.rs&lt;/code&gt; file declares all child modules. If you had a &lt;code&gt;widget_code.rs&lt;/code&gt; on the file system but no &lt;code&gt;mod widget_code;&lt;/code&gt;, Rust would just ignore the declaration entirely. Then Rust also requires us to &lt;code&gt;use widget_code;&lt;/code&gt; to access its contents. The distinction between declaring and using a given module makes some sense: by the time all is said and done with this exercise, we won’t be doing much of anything in this &lt;code&gt;Ordering&lt;/code&gt; module; it’ll exist primarily as a grouping construct for all the &lt;em&gt;other&lt;/em&gt; modules.&lt;/p&gt;
&lt;p&gt;In this case, we go ahead and import the &lt;code&gt;WidgetCode&lt;/code&gt; type from the module. We only have the one type there, with no standalone functions: everything is attached to the type via the &lt;code&gt;impl&lt;/code&gt; block; so we can just call everything directly off of the type. This ends up feeling &lt;em&gt;kind of&lt;/em&gt; like the way we’d do things in a traditional OOP language, but also &lt;em&gt;really not&lt;/em&gt;, because we still have a separation between the data type and the implementation of functionality attached to it. It’s not obvious &lt;em&gt;here&lt;/em&gt;, but we could write &lt;code&gt;impl WidgetCode&lt;/code&gt; in some &lt;em&gt;other&lt;/em&gt; module in the crate, and as long as there’s no conflict between the implementations, it’s fine! And then we could call whatever function we defined in &lt;em&gt;that&lt;/em&gt; block “on” &lt;code&gt;WidgetCode&lt;/code&gt;. This is on the one hand &lt;em&gt;totally&lt;/em&gt; unlike what we’ll see in the other languages, and on the other hand &lt;em&gt;weirdly analogous&lt;/em&gt; to them.&lt;/p&gt;
&lt;p&gt;I’m going to pass over why we need &lt;code&gt;ref code&lt;/code&gt; here, as it gets into details of Rust’s model of ownership and reference borrowing &lt;em&gt;and&lt;/em&gt; it’s going to be unneeded because of improvements to Rust’s compiler fairly soon. The one thing to note here is that we get nice memory/allocation behavior, i.e. we’re not doing a bunch of separate heap string allocations here. This is one of the big upsides to Rust in general! It’s not quite as pretty as what we’ll see below, but the performance wins are awesome.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="elm" class="level3"&gt;
&lt;h3&gt;Elm&lt;/h3&gt;
&lt;p&gt;Elm introduces us to a pattern we’ll see in each of the more traditional “functional” languages: the use of &lt;em&gt;modules&lt;/em&gt; for this kind of structure. First the code, then some comments on it:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- src/ordering/WidgetCode.elm
module Ordering.WidgetCode exposing (WidgetCode, create, value)

import Regex exposing (contains, regex)


type WidgetCode
    = WidgetCode String


create : String -&amp;gt; Result String WidgetCode
create code =
    if contains (regex &amp;quot;W\\d{4}&amp;quot;) code then
        Ok (WidgetCode code)
    else
        Err &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;


value : WidgetCode -&amp;gt; String
value (WidgetCode code) =
    code&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm’s module system lets you choose exactly what to expose. In this case, we’re only exporting the type itself along the &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; functions—but, importantly, &lt;em&gt;not&lt;/em&gt; the normal type constructors for the type.&lt;/p&gt;
&lt;p&gt;You can import the things exposed both as a module and as individual items. Assume we implemented &lt;code&gt;GizmoCode&lt;/code&gt; the same way. We’d import and use them in &lt;code&gt;Ordering.elm&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- Ordering.elm
import Ordering.WidgetCode as WidgetCode exposing (WidgetCode)
import Ordering.GizmoCode as GizmoCode exposing (GizmoCode)

type ProductCode
    = Widget WidgetCode
    | Gizmo GizmoCode
    
valid =
    WidgetCode.create &amp;quot;W1234&amp;quot;


invalid =
    WidgetCode.create &amp;quot;wat&amp;quot;


unwrapped =
    case valid of
        Result.Ok code -&amp;gt;
            WidgetCode.value (code)

        Result.Err _ -&amp;gt;
            &amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As with Rust, we can’t construct the type without using the provided function. As I’ve written the imports, you’d create a &lt;code&gt;WidgetCode&lt;/code&gt; by writing &lt;code&gt;WidgetCode.create "W1234"&lt;/code&gt;. You could also import it directly, but that would have its own problems once you had the &lt;code&gt;create&lt;/code&gt; function imported for &lt;code&gt;GizmoCode&lt;/code&gt; as well.&lt;/p&gt;
&lt;p&gt;Finally, notice the way we aliased the module name here with &lt;code&gt;as&lt;/code&gt; on the import: we don’t have to write out the fully qualified path this way. And there’s no conflict between the aliased module name and the type name – they live in their own namespaces (as it should be!). Importing the type name distinctly is handy because it means we don’t have to write the body of the union type out as &lt;code&gt;Widget WidgetCode.WidgetCode&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="f" class="level3"&gt;
&lt;h3&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;The F&lt;sup&gt;♯&lt;/sup&gt; code looks a &lt;em&gt;lot&lt;/em&gt; like the Elm code. The main differences here have to do with their module systems.&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;namespace Ordering

type WidgetCode = private WidgetCode of string
module WidgetCode =
    let create code =
        if Regex.IsMatch(code, @&amp;quot;W\d{4}&amp;quot;) then
            Ok (WidgetCode code)
        else
            Error &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;

    let value (WidgetCode code) = code&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we declare that we’re in the &lt;code&gt;namespace Ordering&lt;/code&gt;. Everything here will be publicly visible to everything &lt;em&gt;else&lt;/em&gt; in the &lt;code&gt;namespace Ordering&lt;/code&gt;. We could also make this a &lt;code&gt;module&lt;/code&gt;, and in that case we’d need to explicitly open it in other modules. Because it’s part of the base namespace we’re using for &lt;code&gt;Ordering&lt;/code&gt;, though, we get it for “free”. There’s a downside to this, though. More on that below.&lt;/p&gt;
&lt;p&gt;Also notice that this means that we have yet one more “namespace” for names to live in: &lt;code&gt;namespace&lt;/code&gt; names are different from &lt;code&gt;module&lt;/code&gt; are different from type names! So here we declare a top-level &lt;code&gt;module Ordering&lt;/code&gt; here so that we can actually write code that &lt;em&gt;does something&lt;/em&gt; in the file – &lt;code&gt;namespace&lt;/code&gt;s can only contain type definitions (including &lt;code&gt;module&lt;/code&gt; definitions).&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;namespace Ordering

type ProductCode =
    | Widget of WidgetCode
    | Gizmo of GizmoCode

module DemoIt =
    let valid = WidgetCode.create &amp;quot;W1234&amp;quot;
    let invalid = WidgetCode.create &amp;quot;wat&amp;quot;
    
    let unwrapped =
        match valid with
        | Ok(code) -&amp;gt; WidgetCode.value code
        | Error(_) -&amp;gt; &amp;quot;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The things to notice here as particularly different from the others:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;We don’t have to explicitly import the module names, because we used the same namespace (&lt;code&gt;Ordering&lt;/code&gt;) to group them. We could also have done &lt;code&gt;namespace Ordering.WidgetCode&lt;/code&gt; and &lt;code&gt;open Ordering.WidgetCode&lt;/code&gt;; that might actually make more or less sense in the context. I &lt;em&gt;think&lt;/em&gt; this is probably more idiomatic, however, which is why I picked it.&lt;/li&gt;
&lt;li&gt;Since we’re keeping the rest of the containing module in the same namespace, we &lt;em&gt;do&lt;/em&gt; have to declare &lt;code&gt;module DemoIt&lt;/code&gt; for functionality – not just types – to live in. This is true for both &lt;code&gt;Ordering.fs&lt;/code&gt; and &lt;code&gt;WidgetCode.fs&lt;/code&gt; and so on.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This way of structuring things works really well, but it has one major downside compared to Elm and Rust: where any given name comes from is &lt;em&gt;not&lt;/em&gt; obvious from any given text file. Using modules instead of namespaces and using more fully qualified names &lt;em&gt;could&lt;/em&gt; help here, but the reality is simply that F&lt;sup&gt;♯&lt;/sup&gt; (like C&lt;sup&gt;♯&lt;/sup&gt;) basically leaves you out to dry here. My take is that this is basically what happens when you design a language &lt;em&gt;assuming&lt;/em&gt; IDE-like tooling. But especially when looking at e.g. GitHub diff views, or just browsing source code in general, I strongly prefer the way Elm and Rust generally lead you to do explicit imports or fully qualified paths. (Both have an escape hatch: Rust’s &lt;code&gt;use path::to::module::*;&lt;/code&gt; and Elm’s &lt;code&gt;import Path.To.Module exposing (..)&lt;/code&gt;, but both are actively discouraged as bad practice in &lt;em&gt;most&lt;/em&gt; situations.)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="reason" class="level3"&gt;
&lt;h3&gt;Reason&lt;/h3&gt;
&lt;p&gt;Interestingly, Reason &lt;em&gt;looks&lt;/em&gt; most like Rust but &lt;em&gt;behaves&lt;/em&gt; most like F&lt;sup&gt;♯&lt;/sup&gt;. The biggest difference is that I need a separate &lt;em&gt;interface file&lt;/em&gt; for Reason to get the privacy benefits that I’m getting in all the other languages.&lt;/p&gt;
&lt;p&gt;We put the definition file at &lt;code&gt;ordering/Ordering_WidgetCode.rei&lt;/code&gt;. (I’ll comment on the long name in a moment.)&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type gizmoCode = pri | GizmoCode(string);

let create: string =&amp;gt; Js.Result.t(widgetCode, string);

let value: widgetCode =&amp;gt; string;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that module definition in place, we can separately supply the implementation, in &lt;code&gt;ordering/Ordering_WidgetCode.re&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type widgetCode =
  | WidgetCode(string);

let create = code =&amp;gt; {
  let isMatch =
    Js.Re.fromString(&amp;quot;W\\d{4}&amp;quot;) |&amp;gt; Js.Re.exec(code) |&amp;gt; Js.Option.isSome;
  if (isMatch) {
    Js.Result.Ok(WidgetCode(code));
  } else {
    Js.Result.Error(
      &amp;quot;`WidgetCode` must begin with a &amp;#39;W&amp;#39; and be followed by 4 digits&amp;quot;
    );
  };
};

let value = (WidgetCode(code)) =&amp;gt; code;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that you could do the same thing with an interface file for F&lt;sup&gt;♯&lt;/sup&gt;. We’re also doing something that’s similar in principle to the use of private types in in F&lt;sup&gt;♯&lt;/sup&gt;, but unlike in F&lt;sup&gt;♯&lt;/sup&gt; we &lt;em&gt;have&lt;/em&gt; to use the module interface to make it work as far as I can tell. The &lt;em&gt;interface&lt;/em&gt; can declare the type private, but in the actual implementation, the type has to be non-private to be constructable. (If I’m wrong, please send me a note to let me know! But that’s what I gathered from reading OCaml docs, as well as from command line error messages as I played around.) Also, the fact that Reason has landed on the keyword &lt;code&gt;pri&lt;/code&gt; instead of OCaml and F&lt;sup&gt;♯&lt;/sup&gt;’s much saner &lt;code&gt;private&lt;/code&gt; is super weird.&lt;/p&gt;
&lt;p&gt;The interface file just defines the types, and has the &lt;code&gt;.rei&lt;/code&gt; extension. &lt;code&gt;type widgetCode&lt;/code&gt; here is an &lt;em&gt;abstract&lt;/em&gt; type, which provides no information about what it contains. Note the function types are provided as well. Here I’m using specifically the &lt;code&gt;Js.Result&lt;/code&gt; type; there is also a &lt;code&gt;Result&lt;/code&gt; type in at least one of the OCaml standard libraries. This is one of the more complicated things about Reason compared to the others: there are… &lt;em&gt;several&lt;/em&gt; standard libraries to choose from, which will or won’t work differently depending on what compile target you’re picking.&lt;/p&gt;
&lt;p&gt;In any case, once we have both the module and the implementation defined, we can use it like this in &lt;code&gt;ordering.re&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;module WidgetCode = Ordering_WidgetCode;

module GizmoCode = Ordering_GizmoCode;

open WidgetCode;

open GizmoCode;

type productCode =
  | Widget(widgetCode)
  | Gizmo(gizmoCode);

let valid = WidgetCode.create(&amp;quot;W1234&amp;quot;);

let invalid = WidgetCode.create(&amp;quot;wat&amp;quot;);

let unwrapped =
  switch valid {
  | Js.Result.Ok(code) =&amp;gt; WidgetCode.value(code)
  | Js.Result.Error(_) =&amp;gt; &amp;quot;&amp;quot;
  };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We do this mapping from &lt;code&gt;Ordering_WidgetCode&lt;/code&gt; to &lt;code&gt;WidgetCode&lt;/code&gt; here because OCaml and therefore Reason has only a single global namespace for its module names as defined by the file system. You can nest modules, but only &lt;em&gt;within&lt;/em&gt; files. The workaround is, well… &lt;code&gt;Ordering_&lt;/code&gt; and remapping the name as we have here. This lets you access the nested modules as &lt;code&gt;Ordering.WidgetCode&lt;/code&gt; and so on elsewhere.&lt;/p&gt;
&lt;p&gt;Then we &lt;code&gt;open WidgetCode&lt;/code&gt; etc. so that we can write &lt;code&gt;widgetCode&lt;/code&gt; instead of &lt;code&gt;WidgetCode.widgetCode&lt;/code&gt; in the &lt;code&gt;productCode&lt;/code&gt; definition. This is basically the same effect we get from just being in the same &lt;code&gt;namespace&lt;/code&gt; in F&lt;sup&gt;♯&lt;/sup&gt; (which, again, we could rewrite exactly this way), or from the kinds of imports we discussed above for Rust and Elm.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="numeric-validation-unitquantity" class="level2"&gt;
&lt;h2&gt;Numeric validation: &lt;code&gt;UnitQuantity&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;So far, the showing tilts &lt;em&gt;heavily&lt;/em&gt; in F&lt;sup&gt;♯&lt;/sup&gt;’s and Elm’s favor in terms of expressiveness and elegance. However, there’s a lot of variation depending on exactly what you’re doing. If, for example, you want to validate a &lt;em&gt;range&lt;/em&gt;, well… then Rust actually has a pretty good approach! Once again, you’ll note that these all have a lot in common; the difference mostly comes down to the degree of syntactical noise required to express the same basic thing.&lt;/p&gt;
&lt;p&gt;In this section, I’m not really going to spend a lot of time discussing the details and differences; I’m just leaving it here to show an interesting example where the languages’ design decisions end up have slightly different ergonomic tradeoffs.&lt;/p&gt;
&lt;section id="rust-1" class="level3"&gt;
&lt;h3&gt;Rust&lt;/h3&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// ordering/unit_quantity.rs
pub struct UnitQuantity(u32);

impl UnitQuantity {
    pub fn create(qty: u32) -&amp;gt; Result&amp;lt;UnitQuantity, String&amp;gt; {
        match qty {
            0 =&amp;gt; Err(String::from(&amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;)),
            1...1000 =&amp;gt; Ok(UnitQuantity(qty)),
            _ =&amp;gt; Err(String::from(&amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;)),
        }
    }

    pub fn value(&amp;amp;self) -&amp;gt; u32 {
        self.0
    }

    pub fn minimum() -&amp;gt; UnitQuantity {
        UnitQuantity(1)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="elm-1" class="level3"&gt;
&lt;h3&gt;Elm&lt;/h3&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- ordering/UnitQuantity.elm
module Ordering.UnitQuantity exposing (UnitQuantity, create, value)


type UnitQuantity
    = UnitQuantity Int


create : Int -&amp;gt; Result String UnitQuantity
create qty =
    if qty &amp;lt; 1 then
        Err &amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;
    else if qty &amp;gt; 1000 then
        Err &amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;
    else
        Ok (UnitQuantity qty)


value : UnitQuantity -&amp;gt; Int
value (UnitQuantity qty) =
    qty

    
minimum : UnitQuantity
minimum = UnitQuantity 1&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="f-1" class="level3"&gt;
&lt;h3&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h3&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// ordering/UnitQuantity.fs
namespace Ordering

type UnitQuantity = private UnitQuantity of uint32
module UnitQuantity =
    let create qty =
        if qty &amp;lt; 1u then
            Error &amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;
        else if qty &amp;gt; 1000u then
            Error &amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;
        else
            Ok (UnitQuantity qty)

    let value (UnitQuantity qty) = qty
    
    let minimum = UnitQuantity 1&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="reason-1" class="level3"&gt;
&lt;h3&gt;Reason&lt;/h3&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* ordering/Ordering_UnitQuantity.rei */
type unitQuantity = pri | UnitQuantity(int);

let create: int =&amp;gt; Js.Result.t(unitQuantity, string);

let value: unitQuantity =&amp;gt; int;

let minimum: unitQuantity;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* ordering/Ordering_UnitQuantity.re */

type unitQuantity =
  | UnitQuantity(int);

let create = qty =&amp;gt;
  if (qty &amp;lt; 1) {
    Js.Result.Error(&amp;quot;`UnitQuantity` cannot be less than 1&amp;quot;);
  } else if (qty &amp;gt; 1000) {
    Js.Result.Error(&amp;quot;`UnitQuantity` cannot be greater than 1000&amp;quot;);
  } else {
    Js.Result.Ok(UnitQuantity(qty));
  };

let value = (UnitQuantity(qty)) =&amp;gt; qty;

let minimum = UnitQuantity(1);&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="aside-on-documentation" class="level2"&gt;
&lt;h2&gt;Aside: On Documentation&lt;/h2&gt;
&lt;p&gt;One thing that became &lt;em&gt;extremely&lt;/em&gt; clear in the course of working all of this out is that the documentation stories for these languages are in vastly, &lt;em&gt;vastly&lt;/em&gt; different places.&lt;/p&gt;
&lt;p&gt;Figuring out how to write this private &lt;code&gt;create&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; approach was &lt;em&gt;very&lt;/em&gt; straightforward in Rust, because it’s literally just right there in how &lt;code&gt;impl&lt;/code&gt; blocks and the &lt;code&gt;pub&lt;/code&gt; keyword work: things default to private, including the contents of a struct, and you &lt;em&gt;always&lt;/em&gt; define the related functionality with &lt;code&gt;pub fn&lt;/code&gt; declarations in the related &lt;code&gt;impl&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;Elm and F&lt;sup&gt;♯&lt;/sup&gt; were both slightly harder, in that I had to poke around a bit to figure out the right way to do it. But not &lt;em&gt;that&lt;/em&gt; much harder. Both use module-level isolation to accomplish this; the main difference there was that F&lt;sup&gt;♯&lt;/sup&gt; just lets you do it inline and Elm explicitly ties modules to files.&lt;/p&gt;
&lt;p&gt;Reason… was very, &lt;em&gt;very&lt;/em&gt; difficult to get sorted out. This is just a function of the state of the ecosystem. Reason is &lt;em&gt;distinct syntax&lt;/em&gt; for OCaml, but it also leans on BuckleScript. That means that if you want to figure out how to do anything, you probably need to search in the docs for all of those, and if your answer turns out to come from OCaml then you have to figure out how to translate it back into Reason and BuckleScript! Ultimately, I was able to figure it out and get the project layout to how you see it in the repository, but… it took a lot more digging than with any of the other projects!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;As with our &lt;a href="http://v4.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html"&gt;previous foray&lt;/a&gt;, we can see a ton of similarities across these languages. All lean heavily on pattern-matching for dealing with different scenarios; all let us make use of a &lt;code&gt;Result&lt;/code&gt; type for handling success or failure; all make heavy use of expression-bodied-ness; and all supply &lt;em&gt;some&lt;/em&gt; way to make types constructable only in safe/controlled ways.&lt;/p&gt;
&lt;p&gt;For Rust, that’s a matter of leaving the internals of a &lt;code&gt;struct&lt;/code&gt; private and making &lt;code&gt;pub fn&lt;/code&gt; helpers to do the construction and value retrieval. For Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason, that’s a matter of having the normal type &lt;em&gt;constructors&lt;/em&gt; be private while exposing the types themselves normally. They do that in different ways (F&lt;sup&gt;♯&lt;/sup&gt;’s &lt;code&gt;private type&lt;/code&gt;, Elm’s &lt;code&gt;exposing&lt;/code&gt;, and Reason’s &lt;code&gt;pri&lt;/code&gt; annotation on the type variant in a module interface file), but the effect is essentially identical, and functionally equivalent to what we see in Rust.&lt;/p&gt;
&lt;p&gt;The main differences we see across Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason have to do with the nature of the various module systems. In a lot of ways, Reason’s is the least capable &lt;em&gt;for this specific purpose&lt;/em&gt;, because it’s directly tied to OCaml’s module system, which substantially predates any of the others. (I say “in a lot of ways” because OCaml’s modules are surprisingly capable; they end up being their own kind of types and you can do some crazy things with them, all of which I’d like to actually come to understand… eventually.) Rust’s module system, meanwhile, has a lot of similarities to Elm’s in particular, but because we actually carry functions along with the types they &lt;code&gt;impl&lt;/code&gt; (though they get defined separately, with all the power that entails), we have a bit less boilerplate we need to write just to get at the specific functions in play.&lt;/p&gt;
&lt;p&gt;Next time (probably only a couple of weeks away because we’re working through the book at work in a book club!), I’ll be looking at Chapter 7: Modeling Workflows as Pipelines. I suspect this will be a place where the true functional orientation of Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason will much more sharply differentiate them from the sometimes-functionalish-but-not-actually-functional way we write things in Rust.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;This reference will live and be valid as long as the underlying &lt;code&gt;WidgetCode&lt;/code&gt; is. We could also return a &lt;code&gt;String&lt;/code&gt; if we wanted that value to live independently of the &lt;code&gt;WidgetCode&lt;/code&gt; instance backing it.&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;Putting it in its own module, whether in a separate &lt;em&gt;does&lt;/em&gt; have implications for privacy, though we don’t much care about them in this case. Rust lets us set the privacy on &lt;a href="https://doc.rust-lang.org/1.24.1/reference/visibility-and-privacy.html"&gt;a whole spectrum&lt;/a&gt;, from “visible everywhere” to “only visible in this specific module.”&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 24 Mar 2018 22:00:00 -0400</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2018-03-24:/2018/exploring-4-languages-integrity-and-consistency.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages: Starting to Model the Domain</title><link>http://v4.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html</link><description>&lt;p&gt;In the first three chapters of &lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;, Wlaschin walks through the creation of a “domain model” for an order-taking system. (It’s well worth reading the book just for a bunch of the lessons in that section—I found them quite helpful!) Then, after spending a chapter introducing F&lt;sup&gt;♯&lt;/sup&gt;’s type system, he introduces the ways you can &lt;em&gt;use&lt;/em&gt; those type mechanics to express the domain. In today’s post, I’ll show the idiomatic implementations of these types in each of Rust, Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and ReasonML.&lt;/p&gt;
&lt;section id="simple-values" class="level2"&gt;
&lt;h2&gt;Simple values&lt;/h2&gt;
&lt;p&gt;Simple wrapper types let you take simple types like strings, numbers, etc. and use types to represent part of the business domain you’re dealing with—the basic idea being that a Customer ID may be a number, but it’s not interchangeable with &lt;em&gt;other&lt;/em&gt; numbers such as Order IDs.&lt;/p&gt;
&lt;p&gt;Here’s the most ergonomic and effective (and automatically-formatted in line with the language standards, where applicable!) way to do that in each of the languages:&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct CustomerId(i32);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type CustomerId
    = CustomerId Int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML:&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type customerId =
  | CustomerId(int);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how similar these all are! The Rust implementation is the &lt;em&gt;most&lt;/em&gt; distinctive, though you can do it with the same kind of union type as the others. Here’s how that would look:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum CustomerId {
  CustomerId(i32),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For performance reasons, you might also choose to implement the F&lt;sup&gt;♯&lt;/sup&gt; type as a struct:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;&amp;lt;Struct&amp;gt;
type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="complex-data" class="level2"&gt;
&lt;h2&gt;Complex data&lt;/h2&gt;
&lt;p&gt;Wlaschin then moves on to showing how to model more complex data structures: types that “and” or “or” together other data. We “and” data together using record or struct types, and “or” data together using “union” or “enum” types. (Assume we’ve defined &lt;code&gt;CustomerInfo&lt;/code&gt;, &lt;code&gt;ShippingAddress&lt;/code&gt;, etc. types for all of these.)&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
struct Order {
    customer_info: CustomerInfo,
    shipping_address: ShippingAddress,
    billing_address: BillingAddress,
    order_lines: Vec&amp;lt;OrderLine&amp;gt;,
    billing_amount: BillingAmount,
}

// &amp;quot;or&amp;quot;
enum ProductCode {
    Widget(WidgetCode),
    Gizmo(GizmoCode),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- &amp;quot;and&amp;quot;
type alias Order =
    { customerInfo : CustomerInfo
    , shippingAddress : ShippingAddress
    , billingAddress : BillingAddress
    , orderLines : List OrderLine
    , billingAmount : BillingAmount
    }

-- &amp;quot;or&amp;quot;
type ProductCode
    = Widget WidgetCode
    | Gizmo GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
type Order = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine list
    AmountToBill: BillingAmount
}

// &amp;quot;or&amp;quot;
type ProductCode =
    | Widget of WidgetCode
    | Gizmo of GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML—note that since we’re assuming we’ve already defined the other types here, you can write this without duplicating the name and type declaration, just like you can with JavaScript object properties.&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* &amp;quot;and&amp;quot; */
type order = {
  customerInfo,
  shippingAddress,
  billingAddress,
  orderLine,
  billingAmount
};

/* &amp;quot;or&amp;quot; */
type productCode =
  | Widget(widgetCode)
  | Gizmo(gizmoCode);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An interesting aside: unless you planned to reuse these types, you wouldn’t usually write these as standalone types with this many wrapper types in it in Rust in particular (even if the compiler would often recognize that it could squash them down for you).&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Instead, you’d normally write &lt;em&gt;only&lt;/em&gt; the base enum type to start, and refactor out the &lt;code&gt;struct&lt;/code&gt; wrapper later only if you found you needed it elsewhere:&lt;/p&gt;
&lt;pre class="diff"&gt;&lt;code&gt;enum ProductCode {
-    Widget(WidgetCode),
+    Widget(String),
-    Gizmo(GizmoCode),
+    Gizmo(String),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That said: given how the book is tackling things, and the fact that you might want to &lt;em&gt;validate&lt;/em&gt; these types… having them as these low-cost wrappers is probably worth it. (In fact, having read a bit further than I’ve managed to write out yet, I can guarantee it.)&lt;/p&gt;
&lt;p&gt;We work through the rest of the basic types this way. But what about the types where we don’t yet have a good idea how we want to handle them?&lt;/p&gt;
&lt;p&gt;Each of these languages gives us an out (or more than one) for how to say “I don’t know what to put here yet.”&lt;/p&gt;
&lt;p&gt;Rust (which does not have a built-in &lt;code&gt;Never&lt;/code&gt; type… yet; see below):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// Make an empty enum (which you by definition cannot construct)
enum Never {}

// Use it throughout where we don&amp;#39;t know the type yet. It will fail to compile
// anywhere we try to *use* this, because you can&amp;#39;t construct it.
type OrderId = Never;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (which has a built-in &lt;code&gt;Never&lt;/code&gt; type):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- It will fail to compile anywhere we try to *use* this, because you cannot
-- construct `Never`.
type alias OrderId =
    Never&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (which &lt;em&gt;sort&lt;/em&gt; of does):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// Make a convenience type for the `exn`/`System.Exception` type
type Undefined = exn

type OrderId = Undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (which also &lt;em&gt;sort&lt;/em&gt; of does—identically with F&lt;sup&gt;♯&lt;/sup&gt;):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* Make a convenience type for the `exn`/`System.Exception` type */
type undefined = exn;

/*
  Use it throughout where we don&amp;#39;t know the type yet. It will compile, but fail
  to run anywhere we try to *use* this.
 */
type orderId = undefined;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For both F&lt;sup&gt;♯&lt;/sup&gt; and Reason, that’s following Wlaschin’s example. The main reason to do that is to make explicit that we’re not actually wanting an &lt;em&gt;exception&lt;/em&gt; type in our domain model, but just something we haven’t &lt;em&gt;yet&lt;/em&gt; defined. Anywhere we attempted to use it, we’d have to handle it like, well… an exception, instead of an actual type.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type OrderId = !;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="workflows-and-functions" class="level2"&gt;
&lt;h2&gt;Workflows and functions&lt;/h2&gt;
&lt;p&gt;Once we have the basic types themselves in place, we need to write down the ways we transform between them. In a functional style, we’re not going to implement instance methods—though as we’ll see in the next post, what we do in Rust will have &lt;em&gt;some&lt;/em&gt; similarities to class methods—we’re going to implement standalone functions which take types and return other types.&lt;/p&gt;
&lt;p&gt;Again, you’ll note that despite the common lineage, there is a fair amount of variation here. (Note that we’d also have defined the &lt;code&gt;UnvalidatedOrder&lt;/code&gt;, &lt;code&gt;ValidationError&lt;/code&gt;, and &lt;code&gt;ValidatedOrder&lt;/code&gt; types for all of this; I’m mostly interested in showing &lt;em&gt;new&lt;/em&gt; differences here.)&lt;/p&gt;
&lt;p&gt;Rust (using the &lt;a href="https://github.com/alexcrichton/futures-rs"&gt;Futures&lt;/a&gt; library to represent eventual computation):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidationResponse&amp;lt;T&amp;gt; = Future&amp;lt;Item = T, Error = ValidationError&amp;gt;;

fn validate_order(unvalidated: UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt; {
    unimplemented!()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (using the built-in &lt;code&gt;Task&lt;/code&gt; type for eventual computation; &lt;code&gt;Task&lt;/code&gt;s encapsulate both eventuality and the possibility of failure):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type ValidationResponse a
    = Task (List ValidationError) a

type alias ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse ValidatedOrder&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (using the built-in &lt;code&gt;Async&lt;/code&gt; type for eventual computation):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type ValidationResponse&amp;lt;&amp;#39;a&amp;gt; = Async&amp;lt;Result&amp;lt;&amp;#39;a,ValidationError list&amp;gt;&amp;gt;

type ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (using the built-in JavaScript-specific &lt;code&gt;Js.Promise&lt;/code&gt; type—which is exactly what it sounds like—for eventual computation):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type validationResponse(&amp;#39;a) = Js.Promise.t(Js.Result.t(&amp;#39;a, list(validationError)));

type validateOrder = unvalidatedOrder =&amp;gt; validationResponse(validatedOrder);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again Rust is much &lt;em&gt;more&lt;/em&gt; different here from the others than they are from each other. The biggest difference between Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason is how they handle generics and type parameters.&lt;/p&gt;
&lt;p&gt;You’ll note that in Elm, they just follow the name of the wrapping type. This is a kind of syntactic symmetry: the way you &lt;em&gt;name&lt;/em&gt; a generic type like this is the same basic way you &lt;em&gt;construct&lt;/em&gt; it. It’s quite elegant. And as it turns out, the same is true of Reason; it’s just that its authors have chosen to follow OCaml and use parentheses for them instead of following Haskell with spaces—a reasonable choice, given Reason is surface syntax for OCaml and not Haskell.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; uses angle brackets, I strongly suspect, because that’s what C&lt;sup&gt;#&lt;/sup&gt; uses for generics, and keeping them syntactically aligned in things like this is very helpful. Rust similarly uses angle brackets for similarity with other languages which have similar surface syntax—especially C++ (with its templates).&lt;/p&gt;
&lt;p&gt;The way you &lt;em&gt;name&lt;/em&gt; generic parameters differs between the languages as well. Elm, following Haskell, uses lowercase letters to name its generics (usually called &lt;em&gt;type parameters&lt;/em&gt; in Elm). F&lt;sup&gt;#&lt;/sup&gt; and Reason both (unsurprisingly) follow OCaml in using lowercase letters preceded by an apostrophe to name generics—in F&lt;sup&gt;#&lt;/sup&gt;, &lt;code&gt;TypeGenericOver&amp;lt;'a&amp;gt;&lt;/code&gt;; in Reason, &lt;code&gt;typeGenericOver('a)&lt;/code&gt;. Rust follows the convention from languages like C++, Java, and C&lt;sup&gt;#&lt;/sup&gt; and uses capital letters, &lt;code&gt;TypeGenericOver&amp;lt;T&amp;gt;&lt;/code&gt;. The use of specific letters is conventional, not mandated by the language (unlike the casing). The ML family usually starts with &lt;code&gt;a&lt;/code&gt; and moves through the alphabet; Rust and the languages it follows usually start with &lt;code&gt;T&lt;/code&gt; (for &lt;em&gt;type&lt;/em&gt;) and moves forward through the alphabet. (Sometimes you’ll also see different letters where it’s obviously a better fit for what’s contained.)&lt;/p&gt;
&lt;p&gt;These languages also vary in the syntax for constructing a &lt;em&gt;list&lt;/em&gt; of things. In F&lt;sup&gt;#&lt;/sup&gt; has convenience syntax for a few built-ins (the most common being the &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Option&lt;/code&gt; types), allowing you to write them &lt;em&gt;either&lt;/em&gt; as e.g. &lt;code&gt;List&amp;lt;ConcreteType&amp;gt;&lt;/code&gt; or &lt;code&gt;ConcreteType list&lt;/code&gt; (as here in the example). Elm, Reason, and Rust all just use the standard syntax for generic types—&lt;code&gt;List a&lt;/code&gt;, &lt;code&gt;list('a)&lt;/code&gt;, and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Finally, you’ll also note that we haven’t written out a &lt;em&gt;type&lt;/em&gt; declaration here for Rust; we’ve actually written out a stub of a function, with the &lt;a href="https://doc.rust-lang.org/std/macro.unimplemented.html"&gt;&lt;code&gt;unimplemented!()&lt;/code&gt;&lt;/a&gt; &lt;a href="https://doc.rust-lang.org/1.17.0/reference/macros-by-example.html"&gt;macro&lt;/a&gt;. If you invoke this function, you’ll get a clear crash with an explanation of which function isn’t implemented.&lt;/p&gt;
&lt;p&gt;Now, Rust also &lt;em&gt;does&lt;/em&gt; let us write out the type of these functions as type aliases if we want:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidateOrder =
    Fn(UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You just don’t use these very often in idiomatic Rust; it’s much more conventional to simply write out what I did above. However, the one time you &lt;em&gt;might&lt;/em&gt; use a type alias like this is when you’re defining the type of a closure and you don’t want to write it inline. This is a pretty sharp difference between Rust and the other languages on display here, and it goes to the difference in their approaches.&lt;/p&gt;
&lt;p&gt;Rust is &lt;em&gt;not&lt;/em&gt; a functional-first language in the way that each of the others are, though it certainly draws heavily on ideas from functional programming throughout and makes quite a few affordances for a functional style. Instead, it’s a programming language first and foremost interested in combining the most screaming performance possible with true safety, and leaning on ideas from the ML family (among others!) as part of achieving that.&lt;/p&gt;
&lt;p&gt;Among other things, this is why you don’t have currying or partial application in Rust: those essentially &lt;em&gt;require&lt;/em&gt; you to have invisible heap-allocation to be ergonomic. We &lt;em&gt;don’t&lt;/em&gt; have that in Rust, as we do in Elm, Reason, and F&lt;sup&gt;♯&lt;/sup&gt;. If we want to pass around a function, we have to explicitly wrap it in a pointer to hand it around if we construct it in another function. (I won’t go into more of the details of this here; I’ve covered it some &lt;a href="http://www.newrustacean.com/show_notes/e004/index.html"&gt;on New Rustacean&lt;/a&gt; and some &lt;a href="http://v4.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;in my Rust and Swift comparison&lt;/a&gt; a couple years ago.)&lt;/p&gt;
&lt;p&gt;That same underlying focus on performance and explicitness is the reason we have &lt;code&gt;Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;&lt;/code&gt; in the Rust case: we’re explicitly returning a &lt;em&gt;pointer&lt;/em&gt; to the type here. In Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason, that’s &lt;em&gt;always&lt;/em&gt; the case. But in Rust, you can and often do return stack-allocated data and rely on “move” semantics to copy or alias it properly under the hood.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;So: lots of similarities here at first blush. The biggest differences that show up at this point are purely syntactical, other than some mildly sharper differences with Rust because of its focus on performance. The fact that these languages share a common lineage means it’s not hard to read any of them if you’re familiar with the others, and it’s actually quite easy to switch between them at the levels of both syntax and semantics.&lt;/p&gt;
&lt;p&gt;As usual, when dealing with languages in a relatively similar family, it’s &lt;em&gt;most&lt;/em&gt; difficult to learn the &lt;em&gt;library&lt;/em&gt; differences. The most obvious example of that here is Reason’s &lt;code&gt;Js.Promise&lt;/code&gt;, Elm’s &lt;code&gt;Task&lt;/code&gt;, F&lt;sup&gt;♯&lt;/sup&gt;’s &lt;code&gt;Async&lt;/code&gt;, and Rust’s &lt;code&gt;Future&lt;/code&gt; types: each of those has their own quirks, their own associated helper functions or methods, and their own ways of handling the same basic patterns.&lt;/p&gt;
&lt;p&gt;Still, if you have played with any one of these, you could pretty easily pick up one of the others. It’s sort of like switching between Python and Ruby: there are some real differences there, but the similarities are greater than the differences. Indeed, if anything, these languages are &lt;em&gt;more&lt;/em&gt; similar than those.&lt;/p&gt;
&lt;p&gt;Next time I’ll dig into Wlaschin’s chapter on &lt;em&gt;validating&lt;/em&gt; the domain model, and here some of the not-just-syntax-level differences in the languages will start to become more apparent.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;I can’t speak to what’s idiomatic this way in any of the non-Rust languages, because I just haven’t used them enough yet.&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 14 Jan 2018 09:00:00 -0500</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2018-01-14:/2018/exploring-4-languages-starting-to-model-the-domain.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages: Project Setup</title><link>http://v4.chriskrycho.com/2018/exploring-4-languages-project-setup.html</link><description>&lt;p&gt;In this post, I’m just going to briefly talk through the steps I needed to do to set up each of the languages and my editor setup for them. Gladly, it was pretty simple. At the end, I’ll offer a note on my thoughts on the setup processes. (Note that this isn’t “How to do this for anyone ever”—it’s “how I did it, with some notes where it might be relevant to you.”)&lt;/p&gt;
&lt;p&gt;For context, I’m running macOS and using &lt;a href="https://code.visualstudio.com"&gt;VS Code&lt;/a&gt; as my editor. Whenever I say “Install the VS Code extension,” you can do it either by opening the extension side panel and searching for &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;, or by typing &lt;code&gt;ext install &amp;lt;extension label&amp;gt;&lt;/code&gt;—I’ll write it like &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;extension label&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The source code as of what I’m describing in this post is &lt;a href="https://github.com/chriskrycho/dmmf/tree/project-setup"&gt;at the &lt;code&gt;project-setup&lt;/code&gt; tag&lt;/a&gt; in &lt;a href="https://github.com/chriskrycho/dmmf/"&gt;the repo&lt;/a&gt;.&lt;/p&gt;
&lt;section id="rust" class="level2"&gt;
&lt;h2&gt;Rust&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation:&lt;/strong&gt; Install &lt;a href="https://rustup.rs"&gt;&lt;em&gt;rustup&lt;/em&gt;&lt;/a&gt;: &lt;code&gt;curl https://sh.rustup.rs -sSf | sh&lt;/code&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code extension: &lt;code&gt;Rust (rls)&lt;/code&gt;/&lt;code&gt;rust&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of &lt;a href="https://github.com/chriskrycho/dmmf"&gt;my repo&lt;/a&gt;, I ran &lt;code&gt;cargo new rust&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="elm" class="level2"&gt;
&lt;h2&gt;Elm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: There are installers, but I just did &lt;code&gt;npm i -g elm&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code Elm extension: &lt;code&gt;Elm&lt;/code&gt;/&lt;code&gt;elm&lt;/code&gt;.&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Install the &lt;code&gt;create-elm-app&lt;/code&gt; tool: &lt;code&gt;npm i -g create-elm-app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the root of the project, I ran &lt;code&gt;create-elm-app elm&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="f" class="level2"&gt;
&lt;h2&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Install &lt;a href="http://www.mono-project.com"&gt;mono&lt;/a&gt;: &lt;code&gt;brew install mono&lt;/code&gt; (note installation instructions &lt;a href="option-5-install-f-with-mono-via-homebrew-64-bit"&gt;here&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Install the VS Code Ionide extension: &lt;code&gt;Ionide-fsharp&lt;/code&gt;/&lt;code&gt;ionide-fsharp&lt;/code&gt;. It’ll automatically install the associated Paket and FAKE extensions from the Ionide project as well, and those will install Paket and FAKE during installation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;In the root of the repo, I created the &lt;code&gt;fsharp&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;Then I opened a VS Code instance to to that directory, opened the command palette, and ran &lt;code&gt;F#: New Project&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;I chose &lt;code&gt;console&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;I left the directory blank&lt;/li&gt;
&lt;li&gt;I named the project &lt;code&gt;dmmf&lt;/code&gt; (for &lt;em&gt;D&lt;/em&gt;omain &lt;em&gt;M&lt;/em&gt;odeling &lt;em&gt;M&lt;/em&gt;ade &lt;em&gt;F&lt;/em&gt;unctional).&lt;/li&gt;
&lt;li&gt;Since F&lt;sup&gt;♯&lt;/sup&gt; (like C&lt;sup&gt;♯&lt;/sup&gt;) prefers PascalCase names, I renamed the generated module &lt;code&gt;DMMF&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="reasonml" class="level2"&gt;
&lt;h2&gt;ReasonML&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Following the setup instructions &lt;a href="https://reasonml.github.io/guide/javascript/quickstart"&gt;here&lt;/a&gt;, I ran &lt;code&gt;npm install -g bs-platform&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; following &lt;a href="https://reasonml.github.io/guide/editor-tools/global-installation"&gt;the official instructions&lt;/a&gt;—
&lt;ul&gt;
&lt;li&gt;I ran &lt;code&gt;npm install -g https://github.com/reasonml/reason-cli/archive/3.0.4-bin-darwin.tar.gz&lt;/code&gt; to install the dependencies for the editor configuration.&lt;/li&gt;
&lt;li&gt;I installed the VS Code extension: &lt;code&gt;Reason&lt;/code&gt;/&lt;code&gt;reasonml&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of the repo, I ran &lt;code&gt;bsb -init reason -theme basic-reason&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="comments-on-the-setup-processes" class="level2"&gt;
&lt;h2&gt;Comments on the setup processes&lt;/h2&gt;
&lt;p&gt;Most of the languages have &lt;em&gt;fairly&lt;/em&gt; straightforward processes to get up and running with a good-to-excellent tooling experience.&lt;/p&gt;
&lt;p&gt;The best of them is Rust, which is &lt;em&gt;extremely&lt;/em&gt; easy to get up and running with.&lt;a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; Elm is roughly in the middle—it’s less straightforward than Rust in that &lt;code&gt;create-elm-app&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; an officially supported approach, unlike &lt;code&gt;rustup&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;, so you’re going to have a much less awesome experience if you don’t know about it.&lt;/p&gt;
&lt;p&gt;Reason and F&lt;sup&gt;♯&lt;/sup&gt; both have slightly larger negatives.&lt;/p&gt;
&lt;p&gt;Reason requires you to &lt;code&gt;npm install&lt;/code&gt; a large, gzipped file with multiple dependencies all bundled, instead of having a dedicated installer &lt;em&gt;a la&lt;/em&gt; &lt;code&gt;rustup&lt;/code&gt;. It also has the possibility for a not-so-great first-run experience in the editor, which &lt;a href="https://github.com/facebook/reason/issues/1729"&gt;I discovered&lt;/a&gt; all too quickly.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; essentially requires you to use an editor extension to get the language setup with &lt;a href="https://fsprojects.github.io/Paket/"&gt;Paket&lt;/a&gt;, which is a &lt;em&gt;much&lt;/em&gt; better choice of package manager than the default .NET package manager NuGet. Command line tools exist and are improving rapidly, and you &lt;em&gt;can&lt;/em&gt; &lt;a href="https://fsprojects.github.io/Paket/paket-and-dotnet-cli.html"&gt;get them working&lt;/a&gt;… but it’s harder than it needs to be. And that project setup wizard is &lt;em&gt;fine&lt;/em&gt;, but it’s a lot noisier than just doing &lt;code&gt;create-elm-app&lt;/code&gt; or especially &lt;code&gt;cargo new&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In any case, though, I have them all up and running now! More soon!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;If you’re uncomfortable with running that script, there are &lt;a href="https://www.rust-lang.org/en-US/other-installers.html"&gt;other options&lt;/a&gt; as well.&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;Note that the VS Code extension is &lt;em&gt;not&lt;/em&gt; the best experience out there for Elm: the Atom extensions (&lt;a href="https://atom.io/packages/language-elm"&gt;language-elm&lt;/a&gt; and &lt;a href="https://atom.io/packages/elmjutsu"&gt;elmjutsu&lt;/a&gt;) are. I stuck with VS Code because it’s &lt;em&gt;good enough&lt;/em&gt; and, more importantly, the Code extensions are arguably best in class for the &lt;em&gt;other&lt;/em&gt; languages… and it’s what I use every day.&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3" role="doc-endnote"&gt;&lt;p&gt;I’m not just saying that because I’m a Rust fanboy, either! If Rust were hard to use, I’d be complaining &lt;em&gt;louder&lt;/em&gt; because of my enthusiasm for the language.&lt;a href="#fnref3" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 01 Jan 2018 13:00:00 -0500</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2018-01-01:/2018/exploring-4-languages-project-setup.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages</title><link>http://v4.chriskrycho.com/2017/exploring-4-languages.html</link><description>&lt;p&gt;Today, as I hit the first of the implementation chapters in &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt;, I started thinking about how I wanted to implement it. As I’ve noted &lt;a href="https://twitter.com/chriskrycho/status/934170826718429184"&gt;elsewhere&lt;/a&gt; in the past, very little of the book is &lt;em&gt;truly&lt;/em&gt; specific to F&lt;sup&gt;♯&lt;/sup&gt;, though that’s the language Wlaschin uses in the book—and Wlaschin himself &lt;a href="https://twitter.com/ScottWlaschin/status/934177554331848705"&gt;agrees&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks! Yes, it’s true that you could easily use #ElmLang, #RustLang, #Scala, or especially #OCaml to work through the book. I use hardly any F# specific features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So… I decided to try something a little bit bonkers. I’m going to implement these exercises in &lt;em&gt;four different languages&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fsharp.org"&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reasonml.github.io"&gt;ReasonML&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are all related: they’re descended from &lt;a href="http://smlnj.org/sml.html"&gt;Standard ML&lt;/a&gt;. ReasonML and F&lt;sup&gt;♯&lt;/sup&gt; are like siblings: Reason is merely a custom syntax for OCaml; F&lt;sup&gt;♯&lt;/sup&gt; is (originally) an implementation of OCaml on .NET (though the two languages have diverged since F&lt;sup&gt;♯&lt;/sup&gt; came into existence). Elm and Rust are cousins of each other and of Reason and F&lt;sup&gt;♯&lt;/sup&gt;, though they’re both drawing on other languages besides OCaml as well. I also have some familiarity with Rust, Elm, and F&lt;sup&gt;♯&lt;/sup&gt; already, and have read the docs for Reason a couple times. So this is a &lt;em&gt;bit&lt;/em&gt; less crazy than it might otherwise be.&lt;/p&gt;
&lt;p&gt;Why, though? Mostly because I think it’ll be interesting to compare the implementations of the domain model from the book side by side. It’ll look just a bit different in each language, and I expect to learn a bit more of the &lt;em&gt;feel&lt;/em&gt; of each language by doing this. (That side by side comparison is something I’ve &lt;a href="http://v4.chriskrycho.com/rust-and-swift.html" title="Series: Rust and Swift"&gt;done before&lt;/a&gt; and &lt;a href="http://v4.chriskrycho.com/2015/rust-and-swift-v.html" title="Part V: The value (and challenge) of learning languages in parallel."&gt;found very profitable&lt;/a&gt;.) I’ll also turn it into blog posts, which hopefully will be interesting to others!&lt;/p&gt;
&lt;p&gt;More to come, and soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 31 Dec 2017 20:20:00 -0500</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2017-12-31:/2017/exploring-4-languages.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item></channel></rss>