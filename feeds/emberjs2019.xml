<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - emberjs2019</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Mon, 17 Jun 2019 20:25:00 -0400</lastBuildDate><item><title>#EmberJS2019, Part 1</title><link>http://www.chriskrycho.com/2019/emberjs2019-part-1.html</link><description>&lt;p&gt;Over the last year, the Ember community has steadily delivered on the vision we all traced out in last year’s #EmberJS2018 and Roadmap &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process, culminating with the shipping-very-soon-now &lt;a href="https://emberjs.com/editions/octane/"&gt;Ember Octane Edition&lt;/a&gt;. (All the pieces are pretty much done and are either on stable or will be shortly; we just need another &lt;abbr title="long term support"&gt;LTS&lt;/abbr&gt; release before we cut a full new edition!)&lt;/p&gt;
&lt;p&gt;So… what should we tackle next? This year, I have only two parts, unlike &lt;a href="https://www.chriskrycho.com/emberjs2018"&gt;last year’s four&lt;/a&gt; (and I’m sneaking them in just under the wire, as today is the deadline for entries!):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2019/emberjs2019-part-1"&gt;Part 1 (this post): &lt;b&gt;Let’s finish modernizing the Ember programming model!&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2019/emberjs2019-part-2"&gt;Part 2: &lt;b&gt;Let’s make TypeScript a first-class citizen of the Ember ecosystem.&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;The Octane Edition represents the &lt;em&gt;delivery&lt;/em&gt; of several years worth of work and experimentation. It represents a willingness to say “no” to many good efforts and things Ember needs to continue succeeding. All of that is &lt;em&gt;very&lt;/em&gt; much to the good! It’s precisely what I and many others called for last year.&lt;/p&gt;
&lt;p&gt;This year, it’s time to deliver on a number of other long-standing goals of the Ember effort. That means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a modernized &lt;em&gt;build-system&lt;/em&gt;, and with it the long-promised “svelte” builds, tree-shaking, and the ability to npm-install-your-way-to-Ember&lt;/li&gt;
&lt;li&gt;a modernized &lt;em&gt;routing system&lt;/em&gt;, leaving behind the final bits of cruft from the Ember 1.x era and fully-embracing the component-service architecture suggested last year&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="modernized-build-system" class="level2"&gt;
&lt;h2&gt;Modernized Build System&lt;/h2&gt;
&lt;p&gt;Others have covered the build system in some detail, and I largely agree with their assessments. We &lt;em&gt;do&lt;/em&gt; need to focus on landing that and continuing to modernize our build pipeline, and the Embroider effort and everything it unlocks should absolutely be a core part of the roadmap. One of the biggest ones, for many potential adopters of Ember &lt;em&gt;and&lt;/em&gt; many existing Ember users who have large codebases they’d like to migrate &lt;em&gt;into&lt;/em&gt; Ember is that long-awaited npm-install-your-way-to-Ember story. Let’s make that happen! I’m confident that as long as we make that commitment, we’ll get it done.&lt;/p&gt;
&lt;p&gt;Given that confidence, I’m going to focus for the rest of this post on the &lt;em&gt;directional&lt;/em&gt; question with our routing system—both why we need a change and what I think the change should look like.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="modernized-routing-system" class="level2"&gt;
&lt;h2&gt;Modernized Routing System&lt;/h2&gt;
&lt;p&gt;The Ember Router was years ahead of its time, and it remains very solid and reliable; it’s a workhorse. Unfortunately, the routing system &lt;em&gt;as a system&lt;/em&gt; is showing its age, and has entered something of a period of instability of just the sort Editions are meant to address. Today, routing concerns are spread across four different parts of the application: the &lt;i&gt;route map&lt;/i&gt;, &lt;i&gt;route classes&lt;/i&gt;, &lt;i&gt;controller classes&lt;/i&gt;, and &lt;i&gt;the router service&lt;/i&gt;. Over the next year, we should iteratively design and implement our way toward a future without controllers… and possibly some other simplifications, if we can manage them. We can make working with Ember simultaneously &lt;em&gt;easier for newcomers&lt;/em&gt; and &lt;em&gt;better for old hands&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;“Controllers are dead!” is one of the great bogeymen of Ember lore at this point; but I hope quite sincerely that a year from now it’s basically true. Controllers are the single part of Ember today that shows &lt;em&gt;very&lt;/em&gt; clearly the application’s SproutCore roots. When I started learning AppKit and UIKit early this year, I was struck by all the things that sounded like Ember 1.x—or rather, vice versa! And just as Apple itself is now &lt;a href="https://developer.apple.com/xcode/swiftui/"&gt;moving aggressively toward a programming model without controllers&lt;/a&gt;, so should we!&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It’s not that controllers are &lt;em&gt;bad&lt;/em&gt;, exactly. It’s that they don’t &lt;em&gt;fit&lt;/em&gt; with the rest of the framework at this point. They’re long-lived singletons (like services) but serve as backing classes for templates (like components). They are eagerly instantiated as soon as a &lt;code&gt;LinkTo&lt;/code&gt; component with references them is instantiated, but not &lt;em&gt;set up&lt;/em&gt; until the app transitions to the route associated with them. They’re required if you want to use query parameters, and query parameters don’t work with Ember’s “data down, actions up” paradigm… pretty much at all.&lt;/p&gt;
&lt;p&gt;Controllers need to go, but they need a well-designed set of replacements—in particular, we need a good design for query parameter handling and for what template should be associated with a given route.&lt;/p&gt;
&lt;p&gt;Query param handling is, I admit, mostly outside my wheelhouse. All of the situations where I’ve used it would be trivially solved by putting them on the router service, tracking changes on them with the &lt;code&gt;@tracked&lt;/code&gt; decorator, and updating them with actions. However, I’m reliably informed that some of the more gnarly scenarios out there require a bit more than this, and I defer to the folks who know what they’re talking about there!&lt;/p&gt;
&lt;p&gt;React and Vue simply solve the template problem by mounting &lt;em&gt;components&lt;/em&gt; at given route locations. Ember should probably follow &lt;em&gt;roughly&lt;/em&gt; the same path, while baking in good defaults along the way. Don’t call them “routable components” though! It’s not just that it’s too much baggage; it’s that a good design in this space should not require the components themselves to be anything special at all. Instead, whether it’s part of the route map or the router class grows a small bit of new, purely declarative &lt;abbr&gt;API&lt;/abbr&gt;—e.g. static class properties specifying the relevant components for the loading, resolved, and error states of the route’s model—the route itself should be able to specify exactly what component to render.&lt;/p&gt;
&lt;p&gt;If we put in the work to get a design that satisfies all these constraints, we can come out with a &lt;em&gt;much&lt;/em&gt; simpler routing system—and Ember’s entirely programming model will be &lt;em&gt;much&lt;/em&gt; more coherent as a result.&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; We’ll simply have components, services, and routes—and routes will simply be a mapping from URL to a particular set of data and a corresponding component to render it into. That in turn will take us most of the rest of the way toward the programming model Chris Garrett proposed a year ago: &lt;a href="https://medium.com/@pzuraq/emberjs-2018-ember-as-a-component-service-framework-2e49492734f1"&gt;Ember as a Component-Service Architecture&lt;/a&gt;. This is the fitting conclusion to what we started in Octane: bringing the &lt;em&gt;whole&lt;/em&gt; Ember programming model into coherence.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="bonus" class="level2"&gt;
&lt;h2&gt;Bonus&lt;/h2&gt;
&lt;p&gt;I’d also like to strongly commend my friend Dustin Masters’ post, &lt;a href="https://dev.to/dustinsoftware/the-case-for-embeddable-ember-4120"&gt;The Case for Embeddable Ember&lt;/a&gt;. Call this a stretch goal: if we ship all the build pipeline elements represented above, the extra work required to get to that point is &lt;em&gt;relatively&lt;/em&gt; small—and extremely valuable for many teams who want to replace legacy applications written wholly with Backbone, jQuery etc., or who just want to see if Ember might have value to add without doing a full rewrite of their existing React/Vue/Angular/Aurelia apps.&lt;/p&gt;
&lt;p&gt;Oh… and it turns out that the design constraints I suggested for a routing system that works well with components would lead fairly nicely and easily to Dustin’s proposal, and make for a straightforward path to fully adopt Ember and map its component tree to the router when you’re ready. Just saying.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;You can expect to hear a &lt;em&gt;lot&lt;/em&gt; more from me about Swift UI in this space, both in a general sense &lt;em&gt;and&lt;/em&gt; as it relates to Ember. There are some fascinating points of contact between the two programming models!&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;There may also be opportunities for further simplification past this, along with more substantial rethinks of our router as we have it. But those are not &lt;em&gt;necessary&lt;/em&gt; for the next year, and making these changes will unlock further experimentation in that direction while making Ember more usable in the meantime.&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 17 Jun 2019 20:25:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2019-06-17:/2019/emberjs2019-part-1.html</guid><category>emberjs</category><category>emberjs2019</category><category>JavaScript</category><category>open-source software</category></item><item><title>#EmberJS2019, Part 2</title><link>http://www.chriskrycho.com/2019/emberjs2019-part-2.html</link><description>&lt;p&gt;Over the last year, the Ember community has steadily delivered on the vision we all traced out in last year’s #EmberJS2018 and Roadmap &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; process, culminating with the shipping-very-soon-now &lt;a href="https://emberjs.com/editions/octane/"&gt;Ember Octane Edition&lt;/a&gt;. (All the pieces are pretty much done and are either on stable or will be shortly; we just need another &lt;abbr title="long term support"&gt;LTS&lt;/abbr&gt; release before we cut a full new edition!)&lt;/p&gt;
&lt;p&gt;So… what should we tackle next? This year, I have only two parts, unlike &lt;a href="https://www.chriskrycho.com/emberjs2018"&gt;last year’s four&lt;/a&gt; (and I’m sneaking them in just under the wire, as today is the deadline for entries!):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2019/emberjs2019-part-1"&gt;Part 1: &lt;b&gt;Let’s finish modernizing the Ember programming model!&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.chriskrycho.com/2019/emberjs2019-part-2"&gt;Part 2 (this post): &lt;b&gt;Let’s make TypeScript a first-class citizen of the Ember ecosystem.&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;For the last two and a half years, I have been working off and on towards making TypeScript viable in Ember apps and addons. I was delighted when others came along to help pick up the load, and we’ve &lt;a href="https://www.chriskrycho.com/2019/emberconf-2019-typed-ember-team-report.html"&gt;charted a course&lt;/a&gt; for what we’d like to do over the year ahead. The major priorities we identified all point at what I’ve wanted since I started down this road back at the very end of 2016: for TypeScript to be a first-class citizen in the Ember ecosystem. Here’s my roadmap for how we get there. (Note that here I’m speaking only for myself—neither for the Typed Ember team nor for LinkedIn!)&lt;/p&gt;
&lt;section id="the-roadmap" class="level2"&gt;
&lt;h2&gt;The Roadmap&lt;/h2&gt;
&lt;section id="execute-on-our-priorities" class="level3"&gt;
&lt;h3&gt;1. Execute on Our Priorities&lt;/h3&gt;
&lt;p&gt;All of us want this to happen. It’s not yet clear what all of our priorities will be in our jobs over the back half of 2019—but if we can, we’d like to see those efforts across the line.&lt;/p&gt;
&lt;p&gt;The TypeScript team has eased one of our heavy burdens, by investing in performance monitoring infrastructure over the course of this year and paying close attention to how their changes affect us as well as other TypeScript consumers. We’re deeply appreciative! But there’s still a lot of work to be done that just needs time to actually do the work—reducing churn in type definitions, building type-checked templates, and improving our documentation.&lt;/p&gt;
&lt;p&gt;None of those are insurmountable by any stretch. But they’d also be far likelier to happen if they were concretely identified as priorities for Ember as a whole, and we had commitment from the community to help!&lt;/p&gt;
&lt;p&gt;To briefly summarize &lt;a href="https://www.chriskrycho.com/2019/emberconf-2019-typed-ember-team-report.html"&gt;those priorities&lt;/a&gt; again:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We need to make it so that consumers of our type definitions do not face breakage from updates to Ember’s types &lt;em&gt;or&lt;/em&gt; TypeScript definitions. We already worked out a basic strategy to solve this problem, and I’ve done further exploration to validate that with key stakeholders of large apps (both TypeScript users and apps which &lt;em&gt;want&lt;/em&gt; to use TypeScript) and core Ember contributors… but none of us have had time since EmberConf to write out the strategy as a Typed Ember &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt;, much less to do the actual implementation work.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We need to make templates type-aware and type-safe. As fantastic as the experience of writing Glimmer components is—and I genuinely do love it!—it’ll be an order of magnitude better when you get autocomplete from your editor as soon as you type &lt;code&gt;&amp;lt;SomeComponent @&lt;/code&gt;… and see the names of the valid arguments to a &lt;code&gt;SomeComponent&lt;/code&gt; and the types of things you can pass to them. Everyone who has used TSX in a well-typed React app knows just how good this can be. We can make the experience equally great in Ember, while maintaining the authoring and performance advantages of separate templates. Again: we know how to do this (and the TypeScript team is also working on things which may make it even better for us). We just need the time allocated to take the work from prototype to ready-for-real-world-use.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We need to dramatically expand the documentation we provide. Right now, ember-cli-typescript provides a minimal (and very useful!) set of docs. It’s enough to get you &lt;em&gt;started&lt;/em&gt;, and if you’re already comfortable with TypeScript you’ll do all right. However, we’d love to provide helpful guides that show people not just the &lt;em&gt;mechanics&lt;/em&gt; of using TypeScript with an Ember app, but best practices and techniques and the happy path. There’s a world of difference between being able to run &lt;code&gt;ember install ember-cli-typescript&lt;/code&gt; successfully and being able to author an app or addon in TypeScript successfully, and we need to bridge that gap for successful ecosystem-wide adoption!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="type-the-ecosystem" class="level3"&gt;
&lt;h3&gt;2. Type the Ecosystem&lt;/h3&gt;
&lt;p&gt;We also need to do the work—and this simply &lt;em&gt;cannot&lt;/em&gt; be done solely by the handful of us that make up the core team—to get types in place for the whole of the Ember ecosystem. Two years ago, I started drafting a blog post outlining a quest to type the ecosystem. I rewrote a good chunk of it last year. I even began working on a draft of the quest in our repository in 2018! But we haven’t actually done it, and while a handful of important addons do now have types, (a) most still don’t, and (b) many of those which &lt;em&gt;do&lt;/em&gt; have type definitions could use further iteration to tighten them up to make them more reliable or more useful.&lt;/p&gt;
&lt;p&gt;I &lt;em&gt;hope&lt;/em&gt; to actually open that quest sometime during the third quarter of this year. If things go as I hope, I will be doing some of that work myself, and I will be building documentation and training materials for others so &lt;em&gt;they&lt;/em&gt; can see how to do it, and I will be available for code reviews on conversion efforts. I cannot guarantee that by any stretch—but it is my fervent hope, and there is very good reason to think it may actually come to pass!&lt;/p&gt;
&lt;p&gt;In many ways, this also hinges on our ability to provide a good story for reducing churn in type definitions. Just as it’s important that we make Ember’s &lt;em&gt;own&lt;/em&gt; types stable for consumers, it’s also important that we help addon developers provide the same kinds of guarantees for &lt;em&gt;their&lt;/em&gt; consumers. The entire Ember community takes SemVer seriously, and that means the tools have to support that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="define-embers-typescript-story" class="level3"&gt;
&lt;h3&gt;3. Define Ember’s TypeScript Story&lt;/h3&gt;
&lt;p&gt;If we manage to execute on all the priorities outlined above, then there’s one last step for making TypeScript an official part of Ember’s story: an &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; defining &lt;em&gt;exactly&lt;/em&gt; how Ember can officially support TypeScript—including two major commitments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shipping its own type definitions, with a well-considered approach to SemVer and TypeScript&lt;/li&gt;
&lt;li&gt;considering TypeScript a &lt;em&gt;peer&lt;/em&gt; to JavaScript in &lt;abbr title="Application Programming Interface"&gt;API&lt;/abbr&gt; design decisions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have an basic frame in mind for how we tackle both of those. The first is by far the more important of the two; the latter is already happening in an &lt;i&gt;ad hoc&lt;/i&gt; way and merely requires the former before it can be formalized. But getting to the point where Ember can ship its own type definitions while upholding its semantic versioning commitments &lt;em&gt;and&lt;/em&gt; taking advantage of the advances always happening with TypeScript itself is a large and non-trivial task.&lt;/p&gt;
&lt;p&gt;It means a substantial amount of work within the Ember codebase. It means building new tooling for Ember’s core development process—so that the experience of working on Ember itself can remain ever-more productive even as we make sure that the types published for consumers are reliable, accurate, and stable. It means investing in both further education of the community and more static analysis tooling, to make sure that breaking &lt;em&gt;type&lt;/em&gt;-level changes are not introduced accidentally.&lt;/p&gt;
&lt;p&gt;These efforts are worth the investment they will require, but they &lt;em&gt;are&lt;/em&gt; serious efforts.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="why-it-matters" class="level2"&gt;
&lt;h2&gt;Why It Matters&lt;/h2&gt;
&lt;p&gt;This is not just me speaking as TypeScript fanboy and promoter. These things matter for TypeScript consumers of Ember—and they do, profoundly. But I would not suggest even that &lt;abbr title="Request for Comments"&gt;RFC&lt;/abbr&gt; for official support merely to that end. The TypeScript user community in Ember has done extremely well to date &lt;em&gt;without&lt;/em&gt; that kind of official commitment, and could continue to do so (as do many other communities in the broader JavaScript ecosystem).&lt;/p&gt;
&lt;p&gt;Why, then, do I suggest we make this not just a commitment for our little informal team but for the Ember community as a whole? Because while TypeScript users will benefit the &lt;em&gt;most&lt;/em&gt; from these improvements, JavaScript developers will &lt;em&gt;also&lt;/em&gt; benefit from them.&lt;/p&gt;
&lt;p&gt;When both Ember core and every major addon in the Ember ecosystem has top-notch types available, &lt;em&gt;every&lt;/em&gt; other app and addon author will be able to take advantage of those types, courtesy of the integration offered by TypeScript in every major editor. Whether they’re using Vim or Visual Studio, Ember developers will be able to get rich documentation, suggestions, and inline errors—even for their templates! This can be a massive win for developer productivity throughout the ecosystem. Investing to make TypeScript a first-class citizen fo the Ember ecosystem will make the experience of authoring Ember apps and libraries better for &lt;em&gt;everyone&lt;/em&gt;. So let’s do it!&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 17 Jun 2019 09:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2019-06-17:/2019/emberjs2019-part-2.html</guid><category>emberjs</category><category>emberjs2019</category><category>TypeScript</category><category>JavaScript</category><category>open-source software</category></item></channel></rss>