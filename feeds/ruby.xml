<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - ruby</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Fri, 07 Aug 2015 20:00:00 -0400</lastBuildDate><item><title>High- and Low-Level Programming Languages</title><link>http://www.chriskrycho.com/2015/high-and-low-level-programming-languages.html</link><description>&lt;p&gt;It occurred to me while listening to &lt;a href="https://edwinb.wordpress.com"&gt;Edwin Brady&lt;/a&gt; talk about &lt;a href="http://www.idris-lang.org"&gt;Idris&lt;/a&gt; on the &lt;a href="http://typetheorypodcast.com"&gt;Type Theory Podcast&lt;/a&gt;,&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; having just spent a few weeks starting to learn &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;: “low-level” has at least two meanings in software. One is whether something has manual memory management or is garbage collected, reference counted, or otherwise manages memory itself. This is what people often mean when they talk about C, C++, etc. as being “low-level” and languages like Python or Ruby or C♯ being high-level.&lt;/p&gt;
&lt;p&gt;But then you toss in a language like &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;, and things start to get a little more complicated. Rust can do the same kind of direct memory management that makes C or C++ a good language for things like writing operating system kernels. [&lt;a href="https://github.com/torvalds/linux"&gt;1&lt;/a&gt;,&lt;a href="https://en.wikipedia.org/wiki/Architecture_of_Windows_NT"&gt;2&lt;/a&gt;,&lt;a href="http://www.opensource.apple.com/source/xnu/xnu-2782.10.72/"&gt;3&lt;/a&gt;] But it is also memory-safe, at least in ordinary usage. Like C♯, you have to be explicit about any unsafe code, with the &lt;code&gt;unsafe&lt;/code&gt; keyword on any blocks that do memory management that isn’t safe. And the vast majority of Rust code &lt;em&gt;is&lt;/em&gt; safe.&lt;/p&gt;
&lt;p&gt;More than that, though, Rust &lt;em&gt;feels&lt;/em&gt; like a high-level language. It gives you higher-kinded functions, generics, traits-based composition of types, hygienic macros, and the implementation of many important parts the essentials of the language in the library. If you need to patch something, or extend something, you can do that in a straightforward way. In short, it gives you lots of good abstractions like you would expect in a high-level language.&lt;/p&gt;
&lt;p&gt;Rust is low-level in that you can write (and people are writing) systems-level programs in it. It is high-level in that it lets you express things in ways normally associated with languages like Haskell or OCaml or Python or Ruby. To put it simply: it’s &lt;em&gt;low-level&lt;/em&gt; in its ability to address the computer, and &lt;em&gt;high-level&lt;/em&gt; in the abstractions it hands to a programmer. That’s a powerful combination, and I hope more languages embrace it in the years to come.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Yes, I know that’s insanely nerdy. What did you expect?&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Aug 2015 20:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-08-07:/2015/high-and-low-level-programming-languages.html</guid><category>programming languages</category><category>rust</category><category>python</category><category>ruby</category><category>c</category><category>cplusplus</category></item></channel></rss>