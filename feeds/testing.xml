<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - testing</title><link>http://v4.chriskrycho.com/</link><description></description><lastBuildDate>Wed, 13 Nov 2019 22:30:00 -0500</lastBuildDate><item><title>Test the Interface</title><link>http://v4.chriskrycho.com/2019/test-the-interface.html</link><description>&lt;p&gt;&lt;i&gt;&lt;b&gt;&lt;a href="https://v4.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience&lt;/a&gt;:&lt;/b&gt; software developers interested in honing their craft—especially folks just trying to get a handle on good techniques for testing.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;A fundamental principle of testing software is: &lt;i&gt;test the interface&lt;/i&gt;. Failing to keep this principle in mind is at the root of the majority of the problems I see in automated tests (including quite a few of those I’ve written in the past!).&lt;/p&gt;
&lt;p&gt;What do I mean by &lt;i&gt;test the interface&lt;/i&gt;? I mean that when you are thinking about what kind of test to write, you can answer it by thinking about how the piece of code will be &lt;em&gt;used&lt;/em&gt;. That’s the interface: the place that piece of code interacts with the rest of the world around it. The interaction might be between two functions, or it might be feeding data from a web &lt;abbr title="application programming interface"&gt;API&lt;/abbr&gt; into your application to show users data, or any of a host of things in between. The point is: wherever that interaction is, &lt;em&gt;that’s&lt;/em&gt; the interface, and &lt;em&gt;that’s&lt;/em&gt; what you test.&lt;/p&gt;
&lt;p&gt;To see what I mean, let’s define some different kinds of interfaces and how we might test them in the context of a JavaScript application. (I’m using this context because it’s the one I’m most familiar with these days—but the basic principles apply equally well in lots of other contexts.) When we’re writing our app, we have a bunch of different levels of abstraction we can deal with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the entire application as the user experiences it&lt;/li&gt;
&lt;li&gt;individual user interface elements within the application—&lt;abbr title="user interface"&gt;UI&lt;/abbr&gt; components&lt;/li&gt;
&lt;li&gt;functions and classes that manage the business logic of the application&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is actually pretty much it, though each of those covers an enormous amount of ground. Notice too that each of these layers of abstraction (each interface) is composed of lower levels of abstraction (smaller interfaces). However, you still want to test each interface on its own terms.&lt;/p&gt;
&lt;p&gt;When you are trying to test the entire application as the user experiences it, you should be doing “end-to-end” style testing, preferably with some kind of testing tool that generates the same kinds of input (from the app’s perspective) as a user would. In web apps, we often use tools like &lt;a href="https://developers.google.com/web/tools/puppeteer"&gt;Puppeteer&lt;/a&gt; or &lt;a href="https://www.seleniumhq.org/projects/webdriver/"&gt;Webdriver&lt;/a&gt; to simulate a user clicking through our &lt;abbr&gt;UI&lt;/abbr&gt; and filling in forms and so on. This is the right level of testing: we interact with the whole app and its interface the same way a user does!&lt;/p&gt;
&lt;p&gt;What we &lt;em&gt;shouldn’t&lt;/em&gt; do at this level is use our knowledge of the framework our app is using to go in and replace function calls, or swap out &lt;abbr&gt;UI&lt;/abbr&gt; components. As soon as we do that, our test stops actually telling us the truth about the interface it’s testing. A user can’t reach in and swap out a function at runtime. If &lt;em&gt;you&lt;/em&gt; do that in your tests, then your test tells you something about a fake world you’ve constructed—not the world your user lives in! How do you &lt;em&gt;know&lt;/em&gt; that’s the right level to test at? Because that’s the level at which your app interacts with the user: in terms of clicks and form-filling and those kinds of events. &lt;em&gt;Not&lt;/em&gt; in terms of function calls!&lt;/p&gt;
&lt;p&gt;What about &lt;abbr&gt;UI&lt;/abbr&gt; components? The same basic principle holds here. The public interface of a component in any modern web framework is its template—whether that’s JSX, Glimmer templates, Vue templates, Angular templates, or something else. How do you know that? Because that’s the level at which the rest of your codebase will &lt;em&gt;use&lt;/em&gt; the component. So what you should test is that template invocation. This is the level of a “rendering” test (as we call them in Ember).&lt;/p&gt;
&lt;p&gt;The rest of your codebase doesn’t have the liberty (and in most cases doesn’t have the &lt;em&gt;ability&lt;/em&gt;) to reach in and change the behavior of the class or function for your component at runtime. All it can do is call that component with its arguments, and work with anything the component hands back to it. If, during your tests, you violate that—say, by reaching in and calling internal methods on the class that backs a component, rather than via the event handlers you set up to trigger those methods—you are no longer testing what you think you are. Again: you’re in a world of your own construction, &lt;em&gt;not&lt;/em&gt; the world the rest of your app code lives in. Your test only tells you what happens when you do something manually behind the scenes with the internals of your component… &lt;em&gt;not&lt;/em&gt; what happens when interacting with the component the way other code will.&lt;/p&gt;
&lt;p&gt;The same basic principle applies for other classes used in your codebase. This is the layer for “unit” tests. For functions, you just pass in the various arguments allowed and check that you’re getting the results you expect. For classes, you set them up using their public constructors and call only their public methods and set only their public fields. In languages like JavaScript, Python, Ruby, and others, you can often poke at and use methods and data on the class which are really meant to be private.[^private fields] That can be particularly tempting when you’re the author of the class: &lt;em&gt;you&lt;/em&gt; know what these internal details are supposed to do, after all! It can seem faster and easier to just set up a class with some state ahead of time, or to swap out one of its methods for an easier one to test using monkey-patching or mocking.&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; If you do this, however, instead of using the documented public &lt;abbr&gt;API&lt;/abbr&gt;, you’re once again testing something other that what the rest of your app will be using… and this means that once again your tests don’t actually tell you whether the rest of the app can actually use it correctly!&lt;/p&gt;
&lt;p&gt;In each of these cases, we need to &lt;i&gt;test the interface&lt;/i&gt;—the place where the rest of the world will interact with our code, &lt;em&gt;not&lt;/em&gt; its internal mechanics.&lt;/p&gt;
&lt;p&gt;This helps guarantee that what we are testing is what the rest of the world sees—whether the “world” in question is other functions or classes, or external &lt;abbr&gt;API&lt;/abbr&gt;s, or actual users. It also helps us when refactoring, which is making changes to the internals of some piece of code &lt;em&gt;without changing its public interface&lt;/em&gt;. If we test the interface, we can safely refactor internally and know two things: if our tests break, we got our refactoring wrong; and we don’t have to change our tests in the process of refactoring! If we test the internals instead of the interface, though, we’ll &lt;em&gt;often&lt;/em&gt; have to make changes to our tests when we’re trying to refactor, because we’ll be changing those “behind the scenes” details.&lt;/p&gt;
&lt;p&gt;None of this is obvious or intuitive when you’re just starting out, but keeping the principle of &lt;i&gt;test the interface&lt;/i&gt; in mind will help you pick the right kind of test: end-to-end, some kind of rendering/&lt;abbr&gt;UI&lt;/abbr&gt; test for individual components, and unit tests for standalone “business logic” classes or functions. Hopefully this can help a few of you out there internalize this faster than I did!&lt;/p&gt;
&lt;p&gt;[^private fields]: JavaScript is getting private fields and methods soon, which will help a lot with this—but the basic principle here will remain important even then, because not everything that’s private in terms of &lt;abbr&gt;API&lt;/abbr&gt; design can or should be private in terms of the implementation mechanics. This is a question I’d love to dig into… in a future post.&lt;/p&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;A related tip—if you find yourself wishing that the implementation were easier to &lt;em&gt;test&lt;/em&gt;, and needing to mock or stub parts of it to make it testable, that’s &lt;em&gt;often&lt;/em&gt; a sign that your design needs some work!&lt;/p&gt;
&lt;p&gt;Note that I didn’t spend much time on functions here because it’s much &lt;em&gt;harder&lt;/em&gt; to get yourself into these messes with functions. In most languages, you don’t have any way to reach in and mess with their internals, so you’re safe from a lot of these issues. Inputs and outputs are all you have to work with. This is one of the great advantages to working with a functional style where you can. Use of closures for managing state complicates this story a bit, but even there: less so than with most of the other things discussed here!&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 13 Nov 2019 22:30:00 -0500</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2019-11-13:/2019/test-the-interface.html</guid><category>software development</category><category>testing</category></item><item><title>Scales of Feedback Time in Software Development</title><link>http://v4.chriskrycho.com/2018/scales-of-feedback-time-in-software-development.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;&lt;strong&gt;&lt;a href="http://v4.chriskrycho.com/2018/assumed-audiences.html"&gt;Assumed Audience&lt;/a&gt;:&lt;/strong&gt; fans of compiled languages with expressive type systems. I’m not trying to persuade fans of dynamic languages they should use a compiler here; I’m trying to surface something that often goes unstated in discussions among fans of compiled languages with expressive type systems, but hopefully it’s interesting beyond that. If you don’t like compiled languages, just skip the build step bits; the rest all still applies.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;There are basically six stages of the development of any given software component where you can receive feedback on what you build:&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;compilers, static analysis tools, and/or pair programming&lt;/li&gt;
&lt;li&gt;automated test suites&lt;/li&gt;
&lt;li&gt;manual local testing&lt;/li&gt;
&lt;li&gt;continuous integration (&lt;abbr&gt;CI&lt;/abbr&gt;) test results&lt;/li&gt;
&lt;li&gt;deploying to staging (or a similar test environment) for manual testing&lt;/li&gt;
&lt;li&gt;deploying to live, i.e. when production traffic is meaningfully different from what you can test on staging&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What’s interesting to note is that there are also, in my experience, roughly order-of-magnitude differences between each of those layers in terms of the &lt;em&gt;cycle time&lt;/em&gt; between when you make a change and whether you know it is broken. That is, there seem to be rough factor-of-ten differences between the feedback you get from—&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;compilers, static analysis tools, and/or pair programming—all of which can show you feedback in near-real-time as you’re typing and saving your code, especially with a good language server or a fast compiler or a speedy linter&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;automated test suites, assuming they’re running on every build change and are reasonably speedy themselves, or scoped to the things impacted by the changes made&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;manual local testing, which you can repeat after every build, but which usually requires you to switch contexts to execute the program in some way&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;abbr&gt;CI&lt;/abbr&gt;, presumably doing the automated equivalent of what you do in both layers 2 and 3, but requiring a push to some central location and a remote build and execution of the test suite, and often a much larger integration test suite than you’d run locally&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;deploying to staging, and repeating the same kinds of manual testing you might do locally in layer 2 in a more production-like environment&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;deploying to live, and repeating the same kinds of manual testing you might do locally in layers 2 or 5, as well as getting feedback from observability or monitoring systems using your real traffic&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(Those last two &lt;em&gt;might&lt;/em&gt; be comparable in the cycle time sense. However, the way most teams I’ve heard of work, any deploy to live is usually preceded by a deploy to staging. What’s more, with most changes that you can’t test until it’s live, it’s often the case that you’re not going to know if something is wrong until it has been live for at least a little while. Finally, some kinds of things you can really only test with production load and monitoring or observability systems, and those kinds of things are at least sometimes not to be visible immediately after deployment, but only in the system’s aggregate behavior or weird outliers that show up given enough scale.)&lt;/p&gt;
&lt;p&gt;What all of this gets at is that stepping to a higher layer nearly always entails a &lt;em&gt;dramatic&lt;/em&gt; increase in the &lt;em&gt;cycle time&lt;/em&gt; for software development: that is, the amount of time between when I make a change and when I know whether it’s broken or not. If I can know that I have a problem because my compiler surfaces errors in my editor, that probably saves me a minute or two each day over only being able to see the same error in a test suite. By the same token, being able to surface an error in a test suite running on every build will likely save me anything from minutes to hours of cycle time compared to something I can only test in production.&lt;/p&gt;
&lt;p&gt;At first blush, this looks like an argument for pushing everything to the lowest-numbered layer possible, and I think that’s &lt;em&gt;kind of&lt;/em&gt; right. I (and probably many other people who end up in, say, Rust or Haskell or Elm or other languages with similarly rich type systems) tend to prefer putting as much as possible into layer 1 here precisely because we have so often been bitten by things that are at layer 2 in other languages or frameworks and take a lot of time to figure out why they broke at layer 2. This happened to me in a C&lt;sup&gt;♯&lt;/sup&gt; server application just a couple weeks ago, and chasing it down was &lt;em&gt;not fun&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, my enthusiasm for rich type systems notwithstanding, I &lt;em&gt;don’t&lt;/em&gt; think this observation about these layers of cycle time means we should put everything in the compiler all the time. Indeed, there are some things it is too expensive or difficult to test anywhere &lt;em&gt;but&lt;/em&gt; production (all the way up at layer 6). What’s more–although this is often overlooked in these discussions–putting too much of this rich information in layer 1 can absolutely kill your compile times in many languages. In my experience, this is particularly true of many of the languages with rich enough type systems to make layer 1 handling genuinely viable in the first place!&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I do think, though, that being aware of the cost in cycle time is useful, as is being explicit about &lt;em&gt;why&lt;/em&gt; we think it’s worth slotting a particular set of feedback into layer 2 vs. layer 1 (or layers 3, 4, 5, or 6). That goes for library development, of course.&lt;a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; It goes equally for application development, though! It can be really helpful to make explicit both which of these layers you’re landing in and (just as important) why you’ve landed there for any given bit of feedback you want or need to get–making the tradeoffs explicit along the way.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;Thanks to my friend Ben Makuh for looking over an earlier draft of this piece and providing really helpful feedback on it! Thanks as well to Greg Vaughn for noting shortly after I published it that pair programming also sits at the “immediate feedback” layer.&lt;/i&gt;&lt;/p&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;There’s some ongoing work in the Rust web working group to build an exemplar web framework, &lt;a href="https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html"&gt;Tide&lt;/a&gt;. The &lt;a href="https://rust-lang-nursery.github.io/wg-net/2018/10/16/tide-routing.html"&gt;most recent post&lt;/a&gt; tackled routing, and prompted &lt;a href="https://internals.rust-lang.org/t/routing-and-extraction-in-tide-a-first-sketch/8587"&gt;an interesting discussion&lt;/a&gt; on the &lt;a href="https://internals.rust-lang.org/"&gt;Rust internals forum&lt;/a&gt;. This post is a cleaned-up, better-articulated, more general version of &lt;a href="https://internals.rust-lang.org/t/routing-and-extraction-in-tide-a-first-sketch/8587/36?u=chriskrycho"&gt;a post&lt;/a&gt; I offered in that thread.&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;Right now I and a few others are trying to figure out why one particular type definition in the TypeScript definitions for Ember.js causes a build to take about 20× as long as the build without that type definition. It’s the difference between a 6.5-second build and a 2.5-&lt;em&gt;minute&lt;/em&gt; build.&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3" role="doc-endnote"&gt;&lt;p&gt;as in the example of a web server’s &lt;abbr&gt;API&lt;/abbr&gt; for route handling which originally prompted this post&lt;a href="#fnref3" class="footnote-back" role="doc-backlink"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 22 Oct 2018 21:15:00 -0400</pubDate><guid isPermaLink="false">tag:v4.chriskrycho.com,2018-10-22:/2018/scales-of-feedback-time-in-software-development.html</guid><category>software development</category><category>testing</category><category>programming languages</category><category>Rust</category></item></channel></rss>