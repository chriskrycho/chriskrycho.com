<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - elm</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Sun, 14 Jan 2018 09:00:00 -0500</lastBuildDate><item><title>Exploring 4 Languages: Starting to Model the Domain</title><link>http://www.chriskrycho.com/2018/exploring-4-languages-starting-to-model-the-domain.html</link><description>&lt;p&gt;In the first three chapters of &lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;, Wlaschin walks through the creation of a “domain model” for an order-taking system. (It’s well worth reading the book just for a bunch of the lessons in that section—I found them quite helpful!) Then, after spending a chapter introducing F&lt;sup&gt;♯&lt;/sup&gt;’s type system, he introduces the ways you can &lt;em&gt;use&lt;/em&gt; those type mechanics to express the domain. In today’s post, I’ll show the idiomatic implementations of these types in each of Rust, Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and ReasonML.&lt;/p&gt;
&lt;section id="simple-values" class="level2"&gt;
&lt;h2&gt;Simple values&lt;/h2&gt;
&lt;p&gt;Simple wrapper types let you take simple types like strings, numbers, etc. and use types to represent part of the business domain you’re dealing with—the basic idea being that a Customer ID may be a number, but it’s not interchangeable with &lt;em&gt;other&lt;/em&gt; numbers such as Order IDs.&lt;/p&gt;
&lt;p&gt;Here’s the most ergonomic and effective (and automatically-formatted in line with the language standards, where applicable!) way to do that in each of the languages:&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct CustomerId(i32);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type CustomerId
    = CustomerId Int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML:&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type customerId =
  | CustomerId(int);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how similar these all are! The Rust implementation is the &lt;em&gt;most&lt;/em&gt; distinctive, though you can do it with the same kind of union type as the others. Here’s how that would look:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum CustomerId {
  CustomerId(i32),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For performance reasons, you might also choose to implement the F&lt;sup&gt;♯&lt;/sup&gt; type as a struct:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;&amp;lt;Struct&amp;gt;
type CustomerId = CustomerId of int&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="complex-data" class="level2"&gt;
&lt;h2&gt;Complex data&lt;/h2&gt;
&lt;p&gt;Wlaschin then moves on to showing how to model more complex data structures: types that “and” or “or” together other data. We “and” data together using record or struct types, and “or” data together using “union” or “enum” types. (Assume we’ve defined &lt;code&gt;CustomerInfo&lt;/code&gt;, &lt;code&gt;ShippingAddress&lt;/code&gt;, etc. types for all of these.)&lt;/p&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
struct Order {
    customer_info: CustomerInfo,
    shipping_address: ShippingAddress,
    billing_address: BillingAddress,
    order_lines: Vec&amp;lt;OrderLine&amp;gt;,
    billing_amount: BillingAmount,
}

// &amp;quot;or&amp;quot;
enum ProductCode {
    Widget(WidgetCode),
    Gizmo(GizmoCode),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- &amp;quot;and&amp;quot;
type alias Order =
    { customerInfo : CustomerInfo
    , shippingAddress : ShippingAddress
    , billingAddress : BillingAddress
    , orderLines : List OrderLine
    , billingAmount : BillingAmount
    }

-- &amp;quot;or&amp;quot;
type ProductCode
    = Widget WidgetCode
    | Gizmo GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt;:&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// &amp;quot;and&amp;quot;
type Order = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine list
    AmountToBill: BillingAmount
}

// &amp;quot;or&amp;quot;
type ProductCode =
    | Widget of WidgetCode
    | Gizmo of GizmoCode&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ReasonML—note that since we’re assuming we’ve already defined the other types here, you can write this without duplicating the name and type declaration, just like you can with JavaScript object properties.&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* &amp;quot;and&amp;quot; */
type order = {
  customerInfo,
  shippingAddress,
  billingAddress,
  orderLine,
  billingAmount
};

/* &amp;quot;or&amp;quot; */
type productCode =
  | Widget(widgetCode)
  | Gizmo(gizmoCode);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An interesting aside: unless you planned to reuse these types, you wouldn’t usually write these as standalone types with this many wrapper types in it in Rust in particular (even if the compiler would often recognize that it could squash them down for you).&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Instead, you’d normally write &lt;em&gt;only&lt;/em&gt; the base enum type to start, and refactor out the &lt;code&gt;struct&lt;/code&gt; wrapper later only if you found you needed it elsewhere:&lt;/p&gt;
&lt;pre class="diff"&gt;&lt;code&gt;enum ProductCode {
-    Widget(WidgetCode),
+    Widget(String),
-    Gizmo(GizmoCode),
+    Gizmo(String),
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That said: given how the book is tackling things, and the fact that you might want to &lt;em&gt;validate&lt;/em&gt; these types… having them as these low-cost wrappers is probably worth it. (In fact, having read a bit further than I’ve managed to write out yet, I can guarantee it.)&lt;/p&gt;
&lt;p&gt;We work through the rest of the basic types this way. But what about the types where we don’t yet have a good idea how we want to handle them?&lt;/p&gt;
&lt;p&gt;Each of these languages gives us an out (or more than one) for how to say “I don’t know what to put here yet.”&lt;/p&gt;
&lt;p&gt;Rust (which does not have a built-in &lt;code&gt;Never&lt;/code&gt; type… yet; see below):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;// Make an empty enum (which you by definition cannot construct)
enum Never {}

// Use it throughout where we don&amp;#39;t know the type yet. It will fail to compile
// anywhere we try to *use* this, because you can&amp;#39;t construct it.
type OrderId = Never;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (which has a built-in &lt;code&gt;Never&lt;/code&gt; type):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;-- It will fail to compile anywhere we try to *use* this, because you cannot
-- construct `Never`.
type alias OrderId =
    Never&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (which &lt;em&gt;sort&lt;/em&gt; of does):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;// Make a convenience type for the `exn`/`System.Exception` type
type Undefined = exn

type OrderId = Undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (which also &lt;em&gt;sort&lt;/em&gt; of does—identically with F&lt;sup&gt;♯&lt;/sup&gt;):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;/* Make a convenience type for the `exn`/`System.Exception` type */
type undefined = exn;

/*
  Use it throughout where we don&amp;#39;t know the type yet. It will compile, but fail
  to run anywhere we try to *use* this.
 */
type orderId = undefined;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For both F&lt;sup&gt;♯&lt;/sup&gt; and Reason, that’s following Wlaschin’s example. The main reason to do that is to make explicit that we’re not actually wanting an &lt;em&gt;exception&lt;/em&gt; type in our domain model, but just something we haven’t &lt;em&gt;yet&lt;/em&gt; defined. Anywhere we attempted to use it, we’d have to handle it like, well… an exception, instead of an actual type.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type OrderId = !;&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="workflows-and-functions" class="level2"&gt;
&lt;h2&gt;Workflows and functions&lt;/h2&gt;
&lt;p&gt;Once we have the basic types themselves in place, we need to write down the ways we transform between them. In a functional style, we’re not going to implement instance methods—though as we’ll see in the next post, what we do in Rust will have &lt;em&gt;some&lt;/em&gt; similarities to class methods—we’re going to implement standalone functions which take types and return other types.&lt;/p&gt;
&lt;p&gt;Again, you’ll note that despite the common lineage, there is a fair amount of variation here. (Note that we’d also have defined the &lt;code&gt;UnvalidatedOrder&lt;/code&gt;, &lt;code&gt;ValidationError&lt;/code&gt;, and &lt;code&gt;ValidatedOrder&lt;/code&gt; types for all of this; I’m mostly interested in showing &lt;em&gt;new&lt;/em&gt; differences here.)&lt;/p&gt;
&lt;p&gt;Rust (using the &lt;a href="https://github.com/alexcrichton/futures-rs"&gt;Futures&lt;/a&gt; library to represent eventual computation):&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidationResponse&amp;lt;T&amp;gt; = Future&amp;lt;Item = T, Error = ValidationError&amp;gt;;

fn validate_order(unvalidated: UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt; {
    unimplemented!()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm (using the built-in &lt;code&gt;Task&lt;/code&gt; type for eventual computation):&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;type ValidationResponse a
    = Task a (List ValidationError)

type alias ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse ValidatedOrder&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; (using the built-in &lt;code&gt;Async&lt;/code&gt; type for eventual computation):&lt;/p&gt;
&lt;pre class="fsharp"&gt;&lt;code&gt;type ValidationResponse&amp;lt;&amp;#39;a&amp;gt; = Async&amp;lt;Result&amp;lt;&amp;#39;a,ValidationError list&amp;gt;&amp;gt;

type ValidateOrder =
    UnvalidatedOrder -&amp;gt; ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reason (using the built-in JavaScript-specific &lt;code&gt;Js.Promise&lt;/code&gt; type—which is exactly what it sounds like—for eventual computation):&lt;/p&gt;
&lt;pre class="reason"&gt;&lt;code&gt;type validationResponse(&amp;#39;a) = Js.Promise.t(Js.Result.t(&amp;#39;a, list(validationError)));

type validateOrder = unvalidatedOrder =&amp;gt; validationResponse(validatedOrder);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again Rust is much &lt;em&gt;more&lt;/em&gt; different here from the others than they are from each other. The biggest difference between Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason is how they handle generics and type parameters.&lt;/p&gt;
&lt;p&gt;You’ll note that in Elm, they just follow the name of the wrapping type. This is a kind of syntactic symmetry: the way you &lt;em&gt;name&lt;/em&gt; a generic type like this is the same basic way you &lt;em&gt;construct&lt;/em&gt; it. It’s quite elegant. And as it turns out, the same is true of Reason; it’s just that its authors have chosen to follow OCaml and use parentheses for them instead of following Haskell with spaces—a reasonable choice, given Reason is surface syntax for OCaml and not Haskell.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; uses angle brackets, I strongly suspect, because that’s what C&lt;sup&gt;#&lt;/sup&gt; uses for generics, and keeping them syntactically aligned in things like this is very helpful. Rust similarly uses angle brackets for similarity with other languages which have similar surface syntax—especially C++ (with its templates).&lt;/p&gt;
&lt;p&gt;The way you &lt;em&gt;name&lt;/em&gt; generic parameters differs between the languages as well. Elm, following Haskell, uses lowercase letters to name its generics (usually called &lt;em&gt;type parameters&lt;/em&gt; in Elm). F&lt;sup&gt;#&lt;/sup&gt; and Reason both (unsurprisingly) follow OCaml in using lowercase letters preceded by an apostrophe to name generics—in F&lt;sup&gt;#&lt;/sup&gt;, &lt;code&gt;TypeGenericOver&amp;lt;'a&amp;gt;&lt;/code&gt;; in Reason, &lt;code&gt;typeGenericOver('a)&lt;/code&gt;. Rust follows the convention from languages like C++, Java, and C&lt;sup&gt;#&lt;/sup&gt; and uses capital letters, &lt;code&gt;TypeGenericOver&amp;lt;T&amp;gt;&lt;/code&gt;. The use of specific letters is conventional, not mandated by the language (unlike the casing). The ML family usually starts with &lt;code&gt;a&lt;/code&gt; and moves through the alphabet; Rust and the languages it follows usually start with &lt;code&gt;T&lt;/code&gt; (for &lt;em&gt;type&lt;/em&gt;) and moves forward through the alphabet. (Sometimes you’ll also see different letters where it’s obviously a better fit for what’s contained.)&lt;/p&gt;
&lt;p&gt;These languages also vary in the syntax for constructing a &lt;em&gt;list&lt;/em&gt; of things. In F&lt;sup&gt;#&lt;/sup&gt; has convenience syntax for a few built-ins (the most common being the &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Option&lt;/code&gt; types), allowing you to write them &lt;em&gt;either&lt;/em&gt; as e.g. &lt;code&gt;List&amp;lt;ConcreteType&amp;gt;&lt;/code&gt; or &lt;code&gt;ConcreteType list&lt;/code&gt; (as here in the example). Elm, Reason, and Rust all just use the standard syntax for generic types—&lt;code&gt;List a&lt;/code&gt;, &lt;code&gt;list('a)&lt;/code&gt;, and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Finally, you’ll also note that we haven’t written out a &lt;em&gt;type&lt;/em&gt; declaration here for Rust; we’ve actually written out a stub of a function, with the &lt;a href="https://doc.rust-lang.org/std/macro.unimplemented.html"&gt;&lt;code&gt;unimplemented!()&lt;/code&gt;&lt;/a&gt; &lt;a href="https://doc.rust-lang.org/1.17.0/reference/macros-by-example.html"&gt;macro&lt;/a&gt;. If you invoke this function, you’ll get a clear crash with an explanation of which function isn’t implemented.&lt;/p&gt;
&lt;p&gt;Now, Rust also &lt;em&gt;does&lt;/em&gt; let us write out the type of these functions as type aliases if we want:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;type ValidateOrder =
    Fn(UnvalidatedOrder) -&amp;gt; Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You just don’t use these very often in idiomatic Rust; it’s much more conventional to simply write out what I did above. However, the one time you &lt;em&gt;might&lt;/em&gt; use a type alias like this is when you’re defining the type of a closure and you don’t want to write it inline. This is a pretty sharp difference between Rust and the other languages on display here, and it goes to the difference in their approaches.&lt;/p&gt;
&lt;p&gt;Rust is &lt;em&gt;not&lt;/em&gt; a functional-first language in the way that each of the others are, though it certainly draws heavily on ideas from functional programming throughout and makes quite a few affordances for a functional style. Instead, it’s a programming language first and foremost interested in combining the most screaming performance possible with true safety, and leaning on ideas from the ML family (among others!) as part of achieving that.&lt;/p&gt;
&lt;p&gt;Among other things, this is why you don’t have currying or partial application in Rust: those essentially &lt;em&gt;require&lt;/em&gt; you to have invisible heap-allocation to be ergonomic. We &lt;em&gt;don’t&lt;/em&gt; have that in Rust, as we do in Elm, Reason, and F&lt;sup&gt;♯&lt;/sup&gt;. If we want to pass around a function, we have to explicitly wrap it in a pointer to hand it around if we construct it in another function. (I won’t go into more of the details of this here; I’ve covered it some &lt;a href="http://www.newrustacean.com/show_notes/e004/index.html"&gt;on New Rustacean&lt;/a&gt; and some &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;in my Rust and Swift comparison&lt;/a&gt; a couple years ago.)&lt;/p&gt;
&lt;p&gt;That same underlying focus on performance and explicitness is the reason we have &lt;code&gt;Box&amp;lt;ValidationResponse&amp;lt;ValidatedOrder&amp;gt;&amp;gt;&lt;/code&gt; in the Rust case: we’re explicitly returning a &lt;em&gt;pointer&lt;/em&gt; to the type here. In Elm, F&lt;sup&gt;♯&lt;/sup&gt;, and Reason, that’s &lt;em&gt;always&lt;/em&gt; the case. But in Rust, you can and often do return stack-allocated data and rely on “move” semantics to copy or alias it properly under the hood.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;So: lots of similarities here at first blush. The biggest differences that show up at this point are purely syntactical, other than some mildly sharper differences with Rust because of its focus on performance. The fact that these languages share a common lineage means it’s not hard to read any of them if you’re familiar with the others, and it’s actually quite easy to switch between them at the levels of both syntax and semantics.&lt;/p&gt;
&lt;p&gt;As usual, when dealing with languages in a relatively similar family, it’s &lt;em&gt;most&lt;/em&gt; difficult to learn the &lt;em&gt;library&lt;/em&gt; differences. The most obvious example of that here is Reason’s &lt;code&gt;Js.Promise&lt;/code&gt;, Elm’s &lt;code&gt;Task&lt;/code&gt;, F&lt;sup&gt;♯&lt;/sup&gt;’s &lt;code&gt;Async&lt;/code&gt;, and Rust’s &lt;code&gt;Future&lt;/code&gt; types: each of those has their own quirks, their own associated helper functions or methods, and their own ways of handling the same basic patterns.&lt;/p&gt;
&lt;p&gt;Still, if you have played with any one of these, you could pretty easily pick up one of the others. It’s sort of like switching between Python and Ruby: there are some real differences there, but the similarities are greater than the differences. Indeed, if anything, these languages are &lt;em&gt;more&lt;/em&gt; similar than those.&lt;/p&gt;
&lt;p&gt;Next time I’ll dig into Wlaschin’s chapter on &lt;em&gt;validating&lt;/em&gt; the domain model, and here some of the not-just-syntax-level differences in the languages will start to become more apparent.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I can’t speak to what’s idiomatic this way in any of the non-Rust languages, because I just haven’t used them enough yet.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 14 Jan 2018 09:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-14:/2018/exploring-4-languages-starting-to-model-the-domain.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages: Project Setup</title><link>http://www.chriskrycho.com/2018/exploring-4-languages-project-setup.html</link><description>&lt;p&gt;In this post, I’m just going to briefly talk through the steps I needed to do to set up each of the languages and my editor setup for them. Gladly, it was pretty simple. At the end, I’ll offer a note on my thoughts on the setup processes. (Note that this isn’t “How to do this for anyone ever”—it’s “how I did it, with some notes where it might be relevant to you.”)&lt;/p&gt;
&lt;p&gt;For context, I’m running macOS and using &lt;a href="https://code.visualstudio.com"&gt;VS Code&lt;/a&gt; as my editor. Whenever I say “Install the VS Code extension,” you can do it either by opening the extension side panel and searching for &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;, or by typing &lt;code&gt;ext install &amp;lt;extension label&amp;gt;&lt;/code&gt;—I’ll write it like &lt;code&gt;&amp;lt;Extension Name&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;extension label&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The source code as of what I’m describing in this post is &lt;a href="https://github.com/chriskrycho/dmmf/tree/project-setup"&gt;at the &lt;code&gt;project-setup&lt;/code&gt; tag&lt;/a&gt; in &lt;a href="https://github.com/chriskrycho/dmmf/"&gt;the repo&lt;/a&gt;.&lt;/p&gt;
&lt;section id="rust" class="level2"&gt;
&lt;h2&gt;Rust&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation:&lt;/strong&gt; Install &lt;a href="https://rustup.rs"&gt;&lt;em&gt;rustup&lt;/em&gt;&lt;/a&gt;: &lt;code&gt;curl https://sh.rustup.rs -sSf | sh&lt;/code&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code extension: &lt;code&gt;Rust (rls)&lt;/code&gt;/&lt;code&gt;rust&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of &lt;a href="https://github.com/chriskrycho/dmmf"&gt;my repo&lt;/a&gt;, I ran &lt;code&gt;cargo new rust&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="elm" class="level2"&gt;
&lt;h2&gt;Elm&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: There are installers, but I just did &lt;code&gt;npm i -g elm&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Installed the VS Code Elm extension: &lt;code&gt;Elm&lt;/code&gt;/&lt;code&gt;elm&lt;/code&gt;.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Install the &lt;code&gt;create-elm-app&lt;/code&gt; tool: &lt;code&gt;npm i -g create-elm-app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the root of the project, I ran &lt;code&gt;create-elm-app elm&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="f" class="level2"&gt;
&lt;h2&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Install &lt;a href="http://www.mono-project.com"&gt;mono&lt;/a&gt;: &lt;code&gt;brew install mono&lt;/code&gt; (note installation instructions &lt;a href="option-5-install-f-with-mono-via-homebrew-64-bit"&gt;here&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; Install the VS Code Ionide extension: &lt;code&gt;Ionide-fsharp&lt;/code&gt;/&lt;code&gt;ionide-fsharp&lt;/code&gt;. It’ll automatically install the associated Paket and FAKE extensions from the Ionide project as well, and those will install Paket and FAKE during installation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;In the root of the repo, I created the &lt;code&gt;fsharp&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;Then I opened a VS Code instance to to that directory, opened the command palette, and ran &lt;code&gt;F#: New Project&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;I chose &lt;code&gt;console&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;I left the directory blank&lt;/li&gt;
&lt;li&gt;I named the project &lt;code&gt;dmmf&lt;/code&gt; (for &lt;em&gt;D&lt;/em&gt;omain &lt;em&gt;M&lt;/em&gt;odeling &lt;em&gt;M&lt;/em&gt;ade &lt;em&gt;F&lt;/em&gt;unctional).&lt;/li&gt;
&lt;li&gt;Since F&lt;sup&gt;♯&lt;/sup&gt; (like C&lt;sup&gt;♯&lt;/sup&gt;) prefers PascalCase names, I renamed the generated module &lt;code&gt;DMMF&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="reasonml" class="level2"&gt;
&lt;h2&gt;ReasonML&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Language installation&lt;/strong&gt;: Following the setup instructions &lt;a href="https://reasonml.github.io/guide/javascript/quickstart"&gt;here&lt;/a&gt;, I ran &lt;code&gt;npm install -g bs-platform&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editor setup:&lt;/strong&gt; following &lt;a href="https://reasonml.github.io/guide/editor-tools/global-installation"&gt;the official instructions&lt;/a&gt;—
&lt;ul&gt;
&lt;li&gt;I ran &lt;code&gt;npm install -g https://github.com/reasonml/reason-cli/archive/3.0.4-bin-darwin.tar.gz&lt;/code&gt; to install the dependencies for the editor configuration.&lt;/li&gt;
&lt;li&gt;I installed the VS Code extension: &lt;code&gt;Reason&lt;/code&gt;/&lt;code&gt;reasonml&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project setup:&lt;/strong&gt; In the root of the repo, I ran &lt;code&gt;bsb -init reason -theme basic-reason&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="comments-on-the-setup-processes" class="level2"&gt;
&lt;h2&gt;Comments on the setup processes&lt;/h2&gt;
&lt;p&gt;Most of the languages have &lt;em&gt;fairly&lt;/em&gt; straightforward processes to get up and running with a good-to-excellent tooling experience.&lt;/p&gt;
&lt;p&gt;The best of them is Rust, which is &lt;em&gt;extremely&lt;/em&gt; easy to get up and running with.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; Elm is roughly in the middle—it’s less straightforward than Rust in that &lt;code&gt;create-elm-app&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; an officially supported approach, unlike &lt;code&gt;rustup&lt;/code&gt; and &lt;code&gt;cargo&lt;/code&gt;, so you’re going to have a much less awesome experience if you don’t know about it.&lt;/p&gt;
&lt;p&gt;Reason and F&lt;sup&gt;♯&lt;/sup&gt; both have slightly larger negatives.&lt;/p&gt;
&lt;p&gt;Reason requires you to &lt;code&gt;npm install&lt;/code&gt; a large, gzipped file with multiple dependencies all bundled, instead of having a dedicated installer &lt;em&gt;a la&lt;/em&gt; &lt;code&gt;rustup&lt;/code&gt;. It also has the possibility for a not-so-great first-run experience in the editor, which &lt;a href="https://github.com/facebook/reason/issues/1729"&gt;I discovered&lt;/a&gt; all too quickly.&lt;/p&gt;
&lt;p&gt;F&lt;sup&gt;♯&lt;/sup&gt; essentially requires you to use an editor extension to get the language setup with &lt;a href="https://fsprojects.github.io/Paket/"&gt;Paket&lt;/a&gt;, which is a &lt;em&gt;much&lt;/em&gt; better choice of package manager than the default .NET package manager NuGet. Command line tools exist and are improving rapidly, and you &lt;em&gt;can&lt;/em&gt; &lt;a href="https://fsprojects.github.io/Paket/paket-and-dotnet-cli.html"&gt;get them working&lt;/a&gt;… but it’s harder than it needs to be. And that project setup wizard is &lt;em&gt;fine&lt;/em&gt;, but it’s a lot noisier than just doing &lt;code&gt;create-elm-app&lt;/code&gt; or especially &lt;code&gt;cargo new&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In any case, though, I have them all up and running now! More soon!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re uncomfortable with running that script, there are &lt;a href="https://www.rust-lang.org/en-US/other-installers.html"&gt;other options&lt;/a&gt; as well.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Note that the VS Code extension is &lt;em&gt;not&lt;/em&gt; the best experience out there for Elm: the Atom extensions (&lt;a href="https://atom.io/packages/language-elm"&gt;language-elm&lt;/a&gt; and &lt;a href="https://atom.io/packages/elmjutsu"&gt;elmjutsu&lt;/a&gt;) are. I stuck with VS Code because it’s &lt;em&gt;good enough&lt;/em&gt; and, more importantly, the Code extensions are arguably best in class for the &lt;em&gt;other&lt;/em&gt; languages… and it’s what I use every day.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;I’m not just saying that because I’m a Rust fanboy, either! If Rust were hard to use, I’d be complaining &lt;em&gt;louder&lt;/em&gt; because of my enthusiasm for the language.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 01 Jan 2018 13:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-01:/2018/exploring-4-languages-project-setup.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>Exploring 4 Languages</title><link>http://www.chriskrycho.com/2017/exploring-4-languages.html</link><description>&lt;p&gt;Today, as I hit the first of the implementation chapters in &lt;a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional"&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt;&lt;/a&gt;, I started thinking about how I wanted to implement it. As I’ve noted &lt;a href="https://twitter.com/chriskrycho/status/934170826718429184"&gt;elsewhere&lt;/a&gt; in the past, very little of the book is &lt;em&gt;truly&lt;/em&gt; specific to F&lt;sup&gt;♯&lt;/sup&gt;, though that’s the language Wlaschin uses in the book—and Wlaschin himself &lt;a href="https://twitter.com/ScottWlaschin/status/934177554331848705"&gt;agrees&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks! Yes, it’s true that you could easily use #ElmLang, #RustLang, #Scala, or especially #OCaml to work through the book. I use hardly any F# specific features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So… I decided to try something a little bit bonkers. I’m going to implement these exercises in &lt;em&gt;four different languages&lt;/em&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://fsharp.org"&gt;F&lt;sup&gt;♯&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reasonml.github.io"&gt;ReasonML&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are all related: they’re descended from &lt;a href="http://smlnj.org/sml.html"&gt;Standard ML&lt;/a&gt;. ReasonML and F&lt;sup&gt;♯&lt;/sup&gt; are like siblings: Reason is merely a custom syntax for OCaml; F&lt;sup&gt;♯&lt;/sup&gt; is (originally) an implementation of OCaml on .NET (though the two languages have diverged since F&lt;sup&gt;♯&lt;/sup&gt; came into existence). Elm and Rust are cousins of each other and of Reason and F&lt;sup&gt;♯&lt;/sup&gt;, though they’re both drawing on other languages besides OCaml as well. I also have some familiarity with Rust, Elm, and F&lt;sup&gt;♯&lt;/sup&gt; already, and have read the docs for Reason a couple times. So this is a &lt;em&gt;bit&lt;/em&gt; less crazy than it might otherwise be.&lt;/p&gt;
&lt;p&gt;Why, though? Mostly because I think it’ll be interesting to compare the implementations of the domain model from the book side by side. It’ll look just a bit different in each language, and I expect to learn a bit more of the &lt;em&gt;feel&lt;/em&gt; of each language by doing this. (That side by side comparison is something I’ve &lt;a href="http://www.chriskrycho.com/rust-and-swift.html" title="Series: Rust and Swift"&gt;done before&lt;/a&gt; and &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html" title="Part V: The value (and challenge) of learning languages in parallel."&gt;found very profitable&lt;/a&gt;.) I’ll also turn it into blog posts, which hopefully will be interesting to others!&lt;/p&gt;
&lt;p&gt;More to come, and soon.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 31 Dec 2017 20:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-31:/2017/exploring-4-languages.html</guid><category>functional programming</category><category>rust</category><category>elm</category><category>fsharp</category><category>reasonml</category><category>domain-driven design</category><category>four-languages</category></item><item><title>I Want JSON Decoders</title><link>http://www.chriskrycho.com/2017/i-want-json-decoders.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;This post was originally published at &lt;a href="https://www.dailydrip.com/blog/i-want-json-decoders.html"&gt;DailyDrip.com&lt;/a&gt;. They’re doing really great work over there, so I encourage you to check out their content and consider subscribing!&lt;/i&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;The other day, I got a report about the Ember.js app I’m working on: when a customer applied a coupon in the basket, they’d see an indication that the coupon was applied, but the basket total would still display as if it hadn’t been updated. Orders were &lt;em&gt;placed&lt;/em&gt; correctly, but they wouldn’t render right. I dug around for a bit, and then discovered that it was one of the (many) places where &lt;code&gt;undefined&lt;/code&gt; was biting us.&lt;/p&gt;
&lt;p&gt;How did this happen? It turned out it was a perfect storm: a confusingly-designed &lt;abbr&gt;API&lt;/abbr&gt; combined with a reasonable (but in this case, very unhelpful) assumption in our data layer. When the total on a given basket dropped to zero, our &lt;abbr&gt;API&lt;/abbr&gt; simply didn’t send back a value on the payload at all. Instead of &lt;code&gt;{ total: 0, ... }&lt;/code&gt;, there was just, well, &lt;code&gt;{ ... }&lt;/code&gt; – no &lt;code&gt;total&lt;/code&gt; field at all. Meanwhile, our data layer was designed to let a server send back only the fields which &lt;em&gt;required&lt;/em&gt; updating. That way, you can send back partial records to indicate only what has changed, instead of having to send back the whole of what might be a very large record, or a very large collection of records.&lt;/p&gt;
&lt;p&gt;The combination was terrible, though: because the server didn’t send back the &lt;code&gt;total&lt;/code&gt; field at all when it dropped to &lt;code&gt;0&lt;/code&gt;, the client never updated the total it displayed to the user: as far as it was concerned, the server was saying “no change here!”&lt;/p&gt;
&lt;p&gt;The first and most obvious solution here, of course, is the one we implemented: we had the &lt;abbr&gt;API&lt;/abbr&gt; always send back a value, even if that value was &lt;code&gt;0&lt;/code&gt;. But it seems like there should be a better way.&lt;/p&gt;
&lt;p&gt;Lots of languages have fairly nice facilities for parsing JavaScript. Several languages even have tools for automatically constructing local, strongly-typed data structures from the structure of a &lt;abbr&gt;JSON&lt;/abbr&gt; response on an &lt;abbr&gt;API&lt;/abbr&gt;. F♯’s &lt;a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/"&gt;type providers&lt;/a&gt; are like this and &lt;em&gt;really fancy&lt;/em&gt; in the way they’ll automatically derive the type for you so you don’t even have to write it out as you would in everything from Haskell to C#. But for the most part in JavaScript, you have at most a way to map data to a local record in your data store – certainly none of those type safe guarantees. In TypeScript, you can write the types you receive out carefully – though, as I discovered in this case, probably not carefully &lt;em&gt;enough&lt;/em&gt; unless you model &lt;em&gt;everything&lt;/em&gt; as an optional field, and then you’re back to checking for &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; everywhere, and &lt;em&gt;why isn’t this already a solved problem?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;And it turns out, it &lt;em&gt;is&lt;/em&gt; a solved problem – or at least, it is in Elm, &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;via&lt;/a&gt; those &lt;a href="https://guide.elm-lang.org/interop/json.html"&gt;&lt;abbr&gt;JSON&lt;/abbr&gt; Decoders&lt;/a&gt;. I don’t get to write Elm at work right now (or any time in the foreseeable future) – but if I can’t write Elm, I can at least try to steal a bunch of its great ideas and push them back into my TypeScript.&lt;/p&gt;
&lt;p&gt;So… what exactly are &lt;abbr&gt;JSON&lt;/abbr&gt; Decoders and how would they have solved this problem? (And why, if you’re already familiar a little with Elm and possibly feeling frustrated with decoding, are they actually worth it?)&lt;/p&gt;
&lt;p&gt;A &lt;abbr&gt;JSON&lt;/abbr&gt; Decoder is just a way of guaranteeing that once you’re inside the boundary of your program, you &lt;em&gt;always&lt;/em&gt; have a valid instance of the data type you’ve decoded it into, &lt;em&gt;or&lt;/em&gt; an error which tells you why you &lt;em&gt;don’t&lt;/em&gt; have a valid instance of the data. They’re composable, so you can stack them together and take smaller decoders to build bigger ones, so if you have a complex &lt;abbr&gt;JSON&lt;/abbr&gt; structure, you can define repeated substructures in it, or decoders for dissimilar sibling items in it, and use them to put together a grand decoder for your whole final structure. The decoders use the &lt;a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result"&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, and they hand back either &lt;code&gt;Ok&lt;/code&gt; with the decoded value or &lt;code&gt;Err&lt;/code&gt; with the reason for the failure – and if &lt;em&gt;any&lt;/em&gt; piece of a decoded type doesn’t match with what you’ve specified, you’ll end up with an &lt;code&gt;Err&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, initially that might sound like a recipe for disaster – &lt;abbr&gt;JSON&lt;/abbr&gt; payloads can be formed in weird ways all the time! – but in fact it encourages you to think through the various ways your payloads can be formed and to account for them. &lt;em&gt;Sometimes&lt;/em&gt;, if the payload doesn’t have what you expect, that really does mean something is wrong either in your request or in the server-side implementation. In that case, getting an &lt;code&gt;Err&lt;/code&gt; is &lt;em&gt;exactly&lt;/em&gt; what you want. Other times, the server might be perfectly legitimate in sending back a variety of shapes in its response, and your responsibility is to decide how to decode it to make sense in your app. Remember, the problem I had was that I received a payload which didn’t have the data. With Elm’s decoders, I would have had three choices:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;I could have treated this as an error, and passed that along to be dealt with in some way.&lt;/li&gt;
&lt;li&gt;I could have normalized it as a 0-value payload.&lt;/li&gt;
&lt;li&gt;I could have treated it &lt;em&gt;explicitly&lt;/em&gt; as a no-op, maintaining whatever previous state I had in the data store, i.e. the implicit behavior of my actual data store.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What I &lt;em&gt;couldn’t&lt;/em&gt; do, though, is do any one of those &lt;em&gt;accidentally&lt;/em&gt;. I could still support incomplete payloads (via option 3), but I’d be explicitly opting into that, and there would be an obvious place where that was the case. This would be particularly helpful in a scenario where I wasn’t also in charge of the &lt;abbr&gt;API&lt;/abbr&gt;: if I couldn’t just go change it so the &lt;abbr&gt;API&lt;/abbr&gt; itself had a more sensible behavior, I could enforce whichever desired behavior on my own end. More than that, with something modeled on the Elm &lt;abbr&gt;JSON&lt;/abbr&gt; Decoders, I would &lt;em&gt;have&lt;/em&gt; to: there would be no implicit consumption of raw &lt;abbr&gt;JSON&lt;/abbr&gt;.&lt;/p&gt;
&lt;p&gt;The first time I played with the Elm &lt;abbr&gt;JSON&lt;/abbr&gt; Decoder approach, I thought it was a lot of work. I was used to just doing &lt;code&gt;JSON.parse()&lt;/code&gt; in JS or &lt;code&gt;json.loads()&lt;/code&gt; in Python. Now I needed to define a whole series of decode steps explicitly for every field in a response? Good grief! But it grew on me. More than that, I now actively miss it in my apps; I’d have been really happy not to have to spend a morning hunting down this particular bug.&lt;/p&gt;
&lt;p&gt;Sometimes that explicitness can seem like quite a lot of boilerplate, and indeed it is: there’s a reason the Elm &lt;a href="https://github.com/NoRedInk/elm-decode-pipeline"&gt;elm-decode-pipeline&lt;/a&gt; project exists. But even given the &lt;em&gt;initial&lt;/em&gt; nicety of something like F♯ type providers, I think the Elm approach has a slight edge in the long-term for &lt;em&gt;maintainability&lt;/em&gt; specifically. It’s one thing to be able to just get to work right away and have a type definition you know to conform to a given &lt;abbr&gt;API&lt;/abbr&gt; response. It’s something else entirely to be able to &lt;em&gt;know&lt;/em&gt; that you’ve accounted for all the varieties of responses you might get (and without throwing an exception for failed &lt;abbr&gt;JSON&lt;/abbr&gt; decoding at that!).&lt;/p&gt;
&lt;p&gt;Given all of this, I’ve started mentally teasing out what such a &lt;abbr&gt;JSON&lt;/abbr&gt; decoding library for Ember.js might look like in TypeScript. It’s a long way off, but it’s the kind of thing that I &lt;em&gt;really&lt;/em&gt; want to experiment with, and that I think would make for a big win for the maintainability of our apps. Keep your eyes peeled, because I suspect this is another thing JS will steal from Elm, and that’s &lt;em&gt;great&lt;/em&gt; in my book.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 25 Dec 2017 19:20:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-12-25:/2017/i-want-json-decoders.html</guid><category>JavaScript</category><category>Elm</category><category>TypeScript</category><category>web development</category><category>software development</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we’re both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I’ll be reusing some of this material as the basis of an internal tech talk I’m giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s not tied to JS directly, which means it’s free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That’s the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it’s… still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript’s is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; – not mostly sure, 100% sure – that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say “by design,” I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of “soundness holes” in the type system—there’s still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS… but not none. (That’s even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It’s just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean—&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that’s no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I’d summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item></channel></rss>