<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - programming languages</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Sun, 13 May 2018 11:00:00 -0400</lastBuildDate><item><title>Aesthetics and Programming Languages</title><link>http://www.chriskrycho.com/2018/aesthetics-and-programming-languages.html</link><description>&lt;p&gt;My distaste for the aesthetics of C&lt;sup&gt;♯&lt;/sup&gt; are fairly well known to people I talk to about programming languages—perhaps equally as well known as my love of Rust. So much so that both are running jokes among some of my colleagues and friends. My hypersensitivity to aesthetics both in general and also specifically in programming languages and work environment is &lt;em&gt;also&lt;/em&gt; so well-known as to be a gag.&lt;/p&gt;
&lt;p&gt;But I was writing a bunch of Rust this weekend, and looking at it and thinking about it and wondering why it is that C&lt;sup&gt;♯&lt;/sup&gt; drives me so up the wall aesthetically and experientially, while Rust doesn’t. On the surface, they don’t actually look all that different.&lt;/p&gt;
&lt;p&gt;Here’s &lt;em&gt;roughly&lt;/em&gt; equivalent code in each:&lt;/p&gt;
&lt;pre class="cs"&gt;&lt;code&gt;public class Person {
    public string Name { get; set; } = &amp;quot;Chris&amp;quot;;

    public void greet() {
        Console.WriteLine($&amp;quot;Hello, {Name}&amp;quot;);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Person {
    name: String,
}

impl Person {
    pub fn new() -&amp;gt; Person {
        Person { name: String::from(&amp;quot;Chris&amp;quot;) }
    }

    pub fn greet(&amp;amp;self) {
        println!(&amp;quot;Hello, {}&amp;quot;, self.name);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you start tossing in generics and lifetimes, Rust can actually end up looking a &lt;em&gt;lot&lt;/em&gt; messier than C&lt;sup&gt;♯&lt;/sup&gt;.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;impl&amp;lt;&amp;#39;a, &amp;#39;b, T, U&amp;gt; SomeTrait&amp;lt;&amp;#39;a, U&amp;gt; for SomeType&amp;lt;&amp;#39;b, U&amp;gt;
where
    T: SomeOtherTrait + YetAnotherTrait,
    U: OhWowSoManyTraits
{
    fn some_trait_method(&amp;amp;self) {
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing about that is what I would call aesthetically beautiful in a general sense! There’s a &lt;em&gt;lot&lt;/em&gt; of syntax.&lt;/p&gt;
&lt;p&gt;What I’ve concluded so far, though, is that my difference in feelings comes down to the way that syntax maps back to the underlying semantics, and my feelings about those underlying semantics. The basic language design approach C&lt;sup&gt;♯&lt;/sup&gt; takes—i.e. everything is a class; mutation is both encouraged and implicit; don’t bother with value types—drives me batty. I don’t love the syntax, not least because it ends up being &lt;em&gt;so&lt;/em&gt; verbose and noisy (you can express the same things in F&lt;sup&gt;♯&lt;/sup&gt; much more briefly)—but also because I actively dislike the programming models it encourages (I don’t like the C&lt;sup&gt;♯&lt;/sup&gt; programming model when I see in in F&lt;sup&gt;♯&lt;/sup&gt; either!).&lt;/p&gt;
&lt;p&gt;Rust, by contrast, matches the way I &lt;em&gt;do&lt;/em&gt; and &lt;em&gt;want to&lt;/em&gt; think about the world. Mutability is allowed but neither actively encouraged nor actively discouraged; more to the point it’s &lt;em&gt;explicit&lt;/em&gt;. Insofar as “shared mutable state is the root of all evil,” Rust has two legs up on C&lt;sup&gt;♯&lt;/sup&gt;: it (a) doesn’t &lt;em&gt;allow&lt;/em&gt; shared mutable state and (b) makes explicit where mutation &lt;em&gt;is&lt;/em&gt; happening. It also separates data from behavior. It also has real value types. It also has sum types and pattern matching. In both cases, a lot of the syntactical noise is inessential, a holdover from the legacy of C; but in Rust’s case the way it maps onto a &lt;em&gt;programming model&lt;/em&gt; that is more like OCaml than like C decreases the pain I feel from that noise.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;could&lt;/em&gt; be taken to validate the idea that syntax doesn’t matter, that the underlying semantics are everything, but that’s not the case. It’s not that I &lt;em&gt;love&lt;/em&gt; Rust’s syntax. It’s that, although I dislike it at times, it doesn’t rise to the level of frustration I feel in C&lt;sup&gt;♯&lt;/sup&gt; because it’s not coupled to a programming model that I loathe. The syntax matters; it’s just not the &lt;em&gt;only&lt;/em&gt; thing that matters.&lt;/p&gt;
&lt;p&gt;An interesting thing to consider: what Rust would look like in a world where it embraced its OCaml roots. (I don’t think Rust should have done this; spending its complexity budget on ideas instead of syntax was the right choice. But it’s still interesting.) The simplest level of translation might look something (very) roughly like this:&lt;/p&gt;
&lt;pre class="haskell"&gt;&lt;code&gt;impl &amp;#39;a &amp;#39;b T U SomeTrait &amp;#39;a T for SomeType &amp;#39;b U
  where T : SomeOtherTrait + YetAnotherTrait

  some_trait_method :: &amp;amp;self -&amp;gt; void
  some_trait_method self =
    -- ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is obviously still a lot of syntax, but it’s all basically necessary given the things Rust is trying to express with lifetimes, ownership, etc.—and I did this off the top of my head with literally &lt;em&gt;no&lt;/em&gt; consideration other than “what’s the most direct translation into roughly Haskell-ish syntax I can write?” It makes me genuinely curious where a language that aimed for Rust’s same kinds of guarantees but actively embracing the ML/Haskell family’s syntax might end up. I have a guess that I’d like it even better than I do Rust.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 13 May 2018 11:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-05-13:/2018/aesthetics-and-programming-languages.html</guid><category>csharp</category><category>rust</category><category>programming languages</category></item><item><title>Announcing True Myth 1.0</title><link>http://www.chriskrycho.com/2017/announcing-true-myth-10.html</link><description>&lt;p&gt;I’m pleased to announce the release of &lt;a href="https://github.com/chriskrycho/true-myth"&gt;True Myth 1.0&lt;/a&gt;! True Myth is a library I’ve been working on over the last month or so, for saner programming in JavaScript, with first-class support for TypeScript (and Flow).&lt;/p&gt;
&lt;p&gt;True Myth provides standard, type-safe wrappers and helper functions to help you with two &lt;em&gt;extremely&lt;/em&gt; common cases in programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;not having a value—which it solves with a &lt;code&gt;Maybe&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;li&gt;having a &lt;em&gt;result&lt;/em&gt; where you need to deal with either success or failure—which it solves with a &lt;code&gt;Result&lt;/code&gt; type and associated helper functions and methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You could implement all of these yourself – it’s not hard! – but it’s much easier to just have one extremely well-tested library you can use everywhere to solve this problem once and for all.&lt;/p&gt;
&lt;p&gt;Even better to get one of these with no runtime overhead for using it other than the very small cost of some little container objects—which we get by leaning hard on the type systems in TypeScript or Flow!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;/strong&gt; If you’re familiar with &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; or &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, this has a lot in common with them—its main differences are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;True Myth has a much smaller API surface than they do&lt;/li&gt;
&lt;li&gt;True Myth aims to be much more approachable for people who aren’t already super familiar with functional programming concepts and jargon&lt;/li&gt;
&lt;li&gt;True Myth does &lt;em&gt;no&lt;/em&gt; runtime checking of your types, whereas both those libraries do by default—it relies on TypeScript or Flow instead&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I really like both of those libraries, though, so you might check them out as well!&lt;/p&gt;
&lt;section id="maybe" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Maybe&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes you don’t have a value. In JavaScript land, we usually represent that with either &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, and then trying to program defensively in the places we &lt;em&gt;think&lt;/em&gt; we might get &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as arguments to our functions. For example, imagine an endpoint which returns a JSON payload shaped like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: &amp;quot;Hello!&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But sometimes it might come over like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{
  &amp;quot;hopefullyAString&amp;quot;: null
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or even like this:&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assume we were doing something simple, like logging the length of whatever string was there or logging a default value if it was absent. In normal JavaScript we’d write something like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function logThatValue(thePayload) {
  const length = !!thePayload.hopefullyAString
    ? thePayload.hopefullyAString.length
    : 0;
  
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn’t a big deal right here… but—and this &lt;em&gt;is&lt;/em&gt; a big deal—we have to remember to do this &lt;em&gt;everywhere&lt;/em&gt; we interact with this payload. &lt;code&gt;hopefullyAString&lt;/code&gt; can &lt;em&gt;always&lt;/em&gt; be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; everywhere we interact with it, anywhere in our program. 😬&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; is our escape hatch. If, instead of just naively interacting with the payload, we do a &lt;em&gt;very small&lt;/em&gt; amount of work up front to normalize the data and use a &lt;code&gt;Maybe&lt;/code&gt; instead of passing around &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; values, we can operate safely on the data throughout our application. If we have something, we get an instance called &lt;code&gt;Just&lt;/code&gt;—as in, “What’s in this field? Just a string” or “Just the string ‘hello’”. If there’s nothing there, we have an instance called &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just&lt;/code&gt; is a wrapper type that holds the actual value in it. &lt;code&gt;Nothing&lt;/code&gt; is a wrapper type which has no value in it. But both of them are concrete types and you’ll never get an &lt;code&gt;undefined is not an object&lt;/code&gt; error when trying to use them!&lt;/p&gt;
&lt;p&gt;Both of them have all the same methods available on them, and the same static functions to work on them. And, importantly, you can do a bunch of neat things with a &lt;code&gt;Maybe&lt;/code&gt; instance without checking whether it’s a &lt;code&gt;Nothing&lt;/code&gt; or a &lt;code&gt;Just&lt;/code&gt;. For example, if you want to double a number if it’s present and do nothing if it isn’t, you can use the &lt;code&gt;Maybe.map&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;
const hereIsANumber = Maybe.just(12);          // Just(12)
const noNumberHere = Maybe.nothing&amp;lt;number&amp;gt;();  // Nothing

const double = (n: number) =&amp;gt; n * 2;
hereIsANumber.map(double);  // Just(24)
noNumberHere.map(double);   // Nothing&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;a href="https://true-myth.js.org/modules/_maybe_.html"&gt;a &lt;em&gt;lot&lt;/em&gt;&lt;/a&gt; of those helper functions and methods! Just about any way you would need to interact with a &lt;code&gt;Maybe&lt;/code&gt; is there.&lt;/p&gt;
&lt;p&gt;So now that we have a little idea what &lt;code&gt;Maybe&lt;/code&gt; is for and how to use it, here’s that same example, but rewritten to normalize the payload using a &lt;code&gt;Maybe&lt;/code&gt; instance. We’re using TypeScript, so we will get a compiler error if we don’t handle any of these cases right—or if we try to use the value at &lt;code&gt;hopefullyAString&lt;/code&gt; directly after we’ve normalized it!&lt;/p&gt;
&lt;p&gt;(Note that &lt;code&gt;Maybe.of&lt;/code&gt; will construct either a &lt;code&gt;Maybe.Just&lt;/code&gt; if the string is present, or &lt;code&gt;Maybe.Nothing&lt;/code&gt; if the value supplied to it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Maybe from &amp;#39;true-myth/maybe&amp;#39;;

type Payload = { hopefullyAString?: string };
type NormalizedPayload = { hopefullyAString: Maybe&amp;lt;string&amp;gt; };

function normalize(payload: Payload): NormalizedPayload {
  return {
    hopefullyAString: Maybe.of(payload.hopefullyAString)
  };
}

function logThatValue(payload: NormalizedPayload) {
  const length = payload.hopefullyAString.mapOr(0, s =&amp;gt; s.length);
  console.log(length);
}

fetch(someUrl)
  .then(response =&amp;gt; response.json())
  .then(normalize)
  .then(logThatValue);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you might be thinking, &lt;em&gt;Sure, but we could get the same effect by just supplying a default value when we deserialize the data.&lt;/em&gt; That’s true, you could! Here, for example, you could just normalize it to an empty string. And of course, if just supplying a default value at the API boundary is the right move, you can still do that. &lt;code&gt;Maybe&lt;/code&gt; is another tool in your toolbox, not something you’re &lt;em&gt;obligated&lt;/em&gt; to use everywhere you can.&lt;/p&gt;
&lt;p&gt;However, sometimes there isn’t a single correct default value to use at the API boundary. You might need to handle that missing data in a variety of ways throughout your application. For example, what if you need to treat “no value” distinctly from “there’s a value present, and it’s an empty string”? &lt;em&gt;That’s&lt;/em&gt; where &lt;code&gt;Maybe&lt;/code&gt; comes in handy.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="result" class="level2"&gt;
&lt;h2&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another common scenario we find ourselves in is dealing with operations which might fail. There are a couple patterns we often use to deal with this: &lt;em&gt;callbacks&lt;/em&gt; and &lt;em&gt;exceptions&lt;/em&gt;. There are major problems with both, especially around reusability and composability.&lt;/p&gt;
&lt;p&gt;The callback pattern (as in e.g. Node) encourages a style where literally every function starts with the exact same code:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function getMeAValue(err, data) {
  if (err) {
    return handleErr(err);
  }
  
  // do whatever the *actual* point of the function is
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two major problems with this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s incredibly repetitive – the very opposite of “Don’t Repeat Yourself”. We wouldn’t do this with &lt;em&gt;anything&lt;/em&gt; else in our codebase!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It puts the error-handling right up front and &lt;em&gt;not in a good way.&lt;/em&gt; While we want to have a failure case in mind when designing the behavior of our functions, it’s not usually the &lt;em&gt;point&lt;/em&gt; of most functions – things like &lt;code&gt;handleErr&lt;/code&gt; in the above example being the exception and not the rule. The actual meat of the function is always after the error handling.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But if we’re not using some similar kind of callback pattern, we usually resort to exceptions. But exceptions are unpredictable: you can’t know whether a given function invocation is going to throw an exception until runtime as someone calling the function. No big deal if it’s a small application and one person wrote all the code, but with even a few thousand lines of code or two developers, it’s very easy to miss that. And then this happens:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;// in one part of the codebase
function getMeAValue(url) {
  if (isMalformed(url)) {
    throw new Error(`The url `${url}` is malformed!`);
  }
  
  // do something else to load data from the URL
  return data;
}

function render(toRender) {
  // if toRender can&amp;#39;t generate valid HTML, throw Error(&amp;quot;invalid HTML&amp;quot;);
  // if it can, theRenderedHTML;
}

function setDom(html) {
  /* magic to render into DOM */
}

// somewhere else in the codebase -- throws an exception
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
const response = getMeAValue(badUrl);  // throws here

// we never get here, but it could throw too
const htmlForPage = render(value);

// so we definitely can&amp;#39;t get here safely
setDom(htmlForPage);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice: there’s no way for the caller to know that the function will throw. Perhaps you’re very disciplined and write good docstrings for every function – &lt;em&gt;and&lt;/em&gt; moreover, perhaps everyone’s editor shows it to them &lt;em&gt;and&lt;/em&gt; they pay attention to that briefly-available popover. More likely, though, this exception throws at runtime and probably as a result of user-entered data – and then you’re chasing down the problem through error logs.&lt;/p&gt;
&lt;p&gt;More, if you &lt;em&gt;do&lt;/em&gt; want to account for the reality that any function anywhere in JavaScript might actually throw, you’re going to write something like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;try {
  const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash
  const response = getMeAValue(badUrl);  // throws here
  
  // we never get here, but it could throw too
  const htmlForPage = render(value);
  
  // so we definitely can&amp;#39;t get here safely
  setDom(htmlForPage);
} catch (e) {
  handleErr(e);  // ends up here
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is like the Node example &lt;em&gt;but even worse&lt;/em&gt; for repetition!&lt;/p&gt;
&lt;p&gt;And TypeScript and Flow can’t help you here! They don’t have type signatures to say “This throws an exception!” (TypeScript’s &lt;code&gt;never&lt;/code&gt; might come to mind, but it might mean lots of things, not just exception-throwing.)&lt;/p&gt;
&lt;p&gt;Instead, we can use a &lt;code&gt;Result&lt;/code&gt; to get us a container type, much like &lt;code&gt;Maybe&lt;/code&gt;, to let us deal with this scenario. A &lt;code&gt;Result&lt;/code&gt; is either an &lt;code&gt;Ok&lt;/code&gt; wrapping around a value (like &lt;code&gt;Just&lt;/code&gt; does) or an &lt;code&gt;Err&lt;/code&gt; wrapping around some type defining what went wrong (&lt;em&gt;not&lt;/em&gt; like &lt;code&gt;Nothing&lt;/code&gt;, which has no contents). Both of them have the same sets of methods on them, and the same static functions which can operate on them.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Result from &amp;#39;true-myth/result&amp;#39;;

type Payload = {/* details of the payload...*/}

function getMeAValue(url: string): Result&amp;lt;Payload, string&amp;gt; {
  if (isMalformed(url)) {
    return Result.err(`The url &amp;#39;${url}&amp;#39; is malformed`);
  }
  
  // do something else to load data from the url
  return Result.ok(data);
}

function render(toRender: string): Result&amp;lt;HTMLElement, string&amp;gt; {
  // if toRender can&amp;#39;t generate valid HTML, return Err(&amp;quot;invalid HTML&amp;quot;);
  // if it can, return Ok(theRenderedHTML);
}

function setDom(html: HTMLElement) {
  
}

// somewhere else in the codebase -- no exception this time!
const badUrl = &amp;#39;http:/www.google.com&amp;#39;;  // missing a slash

// value = Err(The url &amp;#39;${http:/www.google.com}&amp;#39; is malformed)
const value = getMeAValue(badUrl);

// htmlForPage = the same error! or, if it was Ok, could be a different
// `Err` (because of how `andThen` works).
const htmlForPage = value.andThen(render);

// we can&amp;#39;t just invoke `setDom` because it doesn&amp;#39;t take a `Result`.
value.match({
  Ok: html =&amp;gt; setDom(html);
  Err: reason =&amp;gt; alert(`Something went seriously wrong here! ${reason}`);
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we have a &lt;code&gt;Result&lt;/code&gt; instance, we can perform tons of operations on whether it’s &lt;code&gt;Ok&lt;/code&gt; or &lt;code&gt;Err&lt;/code&gt;, just as we could with &lt;code&gt;Maybe.Just&lt;/code&gt; and &lt;code&gt;Maybe.Nothing&lt;/code&gt;, until we &lt;em&gt;need&lt;/em&gt; the value. Maybe that’s right away. Maybe we don’t need it until somewhere else deep in our application! Either way, we can deal with it easily enough, and have type safety throughout!&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Give it a spin!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yarn add true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install true-myth&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You can even just &lt;code&gt;ember install true-myth&lt;/code&gt; and use it if you’re using Ember (in which case I encourage you to also use &lt;a href="https://github.com/typed-ember/ember-cli-typescript"&gt;ember-cli-typescript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let me know what you think – if there’s stuff missing, &lt;a href="https://github.com/chriskrycho/true-myth"&gt;open issues&lt;/a&gt;! And if it’s just not to your taste, again, I encourage you to take a look at &lt;a href="http://folktale.origamitower.com"&gt;Folktale&lt;/a&gt; and &lt;a href="https://sanctuary.js.org"&gt;Sanctuary&lt;/a&gt;, which are both excellent and land in very different design spaces in many ways.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 01 Nov 2017 08:40:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-11-01:/2017/announcing-true-myth-10.html</guid><category>software development</category><category>libraries</category><category>programming languages</category><category>typescript</category><category>functional programming</category></item><item><title>The Book of F♯</title><link>http://www.chriskrycho.com/2017/the-book-of-f.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I keep my book review ratings simple—they’re either &lt;em&gt;required&lt;/em&gt;, &lt;em&gt;recommended&lt;/em&gt;, &lt;em&gt;recommended with qualifications&lt;/em&gt;, or &lt;em&gt;not recommended&lt;/em&gt;. If you want the TL;DR, this is it:&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Recommended With Qualifications:&lt;/strong&gt; This book is just okay, and at this point it’s a bit outdated—but if you’re in its fairly narrow target audience, it’s a decent way to get up to speed on F#.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;The Book of F♯: Breaking Free With Managed Functional Programming&lt;/em&gt; is a No Starch Press publication by Dave Fancher, published in 2014. I read it over the course of the last four or so months, just plugging away in my spare cycles. A couple qualifications on the short list of observations that follow:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;I don’t have any experience whatsoever writing production F♯ (though I have &lt;em&gt;read&lt;/em&gt; a fair bit of it). I am interested because it’s a functional programming language on the .NET stack—which isn’t my own personal favorite stack, but &lt;em&gt;is&lt;/em&gt; the stack at Olo. If we’re going to ship functional code on the server, it’ll be in F♯.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I am also not a C♯ developer. As such, I’m &lt;em&gt;explicitly&lt;/em&gt; not the audience of this book. As Fancher put it in the intro:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I wrote this book for people like me: experienced .NET developers looking to break into functional programming while retaining the safety net of the tools and libraries they’re already using.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The net of that is that a lot of what frustrated me about the book is just a result of my not being the target audience.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Those qualifications aside, some assorted thoughts on the book:&lt;/p&gt;
&lt;p&gt;First, as the intro and my above qualification suggest: this is &lt;em&gt;really&lt;/em&gt; not interesting or useful as a general introduction to F♯. Throughout, it assumes a very high baseline of C♯ knowledge. In fact, the majority of the discussion of F♯, even in the section of the book which turns away from object oriented programming toward functional programming, focuses on comparing F♯ to C♯. This makes sense for the target audience, but this is &lt;em&gt;not&lt;/em&gt; the book for you if you’re not a C♯ developer.&lt;/p&gt;
&lt;p&gt;That said, if you &lt;em&gt;are&lt;/em&gt; a C♯ developer, this could be a useful resource as you’re spinning up. It also might be a useful book to work through with a group of C♯ developers who want to learn F♯. The comparisons &lt;em&gt;do&lt;/em&gt; generally work in F♯’s favor, even when doing exactly what you would be doing in the C♯, which makes it an easier “sell” in that regard.&lt;/p&gt;
&lt;p&gt;Along the same lines, the book is structured as a &lt;em&gt;very gradual&lt;/em&gt; introduction to functional programming ideas. Roughly the first half of the book emphasizes F♯’s object-oriented programming abilities, and only in the second half does Fancher turn to a functional style. Again, this is probably the right move given the audience, but it means the book spends a &lt;em&gt;lot&lt;/em&gt; of time on kinds of F♯ you won’t actually be writing very often once you’re going. Idiomatic F♯ isn’t object-oriented. But as a way of helping someone make the transition, it’s not a bad plan: object-oriented F♯ is briefer and nicer in many ways than the exact same code in C♯. It meant that the first half of the book was completely uninteresting to &lt;em&gt;me&lt;/em&gt;, though: I don’t want to write a line of object-oriented F♯.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All of this had a pretty serious downside even for existing C♯ developers, though: the book often ends up seeming like it’s sort of apologizing for or defending F♯ against an expected audience of people asking “What’s wrong with C♯?” And even though there’s a real sense in which that’s true—that &lt;em&gt;is&lt;/em&gt; what a lot of the audience is asking, no doubt—it became quite annoying rhetorically.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; It’s also unnecessary: if someone is picking up a book on F♯, you can assume that they’re alredy at least a little interested in the language and what it might offer! Along those lines, I much prefer the tack taken in what I’ve seen of Scott Wlaschin’s upcoming &lt;em&gt;Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F♯&lt;/em&gt; (The Pragmatic Bookshelf, expected in fall 2017)—which shows not how to do the same things as in C♯, just more briefly; but how to solve the same problems much more effectively.&lt;/p&gt;
&lt;p&gt;Those problems aside, the book was… &lt;em&gt;fine&lt;/em&gt;. I wouldn’t call it scintillating reading, but this kind of technical writing, especially at this length, is really hard work. Credit to Fancher for managing an introduction to an entire programming language in a relatively approachable way, and credit to him and his editors for making sure it remains lucid throughout. Still: I’d love to see the bar for programming books be higher. We need more books which are genuinely engaging in the world of programming language texts. These things are &lt;em&gt;interesting&lt;/em&gt;; we don’t have to make them dry and dull! (And if you want a pretty good example of that: everything I’ve read of Edwin Brady’s &lt;em&gt;Type-Driven Development with Idris&lt;/em&gt; hits the mark.)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;A few other observations about the language itself from reading the book.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First,&lt;/strong&gt; reading this highlighted a lot of strange things about F♯, all of which ultimately come down to the ways F♯’s development has been driven by concerns for interoperability with C♯. Worse, there are a lot of places where the influence of C♯ casts this shadow &lt;em&gt;entirely unnecessarily&lt;/em&gt;. One particular expression of this which drove me crazy: F♯ far too often uses exceptions instead of &lt;code&gt;Option&lt;/code&gt;s. It’s &lt;a href="http://www.chriskrycho.com/2017/better-off-using-exceptions.html"&gt;one thing&lt;/a&gt; to make sure the language gracefully handle exceptions: you &lt;em&gt;will&lt;/em&gt; have them coming from outside contexts. It is another entirely to design core parts of the language to throw exceptions where it doesn’t have to.&lt;/p&gt;
&lt;p&gt;Perhaps the most prominent example is the &lt;code&gt;List.head&lt;/code&gt; function. Its type signature is &lt;code&gt;'T list -&amp;gt; 'T&lt;/code&gt;, where I would expect it to be &lt;code&gt;'T list -&amp;gt; 'T option&lt;/code&gt;. If you call &lt;code&gt;List.head&lt;/code&gt; on an empty list, you get an exception. It would make far more sense for it to return an &lt;code&gt;Option&lt;/code&gt; and just give you &lt;code&gt;None&lt;/code&gt; if there’s no item. Then you’re not worried about &lt;code&gt;try&lt;/code&gt; expressions and the type system will actually help you! This is one of the most valuable parts of having a type system like F♯’s! I really don’t understand a lot of these decisions, not least since this isn’t for interop with C♯ collections—these are for native F♯ collections.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second,&lt;/strong&gt; the use of things like computation expressions instead of type machinery has an interesting effect: it makes it simpler to read when you first encounter it, but harder to compose, build, etc.—and it’s more syntax to remember. Computation expressions just end up being a way to do “monadic” transformations, from what I can tell. But as I noted often in my discussion of &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;Rust and Swift&lt;/a&gt;, I profoundly prefer approaches that build on the same existing machinery—even in the surface syntax of the language—rather than constantly building new machinery. It makes it easier to deeply internalize new concepts and to &lt;em&gt;understand&lt;/em&gt; the language (rather than just being able to &lt;em&gt;use&lt;/em&gt;) the language. It also seems (from my admittedly limited vantage point) that computation expressions are as a result much less &lt;em&gt;composable&lt;/em&gt; than actual type machinery of the sort available in other languages (Haskell, Idris, etc.).&lt;/p&gt;
&lt;p&gt;Now, the tradeoff there is that adding those adds a lot of complexity both to the compiler and to the libraries people are apt to write; there’s a reason Elm has totally eschewed that kind of type machinery to date. But Elm has also refused to just add syntax around ideas like this the way F♯ has here, and it makes for a much cleaner and frankly &lt;em&gt;nicer&lt;/em&gt; language.&lt;/p&gt;
&lt;p&gt;And that brings me to my &lt;strong&gt;third and final&lt;/strong&gt; point: I’m really glad F♯ exists, and that it’s providing a pretty good experience of functional programming on the &lt;abbr title='Common Language Runtime'&gt;CLR&lt;/abbr&gt;. But—and I fully grant that a fair bit of this kind of thing is almost entirely subjective—it doesn’t &lt;em&gt;feel&lt;/em&gt; good in the same way that Elm or Rust do. There is something very difficult to nail down here, but I get a vsiceral experience of joy when writing some languages and not others. Again: that will vary person to person, but I think there are things that make it more or less likely. Things that make it more likely, at least for me, include everything from self-consistency and predictability at the semantic level to the way the code lays out and flows at the visual/syntactical level.&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; Sadly, F♯ just doesn’t hit the right notes&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; for me. I’ll be much, much happier to write it than C♯ at work… but I really just want Elm and Rust and Idris to come save the day.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I am of course writing a &lt;em&gt;lot&lt;/em&gt; of functional code in our JavaScript; JavaScript is a surprisingly good language for it.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;It’s not that OOP is &lt;em&gt;bad&lt;/em&gt;, exactly; it’s just that what passes for OOP in languages like C♯, Java, and yes, F♯, is relatively low utility to me—and I think OOP ideas are much more interesting and useful when applied at a systems level, e.g. in an Actor system, than at the level of individual “actors” within the system. Compare Erlang/Elixir: functional components, organized in what is arguably an &lt;em&gt;incredibly&lt;/em&gt; object-oriented way.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;The temptation extends beyond this book; O’Reilly’s &lt;em&gt;Programming Rust&lt;/em&gt; (Jim Blandy and Jason Orendorff) reads as the same kind of defensive introduction to Rust for C++ developers.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;And yes, nerds, syntax &lt;em&gt;does&lt;/em&gt; matter. Try reading this sentence, nicely punctuated, and with spaces and capitalization. Now: tryreadingthissentencewithoutpunctuationorspacesorcapitalization. There may be a point after which it becomes less important, and a range of things which are equally good in an absolute sense, but it matters.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Pun not intended, but inevitable given the language names here.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 21 Jul 2017 19:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-21:/2017/the-book-of-f.html</guid><category>book-reviews</category><category>programming languages</category><category>fsharp</category><category>writing</category><category>pedagogy</category></item><item><title>Why Elm Instead of TypeScript?</title><link>http://www.chriskrycho.com/2017/why-elm-instead-of-typescript.html</link><description>&lt;p&gt;A few weeks ago, an acquaintance asked in a Slack channel we’re both in:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Can I ask a noob type Elm / JS question?&lt;/p&gt;
&lt;p&gt;Why Elm instead of Typescript? The dev stack and functional programming?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I responded as follows, with only light tweaks to clarify a couple things (and I’ll be reusing some of this material as the basis of an internal tech talk I’m giving on the same subject at Olo in a few weeks):&lt;/p&gt;
&lt;p&gt;A couple things Elm gives you:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;It’s not tied to JS directly, which means it’s free to just do what is the best fit for the language rather than needing to be able to express all the quirks and oddities of JS. That’s the single biggest thing I find all the time with TS (which I use every day and do quite like): as good as it is, and as both powerful and expressive as its type system is, at the end of the day it’s… still a superset of JavaScript, and that can mean some really nice things, but it also means a lot of &lt;em&gt;weird&lt;/em&gt; things.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s type system is &lt;em&gt;sound&lt;/em&gt;; TypeScript’s is not. At a practical level, that means that if an Elm program type-checks (and thus compiles), you can be &lt;em&gt;sure&lt;/em&gt; – not mostly sure, 100% sure – that it is free of things like &lt;code&gt;undefined is not a function&lt;/code&gt;. TypeScript does not (and by design cannot) give you that guarantee. And when I say “by design,” I mean that its designers believed from the outset that soundness was in tension with developer productivity, so they intentionally left a number of “soundness holes” in the type system—there’s still a lot of opportunity for &lt;code&gt;undefined is not a function&lt;/code&gt;, sad to say. You can make it &lt;em&gt;less&lt;/em&gt; than in JS… but not none. (That’s even still true in the TypeScript 2.x series, though the various soundness flags they added in 2.0 and the &lt;code&gt;--strict&lt;/code&gt; option &lt;a href="https://blogs.msdn.microsoft.com/typescript/2017/04/10/announcing-typescript-2-3-rc/"&gt;coming in 2.3&lt;/a&gt; do get you closer.) In Elm, you can make it truly &lt;em&gt;none&lt;/em&gt;. It’s just a sort of known fact at this point that Elm codebases tend to &lt;em&gt;have zero runtime errors&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm’s language design is a huge win.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Elm is a &lt;em&gt;pure functional language&lt;/em&gt;. Because non-pure things are offloaded to the Elm runtime, every single function &lt;em&gt;you&lt;/em&gt; write is pure. Same input means the same output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elm supports first-class currying and partial application. This makes it much, much easier to do the kind of functional-building-block approach that is natural in FP and which is &lt;em&gt;attractive&lt;/em&gt; in (but a lot more work in) JS or TS. Example code to show what I mean—&lt;/p&gt;
&lt;p&gt;Javascript:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const add = (a, b) =&amp;gt; a + b;
const add2 = (c) =&amp;gt; add(2, c);
const five = add2(3);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Elm:&lt;/p&gt;
&lt;pre class="elm"&gt;&lt;code&gt;add a b = a + b
add2 = add 2
five = add2 3&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The combination of the above means that you can refactor and &lt;em&gt;always be sure you get everything&lt;/em&gt;, which is truly magical. And the compiler errors are the best in the world (and that’s no exaggeration).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The way I’d summarize it is to say that Elm makes it easy to do the right thing and hard or impossible to do the wrong thing. TypeScript makes it possible to do the right thing, and gives you a couple switches you can flip to make it harder to do the wrong things, but will ultimately let you do anything.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 23 Apr 2017 17:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-04-23:/2017/why-elm-instead-of-typescript.html</guid><category>Elm</category><category>JavaScript</category><category>TypeScript</category><category>programming languages</category><category>functional programming</category></item><item><title>Differences of Opinion</title><link>http://www.chriskrycho.com/2017/differences-of-opinion.html</link><description>&lt;p&gt;I could not possibly agree more with &lt;a href="http://www.pyret.org/pyret-code/"&gt;this view of teaching software/CS&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We are focused on introductory programming education at a high-school and collegiate level — what is often called “CS 1” and “CS 2” (roughly, the first year of college). Pyret is being actively used in everything from high-schools to upper-level collegiate courses, giving us a tight feedback loop.&lt;/p&gt;
&lt;p&gt;Of course, even in that setting there are differences of opinion about what needs to be taught. Some believe inheritance is so important it should be taught early in the first semester. We utterly reject this belief (as someone once wisely said, “object-oriented programming does not scale down”: what is the point of teaching classes and inheritance when students have not yet done anything interesting enough to encapsulate or inherit from?). Some have gone so far as to start teaching with Turing Machines. Unsurprisingly, we reject this view as well.&lt;/p&gt;
&lt;p&gt;What we do not take a dogmatic stance on is exactly how early state and types should be introduced. Pyret has the usual stateful operations. We discussed this at some length, but eventually decided an introduction to programming must teach state. Pyret also has optional annotations, so different instructors can, depending on their preference, introduce types at different times.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I’m &lt;em&gt;delighted&lt;/em&gt; to see work on languages like Dr. Racket and Pyret, and the more so because the teams behind both have been willing to set aside many of the dogmas of how CS has been taught and actually do &lt;em&gt;pedagogical research&lt;/em&gt;. Also: OOP is a useful tool, but I’m with them: treating inheritance as a first-semester concept is… nutty.&lt;/p&gt;
&lt;p&gt;The whole &lt;a href="http://www.pyret.org/pyret-code/"&gt;“Why Pyret?”&lt;/a&gt; page is worth reading if you have any interest in programming languages or teaching software development and computer science.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 12 Mar 2017 08:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-03-12:/2017/differences-of-opinion.html</guid><category>programming languages</category><category>software development</category><category>pedagogy</category><category>links</category></item><item><title>TypeScript keyof Follow-Up</title><link>http://www.chriskrycho.com/2017/typescript-keyof-follow-up.html</link><description>&lt;p&gt;I recently wrote up some neat things you can do with &lt;a href="http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html"&gt;&lt;code&gt;keyof&lt;/code&gt; and mapped types&lt;/a&gt; in TypeScript 2.1. In playing further with those bits, I ran into some interesting variations on the approach I outlined there, so here we are.&lt;/p&gt;
&lt;p&gt;In the previous post, I concluded with an example that looked like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};

type State
  = &amp;#39;Pending&amp;#39;
  | &amp;#39;Started&amp;#39;
  | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That &lt;code&gt;UnionKeyToValue&amp;lt;State&amp;gt;&lt;/code&gt; type constraint requires us to fill out the &lt;code&gt;STATE&lt;/code&gt; object as expected. The whole point of this exercise was to give us the benefit of code completion with that STATE type so we could use it and not be worried about the kinds of typos that too-often bite us with stringly-typed arguments in JavaScript.&lt;/p&gt;
&lt;p&gt;It turns out we don’t &lt;em&gt;need&lt;/em&gt; that to get completion, though. All editors which use the TypeScript language service will give us the same degree of completion if we start typing a string and then trigger completion:&lt;/p&gt;
&lt;figure&gt;
&lt;img src="http://cdn.chriskrycho.com/images/more-ts.gif" title="screen capture of string completion in VS Code" alt="string completion with TypeScript 2.1" /&gt;&lt;figcaption&gt;string completion with TypeScript 2.1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Granted that you have to know this is a string (though the JetBrains &lt;abbr title="integrated development environment"&gt;IDE&lt;/abbr&gt;s will actually go a step further and suggest the right thing &lt;em&gt;without&lt;/em&gt; needing the string key). But that’s roughly equivalent to knowing you need to import the object literal constant to get the completion that way. Six one, half dozen the other, I think.&lt;/p&gt;
&lt;p&gt;This makes it something of a wash with the original approach, as long as you’re dealing in a pure-TypeScript environment. The big advantage that the original approach still has, of course, is that it also plays nicely with a mixed TypeScript and JavaScript environment. If you’re just progressively adding TypeScript to an existing JavaScript codebase, that’s possibly reason enough to stick with it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: an additional reason to prefer my original solution:&lt;/p&gt;
&lt;blockquote class="twitter-tweet" data-lang="en"&gt;
&lt;p lang="en" dir="ltr"&gt;
&lt;a href="https://twitter.com/chriskrycho"&gt;@chriskrycho&lt;/a&gt; &lt;a href="https://twitter.com/typescriptlang"&gt;@typescriptlang&lt;/a&gt; I think a benefit of your previous solution is that you can rename keys and all their usages.
&lt;/p&gt;
— Timm (@timmpreetz) &lt;a href="https://twitter.com/timmpreetz/status/816672215924097024"&gt;January 4, 2017&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 03 Jan 2017 20:35:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-01-03:/2017/typescript-keyof-follow-up.html</guid><category>programming languages</category><category>software development</category><category>typescript</category><category>javascript</category></item><item><title>keyof and Mapped Types In TypeScript 2.1</title><link>http://www.chriskrycho.com/2016/keyof-and-mapped-types-in-typescript-21.html</link><description>&lt;p&gt;In the last few months, I’ve been playing with both &lt;a href="https://flowtype.org"&gt;Flow&lt;/a&gt; and &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; as tools for increasing the quality and reliability of the JavaScript I write at Olo. Both of these are syntax that sits on top of normal JavaScript to add type analysis—basically, a form of &lt;a href="https://en.wikipedia.org/wiki/Gradual_typing"&gt;gradual typing&lt;/a&gt; for JS.&lt;/p&gt;
&lt;p&gt;Although TypeScript’s tooling has been better all along&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I initially preferred Flow’s type system quite a bit: it has historically been much more focused on &lt;a href="http://stackoverflow.com/questions/21437015/soundness-and-completeness-of-systems"&gt;soundness&lt;/a&gt;, especially around the &lt;em&gt;many&lt;/em&gt; problems caused by &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, than TypeScript. And it had earlier support for &lt;a href="https://flowtype.org/docs/disjoint-unions.html"&gt;tagged unions&lt;/a&gt;, a tool I’ve come to find invaluable since picking them up from my time with Rust.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But the 2.0 and 2.1 releases of TypeScript have changed the game substantially, and it’s now a &lt;em&gt;very&lt;/em&gt; compelling language in its own right—not to mention a great tool for writing better JavaScript. So I thought I’d highlight how you can get a lot of the benefits you would get from the type systems of languages like Elm with some of those new TypeScript features: the &lt;em&gt;&lt;code&gt;keyof&lt;/code&gt; operator&lt;/em&gt; and &lt;em&gt;mapped types&lt;/em&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i&gt;Some readers may note that what I’m doing here is a &lt;em&gt;lot&lt;/em&gt; of wrangling to cajole TypeScript into giving me the kinds of things you get for free in an ML-descended language. Yep. The point is that you &lt;em&gt;can&lt;/em&gt; wrangle it into doing this.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="plain-old-javascript" class="level3"&gt;
&lt;h3&gt;Plain old JavaScript&lt;/h3&gt;
&lt;p&gt;Let’s say we want to write a little state machine in terms of a function to go from one state to the next, like this:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case &amp;#39;Pending&amp;#39;: return &amp;#39;Started&amp;#39;;
    case &amp;#39;Started&amp;#39;: return &amp;#39;Completed&amp;#39;;
    case &amp;#39;Completed&amp;#39;: return &amp;#39;Completed&amp;#39;;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will work, and it’ll even throw an error if you hand it the wrong thing. But you’ll find out at runtime if you accidentally typed &lt;code&gt;nextState('Pednign')&lt;/code&gt; instead of &lt;code&gt;nextState('Pending')&lt;/code&gt;—something I’ve done more than once in the past. You’d have a similar problem if you’d accidentally written &lt;code&gt;case 'Strated'&lt;/code&gt; instead of &lt;code&gt;case 'Started'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many contexts like this one in JavaScript—perhaps the most obvious being &lt;a href="http://redux.js.org/docs/basics/Actions.html"&gt;Redux actions&lt;/a&gt;, but I get a lot of mileage out of the pattern in Ember, as well. In these contexts, I find it’s convenient to define types that are kind of like pseudo-enums or pseudo-simple-unions, like so:&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you’ve defined an object this way, instead of using strings directly in functions that take it as an argument, like &lt;code&gt;nextState('Started')&lt;/code&gt;, you can use the object property: &lt;code&gt;nextState(STATE.Started)&lt;/code&gt;. You can rewrite the function body to use the object definition instead as well:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;function nextState(state) {
  switch(state) {
    case STATE.Pending: return STATE.Started;
    case STATE.Started: return STATE.Completed;
    case STATE.Completed: return STATE.Completed;
    default: throw new Error(`Bad state: ${state}`);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the object and its keys instead gets you something like a namespaced constant. As a result, you can get more help with things like code completion from your editor, along with warnings or errors from your linter if you make a typo. You’ll also get &lt;em&gt;slightly&lt;/em&gt; more meaningful error messages if you type the wrong thing. For example, if you type &lt;code&gt;STATE.Strated&lt;/code&gt; instead of &lt;code&gt;STATE.Started&lt;/code&gt;, any good editor will give you an error—especially if you’re using a linter. At Olo, we use &lt;a href="http://eslint.org"&gt;ESLint&lt;/a&gt;, and we have it &lt;a href="https://github.com/ember-cli/ember-cli-eslint/"&gt;set up&lt;/a&gt; so that this kind of typo/linter error fails our test suite (and we never merge changes that don’t pass our test suite!).&lt;/p&gt;
&lt;p&gt;This is about as good a setup as you can get in plain-old JavaScript. As long as you’re disciplined and always use the object, you get some real benefits from using this pattern. But you &lt;em&gt;always&lt;/em&gt; have to be disciplined. If someone who is unfamiliar with this pattern types &lt;code&gt;nextState('whifflebats')&lt;/code&gt; somewhere, well, we’re back to blowing up at runtime. Hopefully your test suite catches that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="typescript-to-the-rescue" class="level3"&gt;
&lt;h3&gt;TypeScript to the rescue&lt;/h3&gt;
&lt;p&gt;TypeScript gives us the ability to &lt;em&gt;guarantee&lt;/em&gt; that the contract is met (that we’re not passing the wrong value in). As of the latest release, it also lets us guarantee the &lt;code&gt;STATES&lt;/code&gt; object to be set up the way we expect. And last but not least, we get some actual productivity boosts when writing the code, not just when debugging it.&lt;/p&gt;
&lt;p&gt;Let’s say we decided to constrain our &lt;code&gt;nextState&lt;/code&gt; function so that it had to both take and return some kind of &lt;code&gt;State&lt;/code&gt;, representing one of the states we defined above. We’ll leave a &lt;code&gt;TODO&lt;/code&gt; here indicating that we need to figure out how to write the type of &lt;code&gt;State&lt;/code&gt;, but the function definition would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// TODO: figure out how to define `State`
function nextState(state: State): State {
  // the same body...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeScript has had &lt;a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt; since the &lt;a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html"&gt;1.4 release&lt;/a&gt; so they might seem like an obvious choice, and indeed we could write easily a type definition for the strings in &lt;code&gt;STATES&lt;/code&gt; as a union:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, you can’t write something like &lt;code&gt;State.Pending&lt;/code&gt; somewhere; you have to write the plain string &lt;code&gt;'Pending'&lt;/code&gt; instead. You still get some of the linting benefits you got with the approach outlined above via TypeScript’s actual type-checking, but you don’t get &lt;em&gt;any&lt;/em&gt; help with autocompletion. Can we get the benefits of both?&lt;/p&gt;
&lt;p&gt;Yes! (This would be a weird blog post if I just got this far and said, “Nope, sucks to be us; go use Elm instead.”)&lt;/p&gt;
&lt;p&gt;As of the 2.1 release, TypeScript lets you define types in terms of keys, so you can write a type like this:&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can use that type any place you need to constrain the type of a variable, or a return, or whatever:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const goodState: StateFromKeys = STATE.Pending;

// error: type &amp;#39;&amp;quot;Blah&amp;quot;&amp;#39; is not assignable to type &amp;#39;State&amp;#39;
const badState: StateFromKeys = &amp;#39;Blah&amp;#39;;

interface StateMachine {
  (state: StateFromKeys): StateFromKeys;
}

const nextState: StateMachine = (state) =&amp;gt; {
  // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The upside to this is that now you can guarantee that anywhere you’re supposed to be passing one of those strings, you &lt;em&gt;are&lt;/em&gt; passing one of those strings. If you pass in &lt;code&gt;'Compelte'&lt;/code&gt;, you’ll get an actual error—just like if we had used the union definition above. At a minimum, that will be helpful feedback in your editor. Maximally, depending on how you have your project configured, it may not even generate any JavaScript output.&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; So that’s a significant step forward beyond what we had even with the best linting rules in pure JavaScript.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="going-in-circles" class="level3"&gt;
&lt;h3&gt;Going in circles&lt;/h3&gt;
&lt;p&gt;But wait, we can do more! TypeScript 2.1 &lt;em&gt;also&lt;/em&gt; came with a neat ability to define “mapped types,” which map one object type to another. They have a few &lt;a href="http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#mapped-types"&gt;interesting examples&lt;/a&gt; which are worth reading. What’s interesting to us here is that you can write a type like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in keyof typeof STATE]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And of course, you can simplify that using the type we defined above, since &lt;code&gt;StateFromKeys&lt;/code&gt; was just &lt;code&gt;keyof typeof STATE&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve now defined an object type whose &lt;em&gt;key&lt;/em&gt; has to be one of the items in the &lt;code&gt;State&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;Now, by itself, this isn’t all that useful. Above, we defined that as the keys on the &lt;code&gt;STATE&lt;/code&gt; object, but if we tried to use that in conjunction with this new type definition, we’d just end up with a recursive type definition: &lt;code&gt;StateFromKeys&lt;/code&gt; defined as the keys of &lt;code&gt;STATE&lt;/code&gt;, &lt;code&gt;StateAsMap&lt;/code&gt; defined in terms of the elements of &lt;code&gt;StateFromKeys&lt;/code&gt;, and then &lt;code&gt;STATE&lt;/code&gt; defined as a &lt;code&gt;StateAsMap&lt;/code&gt;…&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: StateAsMap = {
  Pending: &amp;#39;Pending&amp;#39;,
  Active: &amp;#39;Active&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}

type StateFromKeys = keyof typeof STATE;

type StateAsMap = {
  [K in StateFromKeys]: K
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You end up with multiple compiler errors here, because of the circular references. This approach won’t work. If we take a step back, though, we can work through this (and actually end up someplace better).&lt;/p&gt;
&lt;/section&gt;
&lt;section id="join-forces" class="level3"&gt;
&lt;h3&gt;Join forces!&lt;/h3&gt;
&lt;p&gt;First, let’s start by defining the mapping generically. After all, the idea here was to be able to use this concept all over the place—e.g. for &lt;em&gt;any&lt;/em&gt; Redux action, not just one specific one. We don’t need this particular &lt;code&gt;State&lt;/code&gt;; we just need a constrained set of strings (or numbers) to be used as the key of an object:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type MapKeyAsValue&amp;lt;Key extends string&amp;gt; = {
  [K in Key]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In principle, if we didn’t have to worry about the circular references, we could use that to constrain our definition of the original &lt;code&gt;STATE&lt;/code&gt; itself:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const STATE: MapKeyAsValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how to get around the problem of circular type definitions? Well, it turns out that the &lt;code&gt;K&lt;/code&gt; values in these &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; and &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; types are equivalent:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// Approach 1, using an object
const STATE = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};

type StateFromKeys = keyof typeof STATE;
type StateObjectKeyToValue = {
  [K in StateFromKeys]: K  // &amp;lt;- K is just the keys!
};

// Approach 2, using unions
type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;
type StateUnionKeyToValue = {
  [K in StateUnion]: K  // &amp;lt;- K is also just the keys!
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, unlike the &lt;code&gt;StateObjectKeyToValue&lt;/code&gt; version, &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; doesn’t make any reference to the &lt;code&gt;STATE&lt;/code&gt; object. So we can use &lt;code&gt;StateUnionKeyToValue&lt;/code&gt; to constrain &lt;code&gt;STATE&lt;/code&gt;, and then just use &lt;code&gt;StateUnion&lt;/code&gt; to constrain all the places we want to &lt;em&gt;use&lt;/em&gt; one of those states. Once we put it all together, that would look like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type StateUnion = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

type StateUnionKeyToValue = {
  [K in StateUnion]: K
};

const STATE: StateUnionKeyToValue = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By doing this, we get two benefits. First, &lt;code&gt;STATE&lt;/code&gt; now has to supply the key and value for &lt;em&gt;all&lt;/em&gt; the union’s variants. Second, we know that the key and value are the same, and that they map to the union’s variants. These two facts mean that we can be 100% sure that wherever we define something as requiring a &lt;code&gt;State&lt;/code&gt;, we can supply one of the items on &lt;code&gt;STATE&lt;/code&gt; and it will be guaranteed to be correct. If we change the &lt;code&gt;State&lt;/code&gt; union definition, everything else will need to be updated, too.&lt;/p&gt;
&lt;p&gt;Now we can make this generic, so it works for types besides just this one set of states—so that it’ll work for &lt;em&gt;any&lt;/em&gt; union type with string keys, in fact. (That string-key constraint is important because objects in TypeScript can currently only use strings or numbers as keys; whereas union types can be all sorts of things.) Apart from that constraint on the union, though, we can basically just substitute a generic type parameter &lt;code&gt;U&lt;/code&gt;, for “union,” where we had &lt;code&gt;StateUnion&lt;/code&gt; before.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type UnionKeyToValue&amp;lt;U extends string&amp;gt; = {
  [K in U]: K
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then any object we say conforms to this type will take a union as its type parameter, and every key on the object must have exactly the same value as the key name:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;type State = &amp;#39;Pending&amp;#39; | &amp;#39;Started&amp;#39; | &amp;#39;Completed&amp;#39;;

// Use `State` as the type parameter to `UnionKeyToValue`.
const STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If any of those don’t have &lt;em&gt;exactly&lt;/em&gt; the same value as the key name, you’ll get an error. So, each of the following value assignments would fail to compile, albeit for different reasons (top to bottom: capitalization, misspelling, and missing a letter).&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;const BAD_STATE: UnionKeyToValue&amp;lt;State&amp;gt; = {
  Pending: &amp;#39;pending&amp;#39;,  // look ma, no capitals
  Started: &amp;#39;Strated&amp;#39;,  // St-rated = whuh?
  Completed: &amp;#39;Complete&amp;#39;,  // so tense
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll see a compiler error that looks something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="line-block"&gt;[ts]&lt;br /&gt;
Type ‘{ Pending: “pending”; Started: “Strated”; Completed: “Complete” }’ is not assignable to type ‘UnionKeyToValue&lt;State&gt;’.&lt;br /&gt;
  Types of property ‘Pending’ are incompatible.&lt;br /&gt;
    Type ‘“pending”’ is not assignable to type ‘“Pending”’.&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the key and the name don’t match, the compiler tells us we didn’t keep the constraint we defined on what these types should look like. Similarly, if you forget an item from the union, you’ll get an error. If you add an item that isn’t in the original union, you’ll get an error. Among other things, this means that you can be confident that if you add a value to the union, the rest of your code won’t compile until you include cases for it. You get all the power and utility of using union types, &lt;em&gt;and&lt;/em&gt; you get the utility of being able to use the object as a namespace of sorts.&lt;a href="#fn6" class="footnote-ref" id="fnref6"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And the TypeScript language service—which you can use from a &lt;em&gt;lot&lt;/em&gt; of editors, including VS Code, Atom, Sublime Text, and the JetBrains IDEs—will actually give you the correct completion when you start definition a type. So imagine we were defining some other union type elsewhere in our program to handle events. Now we can use the same &lt;code&gt;UnionKeyToValue&lt;/code&gt; type to construct this type, with immediate, &lt;em&gt;correct&lt;/em&gt; feedback from the TypeScript language service:&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt;
&lt;source type='video/mp4' src='http://cdn.chriskrycho.com/images/completion.mp4'&gt;
&lt;/video&gt;
&lt;figcaption&gt;
TypeScript live code completion of the mapped type
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;By inverting our original approach of using &lt;code&gt;keyof&lt;/code&gt; (itself powerful and worth using in quite a few circumstances) and instead using the new mapped types, we get a &lt;em&gt;ton&lt;/em&gt; of mileage in terms of productivity when using these types—errors prevented, and speed of writing the code in the first place increased as well.&lt;/p&gt;
&lt;p&gt;Yes, it’s a little verbose and it does require duplicating the strings whenever you define one of these types.&lt;a href="#fn7" class="footnote-ref" id="fnref7"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; But, and this is what I find most important: there is only one &lt;em&gt;source&lt;/em&gt; for those string keys, the union type, and it is definitive. If you change that central union type, everything else that references it, including the namespace-like object, will fail to compile until you make the same change there.&lt;/p&gt;
&lt;figure&gt;
&lt;video autoplay=autoplay muted=muted playsinline=playsinline loop=loop&gt;
&lt;source type='video/mp4' src='http://cdn.chriskrycho.com/images/change-union.mp4'&gt;
&lt;/video&gt;
&lt;figcaption&gt;
Updating a union
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;So it’s a lot more work than it would be in, say, Elm. But it’s also a lot more guarantees than I’d get in plain-old-JavaScript, or even TypeScript two months ago.&lt;/p&gt;
&lt;p&gt;I’ll call that a win.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;it’s no surprise that Microsoft’s developer tooling is stronger than Facebook’s&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;along with all the other ML-descended languages I’ve played with, including Haskell, F&lt;sup&gt;♯&lt;/sup&gt;, PureScript, and Elm.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Aside: to be extra safe and prevent any confusion or mucking around, you should probably call &lt;code&gt;Object.freeze()&lt;/code&gt; on the object literal, too:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;const STATE = Object.freeze({
  Pending: &amp;#39;Pending&amp;#39;,
  Started: &amp;#39;Started&amp;#39;,
  Completed: &amp;#39;Completed&amp;#39;,
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both convention and linters make it unlikely you’ll modify something like this directly—but impossible is better than unlikely.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Flow has supported this feature for some time; you can write &lt;code&gt;$Keys&amp;lt;typeof STATE&amp;gt;&lt;/code&gt;—but the feature is entirely undocumented.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;Set your &lt;code&gt;&amp;quot;compilerOptions&amp;quot;&lt;/code&gt; key in your &lt;code&gt;tsconfig.json&lt;/code&gt; to include &lt;code&gt;&amp;quot;noEmitOnError&amp;quot;: true,&lt;/code&gt;.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6"&gt;&lt;p&gt;For namespacing in a more general sense, you should use… &lt;a href="http://www.typescriptlang.org/docs/handbook/namespaces.html"&gt;namespaces&lt;/a&gt;.&lt;a href="#fnref6" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7"&gt;&lt;p&gt;It would be great if we could get these benefits without the duplication—maybe someday we’ll have better support in JS or TS natively.&lt;a href="#fnref7" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 17 Dec 2016 23:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-12-17:/2016/keyof-and-mapped-types-in-typescript-21.html</guid><category>javascript</category><category>typescript</category><category>software development</category><category>programming languages</category></item><item><title>Using Rust for ‘Scripting’</title><link>http://www.chriskrycho.com/2016/using-rust-for-scripting.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;&lt;strong&gt;Edit&lt;/strong&gt;: fixed some typos, cleaned up implementation a bit based on feedback around the internet.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;A lightly edited version of this post was syndicated in &lt;a href="https://hackerbits.com/chris-krycho-using-rust-for-scripting/"&gt;Hacker Bits, Issue 13&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="i.-using-rust-instead-of-python" class="level2"&gt;
&lt;h2&gt;I. Using Rust Instead of Python&lt;/h2&gt;
&lt;p&gt;A friend asked me today about writing a little script to do a simple conversion of the names of some files in a nested set of directories. Everything with one file extension needed to get another file extension. After asking if it was the kind of thing where he had time to and/or wanted to learn how to do it himself (always important when someone has expressed that interest more generally), I said, “Why don’t I do this in Rust?”&lt;/p&gt;
&lt;p&gt;Now, given the description, you might think, &lt;i class=thought&gt;Wouldn’t it make more sense to do that in Python or Perl or even just a shell script?&lt;/i&gt; And the answer would be: it depends—on what the target operating system is, for example, and what the person’s current setup is. I knew, for example, that my friend is running Windows, which means he doesn’t have Python or Perl installed. I’m not a huge fan of either batch scripts or PowerShell (and I don’t know either of them all that well, either).&lt;/p&gt;
&lt;p&gt;I could have asked him to install Python. But, on reflection, I thought: &lt;i class=thought&gt;Why would I do that? I can write this in Rust.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Writing it in Rust means I can compile it and hand it to him, and he can run it. And that’s it. As wonderful as they are, the fact that languages like Python, Perl, Ruby, JavaScript, etc. require having the runtime bundled up with them makes just shipping a tool a lot harder—&lt;em&gt;especially&lt;/em&gt; on systems which aren’t a Unix derivative and don’t have them installed by default. (Yes, I know that &lt;em&gt;mostly&lt;/em&gt; means Windows, but it doesn’t &lt;em&gt;solely&lt;/em&gt; mean Windows. And, more importantly: the vast majority of the desktop-type computers in the world &lt;em&gt;still run Windows&lt;/em&gt;. So that’s a big reason all by itself.)&lt;/p&gt;
&lt;p&gt;So there’s the justification for shipping a compiled binary. Why Rust specifically? Well, because I’m a fanboy. (But I’m a fanboy because Rust often gives you roughly the feel of using a high-level language like Python, but lets you ship standalone binaries. The same is true of a variety of other languages, too, like Haskell; but Rust is the one I know and like right now.)&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;&lt;strong&gt;Edit the second:&lt;/strong&gt; this is getting a lot of views from Hacker News, and it’s worth note: I’m not actually advocating that everyone stop using shell scripts for this kind of thing. I’m simply noting that it’s &lt;em&gt;possible&lt;/em&gt; (and sometimes even &lt;em&gt;nice&lt;/em&gt;) to be able to do this kind of thing in Rust, cross-compile it, and just ship it. And hey, types are nice when you’re trying to do more sophisticated things than I’m doing here! Also, for those worried about running untrusted binaries: I handed my friend the code, and would happily teach him how to build it.&lt;/i&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="ii.-building-a-simple-script" class="level2"&gt;
&lt;h2&gt;II. Building a Simple “Script”&lt;/h2&gt;
&lt;p&gt;Building a “script”-style tool in Rust is pretty easy, gladly. I’ll walk through exactly what I did to create this “script”-like tool for my friend. My goal here was to rename every file in a directory from &lt;code&gt;*.cha&lt;/code&gt; to &lt;code&gt;*.txt&lt;/code&gt;.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.rust-lang.org/en-US/downloads.html"&gt;Install Rust.&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a new binary:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;cargo new --bin rename-it&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the dependencies to the Cargo.toml file. I used the &lt;a href="https://doc.rust-lang.org/glob/glob/index.html"&gt;glob&lt;/a&gt; crate for finding all the &lt;code&gt;.cha&lt;/code&gt; files and the &lt;a href="https://clap.rs"&gt;clap&lt;/a&gt; crate for argument parsing.&lt;/p&gt;
&lt;pre class="toml"&gt;&lt;code&gt;[package]
name = &amp;quot;rename-it&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Chris Krycho &amp;lt;chris@chriskrycho.com&amp;gt;&amp;quot;]

[dependencies]
clap = &amp;quot;2.15.0&amp;quot;
glob = &amp;quot;0.2&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the actual implementation to the &lt;code&gt;main.rs&lt;/code&gt; file (iterating till you get it the way you want, of course).&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;extern crate clap;
extern crate glob;

use glob::glob;
use std::fs;

use clap::{Arg, App, AppSettings};


fn main() {
  let path_arg_name = &amp;quot;path&amp;quot;;
  let args = App::new(&amp;quot;cha-to-txt&amp;quot;)
    .about(&amp;quot;Rename .cha to .txt&amp;quot;)
    .setting(AppSettings::ArgRequiredElseHelp)
    .arg(Arg::with_name(path_arg_name)
      .help(&amp;quot;path to the top directory with .cha files&amp;quot;))
    .get_matches();

  let path = args.value_of(path_arg_name)
    .expect(&amp;quot;You didn&amp;#39;t supply a path&amp;quot;);
  let search = String::from(path) + &amp;quot;/**/*.cha&amp;quot;;
  let paths = glob(&amp;amp;search)
    .expect(&amp;quot;Could not find paths in glob&amp;quot;)
    .map(|p| p.expect(&amp;quot;Bad individual path in glob&amp;quot;));

  for path in paths {
    match fs::rename(&amp;amp;path, &amp;amp;path.with_extension(&amp;quot;txt&amp;quot;)) {
      Ok(_) =&amp;gt; (),
      Err(reason) =&amp;gt; panic!(&amp;quot;{}&amp;quot;, reason),
    };
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compile it.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;cargo build --release&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the executable to hand to a friend.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In my case, I actually added in the step of &lt;em&gt;recompiling&lt;/em&gt; it on Windows after doing all the development on macOS. This is one of the real pieces of magic with Rust: you can &lt;em&gt;easily&lt;/em&gt; write cross-platform code. The combination of Cargo and native-compiled-code makes it super easy to write this kind of thing—and, honestly, easier to do so in a cross-platform way than it would be with a traditional scripting language.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But what’s really delightful is that we can do better. I don’t even need to install Rust on Windows to compile a Rust binary for Windows.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="iii.-cross-compiling-to-windows-from-macos" class="level2"&gt;
&lt;h2&gt;III. Cross-Compiling to Windows from macOS&lt;/h2&gt;
&lt;p&gt;Once again, let’s do this step by step. Three notes: First, I got pretty much everything other than the first and last steps here from WindowsBunny on the &lt;a href="https://botbot.me/mozilla/rust/"&gt;#rust&lt;/a&gt; &lt;abbr&gt;IRC&lt;/abbr&gt; channel. (If you’ve never hopped into #rust, you should: it’s amazing.) Second, you’ll need a Windows installation to make this work, as you’ll need some libraries. (That’s a pain, but it’s a one-time pain.) Third, this is the setup for doing in on macOS Sierra; steps may look a little different on an earlier version of macOS or on Linux.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Install the Windows compilation target with &lt;code&gt;rustup&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;rustup target add x86_64-pc-windows-msvc&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the required linker (&lt;a href="http://lld.llvm.org"&gt;&lt;code&gt;lld&lt;/code&gt;&lt;/a&gt;) by way of installing the LLVM toolchain.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;brew install llvm&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a symlink somewhere on your &lt;code&gt;PATH&lt;/code&gt; to the newly installed linker, specifically with the name &lt;code&gt;link.exe&lt;/code&gt;. I have &lt;code&gt;~/bin&lt;/code&gt; on my &lt;code&gt;PATH&lt;/code&gt; for just this kind of thing, so I can do that like so:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ln -s /usr/local/opt/llvm/bin/lld-link ~/bin/link.exe&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(We have to do this because the Rust compiler &lt;a href="https://github.com/rust-lang/rust/blob/master/src/librustc_trans/back/msvc/mod.rs#L300"&gt;specifically goes looking for &lt;code&gt;link.exe&lt;/code&gt; on non-Windows targets&lt;/a&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the target files for the Windows build to link against. Those are in these directories, where &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; will be a number like &lt;code&gt;10586.0&lt;/code&gt; or similar (you should pick the highest one if there is more than one):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C:\Program Files\Windows Kits\10\Lib\10.0.&amp;lt;something&amp;gt;\ucrt\x64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C:\Program Files\Windows Kits\10\Lib\10.0.&amp;lt;something&amp;gt;\um\x64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\lib\amd64&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that if you don’t already have &lt;abbr&gt;MSVC&lt;/abbr&gt; installed, you’ll need to install it. If you don’t have Visual Studio installed on a Windows machine &lt;em&gt;at all&lt;/em&gt;, you can do that by using the links &lt;a href="http://landinghub.visualstudio.com/visual-cpp-build-tools"&gt;here&lt;/a&gt;. Otherwise, on Windows, go to &lt;strong&gt;Add/Remove Programs&lt;/strong&gt; and opting to Modify the Visual Studio installation. There, you can choose to add the C++ tools to the installation.&lt;/p&gt;
&lt;p&gt;Note also that if you’re building for 32-bit Windows you’ll want to grab &lt;em&gt;those&lt;/em&gt; libraries instead of the 64-bit libraries.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set the &lt;code&gt;LIB&lt;/code&gt; environment variable to include those paths and build the program. Let’s say you put them in something like &lt;code&gt;/Users/chris/lib/windows&lt;/code&gt; (which is where I put mine). Your Cargo invocation will look like this:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;env LIB=&amp;quot;/Users/chris/lib/windows/ucrt/x64/;/Users/chris/lib/windows/um/x64/;/Users/chris/lib/windows/VC_lib/amd64/&amp;quot; \
cargo build --release --target=x86_64-pc-windows-msvc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the final &lt;code&gt;/&lt;/code&gt; on each path and the enclosing quotation marks are all important!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the binary to hand to a friend, without ever having had to leave your Mac.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To be sure, there was a little extra work involved in getting cross-compilation set up. (This is the kind of thing I’d love to see further automated with &lt;code&gt;rustup&lt;/code&gt; in 2017!) But what we have at the end is pretty magical. Now we can just compile cross-platform code and hand it to our friends.&lt;/p&gt;
&lt;p&gt;Given that, I expect not to be using Python for these kinds of tools much going forward.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Again: you can do similar with Haskell or OCaml or a number of other languages. And those are great options; they are in &lt;em&gt;some&lt;/em&gt; ways easier than Rust—but Cargo is really magical for this.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 14 Nov 2016 22:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-11-14:/2016/using-rust-for-scripting.html</guid><category>rust</category><category>software development</category><category>programming languages</category></item><item><title>Rust and Swift (xviii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xviii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;section id="part-i-ownership-semantics-vs.reference-counting" class="level2"&gt;
&lt;h2&gt;Part I: Ownership Semantics vs. Reference Counting&lt;/h2&gt;
&lt;p&gt;Perhaps unsurprisingly, the Swift book follows on from its discussion of initialization with a discussion of deinitialization, and here the differences between Rust and Swift are substantial, but (as has so often been the case) so are the analogies.&lt;/p&gt;
&lt;p&gt;In Rust, memory is, by default, stack-allocated and -deallocated, but with a very impressive system for tracking the lifetime of that data and allowing its to be moved from one function to another. The Rust compiler tracks the &lt;em&gt;ownership&lt;/em&gt; of every given item in the program as it is passed from one function to another, allowing other parts of the program to “borrow” the data safely, until a given piece of data goes out of scope entirely. At that point, Rust runs its destructors automatically. As part of its system for managing memory safely, Rust also tracks where and when a program attempts to access any given piece of data (whether directly or via reference), and will refuse to compile if you try to reference data in a place where it has already gone out of scope and been cleaned up (“dropped,” in Rust-speak).&lt;/p&gt;
&lt;p&gt;If this was a bit fuzzy, don’t worry: there’s a lot to say here. It’s arguably the most distinctive feature of the language, and it’s also the main thing that tends to trip up newcomers to the language. If you’re interested in further material on the topic, my own most succinct treatment of it is in &lt;a href="http://www.newrustacean.com/show_notes/e002/index.html" title="e002: Something borrowed, something... moved?"&gt;an early episode&lt;/a&gt; of New Rustacean, my Rust developer podcast, and &lt;a href="https://doc.rust-lang.org/book/ownership.html"&gt;the official documentation&lt;/a&gt; is &lt;em&gt;very&lt;/em&gt; good. For now, suffice it to say: Rust does extremely rigorous &lt;em&gt;compile-time&lt;/em&gt; checks to let you do C or C++-style memory management, but with absolute guarantees that you won’t have e.g. use-after-free bugs, with a default to handling everything on the stack.&lt;/p&gt;
&lt;p&gt;It is of course impossible to handle &lt;em&gt;everything&lt;/em&gt; on the stack, so there are heap-allocated types (e.g. vectors, a dynamically sized array-like type), which are fundamentally reference (or pointer) types. But those follow the same basic rules: Rust tracks the &lt;em&gt;pointers&lt;/em&gt; throughout their uses, and when they go out of scope, Rust automatically tears down not only the pointer but also the data behind it. There are times, though, when you can’t comply with Rust’s normal rules for handling multiple-access to the same data. For those situations, it also supplies some “smart pointer” container types, &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt;, the &lt;em&gt;reference-counted&lt;/em&gt; (non-thread-safe) and &lt;em&gt;atomically reference-counted&lt;/em&gt; (thread-safe) types. Both types just wrap up a type that you intend to put on the heap with reference-counters, which increment and decrement as various pieces of a program get access to them. Note that, unlike the compiler-level, &lt;em&gt;compile-time&lt;/em&gt; checks mentioned earlier, these are &lt;em&gt;run-time&lt;/em&gt; counts and they therefore incur a small but real runtime performance penalty. (The distinctions between the two types have to do with how they guarantee their memory safety and what kinds of a guarantees are required for cross-thread safety, and they’re important for writing Rust but not so important for this comparison, so I’ll leave them aside.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;In Swift, all class instances (which are pass-by-reference types) are tracked with &lt;em&gt;automatic reference counting&lt;/em&gt; and cleaned up automatically when there are no more references to them. Don’t confuse Rust’s “&lt;em&gt;atomically&lt;/em&gt; reference-counted” type with Swift’s “&lt;em&gt;automatically&lt;/em&gt; reference-counted” type. Unlike Rust’s behavior in having everything checked at compile-time, reference counting is a run-time check in Swift, just as it is with the &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;Arc&lt;/code&gt; types in Rust.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; But it happens for all reference types all the time in Swift, not just when specified manually as in Rust. (Value types seem to be &lt;em&gt;always&lt;/em&gt; passed by value, though the compiler has some smarts about that so it doesn’t get insanely expensive.) It’s &lt;em&gt;automatic&lt;/em&gt; in that the compiler and runtime handle it “behind the scenes” from the developer’s perspective.&lt;/p&gt;
&lt;p&gt;Swift’s approach here isn’t quite the same as having a full-on garbage-collected runtime like you’d see in Java, C&lt;sup&gt;#&lt;/sup&gt;, Python, Ruby, JavaScript, etc. (and so doesn’t have the performance issues those often can). But it also isn’t like Rust’s default of having &lt;em&gt;no&lt;/em&gt; runtime cost. It’s somewhere in the middle, with a goal of very good performance but good developer ergonomics. I think it achieves that latter goal: for the most part, it means that you don’t have to think about memory allocation and deallocation explicitly. Certainly there are times when you have to think about how your program handles those issues, but neither is it right up in your face like it is in Rust,&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; nor does it come with the costs of a heavier runtime (from startup, to GC pauses, to non-deterministic performance characteristics).&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To make it concrete, the following snippets do &lt;em&gt;basically&lt;/em&gt; the same thing—but note that the reference counting is explicit in Rust. We’ll start with Rust, doing it the normal way:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct WouldBeJedi {
    name: String,
    rank: u8,
    description: String,
}

impl WouldBeJedi {
    fn new(name: &amp;amp;str, rank: u8, description: &amp;amp;str) -&amp;gt; WouldBeJedi {
        WouldBeJedi {
            name: name.to_string(),
            rank: rank,
            description: description.to_string()
        }
    }
}

fn main() {
    let trainee = WouldBeJedi::new(
        &amp;quot;Zayne Carrick&amp;quot;, 1, &amp;quot;not very competent, but still a great hero&amp;quot;);

    // When calling the function, we pass it a reference, and it
    // &amp;quot;borrows&amp;quot; access to the data. But the validity of that access
    // is checked at compile time. `main()` keeps the &amp;quot;ownership&amp;quot;
    // of the data.
    describe(&amp;amp;trainee);

    // When `main` ends, nothing owns the data anymore, so
    // Rust cleans it up. If something were still borrowing the
    // data (say, if we&amp;#39;d passed a reference into another thread),
    // this would actually be a compile error, because references
    // have to be guaranteed to live as long as the thing they
    // point back to. Rust has tools for managing that, as well,
    // its &amp;quot;lifetimes&amp;quot;, but we can leave them aside for this example.
}

fn describe(trainee: &amp;amp;WouldBeJedi) {
    // Rust checks at compile time to make sure there are no
    // mutable &amp;quot;borrows&amp;quot; of the data, and therefore knows
    // that it is safe to reference the data here, because it can
    // be *sure* nothing will change it at the same time.

    // Under the covers, this macro will actually call a
    // function with the data we pass it, so Rust actually checks
    // the ownership and borrowing state here, too. Again, all
    // at compile time, and therefore with no runtime penalty.
    println!(&amp;quot;{} (rank {}) is {}.&amp;quot;,
             trainee.name,
             trainee.rank,
             trainee.description);

    // When we exit the function, Rust notes that it is no
    // longer &amp;quot;borrowing&amp;quot; the data.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here’s the Swift code—note as well that we use a &lt;code&gt;class&lt;/code&gt; not a &lt;code&gt;struct&lt;/code&gt; here:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class WouldBeJedi {
    let name: String
    let rank: UInt8
    let description: String

    init(name: String, rank: UInt8, description: String) {
        self.name = name
        self.rank = rank
        self.description = description
    }
}

func main() {
    let aTrainee = WouldBeJedi(
        name: &amp;quot;Zayne Carrick&amp;quot;,
        rank: 1,
        description: &amp;quot;not very competent, but a great hero&amp;quot;)

    // When calling the function, the reference count goes up
    // here, too, but it&amp;#39;s implicit, rather than explicit.
    describe(aTrainee)

    // The implicit reference count Swift maintains for `aTrainee`
    // will go from 1 to 0 here, and Swift will do its cleanup of the
    // object data.
}

func describe(_ trainee: WouldBeJedi) {
    // When we enter this function, Swift bumps the reference
    // count, from 1 to 2. Both `main` and `describe` now have a
    // reference to the data.

    // No need for the unwrapping or any of that; Swift handles it
    // all automatically... thus the name of the technology!
    print(&amp;quot;\(trainee.name) (rank \(trainee.rank)) is \(trainee.description).&amp;quot;)

    // When we exit the function, Swift bumps the reference count
    // back down to 1 automatically.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, here is the (much longer, because all the reference counting is done explicitly) reference-counted Rust version:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;use std::rc::Rc;

pub struct WouldBeJedi {
    name: String,
    rank: u8,
    description: String,
}

fn main() {
    let trainee = WouldBeJedi {
        name: &amp;quot;Zayne Carrick&amp;quot;.to_string(),
        rank: 1,
        description: &amp;quot;not very competent, but a great hero&amp;quot;.to_string()
    };
    let wrapped_trainee = Rc::new(trainee);

    // Start by calling `clone()` to get a *reference* to the
    // trainee. This increases the reference count by one.
    let ref_trainee = wrapped_trainee.clone();
    // Then pass the reference to the `describe()` function.
    // Note that we *move* the reference to the function, so
    // once the function returns, the reference will go out
    // of scope, and the reference count will decrement.
    describe(ref_trainee);

    // When `main` ends, several things will happen in order:
    // 1. The reference count on the `wrapped_trainee` will
    //    go to zero. As a result, the `wrapped_trainee`
    //    pointer---the `Rc` type we created---will get
    //    cleaned up.
    // 2. Once `wrapped_trainee` has been cleaned up, Rust
    //    will notice that there are no more references
    //    anywhere to `trainee` and clean it up as well.
    //    (More on this below.)
}

fn describe(trainee: Rc&amp;lt;WouldBeJedi&amp;gt;) {
    // We now have a *reference* to the underlying data, and
    // therefore can freely access the underlying data.
    println!(&amp;quot;{} (rank {}) is {}.&amp;quot;,
             trainee.name,
             trainee.rank,
             trainee.description);


    // When we exit the function, Rust destroys this *owned*
    // clone of the reference, and that bumps the reference
    // count back down to 1 automatically.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that if we strip out all the explanatory comments and details, the &lt;em&gt;normal&lt;/em&gt; versions of the Rust and Swift code are pretty similar.&lt;/p&gt;
&lt;p&gt;Rust—&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct WouldBeJedi {
    name: String,
    rank: u8,
    description: String,
}

impl WouldBeJedi {
    fn new(name: &amp;amp;str, rank: u8, description: &amp;amp;str) -&amp;gt; WouldBeJedi {
        WouldBeJedi {
            name: name.to_string(),
            rank: rank,
            description: description.to_string()
        }
    }
}

fn main() {
    let trainee = WouldBeJedi::new(
        &amp;quot;Zayne Carrick&amp;quot;,
        1,
        &amp;quot;not very competent, but still a great hero&amp;quot;);

    describe(&amp;amp;trainee);
}

fn describe(trainee: &amp;amp;WouldBeJedi) {
    println!(&amp;quot;{} (rank {}) is {}.&amp;quot;,
             trainee.name,
             trainee.rank,
             trainee.description);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift (as usual, is &lt;em&gt;slightly&lt;/em&gt; briefer than Rust)—&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class WouldBeJedi {
    let name: String
    let rank: UInt8
    let description: String

    init(name: String, rank: UInt8, description: String) {
        self.name = name
        self.rank = rank
        self.description = description
    }
}

func main() {
    let aTrainee = WouldBeJedi(
        name: &amp;quot;Zayne Carrick&amp;quot;,
        rank: 1,
        description: &amp;quot;not very competent, but a great hero&amp;quot;)

    describe(aTrainee)
}

func describe(_ trainee: WouldBeJedi) {
    print(&amp;quot;\(trainee.name) (rank \(trainee.rank)) is \(trainee.description).&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in both of these implementations, all the actual cleanup of the memory is handled behind the scenes—this feels much more like writing Python than writing C, &lt;em&gt;especially&lt;/em&gt; for complex data types. Not least because this same kind of nice cleanup can happen for complex, heap-allocated types like dynamically-sized vectors/arrays, etc. Both languages just manage it automatically. (The same is true of modern C++, for the most part, but it has a more complicated story there because of its relationship with C, where &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; and friends run rampant and are quite necessary for writing a lot of kinds of code.) Most of the time, when you’re done using data, you just &lt;em&gt;stop using it&lt;/em&gt;, and both Rust and Swift will clean it up for you. The feel of using either language is fairly similar, though the underlying semantics are quite different.&lt;/p&gt;
&lt;hr /&gt;
&lt;/section&gt;
&lt;section id="part-2-deconstructiondeinitialization" class="level2"&gt;
&lt;h2&gt;Part 2: Deconstruction/Deinitialization&lt;/h2&gt;
&lt;p&gt;Both Rust and Swift recognize that, the ordinary case notwithstanding, there are many times when you &lt;em&gt;do&lt;/em&gt; need to run some cleanup as part of tearing down an object. For example, if you had an open database connection attached to an object, you should return it to the collection pool before finishing tear-down of the object.&lt;/p&gt;
&lt;p&gt;In Rust, this is accomplished by implementing the &lt;code&gt;Drop&lt;/code&gt; trait and supplying the requisite &lt;code&gt;drop&lt;/code&gt; method. Imagine we had defined a &lt;code&gt;Jedi&lt;/code&gt; type, with a bunch of details about the Jedi’s lightsaber (including whether the Jedi even &lt;em&gt;has&lt;/em&gt; a lightsaber. We know from the &lt;em&gt;Star Wars&lt;/em&gt; movies that lightsabers turn off automatically when the Jedi dies, or even just drops it for that matter. We can implement &lt;em&gt;all&lt;/em&gt; of this in Rust using just the &lt;code&gt;Drop&lt;/code&gt; trait. Here’s a pretty full example.&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; (Note that both of these implementations draw heavily on material I covered in &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;previous posts&lt;/a&gt;.)&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;#[derive(Debug)]
enum Color {
    Red,
    Blue,
    Green,
    Purple,
    Yellow
}

enum SaberState {
    On,
    Off,
}

struct Lightsaber {
    color: Color,
    blades: u8,
    state: SaberState
}

impl Lightsaber {
    pub fn new(color: Color, blades: u8) -&amp;gt; Lightsaber {
        if blades &amp;gt; 2 {
            panic!(&amp;quot;That&amp;#39;s just silly. Looking at you, Kylo.&amp;quot;);
        }

        Lightsaber { color: color, blades: blades, state: SaberState::Off }
    }

    pub fn on(&amp;amp;mut self) {
        self.state = SaberState::On;
    }

    pub fn off(&amp;amp;mut self) {
        self.state = SaberState::Off;
    }
}

struct WouldBeJedi {
    name: String,
    lightsaber: Option&amp;lt;Lightsaber&amp;gt;,
}

impl WouldBeJedi {
    pub fn new(name: &amp;amp;str, lightsaber: Option&amp;lt;Lightsaber&amp;gt;) -&amp;gt; WouldBeJedi {
        WouldBeJedi { name: name.to_string(), lightsaber: lightsaber }
    }

    pub fn describe(&amp;amp;self) {
        let lightsaber = match self.lightsaber {
            Some(ref saber) =&amp;gt;
                format!(&amp;quot;a {:?} lightsaber with {:} blades.&amp;quot;, saber.color, saber.blades),
            None =&amp;gt; &amp;quot;no lightsaber.&amp;quot;.to_string()
        };

        println!(&amp;quot;{} has {}&amp;quot;, self.name, lightsaber)
    }
}

// Here&amp;#39;s the actually important bit.
impl Drop for WouldBeJedi {
    fn drop(&amp;amp;mut self) {
        if let Some(ref mut lightsaber) = self.lightsaber {
            lightsaber.off();
        }
    }
}


fn main() {
    let saber = Lightsaber::new(Color::Yellow, 1);
    let a_jedi = WouldBeJedi::new(&amp;quot;Zayne Carrick&amp;quot;, Some(saber));
    a_jedi.describe();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can do much the same in Swift, using its deinitializers, which are fairly analogous to (but much simpler than) &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvii.html"&gt;its initializers&lt;/a&gt;, and fulfill the same role as Rust’s &lt;code&gt;Drop&lt;/code&gt; trait and &lt;code&gt;drop()&lt;/code&gt; method.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;enum Color {
    case red, blue, green, purple, yellow
}

enum SaberState {
    case on, off
}

struct Lightsaber {
    let color: Color
    let blades: UInt8
    var state: SaberState = .off

    init?(color: Color, blades: UInt8) {
        if blades &amp;gt; 2 {
            print(&amp;quot;That&amp;#39;s just silly. Looking at you, Kylo.&amp;quot;)
            return nil
        }

        self.color = color
        self.blades = blades
    }

    mutating func on() {
        state = .on
    }

    mutating func off() {
        state = .off
    }
}

class WouldBeJedi {
    let name: String
    var lightsaber: Lightsaber?

    init(name: String, lightsaber: Lightsaber?) {
        self.name = name
        self.lightsaber = lightsaber
    }

    deinit {
        self.lightsaber?.off()
    }

    func describe() {
        let saberDescription: String
        if let saber = self.lightsaber {
            saberDescription = &amp;quot;a \(saber.color) lightsaber with \(saber.blades) blades.&amp;quot;
        } else {
            saberDescription = &amp;quot;no lightsaber.&amp;quot;
        }

        print(&amp;quot;\(name) has \(saberDescription)&amp;quot;)
    }
}

func main() {
    let saber = Lightsaber(color: .yellow, blades: 1)
    let aJedi = WouldBeJedi(name: &amp;quot;Zayne Carrick&amp;quot;, lightsaber: saber)
    aJedi.describe();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a bit briefer, but that’s mostly down to Swift’s shorthand for optionals (the &lt;code&gt;?&lt;/code&gt; operator), which we’ll get to in a future post.&lt;/p&gt;
&lt;p&gt;Curiously, &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;enum&lt;/code&gt; types &lt;em&gt;cannot&lt;/em&gt; have deinitializers in Swift. I expect this has something to do with their being value types rather than reference types, but the book offers no comment. (If a reader knows the answer, I’d welcome clarification.)&lt;/p&gt;
&lt;p&gt;Much as in the discussion of of initializers, the usual patterns with Rust and Swift’s approach come into play. Rust opts to build the pattern on the same basic language machinery (traits). Swift uses a bit of syntactical sugar dedicated to the purpose. It’s undeniable that the Swift is a bit briefer.&lt;/p&gt;
&lt;p&gt;However, there are a couple upsides to Rust’s approach. First, it is applicable on &lt;em&gt;all&lt;/em&gt; types, where Swift’s applies only to classes. Second, there is no additional syntax to remember. &lt;code&gt;Drop&lt;/code&gt; is just a trait like any other, and &lt;code&gt;drop&lt;/code&gt; a method like any other. Third, then, this means that you can run it explicitly elsewhere if you need to, and as a result you can define whatever kind of custom deconstruction behavior you might need. If we’d created &lt;code&gt;a_jedi&lt;/code&gt; above in Rust, we could simply write &lt;code&gt;a_jedi.drop()&lt;/code&gt; anywhere:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn prove_incompetent(a_jedi: WouldBeJedi) {
    // make some series of grievous mistakes which mean
    // you&amp;#39;re no longer able to be a Jedi and as such,
    // among other things, lose your lightsaber...
    a_jedi.drop();
    // other stuff
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or (going a bit more abstract) we could define a &lt;code&gt;daring_derring_do()&lt;/code&gt; method which called &lt;code&gt;drop()&lt;/code&gt; itself:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;impl WouldBeJedi {
    pub fn daring_derring_do(self) {
        // do some other operation, like freeing slaves from
        // a secret colony of slavers. But if it fails...
        self.drop();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or, really, define &lt;em&gt;any&lt;/em&gt; behavior which culminated in a &lt;code&gt;drop()&lt;/code&gt; call. That’s extremely powerful, and it’s the upside that comes with its just being a trait whose behavior we have to define ourselves.&lt;/p&gt;
&lt;p&gt;That takes us back to one of the fundamental differences in design between the two languages. Rust goes out of its way to leave power in the hands of the user, at the cost of requiring the user to be a bit more explicit. Swift prioritizes brevity and productivity, but it gets there by taking some of the power out of the hands of the developer. Neither of these is wrong, &lt;em&gt;per se&lt;/em&gt;. They’re just aiming for (and in this case, I think, fairly successfully landing in) somewhat different spots on a spectrum of tradeoffs.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; More on initializers!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I did, however, cover them &lt;a href="http://www.newrustacean.com/show_notes/e015/index.html" title="e015: Not dumb pointers"&gt;quite recently&lt;/a&gt; on my podcast. Yes, this &lt;em&gt;is&lt;/em&gt; another shameless plug.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Mostly, anyway. I believe the Swift compiler also does some degree of static analysis similar to that done by Rust—though to a &lt;em&gt;much&lt;/em&gt; lesser extent and, speaking purely descriptively, much less rigorously (it just has different goals). Swift then uses that analysis to handle things at compile time rather than via reference counts if it’s able to determine that it can do so.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;We could, if we so desired, get this same basic behavior in Rust. We can easily imagine a world in which every type was automatically wrapped in &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;, and in fact, I’d be very interested to see just such a language—something which was only a thin layer over Rust, keeping all its semantics but wrapping some or all non-stack-allocated types in &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt; as appropriate. (Something like &lt;a href="http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/"&gt;this&lt;/a&gt;, but done behind the scenes rather than manually opted into.) You’d incur some performance coasts, but with the benefit that you’d have an &lt;em&gt;extremely&lt;/em&gt; ergonomic, practical, ML-descended language quite appropriate for slightly higher-level tasks, and without the radical shift required by switching to a lazily-evaluated, purely functional language like Haskell.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Notably, those tradeoffs are often entirely worth it, and high-performance VMs have astoundingly good characteristics in many ways. The JVM, the CLR, and all the JavaScript VMs have astonishingly excellent performance at this point.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;I &lt;em&gt;might&lt;/em&gt; have gotten slightly carried away in the details here. I’m just a little bit of a nerd.&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 24 Jul 2016 15:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-07-24:/2016/rust-and-swift-xviii.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (xvii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xvii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvi.html"&gt;last part&lt;/a&gt;, I talked through the first chunk of the Swift book’s material on initializers. But it’s a long section, and I definitely didn’t cover everything. (I also got a few bits incorrect, and thankfully got great feedback to tighten it up from Twitter, so if you read it right after I posted it, you might skim back through and find the places where I added “&lt;strong&gt;Edit:&lt;/strong&gt; …”)&lt;/p&gt;
&lt;p&gt;Picking up from where we left on, then. Swift has a number of further initializer types, some of which map rather directly to the way initializers work in Rust, and some of which have no &lt;em&gt;direct&lt;/em&gt; analog at all.&lt;/p&gt;
&lt;p&gt;In the first category are the memberwise initializers Swift supplies by default for &lt;em&gt;all&lt;/em&gt; types. The most basic &lt;code&gt;init&lt;/code&gt; method just uses the names of the members of any given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; type in Swift (as in the previous section, I’m going to use the types the Swift book uses for simplicity):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Size {
    var height = 0.0, width = 0.0
}

someSize = Size(height: 1.0, width: 2.0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This actually looks almost exactly like the normal way we construct types in Rust, where the same basic pattern would look like this:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Size {
    height: f64,
    width: f64,
}

some_size = Size { height: 1.0, width: 2.0 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two big differences between the languages here. The first, and most immediately apparent, is syntactical: in this case, Rust doesn’t have a function-call syntax for creating instances, and Swift does. Swift’s syntax is similar to one of the several C++ constructor patterns, or especially to Python’s initializer calls (if we made a point to be explicit about the keyword arguments):&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;class Size:
    height = 0.0
    width = 0.0
    def __init__(height, width):
        self.height = height
        self.width = width

someSize = Size(height=1.0, width=2.0)  # unnecessarily explicit&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second, and more significant, is that the default, memberwise initializer in in Swift is only available &lt;em&gt;if you have not defined any other initializers&lt;/em&gt;. This is very, &lt;em&gt;very&lt;/em&gt; different from Rust, where there’s not really any such thing as a dedicated initializer—just methods. If we defined &lt;code&gt;Size::new&lt;/code&gt; or &lt;code&gt;Size::default&lt;/code&gt; or &lt;code&gt;Size::any_other_funky_initializer&lt;/code&gt;, it wouldn’t make a whit of difference in our ability to define the type this way.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; However, and this is important: because Rust has field-level public vs. private considerations, we cannot always do memberwise initialization of any given &lt;code&gt;struct&lt;/code&gt; type there, either; it is just that the reasons are different. So:&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;mod Shapes {
    struct Rectangle {
        pub height: f64,
        pub width: f64,
        area: f64,
    }
}

fn main() {
    // This won&amp;#39;t work: we haven&amp;#39;t constructed `Size::area`, and as we noted
    // last time, you cannot partially initialize a struct.
    let some_size = Shapes::Size { height: 1.0, width: 2.0 };

    // But neither will this, because `area` isn&amp;#39;t public:
    let some_other_size = Shapes::Size { height: 1.0, width: 2.0, area: 2.0 };
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swift lets you refer to &lt;em&gt;other&lt;/em&gt; initializers on the same type (reinforcing that &lt;code&gt;init()&lt;/code&gt; is basically a kind of method, albeit one with some special rules and some special sugar). You do that by calling &lt;code&gt;self.init()&lt;/code&gt;, and—very importantly—you can only call it from within another initializer. No funky reinitializations or anything like that. The net result is that if you have a couple different variations on ways you might initialize a type, you still get the benefit of reusability; you don’t have to reimplement the same initialization function over and over again. Do whatever &lt;em&gt;additional&lt;/em&gt; setup is required in any given instance, and then call a common base initializer.&lt;/p&gt;
&lt;p&gt;With Rust, again, we just have methods, so you &lt;em&gt;could&lt;/em&gt; of course call them wherever you like. However, those methods are distinguished as being type-level or instance-level methods by their signatures, rather than by keyword. If the first argument is (some variant on) &lt;code&gt;self&lt;/code&gt;, it’s an instance method, otherwise, a type-level method. This eliminates any potential confusion around the initializers:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Foo {
    pub a: i32
}

impl Foo {
    pub fn new(a: i32) -&amp;gt; Foo {
        Foo { a: a }
    }

    pub fn bar(&amp;amp;self) {
        // yes:
        let another_foo = Foo::new();
        // no (won&amp;#39;t even compile):
        // let self_foo = self.new();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can (of course!) build up a type through multiple layers of methods which are useful to compose an instance &lt;em&gt;together&lt;/em&gt;. This is what the &lt;a href="http://doc.rust-lang.org/stable/style/ownership/builders.html"&gt;&lt;em&gt;builder pattern&lt;/em&gt;&lt;/a&gt; is all about. There are definitely times when you want to be able to tweak how your initialization plays out, and being able to do that without just passing in some hairy set of options in a special data type is nice.&lt;/p&gt;
&lt;p&gt;One other important qualification on the Swift initializers: those default, memberwise constructors you get for free? You &lt;em&gt;only&lt;/em&gt; get them for free if you don’t define your own initializers. (The closest analogy to this in Rust is that you’ll have issues if you try to both &lt;code&gt;#[derive(Default)]&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;impl Default for Foo&lt;/code&gt;, since both will give you an implementation of &lt;code&gt;Foo::default()&lt;/code&gt;.) You can get around this in Swift by using an &lt;em&gt;extension&lt;/em&gt;. We’ll come back to that in a future post.&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; You can also get around it by supplying a parameter-less, body-less initializer in addition to any other initializers you supply, so: &lt;code&gt;init() {}&lt;/code&gt;. (This, frankly, seems like a hack to me. It’s a &lt;em&gt;useful&lt;/em&gt; hack, given the other constraints, but these kinds of things pile up.) Similarly, you can just reimplement member-wise initializers yourself if you have a reason to (say, if you’ve implemented any &lt;em&gt;others&lt;/em&gt; and therefore the defaults no longer exist).&lt;/p&gt;
&lt;p&gt;Now things take a turn into Swift-only territory &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xv.html"&gt;again&lt;/a&gt; as we look at initialization in the context of inheritance. (As mentioned last time: Rust will eventually get inheritance-like behavior, but it’s coming much later, and is not going to be &lt;em&gt;exactly&lt;/em&gt; like classical inheritance. Rust &lt;em&gt;strongly&lt;/em&gt; favors composition over inheritance, where Swift &lt;em&gt;lightly&lt;/em&gt; does but still supports the latter.)&lt;/p&gt;
&lt;p&gt;Swift has two kinds of initializers for class initializers. One, a &lt;em&gt;designated initializer&lt;/em&gt;, is required; a designated initializer must fully initialize every property on a class, and call the superclass initializer (assuming there is one). These can be inherited, but again: they are required.&lt;/p&gt;
&lt;p&gt;There are also &lt;em&gt;convenience initializers&lt;/em&gt;, which provide variant APIs for setting up any given class. These (by definition, given what we said a moment ago) &lt;em&gt;must&lt;/em&gt; call a designated initializer along the way. These could be useful in a lot of different scenarios: setting up variants on the class (as in our temperature examples from before), doing alternate setup depending on initial conditions, etc.&lt;/p&gt;
&lt;p&gt;The only difference between the two syntactically is that &lt;em&gt;convenience&lt;/em&gt; initializers get the &lt;code&gt;convenience&lt;/code&gt; keyword in front of the &lt;code&gt;init&lt;/code&gt; declaration, so:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class Foo {
    var bar : Int
    let quux: String
    // designated
    init(_ bar: Int, _ quux: String) {
        self.bar = bar
        self.quux = quux
    }

    // A convenience method which only takes the string.
    convenience init(_ quux: String) {
        self.init(0, quux)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Swift book gives a set of rules about how these delegated and convenience initializers must behave. The short version is that convenience initializers (eventually) have to call a delegated initializer from &lt;em&gt;their own&lt;/em&gt; class, and designated initializers have to call a designated initializer from the &lt;em&gt;superclass&lt;/em&gt;. This is an implementation detail, though: from the perspective of a &lt;em&gt;user&lt;/em&gt; of the class, it doesn’t matter which initializer is called.&lt;/p&gt;
&lt;p&gt;The other important bit about Swift &lt;em&gt;class&lt;/em&gt; initialization is that it is a two-phase process, which you might think of as “primary initialization” and “customization.” The primary initialization sets up the properties on a class &lt;em&gt;as defined by the class which introduced them&lt;/em&gt;. The following sample should illustrate how it plays out:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class Foo {
    let plainTruth = &amp;quot;Doug Adams was good at what he did.&amp;quot;
    let answer = 0

    init() {
        baz = answer / 2
    }
}

// Bar inherits from Foo
class Bar: Foo {
    let question = &amp;quot;What is the meaning of life, the universe, and everything?&amp;quot;
    let answer = 42

    init() {
        super.init()  // calls Foo.init()
    }

    convenience init(newQuestion question: String, newAnswer answer: Int) {
        self.question = question
        self.answer = answer
        self.init()  // calls own `init()`
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When building a &lt;code&gt;Bar&lt;/code&gt; via either the designated or convenience initializer, &lt;code&gt;plainTruth&lt;/code&gt; and &lt;code&gt;answer&lt;/code&gt; will be set up from &lt;code&gt;Foo&lt;/code&gt;, then &lt;code&gt;question&lt;/code&gt; will be set and &lt;code&gt;answer&lt;/code&gt; will be reassigned in &lt;code&gt;Bar&lt;/code&gt;. If the convenience initializer is used, then it will also override those new defaults with the arguments passed by the caller, before running the designated initializer, which will in turn call the superclass designated initializer. The machinery all makes good sense; I appreciate that there are no weird edge cases in the initialization &lt;em&gt;rules&lt;/em&gt; here. (There &lt;em&gt;are&lt;/em&gt; a bunch of special rules about which initializers get inherited; I’m just going to leave those aside at this point as they’re entirely irrelevant for a comparison between the languages. We’re already pretty far off into the weeds here.)&lt;/p&gt;
&lt;p&gt;Obviously, none of this remotely applies to Rust at all. Not having inheritance &lt;em&gt;does&lt;/em&gt; keep these things simpler (though of course it also means there’s a tool missing from your toolbox which you might miss). And of course, the rules around &lt;em&gt;method resolution&lt;/em&gt; are not totally trivial there, especially now that &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md"&gt;&lt;code&gt;impl&lt;/code&gt; specialization&lt;/a&gt; is making its way &lt;a href="https://github.com/rust-lang/rust/issues/31844"&gt;into the language&lt;/a&gt;. But those don’t strictly speaking, affect &lt;em&gt;initialization&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To account for the case that initialization can fail, Swift lets you definite &lt;em&gt;failable&lt;/em&gt; initializers, written like &lt;code&gt;init?()&lt;/code&gt;. Calling such an initializer produces an optional. You trigger the &lt;code&gt;nil&lt;/code&gt; valued optional state by writing &lt;code&gt;return nil&lt;/code&gt; at some point in the body of the initializer. Quoting from the Swift book, though, “Strictly speaking, initializers do not return a value…. Although you write &lt;code&gt;return nil&lt;/code&gt; tro trigger an initialization failure, you do not use the &lt;code&gt;return&lt;/code&gt; keyword to indicate initialization success.” These failable initializers get the same overall behavior and treatment as normal initializers in terms of delegating to other initializers within the same class, and inheriting them from superclasses.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;class Foo {
    let bar: Int
    init?(succeed: Bool) {
        if !succeed {
            return nil
        }

        bar = 42
    }
}

let foo = Foo(true)
print(&amp;quot;\(foo?.bar)&amp;quot;)  // 42
let quux = Foo(false)
Print(&amp;quot;\(foo?.bar)&amp;quot;)  // nil&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is another of the places where Swift’s choice to treat initialization as a special case, not just another kind of method, ends up having some weird side effects. If &lt;code&gt;init&lt;/code&gt; calls were &lt;em&gt;methods&lt;/em&gt;, they would always just be &lt;em&gt;returning the type&lt;/em&gt;. This is exactly what we see in Rust, of course. To be clear, there are reasons why the Swift team made that choice, and many of them we’ve already touched on incidentally; the long and short of it is that inheritance adds some wrinkles. These aren’t &lt;em&gt;constructors&lt;/em&gt;, they’re &lt;em&gt;initializers&lt;/em&gt;. The point, per the Swift book, is “to ensure that &lt;code&gt;self&lt;/code&gt; is fully and correctly initializer by the time that initialization ends.” If you’re familiar with Python, you can think of Swift initializers as being quite analogous to &lt;code&gt;__init__(self)&lt;/code&gt; methods, which similarly are responsible for &lt;em&gt;initialization&lt;/em&gt; but not &lt;em&gt;construction&lt;/em&gt;. When we build a type in Rust, by contrast, we’re doing something much more like calling Python &lt;code&gt;__new__(cls)&lt;/code&gt; methods, which &lt;em&gt;do&lt;/em&gt; construct the type.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Edit:&lt;/strong&gt; interestingly, I’m &lt;a href="https://twitter.com/austinzheng/status/749831726122217473"&gt;informed via Twitter&lt;/a&gt; that Swift initializers can also throw errors. (Thanks, Austin!) The Swift book doesn’t mention this because it hasn’t gotten to error-handling yet (and so, neither have we).&lt;a href="#fn4" class="footnote-ref" id="fnref4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You can of course write failable constructors in Rust, too:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Foo {
    bar: i64,
};

impl Foo {
    pub fn optional_new(succeed: bool) -&amp;gt; Option&amp;lt;Foo&amp;gt; {
        if succeed { Some(Foo { bar: 0 }) }
        else { None }
    }
}

let foo = Foo::optional_new(true);
match foo {
    Some(f) =&amp;gt; println!(&amp;quot;{}&amp;quot;, f.bar),
    None =&amp;gt; println!(&amp;quot;None&amp;quot;),
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are conditions in both languages where you’d want to do this: places where an initialization &lt;em&gt;can&lt;/em&gt; fail, e.g. trying to open a file, or open a websocket, or anything where the type represents something that is not guaranteed to return a valid result. It makes sense then that in both cases, returning an &lt;em&gt;optional&lt;/em&gt; value is the outcome. Of course, Rust can equally well have an initializer return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Waffles {
    syrup: bool,
    butter: bool,
}

impl Waffles {
    fn properly(all_supplies: bool) -&amp;gt; Result&amp;lt;Waffles, String&amp;gt; {
        if all_supplies {
            Ok(Waffles { syrup: true, butter: true } )
        }
        else {
            let msg = &amp;quot;Who makes waffles this way???&amp;quot;;
            Err(msg.to_string())
        }
    }
}

let waffles = Waffles::properly(true);
match waffles {
    Ok(_) =&amp;gt; println!(&amp;quot;Got some waffles, yeah!&amp;quot;),
    Err(s) =&amp;gt; println!(&amp;quot;{:}&amp;quot;, s),
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;This is simply not the kind of thing you can do in Swift, as far as I can tell. The upside to Swift’s approach is that there is one, standard path. The downside is that if you have a scenario where it makes sense to return an error—i.e., to indicate &lt;em&gt;why&lt;/em&gt; a class failed to initialize and not merely &lt;em&gt;that&lt;/em&gt; it failed—you’re going to have to jump through many more hoops.&lt;a href="#fn5" class="footnote-ref" id="fnref5"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/del&gt; &lt;em&gt;&lt;strong&gt;Edit:&lt;/strong&gt; See above; Swift &lt;em&gt;can&lt;/em&gt; do this. Moreover, the underlying semantics aren’t especially different from Rust’s. However, it does introduce &lt;em&gt;yet more&lt;/em&gt; syntax, rather than just being a normal return. But we’ll talk about that in more detail when we get to error-handling.&lt;/em&gt;&lt;a href="#fn4"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; The downside for Rust is that there’s no shorthand; everything is explicit. The upside is the flexibility to do as makes the most sense in a given context, including defining whatever types you need and returning them as you see fit. If you need a type like &lt;code&gt;PartialSuccessPossible&amp;lt;C, P, E&amp;gt;&lt;/code&gt; where &lt;code&gt;C&lt;/code&gt; is a complete type, &lt;code&gt;P&lt;/code&gt; a partial type, and &lt;code&gt;E&lt;/code&gt; an error, you can do that. (I’m not saying that’s a good idea, for the record.) That in turn flows out of building even higher level language features on lower-level features and not introducing new syntax for the most part. Trade-offs!&lt;/p&gt;
&lt;p&gt;And with that, we’re done talking about initializers. This was a &lt;em&gt;huge&lt;/em&gt; topic—but it makes sense. If you don’t nail this down carefully, you’ll be in for a world of hurt later, and that goes whether you’re designing a language or just using it to build things.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvi.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Initialization: another area where Swift has a lot more going on than Rust.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[**Next: Deinitialization: ownership semantics and automatic reference counting][18]&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Also recall that in Rust, we would set the default values either by using the &lt;code&gt;#[derive(Default)]&lt;/code&gt; annotation or by implementing the &lt;code&gt;Default&lt;/code&gt; trait ourselves.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;I’m including a module because of a quirk around the public/private rules: within the same module, &lt;code&gt;area&lt;/code&gt; isn’t hidden and you can actually go ahead and initialize the object.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;Depending on how you think about extensions, &lt;em&gt;either&lt;/em&gt; Rust doesn’t have anything quite like them… &lt;em&gt;or&lt;/em&gt; every type implementation is just an extension, because &lt;code&gt;impl&lt;/code&gt; allows you to extend &lt;em&gt;any&lt;/em&gt; data type in basically arbitrary ways (a few caveats of course). More on all of this when we get there.&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4"&gt;&lt;p&gt;Here’s a preview of what that would look like, though (fair warning, there’s a lot going on here we haven’t talked about!):&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;enum Setup {
    case succeed
    case error
    case fail
}

enum BarSetupError: ErrorProtocol {
    case argh
}

class Bar {
    let blah: Int
    init?(setup: Setup) throws {
        switch setup {
        case .succeed:
            blah = 42
        case .error:
            throw BarSetupError.argh
        case .fail:
            return nil
        }
    }
}

do {
    let bar = try Bar(setup: .succeed)
    print(&amp;quot;\(bar!.blah)&amp;quot;)

    let baz = try Bar(setup: .fail)
    print(&amp;quot;\(baz?.blah)&amp;quot;)

    let quux = try Bar(setup: .error)
    print(&amp;quot;\(quux?.blah)&amp;quot;)
} catch BarSetupError.argh {
    print(&amp;quot;Oh teh noes!&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from this would be &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt;, and &lt;code&gt;Oh teh noes!&lt;/code&gt;.&lt;a href="#fnref4" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5"&gt;&lt;p&gt;&lt;del&gt;It’s conceivable this is actually possible, but nothing in &lt;em&gt;The Swift Programming Language&lt;/em&gt; even hints at it, if so.&lt;/del&gt; See above!&lt;a href="#fnref5" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 30 Jun 2016 23:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-30:/2016/rust-and-swift-xvii.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Y Combinators, how do they even work?</title><link>http://www.chriskrycho.com/2016/y-combinators-how-do-they-even-work.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I was reading &lt;a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/"&gt;a post&lt;/a&gt; by &lt;a href="http://matt.might.net"&gt;Matt Might&lt;/a&gt;, a computer science professor at the University of Utah, about Y Combinators, and I was having a hard time tracking with some of it just by reading. The way I normally solve this problem is to write it out—and, optimally, to write it out in something roughly like &lt;a href="https://wiki.haskell.org/Literate_programming"&gt;Literate Haskell&lt;/a&gt; or &lt;a href="http://coffeescript.org/#literate"&gt;Literate CoffeeScript&lt;/a&gt;. That’s exactly what you’ll find below; this is basically &lt;em&gt;commentary&lt;/em&gt; on Might’s original post.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;A few other prefatory notes:&lt;/i&gt;&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;i class=editorial&gt;Since this is commentary, I’m not focusing on explaining combinators in general. For a very helpful explanation, though, both of what combinators are and why you’d ever want to use them, &lt;a href="http://programmers.stackexchange.com/a/117575"&gt;read this&lt;/a&gt;.&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=editorial&gt;The Y Combinator itself isn’t all that useful for ordinary programming. It &lt;em&gt;is&lt;/em&gt; really useful as a way of thinking about how programming &lt;em&gt;works&lt;/em&gt;, and that’s why I was reading about it and trying to figure out what was going on in Might’s original post.&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=editorial&gt;This didn’t actually all make sense to me until I also read Might’s post, &lt;a href="http://matt.might.net/articles/python-church-y-combinator/"&gt;“Equational derivations of the Y combinator and Church encodings in Python”&lt;/a&gt;. Which is a crazy post. But kind of fun. &lt;/i&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;Note for background (this was new to me today): &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;v&lt;/em&gt;.&lt;em&gt;e&lt;/em&gt;&lt;/span&gt; is the function which maps v to e. In ECMAScript 2015 or later (hereafter just JS):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const λv_e = v =&amp;gt; e&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Y Combinator is a higher-order functional: it is a function which takes a functional/higher-order function. Quoting from Might:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Y combinator takes a functional as input, and it returns the (unique) fixed point of that functional as its output. A functional is a function that takes a function for its input. Therefore, the fixed point of a functional is going to be a function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And a “fixed point” is an input to a function equal to the &lt;em&gt;output&lt;/em&gt; of the function. (Not all functions have such.) A fixed point is where &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;) = &lt;em&gt;x&lt;/em&gt;&lt;/span&gt;. He uses the example &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt; − 1&lt;/span&gt;, which has two solutions, two &lt;em&gt;fixed points&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;He starts out with the total recursion form—also known as the “crash all the things!” form—of the Y-combinator. (I’m using letters to denote the version of the combinator; this is Y-naive.)&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Yn = (F) =&amp;gt; F(Yn(F))  // all the recursing!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;“Crash all the things”… because of one pesky little detail: it calls itself immediately, and so recurses infinitely. Which is actually kind of a problem.&lt;/p&gt;
&lt;p&gt;Might then asks: What if we transformed this a bit? He notes that we can &lt;em&gt;transform&lt;/em&gt; with lambda calculus to expand what we’re doing, so:&lt;/p&gt;
&lt;figure&gt;
&lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;) = &lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.(&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;))&lt;/span&gt;
&lt;/figure&gt;
&lt;p&gt;(I haven’t done this kind of thing since undergraduate math work I did for physics, but as I was thinking about it, it made sense. I’m used to trying to &lt;em&gt;remove&lt;/em&gt; extraneous variables when dealing with software, but in this case we’re using it as a tool for transforming the equation into a form that is &lt;em&gt;equivalent&lt;/em&gt; but &lt;em&gt;expressed differently&lt;/em&gt;.)&lt;/p&gt;
&lt;p&gt;And &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.(&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt; is equivalent to the fixed point. It’s the function which takes &lt;span class="math inline"&gt;&lt;em&gt;x&lt;/em&gt;&lt;/span&gt; as an argument and results in &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt;; but &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)&lt;/span&gt; is just another argument, so this looks just like our original &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;) = &lt;em&gt;x&lt;/em&gt;&lt;/span&gt;, but with &lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt;(&lt;em&gt;F&lt;/em&gt;)&lt;/span&gt; substituted for &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;&lt;/span&gt;. Can we write this in JS?&lt;/p&gt;
&lt;p&gt;Here’s my implementation, using modern JS; note that it still recurses. (I’m calling this updated Y-transformed, so &lt;code&gt;Yt&lt;/code&gt;.)&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Yt = (F) =&amp;gt; F((x) =&amp;gt; Yt(F)(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His version:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;function Y(F) { return F(function(x) { return Y(F)(x); }); }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mine and his are equivalent; here’s his version transformed to modern JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; F((x) =&amp;gt; Y(F)(x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Might then says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using another construct called the U combinator, we can eliminate the recursive call inside the Y combinator, which, with a couple more transformations gets us to:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I hated it when profs (or books!) did this when I was in college, and it frustrates me here, too. I want to &lt;em&gt;see&lt;/em&gt; the transformation. I really wish Might didn’t skip how the U combinator works or what transformations he applies, because then he jumps to this form:&lt;/p&gt;
&lt;figure&gt;
&lt;span class="math inline"&gt;&lt;em&gt;Y&lt;/em&gt; = (&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)))(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)))&lt;/span&gt;
&lt;/figure&gt;
&lt;p&gt;Writing this out in JS is going to be a real bear. More to the point, I don’t know how he got to it; now I need to go look up the U Combinator it seems.&lt;/p&gt;
&lt;p&gt;…which I’ve &lt;a href="http://www.ucombinator.org"&gt;now done&lt;/a&gt;. So:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the theory of programming languages, the U combinator, &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;&lt;/span&gt;, is the mathematical function that applies its argument to its argument; that is &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;) = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;, or equivalently, &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt; = &lt;em&gt;λ&lt;/em&gt;&lt;em&gt;f&lt;/em&gt;.&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;That is, the U Combinator is the case where you apply a function to itself: &lt;span class="math inline"&gt;&lt;em&gt;U&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;) = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;f&lt;/em&gt;)&lt;/span&gt;—you can see that in the result there, where the first expression is the same as the argument handed to it (and both are functions). It’s also there in the &lt;span class="math inline"&gt;&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;)&lt;/span&gt; calls.&lt;/li&gt;
&lt;li&gt;The transformations are just transforming from a function-argument for to a lambda form, I think. The kind of thing where you go from &lt;code&gt;function a(b) { return c }&lt;/code&gt; to &lt;code&gt;var a = function(b) { return c }&lt;/code&gt; in JS. (Better, in &lt;em&gt;modern&lt;/em&gt; JS, to &lt;code&gt;const a = (b) =&amp;gt; c&lt;/code&gt;.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I’ll return to that in a moment. First, writing up the JS. The innermost term is (repeated) &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;.((&lt;em&gt;h&lt;/em&gt;(&lt;em&gt;h&lt;/em&gt;))(&lt;em&gt;F&lt;/em&gt;))(&lt;em&gt;x&lt;/em&gt;)&lt;/span&gt;, so we’ll start by writing this out.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const λ_inner = (x) =&amp;gt; (h(h)(F))(x)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need the definition of &lt;span class="math inline"&gt;&lt;em&gt;h&lt;/em&gt;&lt;/span&gt; next; this comes from further out, the transformation &lt;span class="math inline"&gt;&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;h&lt;/em&gt;.&lt;em&gt;λ&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;.&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;λ&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;&lt;em&gt;n&lt;/em&gt;&lt;em&gt;n&lt;/em&gt;&lt;em&gt;e&lt;/em&gt;&lt;em&gt;r&lt;/em&gt;)&lt;/span&gt; (where we’re substituting the &lt;code&gt;λ_inner&lt;/code&gt; we just wrote to make this a bit easier to get our heads around).&lt;/p&gt;
&lt;p&gt;Remembering that each “.” in the equation represents a mapping, i.e. a JS function call, we have this (writing it with function definitions starting new lines to clarify):&lt;/p&gt;
&lt;p&gt;Here’s what I came up with as a fairly direct translation into JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (
  (h) =&amp;gt;
    (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))  // substituting λ_inner from above
) (
  (h) =&amp;gt;
    (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))  // substituting λ_inner from above
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His (note that things are aligned as they are so that it’s clear which functions match up):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;var Y = function (F) {
 return (function (x) {
  return F(function (y) { return (x(x))(y);});
  })
        (function (x) {
  return F(function (y) { return (x(x))(y);});
  }) ;
} ;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His transformed to modern JS:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; (
  (x) =&amp;gt; F((y) =&amp;gt; x(x)(y))
) (
  (x) =&amp;gt; F((y) =&amp;gt; x(x)(y))
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;His and mine are not &lt;em&gt;quite&lt;/em&gt; the same (though I know they’re equivalent because they both work). I really wish he’d explained how he got &lt;em&gt;this&lt;/em&gt; substitution as well! More importantly, I wish he’d been consistent in his notation; changing variable names is… frustrating when you’re trying to follow someone’s work.&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;When I get stuck on something like &lt;em&gt;this&lt;/em&gt;, the way I figure it out is by writing out how the substitutions would work at each step. See below.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;In any case, now that we have the Y combinator, we can use it with &lt;code&gt;FactGen&lt;/code&gt;, a functional which, if you pass it the factorial function, passes back the factorial function. &lt;code&gt;FactGen&lt;/code&gt; itself isn’t recursive. But with the Y Combinator, it builds a function which is &lt;em&gt;not&lt;/em&gt; recursive; it doesn’t reference itself anywhere. It just needs the right kind of “factory”: a function which returns &lt;em&gt;another&lt;/em&gt; funtion which itself &lt;em&gt;is&lt;/em&gt; recursive. Here’s a standard recursive factorial implementation (identical to the one Might supplies, though modernized):&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const FactGen =
  (fact) =&amp;gt;
    (n) =&amp;gt; n === 0 ? 1 : n * fact(n - 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You call that like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;Y(FactGen)(5)  // 120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Y(FactGen)&lt;/code&gt; call gets back a function which then runs on whatever input you hand it (a fairly standard pattern with curried arguments), so you could also write it like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const factorial = Y(FactGen)
factorial(5)  // 120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I’m still not sure how his and mine are equivalent.&lt;/p&gt;
&lt;p&gt;A note: wrapping things in &lt;code&gt;(...)&lt;/code&gt; in JS defines that wrapped content as a distinct &lt;em&gt;expression&lt;/em&gt;. As long as the type of a given expression is a function, it can be called with an argument. So &lt;code&gt;(function() {})()&lt;/code&gt; or &lt;code&gt;(() =&amp;gt; {})()&lt;/code&gt; takes a no-operation function and immediately executes it.&lt;/p&gt;
&lt;p&gt;So in his Y combinator, the substitution goes like this:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Y = (F) =&amp;gt; (  // F is FactGen
  // x is the identical function passed as argument below
  (x) =&amp;gt;
    // Run FactGen by taking the function below as its `fact`
    // argument.
    F(
      // `y` is the argument passed to the result of Y, e.g.
      // `fact(5)`. Recall that `x` is the function below; we
      // call it with itself. Calling x(x) will get the actual
      // factorial function returned by `FactGen`.
      (y) =&amp;gt; x(x)(y)
    )
// We close the *expression* which defines the outer function,
// and call it with this next expression as an argument.
) (
  // and x here is the same function, passed as argument
  (x) =&amp;gt;
    // Again, run `FactGen` with this function as its argument.
    F(
      // `y`, again, will be the integer. `x(x)` again will be
      // the actual factorial function.
      (y) =&amp;gt; x(x)(y)
    )
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is pretty funky! But it works; the two anonymous functions call &lt;em&gt;each other&lt;/em&gt; rather than recursing directly.&lt;/p&gt;
&lt;p&gt;In mine, it goes like this, instead:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;const Ymine = (
  // Where in Might&amp;#39;s example, the `x` function was where the
  // U Combinator was applied, here (because I followed the
  // original notation he gave) it&amp;#39;s `h`. So it&amp;#39;s `h` which is
  // the same function handed back and forth as argument
  // to itself.
  (h) =&amp;gt;
    // `h` takes a functional, which takes `FactGen` as its
    // parameter. This is similar to the outermost function in
    // Might&amp;#39;s version.
    (F) =&amp;gt;
      // As in Might&amp;#39;s version, we call `FactGen` here.
      F(
        // The form is *similar* but not identical to his,
        // because of the extra call structure. `h(h)(F)` is the
        // factorial function.
        //
        // Note that then he has `y` where I have `x`; my `x`
        // and his `y` are just the result of the computation
        // (in this case, the integer factorial).
        (x) =&amp;gt; (h(h)(F))(x))
) (
  // This is identical to the above; it&amp;#39;s using the U Combinator.
  (h) =&amp;gt; (F) =&amp;gt; F((x) =&amp;gt; (h(h)(F))(x))
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is how his simplification worked: instead of generating the factorial function each time, it generated it just the once and then &lt;em&gt;used&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;I still couldn’t &lt;em&gt;do&lt;/em&gt; the simplification he did myself. It’ll take more practice using and thinking about combinators and combinatorial logic before I get there, but that’s okay. That’s how learning works.&lt;/p&gt;
&lt;p&gt;And that’s enough playing with combinatorials for now. (Except that I’m kind of tempted to see if I can go implement the U or Y combinators—or both—in Rust.)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class=editorial&gt;If you’re curious how I worked this out… I expanded the JS representations of the final forms (&lt;a href="//www.chriskrycho.com/extra/ycombinator.js"&gt;here’s the code&lt;/a&gt;) and then stepped through the result in my JavaScript dev tools, watching how the function calls worked and what the values of each intermediate value were. It’s fascinating, and well worth your time.&lt;/i&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 19 Jun 2016 09:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-19:/2016/y-combinators-how-do-they-even-work.html</guid><category>javascript</category><category>software development</category><category>programming languages</category></item><item><title>Rust and Swift (xvi)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xvi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class="editorial"&gt;Thanks to ubsan, aatch, and niconii on the &lt;a href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;amp;channel=%23rust"&gt;#rust-lang IRC&lt;/a&gt; for a fascinating discussion of the current status of Rust’s initialization analysis, as well as some very interesting comments on what might be possible to do in the future. Everything actually interesting about Rust in this post comes from the conversation I had with them on the evening of March 13.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The rules various languages have around construction and destruction of objects are &lt;em&gt;extremely&lt;/em&gt; important for programmer safety and ergonomics. I think it’s fair to say that both Swift and rust are actively trying to avoid some of the mistakes made in e.g. C++ which poorly affect both its safety and its ease of use for developers, albeit it in some superficially different ways. Both languages also support defining how types are destroyed, which we’ll come back to in a future discussion.&lt;/p&gt;
&lt;p&gt;The basic aim both Rust and Swift have in this area seems to be the same: avoid &lt;em&gt;partially&lt;/em&gt; initialized objects. (You don’t want partially initialized objects. Ask Objective C developers.)&lt;/p&gt;
&lt;p&gt;Swift does this via its rules around &lt;em&gt;initializers&lt;/em&gt;. Rust does it by requiring that all the values of a type be initialized at its creation. So, for example, the following &lt;em&gt;looks&lt;/em&gt; like it should work, but it doesn’t. You can initialize the variable piecemeal, but you cannot &lt;em&gt;use&lt;/em&gt; it:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;#[derive(Debug)]  // to make it printable.
struct Foo {
    pub a: i32,
    pub b: f64,
}

fn main() {
    // This will compmile, but `foo` will be useless.
    let mut foo: Foo;
    foo.a = 14;
    foo.b = 42.0;

    // This would actually fail to compile. Surprising? A bit!
    // println!(&amp;quot;{:?}&amp;quot;, foo);

    // This will work, though, because it fully constructs the type.
    let foo2 = Foo { a: 14, b: 42.0 };
    println!(&amp;quot;{:?}&amp;quot;, foo);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(The reasons why this is so are fairly complicated. See the addendum at the end for a brief discussion.)&lt;/p&gt;
&lt;p&gt;In any case, this means that especially with more complex data types, providing standard constructor-style methods like &lt;code&gt;new&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; is conventional and helpful. (If the type has non-public members, it’s also strictly necessary.)&lt;/p&gt;
&lt;p&gt;Swift has a number of options for initializers, which correspond to things you in most cases can do in Rust, but in a very different way.&lt;/p&gt;
&lt;p&gt;First, Swift allows you to overload the &lt;code&gt;init&lt;/code&gt; method on a type, so that you can have different constructors for different starting conditions. (This is, to my recollection, the first time any kind of overloading has come up so far in the Swift book—but that could just be my memory failing me. Certainly I haven’t referenced it in any previous discussion, though.)&lt;/p&gt;
&lt;p&gt;The example offered by the Swift book is illuminating for the different approaches the languages take, so we’ll run with it. Here’s a class defining a Celsius type in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Celsius {
    let temp: Double

    init(fromFahrenheit f: Double) {
       temp = 1.8 * (f - 32.0)
    }

    init(fromKelvin k: Double) {
        temp = k - 273.15
    }
}

// Create an instance each way
let freezing = Celsius(temp: 0)
let balmy = Celsius(fromFahrenheit: 75.0)
let absoluteZero = Celsius(fromKelvin: 0.0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the internal and external parameter names. This is a common idiom Swift keeps (albeit with some non-trivial modification, and with &lt;a href="%7B%3E%3E%20TODO:%20Swift%203%20naming%20changes%20%3C%3C%7D"&gt;more to come&lt;/a&gt;). More on this below; first, the same basic functionality in Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Celsius {
    temp: f64
}

impl Celsius {
    fn from_fahrenheit(f: f64) -&amp;gt; Celsius {
        Celsius { temp: 1.8 * (f - 32.0) }
    }

    fn from_kelvin(k: f64) -&amp;gt; Celsius {
        Celsius { temp: k - 273.15 }
    }
}

// Create an instance each way
let freezing = Celsius { temp: 0 };
let balmy = Celsius::from_fahrenheit(75.0);
let absoluteZero = Celsius::from_kelvin(0.0);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note that there might be other considerations in implementing such types, like using a &lt;code&gt;Temperature&lt;/code&gt; base &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;protocol&lt;/code&gt;, or employing type aliases, but those are for later entries!)&lt;/p&gt;
&lt;p&gt;You can see a point I made about Swift’s initializer syntax back in &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-x.html"&gt;part x&lt;/a&gt;: the way Rust reuses normal struct methods while Swift has the special initializers. Neither is clearly the “winner” here. Rust gets to use existing language machinery, simplifying our mental model a bit by not adding more syntax. On the other hand, the addition of initializer syntax lets Swift use a fairly familiar type construction syntax even for special initializer cases, and a leaves us with a bit less noise in the constructor method. Note, though, that initializers in Swift &lt;em&gt;are&lt;/em&gt; special syntax; they’re not just a special kind of method (as the absence of the &lt;code&gt;func&lt;/code&gt; keyword emphasizes)—unlike Rust, where initializers really are just normal struct or instance methods.&lt;/p&gt;
&lt;p&gt;The Swift book notes this distinction:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In its simplest form, an initializer is like an instance method with no parameters, written using the &lt;code&gt;init&lt;/code&gt; keyword.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The new keyword is the thing I could do without. Perhaps it’s just years of writing Python, but I really prefer it when constructors for types are just sugar and you can therefore reimplement them yourself, provide custom variations, etc. as it suits you. Introducing syntax instead of just picking a standard function to call at object instantiation means you lose that. At the same time, and in Swift’s defense, I’ve only rarely wanted or needed to use those facilities in work in Python. It’s a pragmatic decision—and it makes sense as such; it’s just not where my preference lies. The cost is a bit higher than I’d prefer relative to the gain in convenience.&lt;/p&gt;
&lt;p&gt;Back to the initializers and the issue of overloading: the external parameter names (the &lt;em&gt;first&lt;/em&gt; parameter) is one of the main ways Swift tells apart the initializers. This is necessitated, of course, by the choice of a keyword for the initializer; Rust doesn’t have any &lt;em&gt;need&lt;/em&gt; for this, and since Rust doesn’t have overloading, it also &lt;em&gt;can’t&lt;/em&gt; do this. In Rust, different constructors/initializers will have different names, because they will simply be different methods.&lt;/p&gt;
&lt;p&gt;[&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; I’m leaving this here for posterity, but it’s incomplete. See below.&lt;/i&gt;] One other important thing falls out of this: the external parameter names are &lt;em&gt;required&lt;/em&gt; when initializing a type in Swift. Because those parameter names are used to tell apart the constructor, this is not just necessary for the compiler. It’s also an essential element of making the item readable for humans. Imagine if this were &lt;em&gt;not&lt;/em&gt; the case—look again at the &lt;code&gt;Celsius&lt;/code&gt; example:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Celsius {
    let temp: Double

    init(fromFahrenheit f: Double) {
       temp = 1.8 * (f - 32.0)
    }

    init(fromKelvin k: Double) {
        temp = k - 273.15
    }
}

// Create an instance each way
let freezing = Celsius(0)
let balmy = Celsius(75.0)  // our old fromFahrenheit example
let absoluteZero = Celsius(0.0)  // our old &amp;quot;fromKelvin example&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We as humans would have no idea what the constructors are supposed to do, and really at this point there would &lt;em&gt;necessarily&lt;/em&gt; just be one constructor unless the later options took elements of another &lt;em&gt;type&lt;/em&gt;. That would be fairly similar to how overloading works in C++, Java, or C&lt;sup&gt;♯&lt;/sup&gt;, and while method overloading in those langauges is very &lt;em&gt;powerful&lt;/em&gt;, it can also make it incredibly difficult to figure out exactly what method is being called. That includes when the constructor is being called. Take a look at the &lt;em&gt;long&lt;/em&gt; list of &lt;a href="https://msdn.microsoft.com/en-us/library/system.datetime(v=vs.110)"&gt;C&lt;sup&gt;♯&lt;/sup&gt; &lt;code&gt;DateTime&lt;/code&gt; constructors&lt;/a&gt;, for example: you have to either have this memorized, have the documentation open, or be able simply to infer from context what is going on.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Given&lt;/em&gt; the choice of a keyword to mark initializers, then, Swift’s rule about external parameter name usage wherever there is more than one initializer is quite sensible.&lt;/p&gt;
&lt;p&gt;[&lt;i class='editorial'&gt;&lt;strong&gt;Edit:&lt;/strong&gt; several readers, most notably including &lt;a href="https://twitter.com/jckarter/status/740763363626586112"&gt;Joe Groff&lt;/a&gt;, who works on Swift for Apple, pointed out that Swift &lt;em&gt;does&lt;/em&gt; support overloading, including in &lt;code&gt;init()&lt;/code&gt; calls, and uses types to distinguish them. Moreover, you can leave off the label for the parameter. My initial summary was simply incorrect. I think this is a function of my not having finished the chapter yet.&lt;/i&gt;]&lt;/p&gt;
&lt;p&gt;Second, both languages support supplying default values for a constructed type. Swift does this via default values defined at the site of the property definition itself, or simply set directly from within an initializer:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Kelvin {
    var temp: Double = 0.0  // zero kinetic energy!!!
    init () {
        temp = 305.0  // Change of plans: maybe just freezing is better
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you can not supply default values directly on a property, but you can define any number of custom constructors:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Kelvin {
    temp: f64,
}

impl Kelvin {
    fn abs_zero() -&amp;gt; Kelvin {
        Kelvin { temp: 0.0 }
    }

    fn freezing() -&amp;gt; Kelvin {
        Kelvin { temp: 305.0 }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could of course shorten each of those two one line, so:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn abs_zero() -&amp;gt; Kelvin { Kelvin { temp: 0.0 } }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Rust is definitely a little noisier, and that is the downside of this tack. The upside is that these are just functions like any other. This is, in short, &lt;em&gt;exactly&lt;/em&gt; the usual trade off we see in the languages.&lt;/p&gt;
&lt;p&gt;Rust also has the &lt;code&gt;Default&lt;/code&gt; trait and the &lt;code&gt;#[derive(default)]&lt;/code&gt; attribute for getting some basic defaults for a given value. You can either define a &lt;code&gt;Default&lt;/code&gt; implementation yourself, or let Rust automatically do so if the underlying types have &lt;code&gt;Default&lt;/code&gt; implemented:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Kelvin {
    temp: f64,
}

// Do it ourselves
impl Default for Kelvin {
    fn default() -&amp;gt; Kelvin {
        Kelvin { temp: 305.0 }
    }
}

// Let Rust do it for us: calling `Celsius::default()` will get us a default
// temp of 0.0, since that&amp;#39;s what `f64::default()` returns.
#[derive(default)]
struct Celsius {
    temp: f64,
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn’t get you quite the same thing as Swift’s initializer values. It requires you to be slightly more explicit, but the tradeoff is that you also get a bit more control and flexibility.&lt;/p&gt;
&lt;p&gt;There’s actually a lot more to say about initializers—there are &lt;em&gt;many&lt;/em&gt; more pages in the Swift book about them—but this is already about 1,700 words long, and I’ve been slowly chipping away at it since March (!), so I’m going to split this chapter of the Swift book into multiple posts. More to come shortly!&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Inheritance: a Swiftian specialty (for now).&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/2016/rust-and-swift-xvii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; More on initializers!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;section id="addendum-no-late-initialization-in-rust" class="level2"&gt;
&lt;h2&gt;Addendum: No Late Initialization in Rust&lt;/h2&gt;
&lt;p&gt;Returning to the first Rust example—&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;#[derive(Debug)]  // to make it printable.
struct Foo {
    pub a: i32,
    pub b: f64,
}

fn main() {
    // This will compmile, but `foo` will be useless.
    let mut foo: Foo;
    foo.a = 14;
    foo.b = 42.0;

    // This would actually fail to compile. Surprising? A bit!
    // println!(&amp;quot;{:?}&amp;quot;, foo);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can’t do anything with that data for a few reasons (most of this discussion coming from ubsan, aatch, and niconii on the &lt;a href="https://client00.chat.mibbit.com/?server=irc.mozilla.org&amp;amp;channel=%23rust"&gt;#rust-lang IRC&lt;/a&gt; back in March):&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;Rust lets you “move” data out of a struct on a per-field basis. (Rust’s concept of “ownership” and “borrowing” is something we haven’t discussed a lot so far in this series; my &lt;a href="http://www.newrustacean.com/show_notes/e002/index.html" title="New Rustacean e002: Something borrowed, something... moved?"&gt;podcast episode&lt;/a&gt; about it is probably a good starting point.) The main takeaway here is that you could return &lt;code&gt;foo.a&lt;/code&gt; distinctly from returning &lt;code&gt;foo&lt;/code&gt;, and doing so would hand that data over while running the &lt;code&gt;foo&lt;/code&gt; destructor mechanism. Likewise, you could pass &lt;code&gt;foo.b&lt;/code&gt; to the function created by the &lt;code&gt;println!&lt;/code&gt; macro&lt;/li&gt;
&lt;li&gt;Rust allows you to re-initialize moved variables. I haven’t dug enough to have an idea of what that would look like in practice.&lt;/li&gt;
&lt;li&gt;Rust treats uninitialized variables the same as moved-from variables. This seems to be closely related to reason #2. The same “I’m not sure how to elaborate” qualification applies here.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I’ll see if I can add some further comments on (2) and (3) as I hit the later points in the Swift initialization chapter.&lt;/p&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 07 Jun 2016 23:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-07:/2016/rust-and-swift-xvi.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and C++ function definitions</title><link>http://www.chriskrycho.com/2016/03-1801.html</link><description>&lt;p&gt;I just put my finger on one of the (many) reasons Rust reads better than C++: the visual consistency of its function definitions. Compare—&lt;/p&gt;
&lt;p&gt;Rust has:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;fn foo() -&amp;gt; i32 { /* implementation */ }
fn bar() -&amp;gt; f32 { /* implementation */ }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++ has:&lt;/p&gt;
&lt;pre class="cpp"&gt;&lt;code&gt;int foo() { /* implementation */ }
double bar() { /* implementation */ }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That consistency adds up over many lines of code. There are many other such choices; the net effect is that Rust is &lt;em&gt;much&lt;/em&gt; more pleasant to read than C++.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Note: I’m aware that C++11 added the &lt;code&gt;auto foo() -&amp;gt; &amp;lt;type&amp;gt;&lt;/code&gt; syntax. But this actually &lt;em&gt;worsens&lt;/em&gt; the problem. A totally new codebase which uses that form exclusively (which may not always be possible, because the semantics aren’t the same) would have roughly the same visual consistency as Rust &lt;em&gt;in that particular category&lt;/em&gt;. (Plenty of others would still be a mess.) But the vast majority of C++ codebases are &lt;em&gt;not&lt;/em&gt; totally new. Adding the form means your codebase is more likely to look this this:&lt;/p&gt;
&lt;pre class="cpp"&gt;&lt;code&gt;int foo() { /* implementation */ }
auto quux() -&amp;gt; uint32_t { /* implementation */ }
double bar() { /* implementation */ }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is, for the record, &lt;em&gt;more&lt;/em&gt; visual inconsistency—not less!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 03 Jun 2016 18:01:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-06-03:/2016/03-1801.html</guid><category>programming languages</category><category>rust</category><category>cplusplus</category></item><item><title>Ember.js: "Introducing Subteams"</title><link>http://www.chriskrycho.com/2016/emberjs-introducing-subteams.html</link><description>&lt;p&gt;In which one tech I really like (&lt;a href="http://emberjs.com"&gt;Ember.js&lt;/a&gt;) steals a great idea from another tech I really like (&lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 24 May 2016 19:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-05-24:/2016/emberjs-introducing-subteams.html</guid><category>links</category><category>programming languages</category><category>emberjs</category><category>rust</category></item><item><title>Rust and Swift (xv)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="http://www.chriskrycho.com/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The next chapter in the Swift book focuses on &lt;em&gt;inheritance&lt;/em&gt;, a concept which does not yet exist in Rust.&lt;/p&gt;
&lt;p&gt;Swift embraces classical inheritance for &lt;code&gt;class&lt;/code&gt; data types. As noted &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;previously&lt;/a&gt;, Rust’s &lt;code&gt;struct&lt;/code&gt; covers much of the ground covered by Swift’s &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; types together (value and reference types, etc.). However, what Swift’s &lt;code&gt;class&lt;/code&gt; types bring to the table is inheritance-based (and not just composition-based) extension of types.&lt;/p&gt;
&lt;p&gt;This is a bit of an interesting point: it is an area where, &lt;em&gt;as of today&lt;/em&gt;, Swift can do something that is flat impossible in Rust—a rarity.&lt;/p&gt;
&lt;p&gt;However, the &lt;em&gt;status quo&lt;/em&gt; will be changing sometime in the next year or so, as there is a &lt;a href="https://github.com/rust-lang/rfcs/pull/1210"&gt;Rust RFC&lt;/a&gt; which has been accepted and is in the process of being implemented which paves the way for inheritance. (Discussions are &lt;a href="https://aturon.github.io/blog/2015/09/18/reuse/"&gt;ongoing&lt;/a&gt; as to the best way to implement it for Rust. Classical inheritance with vtables as in Swift is probably &lt;em&gt;not&lt;/em&gt; going to be the approach.)&lt;/p&gt;
&lt;p&gt;The reason Rust’s core team chose to proceed without inheritance for the 1.0 release of the language last May is simple: at a philosophical level, they prefer (as in general most developers increasingly acknowledge that we should all prefer) composition over inheritance. &lt;em&gt;Prefer&lt;/em&gt;, not &lt;em&gt;universally choose&lt;/em&gt;, because there are situations in which inheritance is the correct choice. But there is a reason that programming with interfaces rather than via sub-classing is a “best practice” for many scenarios in languages like Java or C#.&lt;/p&gt;
&lt;p&gt;Rust’s &lt;code&gt;trait&lt;/code&gt; system gives you &lt;em&gt;composition&lt;/em&gt; in some remarkably powerful ways, allowing you to do things that in C++, for example, have to be accomplished via a combination of inheritance and overloading. Swift, likewise, supplies a &lt;code&gt;protocol&lt;/code&gt; system and allows extensions to define further behavior on top of existing data structures. From what I’ve gathered, those approaches are preferred over inheritance in Swift for the same reason Rust shipped 1.0 without it!&lt;/p&gt;
&lt;p&gt;But Swift does have inheritance, so it’s worth seeing how it works.&lt;/p&gt;
&lt;p&gt;First, any &lt;code&gt;class&lt;/code&gt; which doesn’t declare a parent from which to inherit is a base class. This is an important difference from, say, Python, where all classes inherit from &lt;code&gt;Object&lt;/code&gt; (leaving aside custom metaclasses).&lt;/p&gt;
&lt;p&gt;The syntax choices Swift has made around sub-class declarations are sensible and readable: &lt;code&gt;class SubClass: ParentClass&lt;/code&gt; is eminently readable and doesn’t have any obvious points of overlap with other elements in the language.&lt;/p&gt;
&lt;p&gt;Indeed, &lt;em&gt;many&lt;/em&gt; of the choices made around classes are quite sensible. Overrides, for example, are made explicit via the &lt;code&gt;override&lt;/code&gt; keyword. While I’ve sometimes poked fun at Swift’s tendency to add keywords everywhere, this seems like a reasonable place to have one, and it’s nice that overrides are explicit rather than implicit. The same is true of the use of &lt;code&gt;super&lt;/code&gt; to refer to the superclass. I’m not sure of the implementation details, but &lt;code&gt;super&lt;/code&gt; &lt;em&gt;appears&lt;/em&gt; to act as just a special/reserved name for an object: all the syntax around it is normal object instance syntax, which is as it should be.&lt;/p&gt;
&lt;p&gt;The limitations around overriding properties all make sense. You can override a read- or write-only parent property as both readable and writable, but you can’t override a readable or writable property &lt;em&gt;not&lt;/em&gt; to be readable or writable respectively. Presumably this is because the method lookup for properties always checks up the inheritance chain for getters or setters, so if one is present, you can’t just get rid of it. (You could of course override with a no-op function that spews a warning or some such, but that would pretty clearly be an abuse of the parent API. There might be times you would do that with a third-party library parent class, but in your own code it should be avoided: it indicates a problem in your API design that you need to address instead.)&lt;/p&gt;
&lt;p&gt;Finally, we have Swift’s &lt;code&gt;final&lt;/code&gt; keyword—and yes, pun intended. It marks whatever block-level item it is attached to—whether class, method, or property—as non-overridable. Attempts to override an item marked final are compile-time failures. (The same kind of thing exists in Java and C#.) In and of itself, this isn’t especially interesting. It is interesting to ponder whether you should make classes subclass-able or not in your API design. There has been &lt;a href="http://mjtsai.com/blog/2015/12/21/swift-proposal-for-default-final/"&gt;an active debate&lt;/a&gt;, in fact, whether classes in Swift should become final &lt;em&gt;by default&lt;/em&gt; in Swift 3.0, rather than open by default. The debate centers on the danger of unintended consequences of overriding, which ultimately takes us back around to the preference for composition, of course.&lt;/p&gt;
&lt;p&gt;All of this, among other things, raises the very interesting question of what this will look like in Rust when, eventually, we get inheritance there. After all, we know it will be quite different in some ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It presumably won’t involve a distinct data type constructor, &lt;em&gt;a la&lt;/em&gt; Swift’s distinction between &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;: there may be syntactic sugar involved, and there will definitely be new functionality present, but it will certainly be built on the existing language features as well. There’s a good chance it will basically &lt;em&gt;look&lt;/em&gt; like just a special case of &lt;code&gt;impl SomeTrait for SomeStruct&lt;/code&gt;, which would fit very well with the ways Rust solves so many other problems.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rust doesn’t have many of the things which Swift takes care to special-case for overriding with &lt;code&gt;final&lt;/code&gt;, but it will need to address that case for inherited methods and data in some way. (The proposal linked above uses a distinction between &lt;code&gt;default&lt;/code&gt; and blanket implementations for trait specialization to pull this off; if those words don’t mean anything to you, don’t worry: I’ve read that post and RFC half a dozen times before I got a really solid handle on all the pieces involved.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It will be a relative latecomer to the language, rather than baked in from the start, and therefore will likely seem a secondary way of solving problems, especially at first. (This is, I think, both intentional and good.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Indexing and subscripts, or: traits vs. keywords again.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xvi.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Initialization: another area where Swift has a lot more going on than Rust.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Mar 2016 14:45:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-12:/2016/rust-and-swift-xv.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (xiv)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xiv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Rust and Swift both support defining subscript access to a given data type, like &lt;code&gt;SomeType[accessedByIndex]&lt;/code&gt;. Unsurprisingly, given &lt;a href="/rust-and-swift.html"&gt;everything we’ve seen so far&lt;/a&gt;, Rust does this with traits, and Swift with a keyword.&lt;/p&gt;
&lt;p&gt;In Rust, you can define subscript-style access to a type by implementing the &lt;code&gt;Index&lt;/code&gt; and/or &lt;code&gt;IndexMut&lt;/code&gt; traits, which allow &lt;em&gt;indexing&lt;/em&gt; into a given location in a kind of type. The implementation simply requires one function, which is called when you use the &lt;code&gt;[]&lt;/code&gt; operator. That function, &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;index_mut&lt;/code&gt;, implements how to do the lookup for the specific type. The &lt;code&gt;impl&lt;/code&gt; block indicates not only that &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;IndexMut&lt;/code&gt; is being implemented, but also the type of the &lt;em&gt;key&lt;/em&gt; used: &lt;code&gt;impl Index&amp;lt;Bar&amp;gt; for Foo { ... }&lt;/code&gt;, where access would look like &lt;code&gt;a_foo[some_bar]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The two kinds of traits and corresponding methods define the behavior for immutable and mutable data type, as their name suggest.&lt;/p&gt;
&lt;p&gt;Since the trait is defined generically, you can implement whatever kinds of accessors you like to the same underlying data structure, including generics accessors with trait bounds.&lt;/p&gt;
&lt;p&gt;It is perhaps telling that in Rust you just find these traits in the general &lt;code&gt;std::ops&lt;/code&gt; module, where all the core language operations and associated operators are defined. Rust doesn’t do “operator overloading” so much as it simply provides operators as one more class of trait potentially applicable to your type. (The family resemblance to Haskell’s type classes and similar in other languages is obvious.)&lt;/p&gt;
&lt;p&gt;In Swift, you define indexing behavior with the &lt;code&gt;subscript&lt;/code&gt; keyword. Subscripts act very similarly to Swift’s &lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;computed properties&lt;/a&gt;. They can be made read- or write-only by including or excluding &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; function definitions, just like computed properties.&lt;/p&gt;
&lt;p&gt;The behavior is in fact so closely aligned with the computed property syntax and behavior that I initially wondered if it wasn’t just a special case. It is not (though I’m sure much of the parsing machinery can be shared). As the designation of &lt;code&gt;subscript&lt;/code&gt; as a keyword strongly implies, and unlike in Rust, this is a separate language construct, not building on existing language machinery.&lt;/p&gt;
&lt;p&gt;Swift, like Rust, allows you to define arbitrary accessors. However, since the behavior relies on the &lt;code&gt;subscript&lt;/code&gt; construct rather than generics and protocols (Swift’s equivalent to Rust’s traits), you define different kinds of accessors via multiple &lt;code&gt;subscript&lt;/code&gt; blocks. (Presumably these could take generic arguments, but I haven’t tested that to be sure.)&lt;/p&gt;
&lt;p&gt;Both languages proceed to use these as ways of accessing types as makes sense—e.g. for not only arrays or vectors, but also dictionaries in Swift and &lt;code&gt;HashMap&lt;/code&gt; types in Rust.&lt;/p&gt;
&lt;p&gt;Since you can define the behavior yourself, you can also use complex types as keys. The languages approach this a bit differently, though. In Rust, if you wanted a compound key, you would need to define either a simple container &lt;code&gt;struct&lt;/code&gt; or use a tuple as the argument. In Swift, because it uses the same basic syntax as computed properties, you can just define as many method arguments, of whatever type, as you want.&lt;/p&gt;
&lt;p&gt;Takeaway: Rust uses traits; Swift uses a keyword. We probably could have guessed that when we started, at this point!&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Methods, instance and otherwise.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Inheritance: a Swiftian specialty (for now).&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Mar 2016 21:25:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-10:/2016/rust-and-swift-xiv.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>The Future of JavaScript</title><link>http://www.chriskrycho.com/2016/the-future-of-javascript.html</link><description>&lt;p&gt;I gave a short tech talk at my new employer &lt;a href="http://www.olo.com"&gt;Olo&lt;/a&gt; today, covering a number of the changes current and forthcoming in ECMAScript 2015 and later. Alas, I ran out of time in preparation and didn’t get to cover everything I wanted—I would have liked very much to cover modules, and to cover fat-arrow-functions in more depth than I did. I’ll look forward to hopefully giving further tech talks at Olo in the future, and perhaps giving this one, expanded and finished out a bit, elsewhere. (If you’d like me to give a talk, including this one, just let me know!) In the meantime, you can take a look at the &lt;a href="//www.chriskrycho.com/talks/es-future-olo"&gt;slides&lt;/a&gt;, which I think will be helpful and interesting!&lt;/p&gt;
&lt;p&gt;And yes, there &lt;em&gt;were&lt;/em&gt; a lot of really delightful &lt;em&gt;Doctor Who&lt;/em&gt; references in this talk. Because &lt;em&gt;of course&lt;/em&gt; there were!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 02 Mar 2016 12:30:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-03-02:/2016/the-future-of-javascript.html</guid><category>talks</category><category>software development</category><category>programming languages</category><category>javascript</category></item><item><title>Rust and Swift (xiii)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xiii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Rust and Swift both have methods which are attached to given data types. However, whereas Rust takes its notion of separation of data and functions rather strictly, Swift implements them on the relevant data structures (classes, structs, or enums) directly. In other words, the implementation of a given type’s methods is within the body of the type definition itself in swift, whereas in Rust it is in an &lt;code&gt;impl&lt;/code&gt; block, usually but not always immediately adjacent in the code.&lt;/p&gt;
&lt;p&gt;This goes to one of the philosophical differences between the two languages. As we’ve discussed often in the series, Rust reuses a smaller set of concepts—language-level primitives—to build up its functionality. So methods on a type and methods for a trait on a type are basically the same thing in Rust; they’re defined in almost exactly the same way (the latter includes &lt;code&gt;for SomeTrait&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; expression). In Swift, a method is defined differently from a protocol definition, which we’ll get to in the future. The point is simply this: the two take distinct approaches to the relationship between a given type definition and the implementations of any functions which may be attached to it.&lt;/p&gt;
&lt;p&gt;Another important difference: access to other members of a given data type from within a method is &lt;em&gt;explicit&lt;/em&gt; in Rust and &lt;em&gt;implicit&lt;/em&gt; in Swift. In Rust, the first parameter to an instance method is always &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;&amp;amp;self&lt;/code&gt; (or a mutable version of either of course), much as in Python. This explicitness distinction is by now exactly what we expect from the two languages.&lt;/p&gt;
&lt;p&gt;Both use dot notation, in line with most other languages with a C-like syntax, for method calls, e.g. &lt;code&gt;instance.method()&lt;/code&gt; in Swift and &lt;code&gt;instance.method()&lt;/code&gt; in Rust. The latter is just syntactical sugar for &lt;code&gt;T::method(&amp;amp;instance)&lt;/code&gt; or &lt;code&gt;T::method(instance)&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the type of the instance (depending on whether the item is being borrowed or moved). Given its implicit knowledge of/access to instance-local data, and the distinctive behavior of Swift methods (see below), I don’t &lt;em&gt;think&lt;/em&gt; the same is, or even could be, true of Swift.&lt;/p&gt;
&lt;p&gt;All of Swift’s &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-viii.html"&gt;other behaviors around functions&lt;/a&gt;—internal and external names, and all the distinctions that go with those—are equally applicable to methods. Similarly, with the sole change that the first parameter is always the instance being acted on, a Rust methods follow all the same rules as ordinary Rust functions (which is why you can call the struct or enum method with an instance parameter as in the example above).&lt;/p&gt;
&lt;p&gt;Swift does &lt;em&gt;have&lt;/em&gt; a &lt;code&gt;self&lt;/code&gt;—it is, of course, implicit. It’s useful at times for disambiguation—basically, when a parameter name shadows an instance name. This will look familiar to people coming from Ruby.&lt;/p&gt;
&lt;p&gt;The strong distinction Swift makes &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;between reference and value types&lt;/a&gt; comes into play on methods, as you might expect, as does its approach to mutability. Methods which change the values in value types (&lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; instances) have to be declared &lt;code&gt;mutating func&lt;/code&gt;. This kind of explicit-ness is good. As we discussed in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;Part 10&lt;/a&gt;, Rust approaches this entire problem differently: types are not value or reference types; they are either mutable and passed mutably (including as &lt;code&gt;mut self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or they are not. If an instance is mutable and passed mutably, a method is free to act on instance data. And in fact both languages require that the instance in question not be immutable. In fact, everything we said in Part 10 about both languages applies here, just with the addendum that private properties are available to methods.&lt;/p&gt;
&lt;p&gt;The distinction, you’ll note, is in where the indication that there’s a mutation happens. Swift has a special keyword combination (&lt;code&gt;mutating func&lt;/code&gt;) for this. With Rust, it’s the same as every other function which mutates an argument. This makes Rust slightly more verbose, but it also means that in cases like this, the existing language tooling is perfectly capable of handling what has to be a special syntactical case in Swift.&lt;/p&gt;
&lt;p&gt;Both Swift and Rust let you out-and-out change the instance by assigning to &lt;code&gt;self&lt;/code&gt;, albeit in fairly different ways. In Swift, you’d write a mutating method which updates the instance proper like this:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Point {
    var x = 0.0, y = 0.0
    mutating func changeSelf(x: Double, y: Double) {
        self = Point(x: x, y: y)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you’d need to explicitly pass a mutable reference and dereference it. (If you tried to pass &lt;code&gt;mut self&lt;/code&gt; instead of &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, it would fail unless you returned the newly created object and assigned it outside.) Note that while the full implementation here is a couple lines longer, because of the data-vs.-method separation discussed earlier, the implementation of the method itself is roughly the same length.&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;pub struct Point {
    pub x: f64,
    pub y: f64,
}

impl Point {
    pub fn change_self(&amp;amp;mut self, x: i32, y: i32) {
        *self = Point { x: x, y: y };
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that though you &lt;em&gt;can&lt;/em&gt; do this, I’m not sure it’s particularly Rustic. My own instinct would be to get a &lt;em&gt;new&lt;/em&gt; &lt;code&gt;Point&lt;/code&gt; rather than mutate an existing one, in either language, and let the other be cleaned up “behind the scenes” as it were (with automatic memory management in Swift or the compiler’s automatic destruction of the type in Rust)—purer functions being my preference these days.&lt;/p&gt;
&lt;p&gt;You can do this with &lt;code&gt;enum&lt;/code&gt; types as well, which the Swift book illustrates with a three-state switch which updates the value type passed to a new value when calling its &lt;code&gt;next()&lt;/code&gt; method. You can do the same in Rust, with the same reference/dereference approach as above.&lt;/p&gt;
&lt;p&gt;Here’s a three-state switch in Swift:&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;enum ThreeState {
    case First, Second, Third
    mutating func next() {
        switch self {
        case First:
            self = Second
        case Second:
            self = Third
        case Third
            self = First
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the same in Rust:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;enum ThreeState { First, Second, Third }
impl ThreeState {
    pub fn next(&amp;amp;mut self) {
        match *self {
            ThreeState::First =&amp;gt; *self = ThreeState::Second,
            ThreeState::Second =&amp;gt; *self = ThreeState::Third,
            ThreeState::Third =&amp;gt; *self = ThreeState::First,
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both languages also have what Swift calls “type methods”, and which you might think of as “static class methods” coming from a language like Java or C♯. In Swift, you define them by adding the &lt;code&gt;static&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; keywords to the &lt;code&gt;func&lt;/code&gt; definition. The &lt;code&gt;class func&lt;/code&gt; keyword combo is only applicable in &lt;code&gt;class&lt;/code&gt; bodies, and indicates that sub-classes may override the method definition.&lt;/p&gt;
&lt;pre class="swift"&gt;&lt;code&gt;struct Bar {
    static func quux() { print(&amp;quot;Seriously, what&amp;#39;s a `quux`?&amp;quot;) }
}

func main() {
    Bar.quux()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust, you simply drop &lt;code&gt;self&lt;/code&gt; as a first parameter and call it with &lt;code&gt;::&lt;/code&gt; syntax instead of &lt;code&gt;.&lt;/code&gt; syntax:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;struct Bar;
impl Bar {
    pub fn quux() { println!(&amp;quot;Seriously, what&amp;#39;s a `quux`?&amp;quot;); }
}

fn main() {
    Bar::quux();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, Rust chooses to use existing language machinery; Swift uses new (combinations of) keywords.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Properties: type and instance, stored and computed.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xiv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Indexing and subscripts, or: traits vs. keywords again.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 28 Feb 2016 11:15:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-02-28:/2016/rust-and-swift-xiii.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>“I Don't Know When I'd Use That”</title><link>http://www.chriskrycho.com/2016/i-dont-know-when-id-use-that.html</link><description>&lt;p&gt;I was reading an interesting Stack Overflow &lt;a href="http://stackoverflow.com/questions/21170493/when-are-higher-kinded-types-useful"&gt;discussion&lt;/a&gt; of the value of &lt;a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala"&gt;higher-kinded types&lt;/a&gt; (hereafter &lt;abbr&gt;HKTs&lt;/abbr&gt;), and noted someone repeatedly commenting, “But when would you use this in a &lt;em&gt;real app&lt;/em&gt;?” To put it the way another &lt;a href="https://m4rw3r.github.io/rust-and-monad-trait/"&gt;blog post&lt;/a&gt; about &lt;abbr&gt;HKTs&lt;/abbr&gt; (in Rust), they are “a feature people do not really know what to do with.”&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: I’m sympathetic to that desire for concrete examples. I’m interested in these kinds of things not primarily for their intellectual value but for their pragmatic value (though I don’t think those two are as distinct as many people do). I’d &lt;em&gt;also&lt;/em&gt; love to see some more real-world examples in those discussions. All too often, the discussions of types in Haskell end up being quite abstract and academic—no surprise, given the language’s origin. But I’m also aware that quite often it’s difficult to see how a given kind of abstraction is useful without jumping into a language which has that abstraction available and &lt;em&gt;using&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;People often get turned off by Haskell (and other similarly high-abstraction languages like Scala) because of challenging terms like &lt;em&gt;monad&lt;/em&gt;, &lt;em&gt;applicative&lt;/em&gt;, &lt;em&gt;functor&lt;/em&gt;, and so on. And again: I get that. To grok Haskell, you need to wrap your head around a lot of &lt;em&gt;math&lt;/em&gt; ideas—mainly various properties of &lt;em&gt;sets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But I remember feeling the same way six years ago when I started playing with JavaScript and jQuery and every tutorial out there simply assumed existing familiarity and comfort with functions as arguments or return values. Coming from the world of Fortran and C, my head ached for weeks as I tried to make sense of what I was seeing. Even when I finally got it, &lt;em&gt;I didn’t like it&lt;/em&gt;. Over the last several years, though, I’ve become increasingly comfortable and even reliant on closures, composition of functions to transform data, and so on as I worked regularly in Python and JavaScript.&lt;/p&gt;
&lt;p&gt;That experience has taught me that my current inability to see the utility of a given abstraction means little about the abstraction. It’s primarily an indicator of my own inexperience.&lt;/p&gt;
&lt;p&gt;To the question of the utility &lt;abbr&gt;HKTs&lt;/abbr&gt; in general—in Haskell, Rust, or somewhere else—I don’t have the knowledge myself (yet) to supply a good answer. Heck, I can’t even &lt;em&gt;explain&lt;/em&gt; them very well. (&lt;a href="http://adriaanm.github.io/research/2010/10/06/new-in-scala-2.8-type-constructor-inference/"&gt;Other people can, though!&lt;/a&gt;) But I can say that reading &lt;a href="https://gumroad.com/l/maybe-haskell"&gt;&lt;em&gt;Maybe Haskell&lt;/em&gt;&lt;/a&gt; showed me clearly that such things can be very useful. Even if I am not yet comfortable using that tool, I see how learning to use it would be profitable in the long-term. And like any good tool, even if you don’t need it every day… when you want it, you &lt;em&gt;really&lt;/em&gt; want it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 17 Jan 2016 10:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-01-17:/2016/i-dont-know-when-id-use-that.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>haskell</category></item><item><title>Rust and Swift (xi)</title><link>http://www.chriskrycho.com/2016/rust-and-swift-xi.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past few months. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I’ve still been (slowly) working through the Swift book and comparing Swift and Rust; I have another draft started which I’ll hopefully finish this week. And I still find the comparison deeply profitable. The two languages continue to evolve in interesting ways, and the comparison is all the more interesting &lt;a href="https://github.com/apple/swift"&gt;now that Swift is open-source&lt;/a&gt; and its future &lt;a href="https://github.com/apple/swift-evolution"&gt;open for community input&lt;/a&gt; (just as &lt;a href="https://github.com/rust-lang/rfcs"&gt;Rust is&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Something I’ve been thinking about for several months, and which the &lt;a href="https://overcast.fm/+CdSzsTIY/1:16:42"&gt;brief discussion of Swift, Go, and Rust&lt;/a&gt; at the end of the latest &lt;a href="http://atp.fm/episodes/151"&gt;Accidental Tech Podcast&lt;/a&gt; brought back to my mind, is the question of what the next generation of systems-level programming language should be. And my answer is: there shouldn’t be &lt;em&gt;just one&lt;/em&gt;. The best possible thing for the space, in many ways, is for there to be a healthy diversity of options and lots of competition in the space. We don’t want to have &lt;em&gt;ten&lt;/em&gt; different systems programming languages to deal with, I think—but three or four or five would be &lt;em&gt;much&lt;/em&gt; preferable to having one or two (closely related) as we have in the decades of C and C++ dominance.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong: both languages (and perhaps especially C) do many things exceptionally well. For all that they are (justly) maligned for some of their problems, the longevity of both C and C++ has a great deal to do with how well they fit the problem domain, and how much they’ve empowered developers to accomplish within that space (which is very, &lt;em&gt;very&lt;/em&gt; large).&lt;/p&gt;
&lt;p&gt;The problem, though, at least as I see it, is that the existence of only two really serious systems programming languages for the last several decades has led a lot of developers to think that C and C++‘s ways of solving problems are the &lt;em&gt;only&lt;/em&gt; way to solve problems. The languages we use shape the way we think about possible solutions, and when a given language doesn’t recognize entire classes of different approaches, that deeply limits developers’ ability to tackle certain issues. (See also the interesting CppCast &lt;a href="http://cppcast.com/2015/10/andrei-alexandrescu/"&gt;interview with D’s Andrei Alexandrescu&lt;/a&gt; in which he makes similar points.)&lt;/p&gt;
&lt;p&gt;The most obvious thing missing from both is the ability to do truly functional-style programming. C of course is also lacking classes and thus is much more difficult to use for any sort of object-oriented programming.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; Neither has anything remotely like Rust’s traits or Swift’s extensions; C++ has only gotten lambdas recently.&lt;/p&gt;
&lt;p&gt;All of this comes out to mean that the set of &lt;em&gt;tools&lt;/em&gt; available to systems programmer has necessarily been missing any number of things available in languages outside that context. In some cases, this may be a necessary consequence of the kinds of programming being done: when you need totally deterministic memory and compiler behavior, dynamic typing and a non-trivial runtime are simply not options. But in many cases, they are simply a function of the history of the languages’ development and history. Being an ALGOL descendant, and especially a C descendant, means there are some fundamental choices about the language which will differ from those made in a language descended from ML.&lt;/p&gt;
&lt;p&gt;All of which is to say: C and C++ have been really useful tools in many ways, but having &lt;em&gt;only&lt;/em&gt; C and C++ available for serious systems programming work over the last decades has left many developers blind to or simply unaware of the real advantages other paradigms might offer them.&lt;/p&gt;
&lt;p&gt;So going forward, I don’t want there to be &lt;em&gt;a winner&lt;/em&gt; in the systems programming space. I’d rather see D, Rust, Swift, Go, and maybe even a few other contenders all stay strong—finding their own niches and continually pushing each other and learning from each other. That will give us a space in which different languages are free to try out different approaches to the same problems, without being tied to the specific constraints faced by other languages. Built-in greenthreading? Go! Hindley-Milner types, memory safety, and zero runtime? Rust! Something in beween, highly expressive and with different type systems and tradeoffs around memory management, etc.? Swift, or D!&lt;/p&gt;
&lt;p&gt;Having a robust, thriving set of competitors in the market will be good for the languages themselves. But it will also be good for developers. It will take off some of the blinders that come from a single language (or a pair of very closely related languages) dominating the ecosystem. It will make it likelier that people will be more familiar with different programming paradigms. And that can only be a good thing, as far as I’m concerned.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-x.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Classes and structs (product types), and reference and value types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2016/rust-and-swift-xii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Properties: type and instance, stored and computed.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;It is of course entirely possible to do non-classical OOP; the point is that C entirely lacks &lt;em&gt;language-level&lt;/em&gt; facilities for OOP, inheritance, etc.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 10 Jan 2016 10:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2016-01-10:/2016/rust-and-swift-xi.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming-languages</category></item><item><title>Rust and Swift (v)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-v.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I’ve been working on learning Swift over the past couple weeks, and had spent the month prior to that doing a deep first dive on Rust. This kind of approach, learning two languages basically at the same time, is entirely new to me, and for good reason. Programming languages are not trivial to learn, and to learn them meaningfully one must practice with them a great deal.&lt;/p&gt;
&lt;p&gt;I’m doing this largely of necessity. I’m hoping to build an application with a very capable, performant cross-platform core language (Rust), but planning to ship a native OS X app (first) when all is said and done. My desire to make the core libraries portable rules out Swift immediately. To be frank, so does the fact that it’s an Apple language: I am happy to use Apple’s tools on its platform, but I don’t want to shackle myself to their choices in the long run. Too, having good Rust experience is likely to be valuable in many other contexts.&lt;/p&gt;
&lt;p&gt;So I need to learn both.&lt;/p&gt;
&lt;p&gt;And, while I wouldn’t ordinarily recommend this course of action—indeed, unless you already have a fair bit of programming experience and already know several languages, I’d actively recommend against it—I’m finding it enormously profitable. The languages have been designed in roughly the same time frame, cite many of the same influences, and overlap substantially in terms of audience and goals. Yet they are, as this series has already highlighted, quite different languages in many ways.&lt;/p&gt;
&lt;p&gt;Learning them in parallel is helping me see the trade-offs each one has made, and force me to think about &lt;em&gt;why&lt;/em&gt; they differ in the ways they do. In particular, I think I have a much better idea what’s going on “under the covers” in each language and therefore know what to expect of them better. This, in turn, has dramatically deepened my grasp of the languages relative to the amount I’ve been looking at them, compared to previous language-learning efforts. (It also helps that I’ve already learned a number of languages, of course, and that I’ve been pushing my brain into the learning-programming-languages space via reading about Haskell, functional patterns in JavaScript, and so on this year.)&lt;/p&gt;
&lt;p&gt;I have a long way to go in both languages, of course. Reading on nights and weekends, and the little bit of playing I’ve been able to do with each of them, is no replacement for just sinking my teeth into a project and finding the pain points. Nonetheless, I’m really glad to be learning these two languages &lt;em&gt;together&lt;/em&gt;. If you’re up for a challenge, try it sometime! You’ll be surprised how much you learn.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iv.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-vi.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Collection types and the difference between syntax and semantics.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Sep 2015 13:45:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-12:/2015/rust-and-swift-v.html</guid><category>software development</category><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>If-expressions in Rust</title><link>http://www.chriskrycho.com/2015/if-expressions-in-rust.html</link><description>&lt;p&gt;I love the fact that all &lt;code&gt;if&lt;/code&gt; statements in Rust are expressions. It gives you a great deal of expressitivity in the language.&lt;/p&gt;
&lt;p&gt;Let’s contrast with Python (which I love, for the record). In Python, you can do something like this:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;some_condition = True
if some_condition:
    a_value = &amp;quot;Yeah!&amp;quot;
else:
    a_value = &amp;quot;Oh, sads.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Those are &lt;em&gt;statements&lt;/em&gt; in the body of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; block; you can’t assign the block itself to &lt;code&gt;a_value&lt;/code&gt;. However, like C, C++, Java, etc., Python does provide an &lt;em&gt;expression&lt;/em&gt;-type conditional, a ternary expression.&lt;/p&gt;
&lt;p&gt;So you can also do this:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;some_condition = True
a_value = &amp;quot;Yeah&amp;quot; if some_condition else &amp;quot;Oh, sads.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This expression form of the &lt;code&gt;if&lt;/code&gt; block is what all Rust &lt;code&gt;if&lt;/code&gt; blocks are. So in Rust, the normal long form is:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition {
    &amp;quot;Yeah!&amp;quot;
}
else {
    &amp;quot;Oh, sads.&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You could also write this with a &lt;code&gt;let mut a_value&lt;/code&gt; and then set its value inside the conditional blocks, but that’s not at all good form in Rust.)&lt;/p&gt;
&lt;p&gt;And of course, you can shorten that rather nicely where the expressions are brief enough:&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition { &amp;quot;Yeah!&amp;quot; } else { &amp;quot;Oh, sads.&amp;quot; }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this gets really nice when you have more complicated work to do in a Rust conditional. It doesn’t matter how many things going on inside an &lt;code&gt;if&lt;/code&gt; expression; it’s still an expression. As such, you can also write this:&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="rust"&gt;&lt;code&gt;let some_condition = true;
let a_value = if some_condition {
    let the_answer = 42;
    let theme = &amp;quot;Take my love, take my land...&amp;quot;;
    &amp;quot;Yeah!&amp;quot;  // An expression!
}
else {
    let the_question = &amp;quot;What do you get when you multiply six by nine?&amp;quot;;
    let song = &amp;quot;You can&amp;#39;t take the sky from me!&amp;quot;;
    &amp;quot;Oh, sads.&amp;quot;  // An expression!
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously this is totally contrived and silly; the point is that no matter what the internals are, &lt;code&gt;if&lt;/code&gt; blocks are expressions, and their final expressions can be assigned like any other.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;As a note: I got here because I was originally thinking you couldn’t do a one-liner like you can in Python. As shown above, that’s totally false, and in fact the Rust version is much more capable than Python’s, because you don’t need a dedicated ternary when all &lt;code&gt;if&lt;/code&gt; blocks are expressions. Rust used to have a C-style ternary (&lt;code&gt;&amp;lt;condition&amp;gt; ? &amp;lt;value if true&amp;gt; : &amp;lt;value if false&amp;gt;&lt;/code&gt;) but it was &lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;removed&lt;/a&gt; during the lead-up to the 1.0 release—a decision I wholeheartedly affirm.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note that under normal conditions the compiler won’t actually accept this because of the unused names.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 12 Sep 2015 11:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-12:/2015/if-expressions-in-rust.html</guid><category>software development</category><category>programming languages</category><category>rust</category><category>python</category></item><item><title>Rust and Swift (iv)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iv.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Both Swift and Rust directly address the issue of having to worry about memory allocation and safety. They do it in different ways, though: Swift by automatic reference counting, Rust by its concept of ownership. For a lot of day-to-day development, I can see the Swift approach being a win for the same reason a language like Python or Ruby is: having that all handled for you is &lt;em&gt;nice&lt;/em&gt;. Having the power Rust gives you comes at the price of increased cognitive load from having to reason about ownership.&lt;/p&gt;
&lt;p&gt;To put it another way: all programming languages have to make trade offs. Although I like Rust’s better than Swift’s so far, I’ve no doubt I will find any number of things to appreciate about Swift over Rust. You can’t have everything.&lt;/p&gt;
&lt;p&gt;This caught my attention in part because dealing with things like strings (or other pass-by-value types) in Swift is rather more straightforward than in Rust. The outcomes are much the same, but since &lt;em&gt;all&lt;/em&gt; &lt;code&gt;String&lt;/code&gt;s in Swift are passed by value (never by reference), you simply don’t have to think about modification—even safe modification!&lt;/p&gt;
&lt;p&gt;Rust of course had the &lt;code&gt;Copy&lt;/code&gt; trait which lets you do this, but the point is that the “ergonomics” are slightly nicer in Swift.&lt;/p&gt;
&lt;p&gt;Also, the string interpolation Swift does is &lt;em&gt;nice&lt;/em&gt;. That’s one thing I really wish Rust had. It’s Python-style string formatting macro is great, but being able to interpolate values (&lt;code&gt;&amp;quot;strings with \(variables)&amp;quot;&lt;/code&gt; or even &lt;code&gt;&amp;quot;embedded expressions like \(2 + 4)&amp;quot;&lt;/code&gt;) is very nice.&lt;/p&gt;
&lt;p&gt;Swift’s approach to strings in general seems well-thought-through and gives appropriate levels of attention to the details which make handling complex or non-Western languages much more manageable. As a typography geek, I appreciate this a great deal.&lt;/p&gt;
&lt;p&gt;That said, since Swift’s strings &lt;em&gt;do&lt;/em&gt; handle all those edge cases for Unicode, you lose some standard string access patterns and lose much (maybe all?) insight into the internal structure of the string. That may be good, and may be bad, depending on the circumstance. Like I said: trade-offs.&lt;/p&gt;
&lt;p&gt;Actually, on reading further, the way Swift handles Unicode strings is pretty nice. It &lt;em&gt;does&lt;/em&gt; give you insight into those, via specific methods for different representations. I particularly appreciate that it’s you deal with them as the standalone &lt;code&gt;String&lt;/code&gt; type as well as giving you direct access to the code points—and not just one Unicode code point set, but any of &lt;abbr&gt;UTF8&lt;/abbr&gt;, &lt;abbr&gt;UTF16&lt;/abbr&gt;, or &lt;abbr&gt;UTF32&lt;/abbr&gt; (Unicode scalars). Trust Apple to pay close attention to text.&lt;/p&gt;
&lt;p&gt;Rust’s strings are &lt;em&gt;good&lt;/em&gt;, but not quite as sophisticated (presumably for simplicity around the memory mapping). All Rust &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;str&lt;/code&gt; instances are composed of &lt;abbr&gt;UTF32&lt;/abbr&gt; Unicode scalars, encoded as &lt;abbr&gt;UTF8&lt;/abbr&gt; sequences. It doesn’t have some of the convenience methods Swift does for getting any of the other representations. That said, I expect this should show up rarely if at all in my ordinary usage. Importantly, the fundamental storage is the same: both use scalars.&lt;/p&gt;
&lt;p&gt;This was the first section where it didn’t feel like Rust was just a clear overall “winner” over Swift. Some of the trade offs between the language designs are more apparent here, and I do appreciate the “ergonomics” of Swift in a number of these things.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-v.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; The value (and challenge) of learning languages in parallel.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Thu, 10 Sep 2015 21:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-10:/2015/rust-and-swift-iv.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (iii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-iii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;I just hit operators in the Swift book. First question: are operators special syntax, or are they sugar for &lt;code&gt;protocol&lt;/code&gt;s? (Every modern language I use or even have played with handles them as sugar for another language construct—Python, Ruby, Io, Elixir, and Rust, to name just a few ranging over a substantial variety of ages and styles.)&lt;/p&gt;
&lt;p&gt;Oh. I did the requisite digging, and operators are functions (which is okay) defined in the &lt;del&gt;global namespace (&lt;em&gt;:sigh:&lt;/em&gt;)&lt;/del&gt; Swift module.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; I say “okay” rather than good because the justification offered is that this is the only way to make the operators work as binary operators between existing instances of types. But that elides the fact that, if that’s the case, it is so because of other language design decisions. This seems like a perfect place to use a &lt;code&gt;protocol&lt;/code&gt;, but perhaps (unlike Rust’s &lt;code&gt;trait&lt;/code&gt;) they’re not sufficiently capable to handle this? That’s an open question; I have no idea about the answer.&lt;/p&gt;
&lt;p&gt;Interestingly, Rust has several fewer operators than Swift, even apart from those mentioned in my &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;previous post&lt;/a&gt;. It drops the pre- and post-increment operators entirely (as does Python), since their results can always be accomplished in other ways with less potential for confusion. Swift keeps them, no doubt in part because most (Objective) C programs are deeply familiar with them and with idioms associated with them.&lt;/p&gt;
&lt;p&gt;I learned a few new things about Rust’s operators as well: the Boolean &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators and its bitwise &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operators differ not only in that the former are &lt;em&gt;short-circuit&lt;/em&gt; operators and the latter are not. Obviously you can also do things like bit-wise flag operations with the latter, but the reference emphasizes the short-circuiting behavior. This makes perfect sense, but it wasn’t something I’d ever considered explicitly before.&lt;/p&gt;
&lt;p&gt;There is no ternary operator in Rust, because of how it handles the relationship between expressions and statements. Swift keeps it. That’s an interesting reflection of differences in design: Rust dropped it because &lt;code&gt;if&lt;/code&gt; blocks are expressions, so it’s redundant, and they have had a goal of removing unnecessary features. (See the discussion on dropping the ternary operator—with an interesting aside from Brendan Eich on JavaScript—&lt;a href="https://github.com/rust-lang/rust/issues/1698"&gt;here&lt;/a&gt;). Note that this is not a criticism of Swift, just an observation, though I do really like Rust’s expression-driven approach.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;??&lt;/code&gt; “nil coalescing operator”, on the other hand, I actively dislike. This seems like shorthand for the sake of shorthand, partly necessitated by the existing drive toward shorthand with optional types in Swift. Sometimes brevity can lead to decreased clarity. Eliding too much, or subsuming it into shorthand, makes the language harder to hold in your head and requires you to slow down more for parsing each line.&lt;/p&gt;
&lt;p&gt;Nothing surprising (or different) between the standard boolean operators in the two languages.&lt;/p&gt;
&lt;p&gt;I wonder how many times the word “concise” (or synonyms of it) appear in the Swift book? It’s increasingly clear to me reading that brevity is one of the primary design goals. Maybe it’s just me, but that actually seems a little weird. Brevity is good so far as it goes, but &lt;em&gt;legibility&lt;/em&gt; is much better.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iv.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Language design tradeoffs, highlighted by string manipulation.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;See edit in discussion of functions and global namespace in &lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;part ii&lt;/a&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 07 Sep 2015 11:55:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-07:/2015/rust-and-swift-iii.html</guid><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>Rust and Swift (ii)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-ii.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;I am reading through the Swift book, and comparing it to Rust, which I have also been learning over the past month. As with the other posts in this series, these are off-the-cuff impressions, which may be inaccurate in various ways. I’d be happy to hear feedback! Note, too, that my preferences are just that: preferences. Your tastes may differ from mine. &lt;a href="/rust-and-swift.html"&gt;(See all parts in the series.)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;At first blush, I find the extra syntax around optionals in Swift more confusing than helpful. I think this comes down to my preference for a more Python-like approach: “Explicit is better than implicit” and “There should be one– and preferably only one –obvious way to do it” both militate against the multiple different ways you can handle optional values in Swift. &lt;code&gt;Optional&lt;/code&gt; types are created in one of two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with the &lt;code&gt;?&lt;/code&gt; operator on a type definition, creating an explicitly wrapped type which must be checked in some way.&lt;/li&gt;
&lt;li&gt;with the &lt;code&gt;!&lt;/code&gt; operator on a type definition, creating an “implicitly unwrapped optional” by forcibly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After creating an optional, you can get at its contents by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using the &lt;code&gt;if let&lt;/code&gt; or &lt;code&gt;while let&lt;/code&gt; constructs to bind the optional value’s non-&lt;code&gt;nil&lt;/code&gt; value for a block&lt;/li&gt;
&lt;li&gt;using the &lt;code&gt;!&lt;/code&gt; operator on a variable name, explicitly unwrapping it (and creating a runtime error if the optional is empty)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By contrast, in Rust you always have to explicitly unwrap the item, using the &lt;code&gt;unwrap&lt;/code&gt; method or pattern matching. There are no implicitly unwrapped types. Moreover, there is no special syntax around creating optional types in Rust: you just declare them with an &lt;code&gt;Option&lt;/code&gt; type or another type that &lt;code&gt;impl&lt;/code&gt;s the &lt;code&gt;Option&lt;/code&gt; behavior. The “shortcut” behavior around error handling, &lt;code&gt;try!&lt;/code&gt;, isn’t special syntax, but application of another standard language construct (in this case, a macro).&lt;/p&gt;
&lt;p&gt;The discussion of &lt;code&gt;assert&lt;/code&gt; in the Swift book re-raises the question about the global namespace:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“You write an assertion by calling the global &lt;code&gt;assert(_:_:)&lt;/code&gt; function.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This continues to suggest strongly that Swift does in fact have a true global namespace, &lt;em&gt;not&lt;/em&gt; an automatically-imported prelude. That can make a big difference for applications in certain spaces (e.g. systems programming), when you might have good reason to want to replace the standard library’s approach with a different one. (See Rust’s &lt;a href="https://doc.rust-lang.org/book/no-stdlib.html"&gt;&lt;code&gt;#[no_std]&lt;/code&gt;&lt;/a&gt; docs and the &lt;a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md"&gt;related RFC&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; “strongly suggests” or no, I have now been &lt;a href="https://twitter.com/jckarter/status/708765262309228544" title="Tweet by one of the Swift developers"&gt;reliably informed&lt;/a&gt; that I was mistaken—and am happy to have been wrong here. As in Haskell, these functions are implicitly imported and belong to the &lt;code&gt;Swift&lt;/code&gt; module.&lt;/p&gt;
&lt;p&gt;In Rust, &lt;code&gt;assert!&lt;/code&gt; is a macro, not a function, which is an interesting but perhaps not &lt;em&gt;especially&lt;/em&gt; important distinction in this particular case. (It might be, though; I’d have to see the implementation of each to see how they play out differently.)&lt;/p&gt;
&lt;p&gt;In any case, this also highlights another large difference between the two: testing is &lt;a href="https://doc.rust-lang.org/stable/book/testing.html"&gt;front and center&lt;/a&gt; in Rust, and barely receives a mention so far in the Swift book (and isn’t in the table of contents). Having language-level support for testing is a big deal.&lt;/p&gt;
&lt;p&gt;Language tour and first chapter of the language guide down, my sense is that Swift is a substantially better language than C or C++ (and presumably than Objective C, but since I don’t know that language I can’t speak to it) for app design, but that Rust is a better language yet. Both a far more modern than their predecessors, but they approach the same problems in surprisingly different ways, relatively similar syntax notwithstanding. So far, I like the Rust approach better.&lt;/p&gt;
&lt;p&gt;In particular, more syntax is not my preferred way to tackle these things. Providing good language constructs and primitives on which to build seems better in &lt;em&gt;many&lt;/em&gt; ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It substantially reduces the cognitive load for the developer, by keeping the number of constructs small and simply varying how they are applied.&lt;/li&gt;
&lt;li&gt;It increases the quality of those primitives, because it forces the language deadness to make sure they actually address the full problem space.&lt;/li&gt;
&lt;li&gt;It lets developers approach the same problem in ways the language design team may not have anticipated, and over time the community may find shared conventions that improve on the &lt;code&gt;std&lt;/code&gt; approach, and nothing has to change in the language spec (or the compiler!) to adopt those changes.&lt;/li&gt;
&lt;li&gt;In general, then, it makes change much easier to manage, and change can be community-driven rather than requiring the language design team to manage it.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-i.html"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Thoughts after reading the introduction to the Swift book.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-iii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Operators, including overloading, and thoughts on brevity.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This may of course be intentional on Apple’s part with Swift. Maintaining tight control over its tooling is very typical of modern Apple.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 06 Sep 2015 10:20:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-06:/2015/rust-and-swift-ii.html</guid><category>rust</category><category>swift</category><category>rust-and-swift</category><category>programming languages</category></item><item><title>Rust and Swift (i)</title><link>http://www.chriskrycho.com/2015/rust-and-swift-i.html</link><description>&lt;p&gt;&lt;i class=editorial&gt;I started writing these responses in a Slack channel of developers I participate in as I worked through the &lt;a href="https://developer.apple.com/swift/"&gt;Swift&lt;/a&gt; &lt;a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/"&gt;book&lt;/a&gt;. I realized after a bit that it would make a better blog post than chat room content, so here we are. This is all entirely off-the-cuff: me just thinking out loud as I read; this is by no means expert opinion.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class=editorial&gt;I later turned this into the first part of a whole &lt;a href="/rust-and-swift.html"&gt;series&lt;/a&gt; comparing Rust and Swift!&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;..&amp;lt;&lt;/code&gt; – seriously?&lt;/p&gt;
&lt;p&gt;That has to be one of the most annoying operators I’ve ever seen. It ends up with cognitive noise because &lt;code&gt;&amp;lt;name&lt;/code&gt; initially processes as “starting a generic” and you have to re-parse it visually and mentally.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After the first chapter of the Swift book, my impression is “a poor man’s Rust”; my gut feel based on that first pass and everything I’ve seen and read about Swift over the past two years is that it’s roughly what you would get if you took Rust’s syntax and replaced Rust’s hard safety goals with the aim of mapping to ObjC semantics. (To be fair to Apple, that interoperability was probably necessary.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An example that jumps out at me as immediately illustrative of the difference in approach the languages take is the way you pass structures by reference vs. copy. In Swift, that’s done via two completely distinct language constructs, &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es respectively.&lt;/p&gt;
&lt;p&gt;In Rust, there is just the &lt;code&gt;struct&lt;/code&gt; type to handle both of those. They’re immutable unless you declare them with &lt;code&gt;mut&lt;/code&gt;, and you can pass them via copy simply by implementing the &lt;code&gt;Copy&lt;/code&gt; &lt;code&gt;trait&lt;/code&gt; (which seems roughly analogous to Swift’s &lt;code&gt;protocol&lt;/code&gt;, but I’ve not yet dig deeply enough to see how they differ). Those things aren’t baked into the language, but use simpler language building blocks to define behavior into he library.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I saw someone do a write up a while back arguing that Go isn’t a &lt;em&gt;bad&lt;/em&gt; language, it just isn’t a &lt;em&gt;good&lt;/em&gt; language. My first impression of Swift, after having spent the last month with Rust, is very much along those lines.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Huh. Here’s something that I appreciate about Rust, Haskell, and others now that I didn’t before: there’s a difference between implicitly/automatically importing a prelude or a given set of standard library functions, and having actually global functions. Does Swift actually have functions like &lt;code&gt;print&lt;/code&gt; in a global namespace, as the book seems to imply, or they being imported automatically &lt;em&gt;a la&lt;/em&gt; Rust/Haskell/etc.?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; it appears Swift does likewise, but that you can’t access the relevant module directly. Which is halfway there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hmm. Why have &lt;code&gt;Double&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;Float&lt;/code&gt;—just for ObjC interop, I guess?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; follow-up from a conversation with a friend: it’s because you have 32- and 64-bit architectures out there; sometimes you don’t want 64 bits of floating point precision for that reason. Note that Rust &lt;em&gt;also&lt;/em&gt; has this distinction; you can declare things as &lt;code&gt;f32&lt;/code&gt; or &lt;code&gt;f64&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extending the above note on &lt;code&gt;class&lt;/code&gt;es and &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;protocol&lt;/code&gt;s vs. Rust’s approach: the same thing is true about &lt;code&gt;extension&lt;/code&gt;, which is a distinct concept from implementing a &lt;code&gt;protocol&lt;/code&gt;; again, in Rust these are both just handled with a single language construct, &lt;code&gt;impl&lt;/code&gt;. That’s not because &lt;code&gt;impl&lt;/code&gt; is overloaded, but rather because the underlying language machinery is the same for the two things. (edited)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(I’ve a feeling learning Swift is going to turn me into even more of a Rust fanboy.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reading the two books in close sequence like this is proving really productive mentally for thinking about how the two handle the same issues. I’ve never done anything quite like this before, and it’s fascinating.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I have an increased appreciation for Rust’s use of semi-colons to turn expressions into statements, and thereby to distinguish clearly between the two (among other things, allowing for implicit return of anything that’s an expression).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another interesting comparison: Rust’s &lt;code&gt;match&lt;/code&gt; and Swift’s &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; fill the same role of pattern matching. I’m curious to see how they differ. Does Swift do matching on arbitrary expressions?&lt;/p&gt;
&lt;p&gt;Also, I see where the syntax choices came from in both, and while I slightly prefer Rust’s, I think both make reasonably good sense; Swift’s will understandably be more familiar to C and ObjC programmers, and that’s a perfectly defensible approach. Seen that way, it is expanding on the C-style construct (even if it’s actually doing something substantially more sophisticated than that under the hood by being a form of actual pattern matching).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2015/rust-and-swift-ii.html"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Basic types and the syntax around them.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 04 Sep 2015 22:59:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-09-04:/2015/rust-and-swift-i.html</guid><category>listicles</category><category>programming languages</category><category>rust</category><category>swift</category><category>rust-and-swift</category></item><item><title>High- and Low-Level Programming Languages</title><link>http://www.chriskrycho.com/2015/high-and-low-level-programming-languages.html</link><description>&lt;p&gt;It occurred to me while listening to &lt;a href="https://edwinb.wordpress.com"&gt;Edwin Brady&lt;/a&gt; talk about &lt;a href="http://www.idris-lang.org"&gt;Idris&lt;/a&gt; on the &lt;a href="http://typetheorypodcast.com"&gt;Type Theory Podcast&lt;/a&gt;,&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; having just spent a few weeks starting to learn &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;: “low-level” has at least two meanings in software. One is whether something has manual memory management or is garbage collected, reference counted, or otherwise manages memory itself. This is what people often mean when they talk about C, C++, etc. as being “low-level” and languages like Python or Ruby or C♯ being high-level.&lt;/p&gt;
&lt;p&gt;But then you toss in a language like &lt;a href="https://www.rust-lang.org"&gt;Rust&lt;/a&gt;, and things start to get a little more complicated. Rust can do the same kind of direct memory management that makes C or C++ a good language for things like writing operating system kernels. [&lt;a href="https://github.com/torvalds/linux"&gt;1&lt;/a&gt;,&lt;a href="https://en.wikipedia.org/wiki/Architecture_of_Windows_NT"&gt;2&lt;/a&gt;,&lt;a href="http://www.opensource.apple.com/source/xnu/xnu-2782.10.72/"&gt;3&lt;/a&gt;] But it is also memory-safe, at least in ordinary usage. Like C♯, you have to be explicit about any unsafe code, with the &lt;code&gt;unsafe&lt;/code&gt; keyword on any blocks that do memory management that isn’t safe. And the vast majority of Rust code &lt;em&gt;is&lt;/em&gt; safe.&lt;/p&gt;
&lt;p&gt;More than that, though, Rust &lt;em&gt;feels&lt;/em&gt; like a high-level language. It gives you higher-kinded functions, generics, traits-based composition of types, hygienic macros, and the implementation of many important parts the essentials of the language in the library. If you need to patch something, or extend something, you can do that in a straightforward way. In short, it gives you lots of good abstractions like you would expect in a high-level language.&lt;/p&gt;
&lt;p&gt;Rust is low-level in that you can write (and people are writing) systems-level programs in it. It is high-level in that it lets you express things in ways normally associated with languages like Haskell or OCaml or Python or Ruby. To put it simply: it’s &lt;em&gt;low-level&lt;/em&gt; in its ability to address the computer, and &lt;em&gt;high-level&lt;/em&gt; in the abstractions it hands to a programmer. That’s a powerful combination, and I hope more languages embrace it in the years to come.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Yes, I know that’s insanely nerdy. What did you expect?&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 07 Aug 2015 20:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-08-07:/2015/high-and-low-level-programming-languages.html</guid><category>programming languages</category><category>rust</category><category>python</category><category>ruby</category><category>c</category><category>cplusplus</category></item></channel></rss>