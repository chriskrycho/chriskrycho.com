<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - angularjs</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Fri, 28 Aug 2015 19:50:00 -0400</lastBuildDate><item><title>HTML5 Location, &lt;base&gt;, and SVG</title><link>http://www.chriskrycho.com/2015/html5-location-base-and-svg.html</link><description>&lt;p&gt;For quite some time, I have been frustrated by a bug in HolyBible.com: Firefox would not render SVGs using the &lt;code&gt;&amp;lt;use xlink:xhref=&amp;quot;#some-SVG-ID&amp;quot;&amp;gt;&amp;lt;/use&amp;gt;&lt;/code&gt; pattern. Today, I set aside my ongoing work on new user-facing functionality and dedicated what working time I had to hunting down the cause of this and fixing it at last.&lt;/p&gt;
&lt;p&gt;I was surprised to find the culprit: the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag. If you don’t know what the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag is, you’re not alone. It is &lt;em&gt;not&lt;/em&gt; used all that much in general, and I had never actually seen it on a site before starting on this project last year.&lt;/p&gt;
&lt;p&gt;So what went wrong? How do these two things play together?&lt;/p&gt;
&lt;p&gt;I am using (and reusing) SVG items throughout the HolyBible.com interface, taking advantage of the ability to define symbols and reference them with the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag, like so:&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;svg version=&amp;quot;1.1&amp;quot; xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot; xmlns:xlink=&amp;quot;http://www.w3.org/1999/xlink&amp;quot; xmlns:ev=&amp;quot;http://www.w3.org/2001/xml-events&amp;quot; style=&amp;quot;display: none&amp;quot;&amp;gt;
  &amp;lt;symbol id=&amp;quot;logo-shape&amp;quot; viewBox=&amp;quot;0 0 256 256&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Logo&amp;lt;/title&amp;gt;
    &amp;lt;desc&amp;gt;The HolyBible.com logo: sunrise breaking over an open book (the Bible).&amp;lt;/desc&amp;gt;
    &amp;lt;path id=&amp;quot;logo-light&amp;quot; d=&amp;quot;M172.1 116.3l5.1-4.1-12.5-.5 32-26.3-41.4 18.4 11-20.1L148 96l12.2-37.5L138.8 91l.1-36.2-10.3 34.4L114 36.1l4.3 54.9-22.2-34.9 13 39.9-18.3-12.4 11 20.1-42.5-19.2 32.8 26.9-10.4.8 4.4 3.9c13.1-1.6 27.4-2.7 42.4-2.7 15.4 0 30.1 1.2 43.6 2.9z&amp;quot;/&amp;gt;
    &amp;lt;path id=&amp;quot;logo-book&amp;quot; d=&amp;quot;M199.9 219.9c-47.4-9.8-96.4-9.8-143.8 0-6-28.9-12-57.7-17.9-86.6 59.3-12.3 120.4-12.3 179.7 0-6 28.9-12 57.8-18 86.6z&amp;quot;/&amp;gt;
  &amp;lt;/symbol&amp;gt;
&amp;lt;/svg&amp;gt;

&amp;lt;!-- somewhere else on the page --&amp;gt;
&amp;lt;svg&amp;gt;
  &amp;lt;use xlink:href=&amp;quot;#logo-shape&amp;quot;&amp;gt;&amp;lt;/use&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Throughout all my early prototyping, this worked perfectly across all modern browsers. (For more, see &lt;a href="https://css-tricks.com/svg-sprites-use-better-icon-fonts/"&gt;CSS Tricks&lt;/a&gt;.) Now, when I started moving from the prototype phase into actually building the application in Angular last fall, I learned that you have to set the base URL for the application using the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag to use the HTML5 Location API with Angular 1.x. If you want URL-based, rather than &lt;code&gt;#&lt;/code&gt;-based navigation in an Angular app, you need this. Following the recommendation of whatever documentation and tutorials I found, I set it so:&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;base href=&amp;quot;/&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this was the recommendation I saw in every bit of documentation and every tutorial, so I assumed it would have no problems. As it turns it, that’s not the case. (This is a &lt;a href="http://www.chriskrycho.com/2015/how-to-build-a-single-page-app-api-right.html"&gt;recurring theme&lt;/a&gt; in my experience with Angular.) In Chrome, Safari, and IE9+, this works exactly as expected. In Firefox, however, it does &lt;em&gt;not&lt;/em&gt;. The use of the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag changes the behavior of &lt;code&gt;#&lt;/code&gt;-based URLs on a page. Specifically, it makes it so that if you’re at a URL that &lt;em&gt;isn’t&lt;/em&gt; the base route, anchor links don’t behave as expected. In order to make the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag as expected, we would have to use the same URL as the base tag. Among other things, this would require making sure that any place we used the &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; tag, we would have to set that—not exactly a good idea, given that it would entail an awful lot of changes if the base URL were ever changed.&lt;/p&gt;
&lt;p&gt;What if, instead, we did this?&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;script&amp;gt;document.write(&amp;#39;&amp;lt;base href=&amp;quot;&amp;#39; + document.location.origin + &amp;#39;&amp;quot; /&amp;gt;&amp;#39;);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This way, when the page renders, it writes the document location based on the &lt;em&gt;current&lt;/em&gt; location. The URL history still behaves as expected with Angular, but the relative URLs for IDs behave as expected in Firefox again, while not breaking the behavior in any other browsers.&lt;/p&gt;
&lt;p&gt;But… then you’ll navigate to another page, and Firefox will be back to not working.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/angular/angular.js/issues/8934#issuecomment-56568466"&gt;solution&lt;/a&gt;, it turns out, only came into being after I’d done the initial implementation, and I have no idea how much later it found its way into the Angular docs. However, even though it now &lt;em&gt;exists&lt;/em&gt; in the docs, it’s by no means obvious why you should do it this way, and certainly no mention of SVG! This might not seem odd to you… but it should, given that the only reason that Angular introduced this API change was to account for &lt;em&gt;exactly this issue&lt;/em&gt;.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As the Angular docs note, leaving out the &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag means all your URLs have to be absolute if you want to use HTML5 location and the &lt;code&gt;$locationProvider&lt;/code&gt;. If you want to use SVGs with &lt;code&gt;&amp;lt;use&amp;gt;&lt;/code&gt; and Firefox, though, that’s what you have to do (and therefore that’s what I’m doing).&lt;/p&gt;
&lt;p&gt;Fun times, right?&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;The closest it gets is this reference:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Links that only contain a hash fragment (e.g. &lt;code&gt;&amp;lt;a href=&amp;quot;#target&amp;quot;&amp;gt;&lt;/code&gt;) will only change &lt;code&gt;$location.hash()&lt;/code&gt; and not modify the url otherwise. This is useful for scrolling to anchors on the same page without needing to know on which page the user currently is.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Even this, however, only &lt;em&gt;hints&lt;/em&gt; at the root of the SVG issue.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sat, 20 Jun 2015 10:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-06-20:/2015/html5-location-base-and-svg.html</guid><category>software development</category><category>angularjs</category><category>javascript</category></item><item><title>Lessons Learned</title><link>http://www.chriskrycho.com/2015/lessons-learned.html</link><description>&lt;p&gt;Since mid July 2014, I have been working on a complete redesign and re-build of &lt;a href="//holybible.com"&gt;HolyBible.com&lt;/a&gt;. The good folks at &lt;a href="//prts.edu"&gt;Puritan Reformed Theological Seminary&lt;/a&gt; who own the site wanted to replace its previous content with a Bible reading tool. While there’s still a lot to wrap up, the project is &lt;em&gt;nearing&lt;/em&gt; its conclusion, and I thought I’d note a few things I’ve learned (in some cases, learned &lt;em&gt;again&lt;/em&gt;) along the way. I want to say up front, lest these be taken the wrong way: I’m extremely proud of the work I’ve done, and the application I’ve delivered &lt;em&gt;does&lt;/em&gt; work to the specifications I was hired to meet. More than that, it does it well. But, of course, it could do it &lt;em&gt;better&lt;/em&gt;. The following thoughts are therefore not, “How I failed” but rather “How I will do this &lt;em&gt;even better&lt;/em&gt; next time around.”&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Single page apps are great, but not always the right choice.&lt;/em&gt; I made the decision, based on my expectations and understandings of what I would need, to develop the site as a single-page web application. This was a mistake. Not the worst mistake ever: it has its upsides, including performance &lt;em&gt;once the app spins up&lt;/em&gt;, but for the kind of content I have here, I would take a different tack today. Better in this case to deliver static content and &lt;em&gt;update&lt;/em&gt; it dynamically as appropriate than to try to load all the content dynamically every time.&lt;/p&gt;
&lt;p&gt;At a technical level, that would probably mean supplementing standard HTML with &lt;a href="//backbonejs.org"&gt;Backbone&lt;/a&gt; instead of developing it as a single-page app in &lt;a href="//angularjs.org"&gt;Angular&lt;/a&gt;. For the backend, while I did it in Node.js and that would work fine, I’d probably do a straight Django app (especially with a few of the goals I learned about &lt;em&gt;after&lt;/em&gt; the project was well along in development).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Progressive enhancement or graceful degradation are hard in web applications, but they still matter.&lt;/em&gt; In the past, I’ve always taken a hard line on making sure things either degrade gracefully or are simply enhanced by JavaScript content. In the architecture decisions I made for this app, I failed to take that into account (largely because I thought it would just &lt;em&gt;need&lt;/em&gt; to work as a web app, but see above). I regret that enormously at this point; it would be much better in this particular case to have content available even if the additional functionality doesn’t work. Even if you &lt;em&gt;are&lt;/em&gt; doing something where you are building an &lt;em&gt;app&lt;/em&gt;, finding ways to make it work on poor connections, older browsers, etc. matters. I’m still thinking a &lt;em&gt;lot&lt;/em&gt; about the best way to do this in the future.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;More popular doesn’t mean better.&lt;/em&gt; Angular has a ton of traction and uptake, and that was deceptive early on. I won’t so easily be fooled in the future. Angular is so very popular in part because Google can put serious money behind its development—and its marketing. But it’s &lt;em&gt;not&lt;/em&gt; the best for many applications; if you’re not in the business of developing your own custom framework, it’s not even &lt;em&gt;close&lt;/em&gt; to the best. Use Ember or Knockout or any number of other full-stack frameworks rather than a meta-framework.&lt;/p&gt;
&lt;p&gt;How to avoid making that mistake? Well, for my part since then, I’ve learned to look not just as the &lt;em&gt;quantity&lt;/em&gt; of material in a given community, but its &lt;em&gt;quality&lt;/em&gt;. For example, &lt;a href="//emberjs.com"&gt;Ember&lt;/a&gt; has &lt;em&gt;incredible&lt;/em&gt; documentation (far better than Angular’s), and they also have a much clearer vision and a more dependable approach to development (strict semantic versioning, etc.). Had I taken the time to read &lt;em&gt;both&lt;/em&gt; sets of docs more carefully and think through the consequences of their designs more thoroughly, I could have recognized this before starting. Next time, I will do just that.&lt;/p&gt;
&lt;p&gt;I will also look at the way the community behaves. The Ember community is &lt;em&gt;far&lt;/em&gt; friendlier for newcomers from what I’ve seen than the Angular community—no slam meant on the Angular crowd, but the Ember folks are just doing that really well. That matters, too. (I can’t speak for other communities, of course; these are just the groups I’ve watched the most.)&lt;/p&gt;
&lt;p&gt;All in all, Ember would have been the better fit between these two (even though, as noted above, it also wouldn’t have been the &lt;em&gt;best&lt;/em&gt; fit).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Unit tests really are the best.&lt;/em&gt; I did a vast majority of this project with unit tests—the first time I’ve ever been able to do that for a whole project. In other projects, I’ve been able to do it for parts, but never this much. It saved my bacon a &lt;em&gt;lot&lt;/em&gt;. Where I got in a hurry and felt like I didn’t have time to write the tests, I (inevitably and predictably!) ended up spending a lot of time chasing down hard-to-isolate bugs—time I could have avoided by writing well-tested (and therefore better-factored) code in the first place. Lesson learned &lt;em&gt;very&lt;/em&gt; thoroughly. Server- and client-side unit tests are &lt;em&gt;really&lt;/em&gt; good. They’re also sometimes &lt;em&gt;hard&lt;/em&gt;; getting mocks set up correctly for dealing with databases, etc. can take a while. That difficulty pays for itself, though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Unit tests &lt;strong&gt;really&lt;/strong&gt; don’t replace API documentation.&lt;/em&gt; I have seen people advocate test-driven-development as a way of obviating the need to do major documentation of an API. This is, in a word, ridiculous. Having to read unit tests if you want to remember how you structured an API call is a pain in the neck. Don’t believe it. Design your API and document it, &lt;em&gt;then&lt;/em&gt; do test-driven development against that contract.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Sometimes ‘good enough’ is enough.&lt;/em&gt; There is always more to be done, and inevitably you can see a thousand things that could be improved. But ‘good’ shipping code is far more valuable than ‘perfect’ code that never ships. You should never ship &lt;em&gt;bad&lt;/em&gt; code, but sometimes you do have to recognize ‘good enough’ and push it out the door.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Full-stack development is fun, but it’s also really hard.&lt;/em&gt; I wrote every scrap of code in HolyBible.com proper (though of course it relies on a lot of third-party code). It was very, very difficult to manage that all by myself; it’s a lot to hold in one’s head. (One of the reasons I chose Node was because keeping my implementation and testing all in one language helped reduce that load somewhat.) Would I do it again? Sure. But very much chastened about the difficulties involved. It has been enormously rewarding, and I &lt;em&gt;like&lt;/em&gt; being a full-stack developer. But it’s a lot of work, and now I know more clearly just how much.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I could say a great deal more about the technical side of things especially, but my biggest takeaway here is that a lot of the hardest and most important work in developing software has nothing to do with the code itself. Architecture and approach shape &lt;em&gt;far&lt;/em&gt; more than the implementation details (even if those details still matter an awful lot). And popularity is not at all the same as either &lt;em&gt;quality&lt;/em&gt; or (especially) &lt;em&gt;suitability for a given task&lt;/em&gt;. In the future, I will be better equipped for the necessary kinds of evaluation, and will hopefully make still better decisions accordingly.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 12 Apr 2015 13:49:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-04-12:/2015/lessons-learned.html</guid><category>software development</category><category>javascript</category><category>angularjs</category></item><item><title>Unsurprisingly, In Flux</title><link>http://www.chriskrycho.com/2015/unsurprisingly-in-flux.html</link><description>&lt;p&gt;&lt;i class="editorial"&gt;This started as a &lt;a href="https://alpha.app.net/chriskrycho/post/57102562"&gt;series of posts&lt;/a&gt; on App.net. I &lt;a href="http://www.chriskrycho.com/2014/a-few-theses-on-blogging.html"&gt;resolved&lt;/a&gt; a while ago that if I was tempted to do that, I should just write a blog post instead. I failed at that resolution, but at a friend’s &lt;a href="https://alpha.app.net/jws/post/57108281"&gt;suggestion&lt;/a&gt;, am adapting it into a blog post anyway. You can see the posts that prompted it &lt;a href="https://alpha.app.net/keita/post/57096585"&gt;here&lt;/a&gt; and &lt;a href="https://alpha.app.net/jws/post/57096838"&gt;here&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The state of JavaScript frameworks today is a scale, really, from not-at-all-monolithic to totally-monolithic, in roughly this order: Backbone – React &amp;amp; Angular – Ember – Meteor.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Backbone and related library Underscore are really collections of common JS tools and patterns you can use to write apps, but they’re not &lt;em&gt;frameworks&lt;/em&gt;, per se. You’ll write all your own boilerplate there.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React and Angular supply much &lt;em&gt;more&lt;/em&gt; of the functionality, but Angular is a “meta-framework” that aims to do &lt;em&gt;some&lt;/em&gt; boilerplate but let you construct your own custom app framework.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Angular is very powerful, but it’s kind of like Git: wires are exposed; you have to understand a &lt;em&gt;lot&lt;/em&gt; about the internals to get it to do what you want. Its routing functionality is pretty limited out of the box, too—so much so that there’s a near-standard third-party router.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React, as I understand it, supplies a paradigm and associated tools oriented primarily at view state management, though with capabilities via extensions for routing, etc. These tools are &lt;em&gt;extremely&lt;/em&gt; powerful for performance in particular. It’s not a full framework, and the docs expressly note that you can &lt;em&gt;just&lt;/em&gt; use React for the view layer with other tools if you want.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In any case, Angular and React do &lt;em&gt;different&lt;/em&gt; things from each other, but both do substantially more than Backbone.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember is a full framework, strongly emphasizing shared conventions (with a lot of common developers from Rails). It’s perhaps less adaptable than React or Angular, but is much more full-featured; you have very little boilerplate to do.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Meteor is like Ember, but does server-side Node as well as client-side stuff, with the goal being to minimize code duplication, sharing assets as much as possible.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Of all of those, Ember has easily (easily!) the best-explained roadmap, most articulate leadership, and best development path. They are also aggressively adopting the best features of other frameworks wherever it makes sense.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Angular is currently in flux, as Google has announced Angular 2.0 will be basically a completely different framework; there will be &lt;em&gt;no&lt;/em&gt; direct migration path for Angular 1.x apps to Angular 2.0+. Total rewrite required.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ember uses a steady 6-week release schedule with very careful regression testing and semantic versioning, with clear deprecation notices and upgrade paths, and is therefore both rapidly iterating &lt;em&gt;and&lt;/em&gt; relatively stable for use.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you just need a set of tools for enhance functionality on otherwise relatively static pages, Backbone+Underscore is a great combo. If you already have a bunch of things in place but want a dedicated view layer, React is good.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re writing a new, full-on web &lt;em&gt;application&lt;/em&gt; (SPA, or organized in whatever other way), I think Ember is the very clear winner at this point. I have good confidence in their leadership and they’re firing on all cylinders.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regarding Angular, &lt;a href="https://alpha.app.net/mikehoss"&gt;@mikehoss&lt;/a&gt; &lt;a href="https://alpha.app.net/mikehoss/post/57105656"&gt;posted&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For the record they are doing that to make it more mobile-friendly. The Ang1 has abysmal performance on mobile. Besides a time machine, this maybe the best option. And Miško is a bit of a jerk.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I can’t speak to his comment about Miško (Miško Hevery, one of the leads on AngularJS), but I agree about Angular itself: the rewrite needs to happen. Angular 1.x is a mess—as are its docs. It’s just not a good time to be using 1.x for any new projects.&lt;/p&gt;
&lt;p&gt;I’ll add to these points that I’ve used Angular for the last 9 months on HolyBible.com development. As I noted: the documentation is pretty rough, and in a lot of cases you really do have to understand what the framework is doing and how before you can get it to do the things you want. This is, in one sense, exactly the &lt;em&gt;opposite&lt;/em&gt; of what I’m looking for in a framework—but it makes sense given Angular’s goal of being a meta-framework.&lt;/p&gt;
&lt;p&gt;Rather like Git, though, which was originally going to be infrastructure for version control systems which would have their own interface, but eventually just had a “good enough” interface that we’re all now stuck with, Angular is being used &lt;em&gt;as&lt;/em&gt; a framework, not just as a &lt;em&gt;meta-framework&lt;/em&gt;, and it’s unsurprisingly not great for that.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;i class="editorial"&gt;Take this for what it’s worth: not the final word (by a long stretch) on JavaScript frameworks, but rather the perspective of one guy who notably &lt;em&gt;hasn’t used all of the frameworks&lt;/em&gt;, but has spent some time looking at them. Moreover, I haven’t particularly edited this; it’s more a summary in the kind of short-form posts that I originally created than a detailed analysis. The only things I’ve done are expand some of the notes on Angular and React, and add the footnote on React.&lt;/i&gt;&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I &lt;em&gt;really&lt;/em&gt; don’t know a ton about React, but I do think a lot of what I do know about it is cool from a programming perspective. From a designer perspective, however, it’s a bit of a pain: React’s “JSX” domain-specific language is &lt;em&gt;much&lt;/em&gt; less friendly to developers than standard HTML, and therefore than either Ember or Angular, both of which implement their templating via HTML templating languages. There’s a substantil tradeoff there: React’s model is interesting not only academically but in practice because of the performance results it produces. It’s worth note, though, that others have recognized this and are adopting it to varying degrees; notably, Ember is incorporating the idea of minimizing changes to the DOM by keeping track of state and updating only differences, rather than refreshing the whole tree, in the new rendering engine (HTMLBars) they’re rolling out over the past several and future several releases.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 08 Apr 2015 16:05:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2015-04-08:/2015/unsurprisingly-in-flux.html</guid><category>software development</category><category>javascript</category><category>angularjs</category><category>emberjs</category><category>react</category></item></channel></rss>