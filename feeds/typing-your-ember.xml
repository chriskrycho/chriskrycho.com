<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Chris Krycho - typing-your-ember</title><link>http://www.chriskrycho.com/</link><description></description><lastBuildDate>Wed, 24 Jan 2018 22:30:00 -0500</lastBuildDate><item><title>TypeScript and Ember.js Update, Part 2</title><link>http://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the previous post in this series, I introduced the big picture of how the story around TypeScript and Ember.js has improved over the last several months. In this post, I’ll be pausing from TypeScript-specific to take a look at how things work with &lt;em&gt;class properties&lt;/em&gt;, since they have some big implications for how we work, which then have ripple effects on computed properties, actions, etc.&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;If you’re interested in all of this and would like to learn more in person, I’m &lt;a href="http://emberconf.com/speakers.html#chris-krycho"&gt;leading a workshop on it at EmberConf 2018&lt;/a&gt;—I’d love to see you there!&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Here’s the outline of this update sequence:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html"&gt;Overview, normal Ember objects, component arguments, and injections.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;&lt;strong&gt;Class properties—some notes on how things differ from the &lt;code&gt;Ember.Object&lt;/code&gt; world (this post).&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html"&gt;Computed properties, actions, mixins, and class methods.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ember Data and related concerns.&lt;/li&gt;
&lt;li&gt;Mixins and proxies; or: the really hard-to-type-check bits.&lt;/li&gt;
&lt;/ol&gt;
&lt;section id="a-detailed-example-contd.-class-properties" class="level2"&gt;
&lt;h2&gt;A detailed example (cont’d.) – class properties&lt;/h2&gt;
&lt;p&gt;Let’s start by recalling the example Component we’re working through:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;
import Computed from &amp;#39;@ember/object/computed&amp;#39;;
import { inject as service } from &amp;#39;@ember/service&amp;#39;;
import { assert } from &amp;#39;@ember/debug&amp;#39;;
import { isNone } from &amp;#39;@ember/utils&amp;#39;;

import Session from &amp;#39;my-app/services/session&amp;#39;;
import Person from &amp;#39;my-app/models/person&amp;#39;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &amp;#39;firstName&amp;#39;)};`;
    }
  );

  aComputed = computed(&amp;#39;aString&amp;#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&amp;#39;session.user&amp;#39;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;#39;session.user&amp;#39;);

  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&amp;#39;aCollection&amp;#39;);
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(value));
    }
  };

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.get(&amp;#39;aCollection&amp;#39;).includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(&amp;#39;ahoy&amp;#39;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Throughout, you’ll note that we’re using &lt;em&gt;assignment&lt;/em&gt; to create these class properties—a big change from the key/value setup in the old &lt;code&gt;.extends({ ... })&lt;/code&gt; model:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Class properties like this are &lt;em&gt;instance properties&lt;/em&gt;. These are compiled to, because they are &lt;em&gt;equivalent to&lt;/em&gt;, assigning a property in the constructor. That is, these two ways of writing class property initialization are equivalent—&lt;/p&gt;
&lt;p&gt;At the property definition site:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // snip...

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // snip..

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  // snip...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the constructor:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // snip...

  // -- Class properties -- //
  aString: string;
  aCollection: string[];

  constructor() {
    super();

    this.aString = &amp;#39;this is fine&amp;#39;;
    this.aCollection = [];

    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  // snip...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see why the first one is preferable: if you don’t need any input to the component to set the value, you can simply set the definition inline where the property is declared.&lt;/p&gt;
&lt;p&gt;However, this is &lt;em&gt;quite&lt;/em&gt; unlike using &lt;code&gt;.extend&lt;/code&gt;, which installs the property on the prototype. Three very important differences from what you’re used to fall out of this, and &lt;em&gt;none of them are specific to TypeScript.&lt;/em&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section id="default-values" class="level3"&gt;
&lt;h3&gt;1. Default values&lt;/h3&gt;
&lt;p&gt;Since class property setup runs during the constructor, if you want the caller to be able to override it, you &lt;em&gt;must&lt;/em&gt; give it an explicit fallback that references what’s passed into the function. Something like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;class AnyClass {
  aDefaultProp = this.aDefaultProp || 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, translated back into the constructor form:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;class AnyClass {
  constructor() {
    this.aDefaultProp = this.aDefaultProp || 0;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, you can see that if something has &lt;em&gt;already set&lt;/em&gt; the &lt;code&gt;aDefaultProp&lt;/code&gt; value (before the class constructor is called), we’ll use that value; otherwise, we’ll use the default. You can think of this as being something like default arguments to a function. In our codebase, we have started using &lt;a href="https://lodash.com/docs/4.17.4#defaultTo"&gt;&lt;code&gt;_.defaultTo&lt;/code&gt;&lt;/a&gt;, which works quite nicely. In the old world of declaring props with their values in the &lt;code&gt;.extends({ ... })&lt;/code&gt; hash, we got this behavior “for free”—but without a lot of other benefits of classes, so not &lt;em&gt;actually&lt;/em&gt; for free.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="no-more-shared-state" class="level3"&gt;
&lt;h3&gt;2. No more shared state&lt;/h3&gt;
&lt;p&gt;Because these are instance properties, &lt;em&gt;not&lt;/em&gt; assigned on the prototype, you do not have to worry about the problem—&lt;a href="https://dockyard.com/blog/2014/04/17/ember-object-self-troll"&gt;well-known among experienced Ember.js developers, but prone to bite people new to the framework&lt;/a&gt;—where you assign an array or object in the &lt;code&gt;.extend()&lt;/code&gt; method and then find that it’s shared between instances.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default Component.extend({
  anArray: [],  // &amp;lt;- this *will* be shared between instances
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve long had to handle this by setting up those properties in our &lt;code&gt;init()&lt;/code&gt; method instead, so that they are created during object instantiation, rather than on the prototype. This problem goes away entirely with classes, including in TypeScript.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class MyComponent extends Component {
  anArray = [];  // &amp;lt;- this will *not* be shared between instances
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note that here, we don’t have a type for the array, so it’s of type &lt;code&gt;any[]&lt;/code&gt;; we &lt;em&gt;always&lt;/em&gt; need type annotations for empty arrays if we want them to be a “narrower,” or more specific, type than that.)&lt;/p&gt;
&lt;/section&gt;
&lt;section id="performance-changes" class="level3"&gt;
&lt;h3&gt;3. Performance changes&lt;/h3&gt;
&lt;p&gt;The flip-side of this is that the only way we currently have to create computed property instances (until decorators stabilize) is &lt;em&gt;also&lt;/em&gt; as instance, not prototype, properties. I’ll look at computed properties (and their types) in more detail in the next post, so here mostly just note how the computed is set up on the class: by assignment, &lt;em&gt;not&lt;/em&gt; as a prototypal property.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class MyComponent extends Component {
  aString = &amp;#39;Hello, there!&amp;#39;;

  itsLength = computed(&amp;#39;aString&amp;#39;, function(this: MyComponent): number {
    return this.aString.length;
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;em&gt;does&lt;/em&gt; have a performance cost, which will be negligible in the ordinary case but pretty nasty if you’re rendering hundreds to thousands of these items onto the page. You can use this workaround for these as well as for any other properties which need to be prototypal (more on &lt;em&gt;that&lt;/em&gt; in the next post as well):&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class MyComponent extends Component.extend({
  itsLength: computed(&amp;#39;aString&amp;#39;, function(this: MyComponent): number {
      return this.aString.length;
    }
  );
}) {
  aString = &amp;#39;Hello, there!&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;em&gt;looks&lt;/em&gt; really weird, but it works exactly as you’d expect.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="class-property-variants" class="level2"&gt;
&lt;h2&gt;Class property variants&lt;/h2&gt;
&lt;p&gt;There are two times when things will look different from basic class properties. Both have to do with setting up the prototype to work the way other parts of the Ember object ecosystem expect.&lt;/p&gt;
&lt;section id="variant-1-prototypalmerged-properties" class="level3"&gt;
&lt;h3&gt;Variant 1: Prototypal/merged properties&lt;/h3&gt;
&lt;p&gt;The first is when you’re using properties that need to be merged with properties in the prototype chain, e.g. &lt;code&gt;attributeBindings&lt;/code&gt; or &lt;code&gt;classNameBindings&lt;/code&gt;, or which (because of details of how components are constructed) have to be set on the prototype rather than as instance properties, e.g. &lt;code&gt;tagClass&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For those, we can just leverage &lt;code&gt;.extend&lt;/code&gt; in conjunction with classes:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;

export default class MyListItem extends Component.extend({
  tagName: &amp;#39;li&amp;#39;,
  classNameBindings: [&amp;#39;itemClass&amp;#39;]
}) {
  itemClass = &amp;#39;this-be-a-list&amp;#39;;

  // etc.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is also how you’ll &lt;em&gt;use&lt;/em&gt; mixins (on defining them, see below):&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import MyMixin from &amp;#39;my-app/mixins/my-mixin&amp;#39;;

export default class AnExample extends Component.extend(MyMixin) {
  // the rest of the definition.
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note, however—and this is very important—that you cannot &lt;code&gt;.extend&lt;/code&gt; an existing &lt;code&gt;class&lt;/code&gt; implementation. As a result, deep inheritance hierarchies &lt;em&gt;may&lt;/em&gt; make transitioning to classes in Ember painful. Most importantly: they may work &lt;em&gt;some&lt;/em&gt; of the time in &lt;em&gt;some&lt;/em&gt; ways, but will break when you least expect. So don’t do that! (This isn’t a TypeScript limitation; it’s a limitation of classes in Ember today.)&lt;a href="#fn3" class="footnote-ref" id="fnref3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;section id="variant-2-mixins" class="level3"&gt;
&lt;h3&gt;Variant 2: Mixins&lt;/h3&gt;
&lt;p&gt;The other time you’ll have to take a different tack—and this falls directly out of the need for prototypal merging—is with &lt;code&gt;Mixin&lt;/code&gt;s, which don’t yet work properly with classes. Worse, it’s difficult (if not impossible) to get rigorous type-checking internally in &lt;code&gt;Mixin&lt;/code&gt; definitions, because you cannot define them as classes: you &lt;em&gt;have&lt;/em&gt; to use the old style throughout, because mixins are created with &lt;code&gt;.create()&lt;/code&gt;, not &lt;code&gt;.extend()&lt;/code&gt;.&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;Note that if you’re writing &lt;em&gt;new&lt;/em&gt; code in Ember.js—using TypeScript or not—I strongly encourage you to simply avoid using mixins at all. Instead, use services (or, occasionally, inheritance). This will require you to change how you write some of your code, but in my experience that change will make your codebase much easier to understand, and therefore much easier to maintain.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;I’ll have a lot more to say about these in part 5 of this series, including a detailed example of how to carefully type-annotate one and use it in another class. For now, suffice it to say that you’ll still need to incorporate &lt;code&gt;Mixin&lt;/code&gt;s via &lt;code&gt;.extend()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import MyMixin from &amp;#39;my-app/mixins/my-mixin&amp;#39;;

export default class SomeNewComponent extends Component.extend(MyMixin) {
  // normal class properties
}&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="summary" class="level2"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Those are the &lt;em&gt;biggest&lt;/em&gt; differences from &lt;code&gt;Ember.Object&lt;/code&gt; that you need to be aware of when working with class properties in Ember.js today, at least in my experience working with them day to day. These are not the only differences with &lt;em&gt;classes&lt;/em&gt;, though, especially when dealing with TypeScript, so in my next entry we’ll take a look at how classes work (and work well!) with most things in Ember.js and TypeScript together.&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;You can use this same feature on classes using Babel, with the &lt;a href="https://babeljs.io/docs/plugins/transform-class-properties/"&gt;class properties transform&lt;/a&gt;.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;Even when &lt;a href="https://github.com/emberjs/rfcs/pull/281"&gt;Ember.js RFC #281&lt;/a&gt; lands, this problem will not go away, at least under the current implementation, since &lt;a href="https://github.com/emberjs/rfcs/pull/281#issuecomment-360023258"&gt;&lt;em&gt;these&lt;/em&gt; will &lt;em&gt;not&lt;/em&gt; be transformed into getters on the prototype&lt;/a&gt;. We are waiting for decorators to solve this problem completely.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3"&gt;&lt;p&gt;In the future, we’ll (hopefully and presumably 🤞🏼) have an escape hatch for those merged or prototypally-set properties via decorators. That’ll look something like this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { className, tagName } from &amp;#39;ember-decorators/component&amp;#39;;

@tagName(&amp;quot;li&amp;quot;)
export default class MyListItem extends Component {
  @className itemClass = &amp;#39;this-be-a-list&amp;#39;;

  @action
  sendAMessage(contents: string): void {

  }
  // etc.
}&lt;/code&gt;&lt;/pre&gt;
&lt;a href="#fnref3" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Wed, 24 Jan 2018 07:00:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-24:/2018/typing-your-ember-update-part-2.html</guid><category>TypeScript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>TypeScript and Ember.js Update, Part 1</title><link>http://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Back in July 2017, I wrote &lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-3.html"&gt;a post&lt;/a&gt; on how to using TypeScript in your Ember.js apps. At the time, we were still busy working on getting the typings more solid for Ember itself, and &lt;code&gt;class&lt;/code&gt; syntax for Ember was apparently a long way away.&lt;/p&gt;
&lt;p&gt;Things have gotten quite a bit better since then, so I thought I’d update that post with recommendations for using TypeScript in an app &lt;em&gt;now&lt;/em&gt; with the updated typings, as well as with another six months of experience using TypeScript in our app at Olo (~20k lines of code in the app and another ~15k in tests).&lt;/p&gt;
&lt;aside&gt;
&lt;p&gt;If you’re interested in all of this and would like to learn more in person, I’m &lt;a href="http://emberconf.com/speakers.html#chris-krycho"&gt;leading a workshop on it at EmberConf 2018&lt;/a&gt;—I’d love to see you there!&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;Here’s how I expect this update series to go:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-1.html"&gt;&lt;strong&gt;Overview, normal Ember objects, component arguments, and injections (this post).&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;Class properties—some notes on how things differ from the &lt;code&gt;Ember.Object&lt;/code&gt; world.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-3.html"&gt;Computed properties, actions, mixins, and class methods.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ember Data and related concerns.&lt;/li&gt;
&lt;li&gt;Mixins and proxies; or: the really hard-to-type-check bits.&lt;/li&gt;
&lt;/ol&gt;
&lt;section id="normal-ember-objects" class="level2"&gt;
&lt;h2&gt;Normal Ember objects&lt;/h2&gt;
&lt;p&gt;For normal Ember objects, things now &lt;em&gt;mostly&lt;/em&gt; just work if you’re using class-based syntax, with a single (though very important) qualification I’ll get to in a minute. And you can use the class-based syntax &lt;em&gt;today&lt;/em&gt; in Ember.js—all the way back to 1.13, as it turns out. If you want to learn more, you can read &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0240-es-classes.md"&gt;this RFC&lt;/a&gt; or &lt;a href="https://medium.com/build-addepar/es-classes-in-ember-js-63e948e9d78e"&gt;this blog post&lt;/a&gt;, both by &lt;a href="https://github.com/pzuraq"&gt;@pzuraq (Chris Garrett)&lt;/a&gt;, who did most of the legwork to research this and flesh out the constraints, and who has also been doing a lot of work on &lt;a href="https://ember-decorators.github.io/ember-decorators/docs/index.html"&gt;Ember Decorators&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Accordingly, I’m assuming the use of ES6 &lt;code&gt;class&lt;/code&gt; syntax throughout. The big reason for this is that things mostly just &lt;em&gt;don’t work&lt;/em&gt; without it. And we’ll see (in a later post) some hacks to deal with places where parts of Ember’s ecosystem don’t yet support classes properly. In general, however, if you see an error like &lt;code&gt;&amp;quot;Cannot use 'new' with an expression whose type lacks a call or construct signature.&amp;quot;&lt;/code&gt;, the reason is almost certainly that you’ve done &lt;code&gt;export default Component.extend({...})&lt;/code&gt; rather than creating a class.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="a-detailed-example" class="level2"&gt;
&lt;h2&gt;A detailed example&lt;/h2&gt;
&lt;p&gt;That means that every new bit of code I write today in our app looks roughly like this, with only the obvious modifications for services, routes, and controllers—I picked components because they’re far and away the most common things in our applications.&lt;/p&gt;
&lt;p&gt;In order to explain all this clearly, I’m going to start by showing a whole component written in the new style. Then, over the rest of this post and the next post, I’ll zoom in on and explain specific parts of it.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;
import Computed from &amp;#39;@ember/object/computed&amp;#39;;
import { inject as service } from &amp;#39;@ember/service&amp;#39;;
import { assert } from &amp;#39;@ember/debug&amp;#39;;
import { isNone } from &amp;#39;@ember/utils&amp;#39;;

import Session from &amp;#39;my-app/services/session&amp;#39;;
import Person from &amp;#39;my-app/models/person&amp;#39;;

export default class AnExample extends Component {
  // -- Component arguments -- //
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`

  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();

  // -- Class properties -- //
  aString = &amp;#39;this is fine&amp;#39;;
  aCollection: string[] = [];

  // -- Computed properties -- //
  // TS correctly infers computed property types when the callback has a
  // return type annotation.
  fromModel = computed(
    &amp;#39;model.firstName&amp;#39;,
    function(this: AnExample): string {
      return `My name is ${get(this.model, &amp;#39;firstName&amp;#39;)};`;
    }
  );

  aComputed = computed(&amp;#39;aString&amp;#39;, function(this: AnExample): number {
    return this.lookAString.length;
  });

  isLoggedIn = bool(&amp;#39;session.user&amp;#39;);
  savedUser: Computed&amp;lt;Person&amp;gt; = alias(&amp;#39;session.user&amp;#39;);

  actions = {
    addToCollection(this: AnExample, value: string) {
      const current = this.get(&amp;#39;aCollection&amp;#39;);
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(value));
    }
  };

  constructor() {
    super();
    assert(&amp;#39;`model` is required&amp;#39;, !isNone(this.model));

    this.includeAhoy();
  }

  includeAhoy(this: AnExample) {
    if (!this.get(&amp;#39;aCollection&amp;#39;).includes(&amp;#39;ahoy&amp;#39;)) {
      this.set(&amp;#39;aCollection&amp;#39;, current.concat(&amp;#39;ahoy&amp;#39;));
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;section id="component-arguments" class="level3"&gt;
&lt;h3&gt;Component arguments&lt;/h3&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // Component arguments
  model: Person;      // required
  modifier?: string;  // optional, thus the `?`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I always put these first so that the “interface” of the object is clear and obvious. You can do the same thing on a controller instance; in that case you would export a &lt;code&gt;Model&lt;/code&gt; from the corresponding &lt;code&gt;Route&lt;/code&gt; class and import it into the &lt;code&gt;Controller&lt;/code&gt;. It’s a bit of boilerplate, to be sure, but it lets you communicate your interface clearly to consumers of the &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;Controller&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An important note about these kind of arguments: you do &lt;em&gt;not&lt;/em&gt; have to do &lt;code&gt;this.get(...)&lt;/code&gt; (or, if you prefer, &lt;code&gt;get(this, ...)&lt;/code&gt;) to access the properties themselves: they’re class instance properties. You can simply access them as normal properties: &lt;code&gt;this.model&lt;/code&gt;, &lt;code&gt;this.modifier&lt;/code&gt;, etc. That even goes for referencing them as computed properties, as we’ll see below.&lt;/p&gt;
&lt;p&gt;For optional arguments, you use the &lt;code&gt;?&lt;/code&gt; operator to indicate they may be &lt;code&gt;undefined&lt;/code&gt;. To get the &lt;em&gt;most&lt;/em&gt; mileage out of this, you’ll want to enable &lt;code&gt;strictNullChecks&lt;/code&gt; in the compiler options.&lt;a href="#fn1" class="footnote-ref" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; However, note that we don’t currently have any way to validate component argument invocation.&lt;a href="#fn2" class="footnote-ref" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; The way I’ve been doing this is using Ember’s debug &lt;a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fdebug/methods/assert?anchor=assert"&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; in the constructor:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;assert(&amp;quot;`model` is required&amp;quot;, !isNone(this.model));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Edit, January 24, 2018:&lt;/strong&gt; Starting in TypeScript 2.7, you can enable a flag, &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;, which requires that all declared, non-optional properties on a class be initialized in the constructor or with a class property assignment. (There’s more on class property assignment in &lt;a href="http://www.chriskrycho.com/2018/typing-your-ember-update-part-2.html"&gt;part 2&lt;/a&gt; of this series.) If you do that, all &lt;em&gt;arguments&lt;/em&gt; to a component should be defined with the &lt;em&gt;definite assignment assertion modifier&lt;/em&gt;, a &lt;code&gt;!&lt;/code&gt; after the name of the property, as on &lt;code&gt;model&lt;/code&gt; here:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;export default class AnExample extends Component {
  // Component arguments
  model!: Person;     // required
  modifier?: string;  // optional, thus the `?`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should still combine that with use of &lt;a href="https://emberjs.com/api/ember/2.18/classes/@ember%2Fdebug/methods/assert?anchor=assert"&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; so that any misses in template invocation will get caught in your tests.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="injections" class="level3"&gt;
&lt;h3&gt;Injections&lt;/h3&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  // -- Injections -- //
  session: Computed&amp;lt;Session&amp;gt; = service();&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the most important thing to note is the required type annotation. In principle, we could work around this by requiring you to explicitly name the service and using a “type registry” to look up what the service type is – more on that below in my discussion of using Ember Data – but I’m not yet persuaded that’s better than just writing the appropriate type annotation. Either way, there’s some duplication. 🤔 We (everyone working in the &lt;a href="https://github.com/typed-ember"&gt;typed-ember&lt;/a&gt; project) would welcome feedback here, because the one thing we &lt;em&gt;can’t&lt;/em&gt; do is get the proper type &lt;em&gt;without&lt;/em&gt; one or the other of these.&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;  // the current approach -- requires importing `Session` so you can define it
  // on the property here
  session: Computed&amp;lt;Session&amp;gt; = service();

  // the alternative approach I&amp;#39;ve considered -- requires writing boilerplate
  // elsewhere, similar to what you&amp;#39;ll see below in the Ember Data section
  session = service(&amp;#39;session&amp;#39;);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One other thing to notice here is that because TypeScript is a &lt;em&gt;structural&lt;/em&gt; type system, it doesn’t matter if what is injected is the actual &lt;code&gt;Session&lt;/code&gt; service; it just needs to be something that &lt;em&gt;matches the shape&lt;/em&gt; of the service – so your normal behavior around dependency injection, etc. is all still as expected.&lt;/p&gt;
&lt;p&gt;That’s enough for one post, I think. In the next entry, we’ll pick up with how you handle class properties, including computed properties, and then talk about mixins as well. In the post after that, we’ll look at Ember Data and some related concerns.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;This isn’t my preferred way of handling optional types; &lt;a href="https://true-myth.js.org"&gt;a &lt;code&gt;Maybe&lt;/code&gt; type&lt;/a&gt; is. And you can, if you like, use &lt;code&gt;Maybe&lt;/code&gt; here:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { Maybe } from &amp;#39;true-myth&amp;#39;;

export default class MyComponent extends Component {
  optionalArg?: string;
  optionalProperty = Maybe.of(this.optionalArg);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then if you invoke the property without the argument, it’ll construct a &lt;code&gt;Nothing&lt;/code&gt;; if you invoke it with the argument, it’ll be &lt;code&gt;Just&lt;/code&gt; with the value.&lt;a href="#fnref1" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;A few of us have batted around some ideas for how to solve that particular problem, but &lt;em&gt;if&lt;/em&gt; we manage those, it’ll probably be way, way later in 2018.&lt;a href="#fnref2" class="footnote-back"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 22 Jan 2018 07:10:00 -0500</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2018-01-22:/2018/typing-your-ember-update-part-1.html</guid><category>TypeScript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>Announcing ember-cli-typescript 1.0.0</title><link>http://www.chriskrycho.com/2017/announcing-ember-cli-typescript-100.html</link><description>&lt;p&gt;I’m extremely pleased to announce the release of &lt;a href="https://github.com/typed-ember/ember-cli-typescript/releases/tag/v1.0.0"&gt;ember-cli-typescript 1.0.0&lt;/a&gt;! You can get it the same way you do &lt;em&gt;any&lt;/em&gt; Ember addon:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;$ ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a detailed walkthrough of adding TypeScript to your projects, see:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-1.html"&gt;Typing Your Ember, Part 1: Set your Ember.js project up to use TypeScript.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-2.html"&gt;Typing Your Ember, Part 2: Adding TypeScript to an existing Ember.js project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what are we shipping today, and what’s on the roadmap?&lt;/p&gt;
&lt;section id="whats-in-1.0" class="level2"&gt;
&lt;h2&gt;What’s In 1.0?&lt;/h2&gt;
&lt;p&gt;This release is intentionally relatively minimal: the goal here is provide stable foundation for building Ember.js applications with TypeScript in the toolchain. This means that in any app you can install the add-on and just start &lt;a href="http://www.chriskrycho.com/2017/typing-your-ember-part-3.html"&gt;progressively converting your app over to TypeScript&lt;/a&gt;. However, we don’t expect to change the way you &lt;em&gt;use&lt;/em&gt; the addon at all in the foreseeable future.&lt;/p&gt;
&lt;p&gt;I’ll give you fair warning that there is one &lt;em&gt;major&lt;/em&gt; challenge you will find as you work with ember-cli-typescript today: the lack of type definitions for most projects, and the limits of the existing type definitions for Ember.js itself. That’s not as bad as it sounds, though:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;See the &lt;a href="#the-roadmap"&gt;&lt;strong&gt;Roadmap&lt;/strong&gt;&lt;/a&gt; below—we’re working on that, and you can help!&lt;/li&gt;
&lt;li&gt;I’ve been using TypeScript successfully in the app I work on at my day job for the last nine months or so. While the lack of (good or any) typings has had its frustrations, &lt;a href="https://www.dailydrip.com/blog/domain-driven-design-and-typed-functional-programming-in-typescript"&gt;TypeScript has already added a &lt;em&gt;lot&lt;/em&gt; of value for us&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
&lt;section id="the-roadmap" class="level2"&gt;
&lt;h2&gt;The Roadmap&lt;/h2&gt;
&lt;p&gt;We have a bunch of things we’re actively working on and which you can expect to land in the next few weeks to months.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1-1-a-prepublish-build-process-for-addons"&gt;1.1: A prepublish build process for addons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#community-driven-work-on-typings"&gt;Community-driven work on typings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section id="a-prepublish-build-process-for-addons" class="level3"&gt;
&lt;h3&gt;1.1: A prepublish build process for addons&lt;/h3&gt;
&lt;p&gt;The major priority for the 1.1 release is an npm prepublication step to generate JavaScript and typing files from add-ons which are using TypeScript. Currently, addons have to take TypeScript as a full dependency, not a dev dependency, because they currently just ship the &lt;code&gt;.ts&lt;/code&gt; files up to npm and they have to be compiled in your app at build time.&lt;/p&gt;
&lt;p&gt;We really don’t want to make any app developer who is using your addon download either the TypeScript files or &lt;em&gt;especially&lt;/em&gt; the TypeScript compiler if we can avoid it. There are three reasons for this:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;The fact that an add-on is developed in TypeScript really shouldn’t affect app developers. If they’re writing a plain-old JavaScript app, the fact that your addon is originally written in TypeScript is irrelevant to them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TypeScript is &lt;em&gt;large&lt;/em&gt;. The v2.4 installation I have in the app I’m working on right now weights 26MB. If I were using four add-ons which required TypeScript, my install cost could easily go up by a hundred megabytes. That’s not always a huge deal on a corporate network, but even where people &lt;em&gt;do&lt;/em&gt; have good download speeds, it’s a hit to developer time. Every time someone has to reinstall all the dependencies, those 26MB have to come down again. If TypeScript becomes common, you might suddenly find yourself with addons using 2.4, 2.5, 2.6, etc.; it’s not hard to see that ballooning up the size of your installation in a really non-trivial way: 26MB × &lt;em&gt;n&lt;/em&gt; versions of TypeScript = &lt;em&gt;do not want&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The TypeScript compilation step takes time. Addons can do this &lt;em&gt;once&lt;/em&gt; and save every consuming app build time. This isn’t the end of the world, but anything we can do to keep build times lower is a real win for developer productivity.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Accordingly the plan is to automatically add a build step which runs the TypeScript compiler on your addon and generates plain-old-JavaScript and the corresponding type definition files (&lt;code&gt;.d.ts&lt;/code&gt;) prior to publishing to npm. That way, TypeScript can remain a dev dependency (rather than a full dependency) of each addon, and not be installed alongside the addon for consumers. Just-JavaScript consumers can just consume the normal JavaScript generated by the build. TypeScript consumers will get the full benefits of the types via the generated typing files.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;should&lt;/em&gt; hopefully land by late August or early September. Fingers crossed.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="community-driven-work-on-typings" class="level3"&gt;
&lt;h3&gt;Community-driven work on typings&lt;/h3&gt;
&lt;p&gt;The process of getting type definitions in place for &lt;em&gt;all&lt;/em&gt; of Ember.js and its ecosystem is way, &lt;em&gt;way&lt;/em&gt; too big for any one person or even a small handful of people to manage alone. This is something we’re going to take on as a community.&lt;/p&gt;
&lt;section id="new-typings-for-ember.js-itself" class="level4"&gt;
&lt;h4&gt;New typings for Ember.js itself&lt;/h4&gt;
&lt;p&gt;We’re actively working on type definitions for Ember which will give us actually-useful-and-correct type checking for Ember’s custom object model. Today, if you use &lt;code&gt;Ember.get&lt;/code&gt; or &lt;code&gt;Ember.set&lt;/code&gt;, you get &lt;em&gt;no&lt;/em&gt; help from the type system. When we finish, those will be type-checked by the compiler and will error if you try to assign the wrong values!&lt;/p&gt;
&lt;p&gt;Importantly, the typings we’re shipping will be backwards compatible with the existing Ember API, but will also include support for the &lt;a href="https://github.com/emberjs/rfcs/pull/176"&gt;RFC #176 JavaScript Modules API&lt;/a&gt;. TypeScript’s module definition system will let us support both in parallel, and we will. Backwards compatibility and &lt;em&gt;stability without stagnation&lt;/em&gt; are things we value for this addon just as much as the rest of the Ember.js ecosystem does.&lt;/p&gt;
&lt;p&gt;This effort, led by Derek Wickern (&lt;a href="https://github.com/dwickern"&gt;@dwickern&lt;/a&gt;), is ongoing in the &lt;a href="https://github.com/typed-ember/ember-typings"&gt;typed-ember/ember-typings&lt;/a&gt; repository. (If you’re wondering why we’re not just doing it in the DefinitelyTyped repository, see below.) We probably won’t be able to get to 100% of everything the Ember Object model does—Ember’s custom object model is &lt;em&gt;incredibly&lt;/em&gt; sophisticated, and TypeScript actually &lt;a href="https://github.com/Microsoft/TypeScript/issues/16699"&gt;still can’t&lt;/a&gt; &lt;em&gt;totally&lt;/em&gt; express it—but Derek already has most of it working. This will be a &lt;em&gt;huge&lt;/em&gt; step forward.&lt;/p&gt;
&lt;p&gt;To be clear, we’re not forking the way you get types. We’ll upstream all of this work to DefinitelyTyped as soon as we have them working, but the DefinitelyTyped repo is &lt;em&gt;huge&lt;/em&gt; and very busy; it’s not a great place to do this kind of substantial rework of existing types. And we really don’t need to have all the &lt;em&gt;other&lt;/em&gt; type definitions DefinitelyTyped supplies in our way as we’re working, either. Having a separate repo gives us a place we can work on types, try them out as a community, etc. before creating PRs on DefinitelyTyped and publishing them officially.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="addon-typings" class="level4"&gt;
&lt;h4&gt;Addon typings&lt;/h4&gt;
&lt;p&gt;We need to get type definitions in place for the addons in the ecosystem! That way when you’re using, say, &lt;a href="https://github.com/simplabs/ember-test-selectors"&gt;ember-test-selectors&lt;/a&gt;, you’ll get an error if you try to use the functions it provides incorrectly. Right now, every addon out there is missing types entirely, so everything gets treated as taking the useless &lt;code&gt;any&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;In a week or so, I’ll have a blog post with a fleshed-out &lt;a href="https://github.com/typed-ember/ember-cli-typescript/issues/48"&gt;quest issue&lt;/a&gt; for tackling it in detail, but here’s the short version: we’re going to try to get type definitions for all the top addons in the ecosystem so that it’s &lt;em&gt;easy&lt;/em&gt; to use TypeScript in your Ember.js app. That blog post and quest issue will explain how to write good typings, and also how to contribute them to a project which may or may not be interested in using TypeScript itself.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Tue, 08 Aug 2017 09:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-08-08:/2017/announcing-ember-cli-typescript-100.html</guid><category>typing-your-ember</category><category>typescript</category><category>emberjs</category></item><item><title>Typing Your Ember, Part 4</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-4.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-3"&gt;previous post&lt;/a&gt; in this series, I noted that one of the most effective current strategies for using TypeScript effectively in an Ember app is to push as much of your logic possible &lt;em&gt;out&lt;/em&gt; of the Ember layer and into plain-old-TypeScript. Unsurprisingly, people had some questions about how to do this, so here’s a brief example.&lt;/p&gt;
&lt;p&gt;As I suggested in that post, we now have a &lt;code&gt;lib&lt;/code&gt; directory in our app, and all new business logic for the app lives there instead of directly on e.g. an &lt;code&gt;Ember.Service&lt;/code&gt; instance. Our current directory structure looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app/
  adapters/
  components/
  config/
  controllers/
  helpers/
  initializers/
  instance-initializers
  lib/    &amp;lt;-- this is the one we care about
    billing/
    utilities/
      numeric.ts
  routes/
  serializers/
  services/
  templates/
  transforms
  app.ts
  router.ts
tests/
package.json
bower.json
// etc.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main thing to notice here is that &lt;code&gt;lib&lt;/code&gt; is just a directory in the app like any other, and its child directories likewise. This means that Ember &lt;abbr title="command line interface"&gt;CLI&lt;/abbr&gt; will resolve it just like normal, too—there’s no need to mess with the resolver or anything.&lt;/p&gt;
&lt;p&gt;Say we had a set of numeric utilities in that &lt;code&gt;numeric.ts&lt;/code&gt; file like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Make text out of numbers, like &amp;quot;1st&amp;quot;, &amp;quot;2nd&amp;quot;, &amp;quot;3rd&amp;quot;, etc.
export const withEnding = (val: number): string =&amp;gt; {
  // boring implementation details elided
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then using it in an Ember component might look like this (where &lt;code&gt;currentNumber&lt;/code&gt; is passed into the component):&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { get, set } from &amp;#39;@ember/object&amp;#39;;
import * as Num from &amp;#39;../lib/utilities/numeric&amp;#39;;

export default Component.extend({
  init() {
    const currentNumber = get(this, &amp;#39;currentNumber&amp;#39;);
    const displayNumber = Num.withEnding(currentNumber);
    set(this, &amp;#39;displayNumber&amp;#39;, displayNumber);
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You might wonder why we’d do this instead of using an &lt;code&gt;Ember.Service&lt;/code&gt;. In the above example, I could of course make &lt;code&gt;Num&lt;/code&gt; a service and inject it…&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { getProperties, set } from &amp;#39;@ember/object&amp;#39;;
import { inject } from &amp;#39;@ember/service&amp;#39;;

export default Component.extend({
  num: inject(),

  init() {
    const { currentNumber, num } =
      getProperties(this, &amp;#39;currentNumber&amp;#39;, &amp;#39;num&amp;#39;);

    const displayNumber = num.withEnding(currentNumber);
    set(this, &amp;#39;displayNumber&amp;#39;, displayNumber);
  },
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…but that doesn’t actually &lt;em&gt;gain&lt;/em&gt; me anything—the service here is just a way of exposing a function, after all—and it actually makes everything a bit more verbose. It also decreases the overall analyzability of this for things like tree-shaking: that module dependency is now something that Ember itself has to manage, instead of being statically analyzable at build time. Taking this approach also diminishes the reusability of any numeric helpers I put in there. If we couple them to an &lt;code&gt;Ember.Service&lt;/code&gt;, instead of using an ES6 module, they would stop being things we can easily reuse in non-Ember projects. Instead, by using modules, we leave ourselves the ability to easily extract those numeric helpers, and publish them for either internal or external consumption.&lt;/p&gt;
&lt;p&gt;Along those lines, we actually have a module to support &lt;abbr title="Block-Element-Modifier"&gt;&lt;a href="https://en.bem.info/methodology/quick-start/"&gt;BEM&lt;/a&gt;&lt;/abbr&gt; with Ember Components—and we plan to extract both the basic TypeScript library as well as a &lt;code&gt;BemComponent&lt;/code&gt; Ember-specific wrapper as open-source libraries in the near future. Besides the Ember addon, &lt;em&gt;anyone&lt;/em&gt; will be able to consume and use the underlying TypeScript library, whatever their framework or library of choice. Importantly, that includes us in our other codebases, which include lots of old jQuery and some new React, and might include some Glimmer.js in the future. Any or all of our utilities for these kinds of things become reusable if they’re just TypeScript.&lt;/p&gt;
&lt;p&gt;Pragmatically, it’s also just easier to do and get good help from TypeScript by going this way. It also means that unit-testing requires &lt;em&gt;no&lt;/em&gt; context from Ember whatsoever, which keeps those tests lighter and faster. Even though Ember’s unit tests are already super quick, when you have hundreds or thousands of unit tests, every little bit matters. It also, and probably even more importantly, means there are fewer places where you could mess things up when configuring tests—not that I have any experience messing up test configurations in Ember!&lt;/p&gt;
&lt;p&gt;One important thing to note is that this all works best with Ember—by far—when your &lt;code&gt;lib&lt;/code&gt; modules aren’t managing stateful objects, but rather defining data structures and functions which just transform those structures in some way. This approach is a great fit for us, because we’re increasingly writing a lot of our business and even &lt;abbr title="user interface"&gt;UI&lt;/abbr&gt; logic in terms of &lt;a href="http://www.chriskrycho.com/2016/what-is-functional-programming.html#pure-functions"&gt;pure functions&lt;/a&gt; which transform simple “record” types. That keeps each controller, route, component, or service doing relatively little work: they are responsible for getting and passing around data in the application, and for triggering actions—but they’re not responsible for &lt;em&gt;understanding&lt;/em&gt; or &lt;em&gt;manipulating&lt;/em&gt; that data. Meanwhile the module code doesn’t do &lt;em&gt;any&lt;/em&gt; stateful work; there’s no mutation—just boring, input-to-output functions.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; By contrast, if you’re dealing with stateful objects, you’re apt to end up running into places where you have lifecycle concerns, and that’s where Ember excels.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In summary:&lt;/strong&gt; in this model, Ember handles all the lifecycle and view management, and is responsible for sending data in and out of the application. Plain old modules handle defining what the core internal data types are, and for manipulating, transforming, and creating data.&lt;/p&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;If you’re wondering: we’re not using anything like Redux or Immutable.js yet, but both &lt;a href="https://github.com/ember-redux/ember-redux"&gt;ember-redux&lt;/a&gt; and &lt;a href="https://github.com/rtfeldman/seamless-immutable"&gt;seamless-immutable&lt;/a&gt; would be great fits for the way we’re building the app at this point, and it’s likely at least &lt;a href="https://github.com/ember-redux/ember-redux"&gt;ember-redux&lt;/a&gt; will become part of our stack in the relatively near future.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Mon, 31 Jul 2017 19:30:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-31:/2017/typing-your-ember-part-4.html</guid><category>emberjs</category><category>typescript</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 3</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-3.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-1"&gt;first&lt;/a&gt; of this series, I described how to set up a brand new Ember.js app to use TypeScript. In the &lt;a href="/2017/typing-your-ember-part-2"&gt;second&lt;/a&gt; part, walked through adding TypeScript to an existing Ember.js app. In this part, I’m going to talk about using TypeScript effectively in a modern Ember.js app.&lt;/p&gt;
&lt;section id="heavy-lifting-so-so-results" class="level2"&gt;
&lt;h2&gt;Heavy lifting, so-so results&lt;/h2&gt;
&lt;p&gt;Let’s get this out of the way up front: right now, using types in anything which extends &lt;code&gt;Ember.Object&lt;/code&gt; is going to be a lot of work for a relatively low reward. &lt;code&gt;Ember.Object&lt;/code&gt; laid the foundation for the modern JavaScript class system (and thus the TypeScript class system), but it has a huge downside: it’s string keys and referennces all the way down. This kind of thing is just normal Ember code—and note all the string keys:&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default Component.extend({
  someProperty: &amp;#39;with a string value&amp;#39;,
  someOther: computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty = get(this, &amp;#39;someProperty&amp;#39;);
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }),
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What this comes out to—even with a lot of the very helpful changes made to TypeScript itself in the 2.x series to help support object models like this one—is a lot of work adding types inline, and having to be really, really careful that your types are &lt;em&gt;correct&lt;/em&gt;. If that property you’re &lt;code&gt;Ember.get&lt;/code&gt;-ing can ever be &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you’d better write the type as &lt;code&gt;string | void&lt;/code&gt; instead of just &lt;code&gt;string&lt;/code&gt;. For example: this code is written with the correct types:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default Component.extend({
  someProperty: &amp;#39;with a string value&amp;#39;,  // no type annotation
  someOther: computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty: string = get(this, &amp;#39;property&amp;#39;);
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }),
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note two important things about it, however:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;TypeScript does not (and, with the &lt;em&gt;current&lt;/em&gt; typings for Ember, cannot) figure out the type of &lt;code&gt;someProperty&lt;/code&gt; from this definition; &lt;code&gt;get&lt;/code&gt; currently just hands back &lt;code&gt;any&lt;/code&gt; as the type of these kinds of things. That type annotation is necessary for you to get any mileage out of TypeScript &lt;em&gt;at all&lt;/em&gt; in a computed property like this.&lt;/li&gt;
&lt;li&gt;If, anywhere in your code, you &lt;em&gt;set&lt;/em&gt; the value of &lt;code&gt;someProperty&lt;/code&gt;—including to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, or to &lt;code&gt;{ some: 'object' }&lt;/code&gt;—this could fail.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Unfortunately, this second point means that TypeScript actually &lt;em&gt;can’t&lt;/em&gt; guarantee this the way we’d like. There’s hope coming for this in the future in several ways—more on that in a moment—but for now, I’ll summarize this by saying TypeScript is really helpful &lt;em&gt;within&lt;/em&gt; a function, once you’ve correctly defined the types you’re using. That means that you have to continue to be &lt;em&gt;very&lt;/em&gt; careful in what you’re doing in the context of any &lt;code&gt;Ember.Object&lt;/code&gt; instance, including all the Ember types which descend from &lt;code&gt;Object&lt;/code&gt;, and therefore also any types &lt;em&gt;you&lt;/em&gt; define which extend those in turn.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="future-niceties" class="level2"&gt;
&lt;h2&gt;Future niceties&lt;/h2&gt;
&lt;p&gt;In the future, we’ll be able to get away from a lot of these difficulties by way of two changes coming down the line: Ember embracing ES6 classes to replace its current custom object system, and embracing decorators as a way of replacing the current approach to computed properties. Let’s take those in turn.&lt;/p&gt;
&lt;section id="class-syntax" class="level3"&gt;
&lt;h3&gt;&lt;code&gt;class&lt;/code&gt; syntax&lt;/h3&gt;
&lt;p&gt;When Ember was birthed in the early 2010s (first as “SproutCore 2” and then “Amber.js” and finally “Ember.js”), the JavaScript world was a &lt;em&gt;remarkably&lt;/em&gt; different place. The current pace of change year to year is nothing short of astounding for any language, but doubly so for one that sat languishing for so long. When Ember came around, something like today’s &lt;code&gt;class&lt;/code&gt; syntax was unimaginable, and so essentially every framework had its own class system of some sort. Over the past few years, with the proposal and standardization of the &lt;code&gt;class&lt;/code&gt; syntax as nice sugar for JavaScript’s prototypal inheritance, the need for a custom object and inheritance model has essentially gone away entirely. However, Ember doesn’t do breaking changes to its API just because; we as a community and the core team in particular have chosen to place a high priority on backwards compatibility. So any adoption of ES6 classes had to work in such a way that we got it &lt;em&gt;without&lt;/em&gt; making everyone rewrite their code from scratch.&lt;/p&gt;
&lt;p&gt;All of this impacts our story with TypeScript because, well, TypeScript for a long time couldn’t even begin to handle this kind of complexity (it’s a lot for a static type system to be able to express, given how &lt;em&gt;very&lt;/em&gt; dynamic the types here can be). As of TS 2.3, it can express &lt;em&gt;most&lt;/em&gt; of this object model, which is great… but it’s forever out of step with the rest of the JS/TS ecosystem, which is not so great. ES6 classes are first-class items in TypeScript and the support for getting types right within them is much, &lt;em&gt;much&lt;/em&gt; stronger than the support for the mixin/extension style object model Ember currently uses. So moving over to ES6 classes will make it much easier for TS to do the work of telling you &lt;em&gt;you’re doing it wrong with that class&lt;/em&gt;—and most importantly, it’ll be able to do that automatically, without needing the incredibly hairy type definition files that we’re still trying to write to get Ember’s current model represented. It Will Just Work. That means less maintenance work and fewer places for bugs to creep in.&lt;/p&gt;
&lt;p&gt;Gladly, we’re getting there! Already today, in the most recent versions of Ember, you can write this, and it will work:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;

export default class MyComponent extends Component {
  theAnswer = 42;
  andTheQuestionIs =
    &amp;quot;What is the meaning of life, the universe, and everything?&amp;quot;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When I say “it will work,” I mean you can then turn around and write this in your &lt;code&gt;my-component.hbs&lt;/code&gt; and it’ll be exactly what you would expect from the old &lt;code&gt;Ember.Component.extend()&lt;/code&gt; approach:&lt;/p&gt;
&lt;pre class="hbs"&gt;&lt;code&gt;{{andTheQuestionIs}} {{the Answer}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is one serious limitation of that today: you can’t do that with a class you need to extend &lt;em&gt;further&lt;/em&gt;. So if, for example, you do like we do and customize the application route rinstance and then reuse that in a couple places, you’ll still have to use the old syntax:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Route from &amp;#39;@ember/route&amp;#39;;

export default Route.extend({
  // your customizations...
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But everywhere you consume that, you can use the new declaration:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import ApplicationRoute from &amp;#39;my-app/routes/application&amp;#39;;

export default class JustSomeRoute extends ApplicationRoute {
  model() {
    // etc.
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There’s more work afoot here, too, to make it so that these restrictions can go away entirely… but those changes will undoubtedly be covered in considerable detail on &lt;a href="http://www.emberjs.com/blog/"&gt;the official Ember blog&lt;/a&gt; when they roll out.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="decorators" class="level3"&gt;
&lt;h3&gt;Decorators&lt;/h3&gt;
&lt;p&gt;Now, that’s all well and good, but it doesn’t necessarily help with this scenario:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed, get } from &amp;#39;@ember/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;is just a string&amp;#39;;

  someOtherProperty = computed(&amp;#39;someProperty&amp;#39;, function() {
    const someProperty = get(this, &amp;#39;someProperty&amp;#39;);
    return someProperty + &amp;#39; and now I have appended to it&amp;#39;;
  });
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re back in the same spot of having unreliable types there. And again: some really careful work writing type definitions to make sure that &lt;code&gt;computed&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; both play nicely together with the class definition would help somewhat, but… well, it’d be nice if the types could just be determined automatically by TypeScript. (Also, there’s an &lt;a href="https://github.com/Microsoft/TypeScript/issues/16699"&gt;open bug&lt;/a&gt; on the TypeScript repository for trying to deal with &lt;code&gt;computed&lt;/code&gt;; suffice it to say that computed as it currently stands is a sufficiently complicated thing that even with all the incredible type machinery TS 2.1, 2.2, and 2.3 have brought to bear on exactly these kinds of problems… it still can’t actually model &lt;code&gt;computed&lt;/code&gt; correctly.)&lt;/p&gt;
&lt;p&gt;For several years now, Rob Jackson has maintained [a small library] that let you write computed properties with decorators. Up till recently, those were incompatible with TypeScript, because they used to work in the context of object literals rather than classes—and TypeScript never supported that. However, as of about a month ago as I’m writing this, they’ve been updated and they &lt;em&gt;do&lt;/em&gt; work with ES6 classes. So, given the class syntax discussed above, you can now &lt;code&gt;ember install ember-decorators&lt;/code&gt; and then do this:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed } from &amp;#39;ember-decorators/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;with a string value&amp;#39;;

  @computed(&amp;#39;someProperty&amp;#39;)
  someOther(someProperty: string) {
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we can provide a type on the parameter to &lt;code&gt;someOther&lt;/code&gt;, which at a minimum makes this enormously cleaner and less repetitive syntactically. More interestingly, however, we &lt;em&gt;should&lt;/em&gt; (though no one has done it just yet, to my knowledge) be able to write a type definition for &lt;code&gt;@computed&lt;/code&gt; such that TypeScript will already know that &lt;code&gt;someProperty&lt;/code&gt; here &lt;em&gt;is&lt;/em&gt; a string, because it’ll have the context of the class in which it’s operating. So that example will be even simpler:&lt;/p&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;import Component from &amp;#39;@ember/component&amp;#39;;
import { computed } from &amp;#39;ember-decorators/object&amp;#39;;

export default class MyComponent extends Component {
  someProperty = &amp;#39;with a string value&amp;#39;;

  @computed(&amp;#39;someProperty&amp;#39;)
  someOther(someProperty) {
    return someProperty + &amp;#39; that you can append to&amp;#39;;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in that imagined, wonderful future world, if we tried to do something that isn’t a valid string operation—say, we tried &lt;code&gt;someProperty / 3&lt;/code&gt;—TypeScript would complain to us, loudly.&lt;/p&gt;
&lt;p&gt;Although this is still a future plan, rather than a present reality, it’s not &lt;em&gt;that&lt;/em&gt; far off. We just need someone to write that type definition for the decorators, and we’ll be off to the races wherever we’re using the new ES6 class approach instead of the existing &lt;code&gt;Ember.Object&lt;/code&gt; approach. So: &lt;em&gt;soon&lt;/em&gt;. I don’t know how soon, but soon.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="current-ameliorations" class="level2"&gt;
&lt;h2&gt;Current ameliorations&lt;/h2&gt;
&lt;p&gt;In the meantime, of course, many of us are maintaining large codebases. I just checked, and our app (between the app itself and the tests) has around 850 files and 34,000 lines of code. Even as those new abilities land, we’re not going to be converting all of them all at once. And we want to get some real mileage out of TypeScript in the meantime. One of the best ways I’ve found to do this is to take a step back and think about the pieces of the puzzle which Ember is solving for you, and which it &lt;em&gt;isn’t&lt;/em&gt;. That is, Ember is really concerned with managing application state and lifecycle, and with rendering the UI. And it’s &lt;em&gt;fabulous&lt;/em&gt; about those things. What it’s not particularly concerned with (and what it shouldn’t be) is the particulars of how your business logic is implemented. And there’s no particular reason, &lt;em&gt;especially&lt;/em&gt; if most of that business logic is implemented in terms of a bunch of pure, straightforward, input-to-output functions that operate on well-defined data types, for all of your business logic to live in &lt;code&gt;Ember.Object&lt;/code&gt;-descended classes.&lt;/p&gt;
&lt;p&gt;Instead, we have increasingly chosen to write our business logic in bog-standard TypeScript files. These days, our app has a &lt;code&gt;lib&lt;/code&gt; directory in it, with packages like &lt;code&gt;utilities&lt;/code&gt; for commonly used tools… but also like &lt;code&gt;billing&lt;/code&gt;, where we implement &lt;em&gt;all&lt;/em&gt; of our client-side billing business logic. The display logic goes in the &lt;code&gt;Ember.Controller&lt;/code&gt; and &lt;code&gt;Ember.Component&lt;/code&gt; classes, and the routing and state management goes in the &lt;code&gt;Ember.Route&lt;/code&gt; and &lt;code&gt;Ember.Data&lt;/code&gt; pieces as you’d expect. But none of the business logic lives there. That means that we’re entirely free of the aforementioned constraints for the majority of the time dealing with that data. If we do a good job making sure the data is good at the boundaries—route loads, for example, and when we send it back to the server—then we can effectively treat everything else as just boring old (new?) TypeScript.&lt;/p&gt;
&lt;p&gt;So far we’ve only taken that approach with about a quarter of our app, but it’s all the latest pieces of our app, and it has been incredibly effective. Even once we’re able to take advantage of all those shiny new features, we’re going to keep leaning heavily on this approach, because it lets Ember do what Ember is best at, and keeps us from coupling our business logic to the application state management or view rendering details.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion" class="level2"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So that’s the state of things in Ember with TypeScript today. Your best bet for getting real mileage out of TypeScript today is to use the new class syntax support and decorators wherever you can within Ember-specific code, and then to write as much of your business logic outside the Ember system as possible. Gladly, all of that points you right at the future (in the case of syntax) and just good practice (in the case of separating out your business logic). So: not too shabby overall. It’s working well for us, and I hope it does for you as well!&lt;/p&gt;
&lt;p&gt;Next time: how we got here with the &lt;code&gt;ember-cli-typescript&lt;/code&gt; compiler, and where we hope to go from here!&lt;/p&gt;
&lt;/section&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Note that here and throughout, I’m using the &lt;a href="https://github.com/emberjs/rfcs/blob/master/text/0176-javascript-module-api.md#addendum-1---table-of-module-names-and-exports-by-global"&gt;RFC #176 Module API&lt;/a&gt;, which you can use today via &lt;a href="https://github.com/ember-cli/babel-plugin-ember-modules-api-polyfill"&gt;this polyfill&lt;/a&gt;.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 28 Jul 2017 12:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-07-28:/2017/typing-your-ember-part-3.html</guid><category>emberjs</category><category>typescript</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 2</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-2.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In the &lt;a href="/2017/typing-your-ember-part-1"&gt;first part&lt;/a&gt; of this series, I described how to set up a brand new Ember.js app to use TypeScript. In this part, I’m going to talk about starting to use TypeScript in the context of an existing Ember.js app.&lt;/p&gt;
&lt;p&gt;This is, in many ways, even simpler than setting up an app for the first time, because you already have almost everything you need. The steps here are exactly what you’re used to if you’re used to using the Ember CLI ecosystem:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Install &lt;code&gt;ember-cli-typescript&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Start using TypeScript wherever you want in your app.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It really is that simple, for the most part. There are a couple qualifications, and a couple tips, though.&lt;/p&gt;
&lt;p&gt;Let’s start with &lt;strong&gt;qualifications&lt;/strong&gt;. There are open, unresolved &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/"&gt;issues&lt;/a&gt; about using &lt;code&gt;ember-cli-typescript&lt;/code&gt; in your app in certain contexts. For example: &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/8"&gt;using it with &lt;code&gt;ember-browserify&lt;/code&gt;&lt;/a&gt;. While everything will &lt;em&gt;build&lt;/em&gt; correctly in that case (even if the TypeScript compiler complains about being unable to resolve some things, the Ember CLI build pipeline will still work as expected), your editor integration won’t. There are a bunch of corners like this we’re still hammering out; those are the main things we need to get resolved before we can call this a “1.0.” We have the &lt;em&gt;main&lt;/em&gt; stuff working, but, well… there’s more to do.&lt;/p&gt;
&lt;p&gt;Along those same lines, you should take a close look at the &lt;a href="https://github.com/emberwatch/ember-cli-typescript#not-yet-supported"&gt;&lt;strong&gt;Not yet supported&lt;/strong&gt;&lt;/a&gt; section of the README. There are parts of Ember’s programming model which TypeScript certainly &lt;em&gt;can&lt;/em&gt; support, but which we haven’t done the lifting to get the type declaration file to help with yet. (Looking for a place to pitch in and already comfortable doing some heavy lifting with some of TypeScript’s &lt;a href="http://www.typescriptlang.org/docs/handbook/mixins.html"&gt;most advanced type features&lt;/a&gt;? We could use the help.)&lt;/p&gt;
&lt;p&gt;One other thing to be aware of is that your &lt;code&gt;tsconfig.json&lt;/code&gt; settings will affect what kind of resolution your editor gives you. If you have &lt;code&gt;allowJs&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;, your editors will resolve JS modules. Otherwise, they’ll &lt;em&gt;only&lt;/em&gt; resolve TS modules. This can be incredibly annoying at times. However, this isn’t something we’ve nailed down in terms of what the default should be yet. (You can &lt;a href="https://github.com/emberwatch/ember-cli-typescript/issues/"&gt;come tell us&lt;/a&gt; on GitHub if you have thoughts or insights there!) And the fact that Microsoft has left this configurable is suggestive: different projects may have different preferences here.&lt;/p&gt;
&lt;p&gt;Now, for the &lt;strong&gt;tips&lt;/strong&gt;. Note that these are just a couple quick pointers; I’ll come back and talk about structuring your project and more sophisticated uses of TypeScript in the future.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Don’t turn on &lt;code&gt;--strict&lt;/code&gt; or the corresponding individual flags on day 1. Unless you have an extremely unusual and disciplined Ember.js codebase, you’ll have an incredible set of errors to deal with.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t set the the &lt;code&gt;noEmitOnError&lt;/code&gt; flag to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;, for much the same reason. Since the state of type declaration files for Ember is best described as &lt;em&gt;nascent&lt;/em&gt; at present, many of your files will have errors in them just from failed imports!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t try to convert everything at once. Just pick the next feature or bug you’re working on, and start with the files you’re touching for that bug. Rename it to &lt;code&gt;.ts&lt;/code&gt;, fix any major issues it flags up that you can—but stick as locally as possible. You’re apt to find a &lt;em&gt;lot&lt;/em&gt; of small bugs as you start migrating, and some of them are things which are apt to affect your whole system because they touch central data types. It’s okay. You can come back to those later. For today, you can just be explicit about the weirdnesses.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As part of that: get comfortable—really, really comfortable—with &lt;a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types"&gt;union types&lt;/a&gt;. They’ll make it much easier to express the kind of code you’ve &lt;em&gt;actually&lt;/em&gt; written.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t worry about adding explicit types to &lt;em&gt;everything.&lt;/em&gt; In fact, depending on how comfortable you are already with typed languages, you should probably take a pretty different tack with this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you’re just stepping into the world of typed programming languages, you might start adding types where they’re the &lt;em&gt;lowest risk&lt;/em&gt;: some place like your automated tests. That’ll help you start to see how to take advantage of them, while not impacting the way you write your app code until you have a better idea how best to employ the types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re already really comfortable with typed programming languages, you might employ types where they’re &lt;em&gt;most helpful:&lt;/em&gt; start with some types in the hairiest or trickiest spots of your app.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is plenty more I could say, but I think that’s a good start for now. I’ll have lots more to add in later posts about the details of how specifically to get the most mileage out of types within an Ember.js app today.&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2017/typing-your-ember-part-1"&gt;&lt;strong&gt;Previous:&lt;/strong&gt; Part 1 – Set your Ember.js project up to use TypeScript.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;Also, I &lt;em&gt;strongly&lt;/em&gt; encourage you to write types in terms of unions of types rather than in terms of &lt;a href="http://www.typescriptlang.org/docs/handbook/interfaces.html#optional-properties"&gt;optional properties on types&lt;/a&gt;. That might be surprising; I’ll explain it in more detail in a future post.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Sun, 07 May 2017 22:00:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-05-07:/2017/typing-your-ember-part-2.html</guid><category>typescript</category><category>emberjs</category><category>typing-your-ember</category></item><item><title>Typing Your Ember, Part 1</title><link>http://www.chriskrycho.com/2017/typing-your-ember-part-1.html</link><description>&lt;p&gt;&lt;i class='series-overview'&gt;You write &lt;a href="https://emberjs.com"&gt;Ember.js&lt;/a&gt; apps. You think &lt;a href="http://www.typescriptlang.org"&gt;TypeScript&lt;/a&gt; would be helpful in building a more robust app as it increases in size or has more people working on it. But you have questions about how to make it work.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;This is the series for you! I’ll talk through everything: from the very basics of how to set up your Ember.js app to use TypeScript to how you can get the most out of TypeScript today—and I’ll be pretty clear about the current tradeoffs and limitations, too.&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;i class='series-overview'&gt;&lt;a href="/typing-your-ember.html"&gt;(See the rest of the series. →)&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;In this first post in the series, we’re going to keep things simple and easy: we’re going to get an Ember.js app configured to use TypeScript. Later posts will cover some of the other details.&lt;/p&gt;
&lt;p&gt;Because of the lovely &lt;a href="https://ember-cli.com"&gt;Ember CLI&lt;/a&gt; ecosystem, this is a pretty straightforward process. I’m going to start from &lt;em&gt;zero&lt;/em&gt; so that even if you’ve never written an Ember app before, you can get this up and running by following these instructions. These instructions have also been tested and confirmed to work across platforms—you can do this equally on Windows, macOS, or Linux.&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Make sure you have Ember’s prerequisites installed. Get &lt;a href="https://nodejs.org/en/"&gt;Node&lt;/a&gt; for your platform. Optionally (but highly recommended) install &lt;a href="https://yarnpkg.com"&gt;Yarn&lt;/a&gt; to manage your Node packages.&lt;a href="#fn1" class="footnoteRef" id="fnref1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the Ember command lines tools globally:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;yarn global add ember-cli&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;npm install --global ember-cli&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create an Ember app.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember new my-ts-app --yarn&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Using the &lt;code&gt;--yarn&lt;/code&gt; flag will make it so your app uses &lt;a href="https://yarnpkg.com"&gt;&lt;code&gt;yarn&lt;/code&gt;&lt;/a&gt; and creates a &lt;code&gt;yarn.lock&lt;/code&gt; file instead of using &lt;code&gt;npm&lt;/code&gt; when it installs its dependencies.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now move to the root of the newly created app: this is where we’ll do everything else in the post.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;cd my-ts-app&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;a href="https://emberobserver.com/addons/ember-cli-typescript"&gt;&lt;em&gt;ember-cli-typescript&lt;/em&gt; add-on&lt;/a&gt;.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember install ember-cli-typescript&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generate your first UI component.&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember generate component some-input&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Rename the files it generated from &lt;code&gt;.js&lt;/code&gt; to &lt;code&gt;.ts&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;app/components/some-input.js&lt;/code&gt; → &lt;code&gt;app/components/some-input.ts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tests/integration/components/some-input-test.js&lt;/code&gt; → &lt;code&gt;tests/integration/components/some-input-test.ts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Eventually, we’ll make it so that you get TypeScript for all newly generated components when using &lt;em&gt;ember-cli-typescript&lt;/em&gt;.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add some content to the files:&lt;/p&gt;
&lt;pre class="handlebars"&gt;&lt;code&gt;{{!-- some-input.hbs --}}
{{input value=theValue change=(mut theValue)}}
{{theValue}}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="typescript"&gt;&lt;code&gt;// some-input.ts
import Ember from &amp;#39;ember&amp;#39;;

export default Ember.Component.extend({
  theValue: &amp;#39;&amp;#39;,
});&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Update your &lt;code&gt;application.hbs&lt;/code&gt; file to remove the default &lt;code&gt;{{welcome}}&lt;/code&gt; template and replace it with &lt;code&gt;{{some-input}}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Spin up the Ember application with Ember CLI’s development server:&lt;/p&gt;
&lt;pre class="sh"&gt;&lt;code&gt;ember serve&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’ll likely note some warnings: the TypeScript compiler won’t be able to find some of the modules imported in your files. I’ll have more to say about this in a future post. For now, suffice it to say: don’t worry, Ember CLI is still resolving and compiling your modules just fine.&lt;a href="#fn2" class="footnoteRef" id="fnref2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Load the application by going to &lt;code&gt;localhost:4200&lt;/code&gt; in your browser. You should see a blank white screen with an input in it. Type in it, and see the input rendered to the page. Simple enough, but it’s using a TypeScript file compiled along the way!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that’s it: we’re done setting up an Ember.js app to use TypeScript! In the next post, I’ll talk a bit about strategies for migrating an existing app to TypeScript—not just the mechanics of it, but also where and how to start actually integrating types into your code.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="/2017/typing-your-ember-part-2"&gt;&lt;strong&gt;Next:&lt;/strong&gt; Part 2 – Adding TypeScript to an existing Ember.js project.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;section class="footnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1"&gt;&lt;p&gt;I strongly prefer to use &lt;code&gt;yarn&lt;/code&gt; over &lt;code&gt;npm&lt;/code&gt; because &lt;code&gt;yarn&lt;/code&gt; installs are predictable and repeatable, and if there’s one thing I don’t need to spend time on when developing our Ember.js app at Olo, it’s chasing problems with transitive dependencies that are different in the build server than in my local development environment. Yarn’s lockfiles mean what ends up built on the server is &lt;em&gt;exactly&lt;/em&gt; what ended up built on my machine.&lt;a href="#fnref1"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2"&gt;&lt;p&gt;But if you’re curious, here’s a preview: we really need more &lt;a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html"&gt;type definitions&lt;/a&gt; for the Ember ecosystem. I’ll be covering &lt;em&gt;how&lt;/em&gt; we build those in much more detail in a future installment.&lt;a href="#fnref2"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Krycho</dc:creator><pubDate>Fri, 05 May 2017 00:10:00 -0400</pubDate><guid isPermaLink="false">tag:www.chriskrycho.com,2017-05-05:/2017/typing-your-ember-part-1.html</guid><category>typescript</category><category>emberjs</category><category>typing-your-ember</category></item></channel></rss>